{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","src/glue/wasm/i64.ts","~lib/builtins.ts","src/common.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/shared/runtime.ts","~lib/util/sort.ts","~lib/string.ts","~lib/util/error.ts","~lib/rt.ts","std/assembly/shared/feature.ts","std/assembly/shared/target.ts","std/assembly/shared/runtime.ts","std/assembly/shared/typeinfo.ts","src/compiler.ts","src/util/text.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","src/util/path.ts","src/util/terminal.ts","~lib/typedarray.ts","src/util/vector.ts","~lib/util/bytes.ts","src/tokenizer.ts","src/flow.ts","src/program.ts","~lib/set.ts","src/glue/binaryen.ts","src/types.ts","src/module.ts","src/ast.ts","src/diagnosticMessages.generated.ts","src/builtins.ts","~lib/array.ts","src/diagnostics.ts","~lib/number.ts","src/util/collections.ts","src/glue/wasm/collections.ts","src/resolver.ts","~lib/staticarray.ts","src/util/math.ts","src/util/binary.ts","src/glue/wasm/float.ts","src/bindings/js.ts","~lib/math.ts","src/index-wasm.ts","src/parser.ts","src/passes/pass.ts","src/passes/shadowstack.ts","src/passes/rtrace.ts","src/bindings/util.ts","src/bindings/tsd.ts","~lib/memory.ts","~lib/function.ts"],"names":[],"mappings":"ml+BYkDI,AAAO,AAAmB,EAA0B,MAA0B,2BTIhF,EAAsB,KACtB,EAAa,KACb,AAAO,cAqCL,AAAO,AAAmB,KAAqB,AAAC,UAUhD,AAAO,AAAI,KAAqB,SAoDlC,AAAgB,KAChB,AAAS,IACT,AAAW,OACX,IAAO,EAAQ,KACT,GAAO,AAAO,KAAc,oBAChC,AAAgB,EAA0B,GAAgB,KAC1D,AAAO,eArDP,EAAqB,AAAC,KAAqB,AAAC,MAAc,iBAV1D,EAAqB,EAA0B,KAAqB,YA2BpE,AAAW,OACX,AAAI,EAAQ,KACN,GAAO,AAAO,KAAa,KAAQ,EAA0B,yBACjE,EAEF,AAAW,OACP,GAAO,AAAO,mBAClB,EAAY,KACZ,EAAY,0BWlHd,AAAU,KACV,AAAI,EAAK,AAAU,QAAsB,cACzC,AAAO,AAAqB,EAAM,GAAgB,EAAK,aXiGrD,AAAW,OAEX,AAAO,EAAQ,QAAkB,AAAC,AAAW,KAAQ,GAA8B,UAkBnF,AAAW,OACX,EAAqB,EAA0B,MAC/C,EAAY,KACZ,EAAY,KACZ,EAAY,UAKZ,AAAI,EAAQ,KAAM,AAAO,AAAO,8BAChC,KACA,EAAY,EAAS,OAAqB,AAAK,IAAS,WA6K1D,AAAI,AAAC,KAAK,EACV,AAAU,AAAmB,EAAM,KACnC,AAAI,GACJ,AAAI,KAAa,KACf,KACA,AAAE,aAhKJ,AAAU,KACV,IAAO,EAAM,MACX,AAAQ,AAAY,KAAM,KAC1B,EAAO,qBAzDP,AAAO,EAAkB,KAAc,AAAC,8EFyJ1C,AAAgB,OACZ,GAAO,AAAO,EAAY,oBAC9B,AAAW,EAAY,AAAC,QACpB,GAAO,AAAO,EAAQ,oBAI1B,AAAI,EAAO,MACT,AAAK,IACL,AAAK,AAAM,EAAQ,MAGnB,AAAkB,AAAI,IAAM,gBAC5B,AAAK,EAAM,AAAW,MACtB,AAAK,AAAO,EAAgB,EAAK,IAAa,EAAK,MACnD,EAAM,EAAU,OAEd,GAAO,AAAO,EAAK,KAAW,EAAK,wBAGvC,AAAW,OACX,AAAW,OACX,AAAI,IAAM,EAAY,MACtB,AAAI,IAAM,EAAY,MAGtB,AAAI,EAAS,EAAQ,IAAM,IAAI,IAjI/B,AAAO,AACL,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,aAiI5D,EAAQ,IAAM,IAAI,IAAI,IAzHxB,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,IAC5D,MA0HA,AAAI,AAAC,KACH,AAAY,EAAM,IAAM,IAzJ5B,AAAO,AACL,EAA2B,EAAM,YAyJ/B,EAAM,IAAM,IAAI,EAAS,AAAE,EAAK,WAjJpC,AACE,EAA2B,EAAM,IACjC,MAkJE,AAAI,AAAC,KAAO,OAAc,AAAE,EAAK,mBArGjC,GAAO,AAAO,mBAClB,AAAgB,OACZ,GAAO,AAAO,EAAY,oBAE9B,AAAY,EAAS,0BACrB,AAAgB,OAGhB,AAAI,EAAY,KACd,AAAY,EAAM,KAClB,EAAe,AAAY,EAAY,GAAkB,EAAY,AAAC,YACtE,AAAQ,EAAS,IAnHnB,AAAO,AAAkB,EAA2B,GAAkB,KAAe,AAAC,YAoHpF,AAAY,QAKd,AAAI,EAAY,KACd,AAAW,EAAY,IAhIzB,AAAO,AAAY,EAA2B,WAiI5C,AAAe,OACX,GAAO,AAAO,EAAW,oBAC7B,AAAY,EAAM,KAClB,AAAQ,IACR,EAAe,AAAY,EAAW,GAAkB,EAAY,AAAC,aAIvE,EAAe,EAAY,MAI3B,AAAW,EAAY,AAAC,QACpB,GAAO,AAAO,EAAQ,oBACtB,GAAO,AAAO,EAA2B,GAAiB,GAAQ,oBAGtE,AAAa,EAA2B,GAAiB,KAIzD,AAAI,EAAO,MACT,AAAK,IACL,AAAK,AAAM,EAAQ,MAGnB,AAAkB,AAAI,IAAM,gBAC5B,AAAK,EAAM,AAAW,MACtB,AAAK,AAAO,EAAgB,EAAK,IAAa,EAAK,MACnD,EAAM,EAAU,OAEd,GAAO,AAAO,EAAK,KAAW,EAAK,wBAGvC,AAAW,EAAQ,IAAM,IAAI,IA1F7B,AAAO,AACL,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,YA0F9D,EAAa,KACb,EAAa,KACb,AAAI,IAAM,EAAY,MACtB,EAAQ,IAAM,IAAI,IAAI,IArFtB,AACE,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,IAC5D,MAsFF,OAAe,EAAK,OACpB,EAAM,IAAM,IAAI,EAAM,IAAM,IArH5B,AAAO,AACL,EAA2B,EAAM,UAoHA,EAAK,MA5GxC,AACE,EAA2B,EAAM,IACjC,YA6NE,GAAO,AAAO,EAAS,oBAC3B,AAAQ,AAAC,AAAC,EAAQ,GAAiB,GAAW,AAAC,MAAW,KAC1D,EAAO,AAAC,QAER,AAAW,EAAQ,IAtMnB,AAAO,AACL,WAsMF,AAAsB,IACtB,AAAI,IACE,GAAO,AAAO,EAAS,EAA0B,qBAIrD,AAAI,EAAQ,GAAgB,KAC1B,EAAS,KACT,AAAW,WAMJ,GAAO,AACT,EAAS,EAA0B,uBAI5C,AAAW,EAAM,KACjB,AAAI,EAAO,EAAiB,GAAgB,MAC1C,AAAO,IAIT,AAAe,EAAO,EAAI,MAC1B,AAAW,IACX,EAAc,EAAW,GAAQ,EAAW,OAC5C,EAAY,KACZ,EAAY,KAGZ,AAAO,AAAkB,EAAQ,GAAiB,KAClD,EAAc,EAAI,MAClB,EAAQ,IAAM,IAhOd,AACE,EACA,OAgOF,AAAY,EAAM,KAElB,AAAO,SA4CP,AAAI,GACJ,AAAiB,AAAC,GAAc,GAAW,AAAC,QAC5C,AAAkB,IAClB,AAAkB,AAAO,AAAC,AAAC,EAAa,IAAa,KAAU,AAAC,QAAY,KAC5E,AAAI,EAAc,KAAe,AAAY,EAAc,KAAe,SAAG,EAC7E,AAAW,IACX,EAAa,KACb,EAAQ,IAAM,aACT,AAAgB,MAAG,EAAK,KAC3B,EAAM,IAAM,IAAI,kBACX,AAAc,MAAG,EAAK,KACzB,EAAQ,IAAM,IAAI,IAAI,wBADY,AAAE,WAFF,AAAE,WAMxC,AAAe,EAAa,MACxB,GAIG,AACK,EAAM,EAAU,EAAiB,OAE7C,AAAO,SAwEP,AAAY,AAAkB,EAAM,KACpC,AACE,EAAO,KAAK,AAAE,EAAM,UACpB,AAAE,KAAe,yBAEnB,AAAO,MAZP,AAAI,GACJ,EAAe,KAAe,MAC9B,AAAY,EAAM,QAiClB,AAAI,EAAM,MAAa,EACvB,AAAI,AAAC,KAAM,IACX,AAAU,EAAM,AAAe,WExV/B,AAAI,EAAyB,MAC3B,EAAoB,KACpB,EAAW,MAEX,EAAS,QACT,AAAI,GAGJ,AAAO,EAAyB,aAtElC,QAAQ,MACD,OAOA,OAmCA,QA1CY,AACf,AAAQ,IACR,AAAa,IACb,AAAW,KACX,AAAO,IACP,AAAO,EAAa,KAEL,AACf,AAAY,AAAK,KACjB,AAAM,OACN,IAAO,EAAO,KACZ,AAAO,IACP,AAAI,KAAa,KACf,EAAY,KACZ,AAAa,IACb,AAAgB,EAAyB,GAAgB,KACzD,AAAO,EAAa,KAEtB,AAAM,YAER,AAAa,IACb,AAAW,KACX,AAAM,OACN,AAAI,EAAO,KACT,AAAW,KACX,AAAM,OACN,IAAO,EAAO,KACZ,AAAI,KAAa,KACf,EAAY,KACZ,AAAgB,EAAyB,GAAgB,MAE3D,AAAM,YAER,AAAW,IACX,AAAY,IACZ,AAAU,IACV,AAAQ,IACR,AAAO,OACP,AAAQ,KAEV,AAAO,EAAa,KAEJ,AAChB,AAAM,IACN,AAAI,EAAO,KACT,AAAO,OACH,GAAO,AAAO,KAAa,AAAK,qBACpC,AAAK,KACL,AAAO,IAET,EAAwB,KACxB,EAAe,KACf,AAAQ,IACR,GAGJ,AAAO,QAgKP,AAAI,GACJ,AAAI,GACJ,AAAoB,GAAc,IAAa,MAC/C,EACE,EAAU,MACV,AAAI,EAAS,KACX,AAAI,GACJ,AAAY,AAAQ,GAAa,KAAa,KAAO,MACrD,AAAI,GACJ,EAEK,EAAS,MAClB,AAAI,GACJ,AAAY,EAAQ,GAAc,AAAM,EAAQ,GAAY,QAC5D,AAAI,MFsCJ,AAAO,EAAQ,KACX,GACA,AAAC,AAAC,EAAO,GAAiB,GAAW,AAAC,MAAW,QAKrD,AAAI,EAAO,SAA+B,eAC1C,AAAO,AAAY,YA/InB,AAAI,EAAO,MACT,AAAK,IACL,AAAK,AAAM,EAAQ,MAKnB,AAAkB,EAAO,SACrB,EAAQ,EAAM,EAAW,AAAW,MAAU,IAC9C,KACJ,AAAK,EAAM,AAAW,MACtB,AAAK,AAAO,EAAgB,EAAK,IAAa,EAAK,MACnD,EAAM,EAAU,OAEd,GAAO,AAAO,EAAK,KAAW,EAAK,wBAGvC,AAAY,EAAM,IAAM,kBAAO,AAAC,KAAK,MACrC,AAAyB,IACzB,AAAI,AAAC,KAEH,AAAY,KAAc,AAAC,KAAM,EAAK,OACtC,AAAI,AAAC,KACH,AAAO,KAEP,AAAK,AAAW,KAChB,AAAQ,EAAM,IAAM,IArMxB,AAAO,AACL,EAA2B,EAAM,YAqM3B,GAAO,AAAO,mBAClB,AAAO,EAAQ,IAAM,IAAI,AAAS,6BAGpC,AAAO,EAAQ,IAAM,IAAI,AAAS,KAvLpC,AAAO,AACL,EAA2B,AAAC,AAAC,EAAM,GAAW,GAAc,aAwL9D,AAAO,SA4EP,AAAI,GAMJ,AAAI,EAAO,SAET,EAAQ,AAAC,EAAM,EAAW,AAAW,KAAU,OAIjD,AAAkB,IAClB,EAAQ,EAAkB,AAAM,AAAC,EAAsB,GAAM,GAAkB,EAA0B,IA/PzG,AAAO,AACL,cA+PF,AAAkB,AAAO,AAAC,EAAO,KAAU,AAAC,QAAY,KACxD,AAAkB,AAAI,IAAa,YACnC,AAAI,AAAY,IAAe,KAC7B,AAAI,AAAY,IAAe,KAAG,GAEpC,AAAiB,IACjB,AAAU,EAAM,EAAsB,GAAI,EAAqB,aAzF/D,AAAgB,OACZ,GAAO,AAAO,AAAE,AAAC,EAAO,GAAkB,qBAG9C,AAAgB,AAAC,EAAY,AAAC,MAAa,KAC3C,AAAI,EAAa,EAAiB,MAChC,EAAe,EAAQ,EAAY,OAEnC,AAAY,AAAkB,EAA2B,GAAiB,KAC1E,EAAe,AAAC,EAAY,GAAkB,MAC9C,AAAY,EAAM,MAIlB,EAAe,EAAY,AAAC,SAC5B,EAAS,IAlRX,AAAO,AAAkB,EAA2B,GAAkB,KAAe,AAAC,UAkRpF,6BAA0B,AAAC,eAwH7B,AAAkB,AAAY,OAC9B,AAAY,AAAY,EAAM,OAC9B,AAAI,AAAC,KACH,AAAW,EAAM,KACjB,AAAQ,AAA8B,EAAM,OACxC,GAAO,AAAO,oBAEhB,GAAO,AAAO,AAAC,KAAe,AAAC,MAAc,oBACjD,AAAY,EAAM,KAClB,AAAa,EAAM,EAAO,KAC1B,AAAI,GACJ,AAAO,MAmEP,AAAI,AAAC,KAAM,IACX,AAAO,AAAgC,EAAM,KAAS,6BErTtD,AAAI,EAAQ,SAAgC,eAC5C,AAAI,EAAS,KAAW,IACxB,AAAU,AAAmB,AAAQ,EAAkB,MAAQ,KAC/D,EAAW,KACX,EAAa,KACb,EAAW,EAAW,KACtB,EAAS,QACT,AAAU,EAAyB,KAEnC,AAAY,EAAK,EAAG,KACpB,AAAO,QAuBP,AAAI,AAAC,KAAU,EACX,GAAO,AAAO,mBAClB,AAAY,AAAmB,EAAW,KAC1C,AAAI,KAAe,KACjB,AAAa,AAAmB,EAAY,KAC5C,AAAkB,OAClB,AAAI,EAAe,AAAK,MAEtB,AAAI,IAGF,MAGA,OAEG,AAAI,EAAe,KAAe,EAAS,SAEhD,2FiBkXc,0EQ3mBlB,AAAQ,EAAQ,KAAI,AAAI,EAAM,KAAO,WAAK,AAAI,IAAO,aACrD,AAAQ,EAAQ,KAAI,AAAI,EAAM,KAAO,WAAK,AAAI,IAAO,aAEjD,EAAe,IAAG,AAChB,EAAQ,KACV,AACE,EAAM,GACN,EACA,AAAQ,EAAM,yGG69FC,QAmEH,0JI9hGK,KACE,KACH,KACD,KACI,KACD,KACF,KACG,KACK,KACC,KACD,KACP,KACE,KACE,0a5BgD3B,AAAI,EAAQ,OACV,AAAI,EAAQ,MACV,AAAO,EAAI,AAAI,EAAS,MAExB,AAAO,EAAI,AAAI,EAAS,MAAS,AAAI,EAAS,SAGhD,AAAI,EAAQ,QACV,AAAO,EAAI,AAAI,EAAS,QAExB,AAAO,EAAI,AAAI,EAAS,QAAc,AAAI,EAAS,oBAyCvD,IAAO,EAAO,OAEZ,AAAQ,EAAM,OACd,AAAQ,EAAM,OACd,AAAM,IAEN,AAAS,EAAI,MACb,AAAS,EAAI,MAEb,AAAc,AAAe,IAAU,EAAa,SACpD,AAAc,AAAe,IAAU,EAAa,SAEpD,EAAU,KACV,AAAW,EAAU,EAAU,IAAI,EAAW,EAAW,YAG3D,AAAI,EAAO,MACT,AAAS,EAAM,MACf,AAAS,EAAM,MACf,AAAM,IACN,EAAU,KACV,AAAa,AAAU,IAAU,EAAa,SAC9C,AAAW,EAAU,EAAU,IAAI,MAGrC,AAAI,EAAO,KACT,EAAU,KACV,AAAa,AAAU,IAAU,EAAc,SAC/C,AAAW,EAAU,EAAU,IAAI,MAEnC,EAAU,KACV,AAAY,EAAc,KAC1B,AAAW,EAAU,EAAU,IAAI,SAoCrC,IAAO,EAAU,KACf,EAAU,KACV,AACE,EAAU,EAAU,IACpB,AAAU,IAAO,AAAC,GAAa,IAAS,UAE1C,EAAQ,UAEV,AAAI,EAAS,KACX,AAAW,EAAQ,AAAU,IAAO,GAAc,mBA9FpD,AAAI,EAAW,IAxCf,AAAO,AAAU,GAAU,QAyCzB,AAAO,AAAC,EAAK,AAAS,KAAS,EAAK,AAAS,KAAS,KAE9C,KAAe,IAAc,IACvC,IAAO,EAAO,KACZ,EAAO,KACP,EAAK,KACL,EAAM,UAER,IAAO,EAAO,KACZ,EAAO,KACP,YAEF,AAAO,EAAI,UAoJX,AAAW,KACX,AAAI,AAAC,EAAS,EAAQ,IAAO,KAC3B,AAAY,AAAI,AAAI,GAAS,MAC7B,AAAW,EAAO,KAClB,EACE,OACA,AAAW,EAAU,EAAU,IAAI,AAAU,IAAO,AAAM,EAAM,IAAS,UACzE,EAAQ,KACD,SAET,EACE,OACA,AAAQ,EAAM,KACd,AAAW,EAAU,EAAU,IAAI,AAAU,IAAO,AAAM,EAAM,EAAI,KAAS,UAC7E,AAAM,IACC,YkCzQT,AAAO,AAAO,EAAM,kaJoId,MACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,UACA,YAzMK,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACN,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACP,AAAO,MACN,AAAO,MACP,AAAO,MACV,AAAO,U5BgNlB,AAAW,EAA2B,EAAU,MAChD,AAAW,EAA2B,EAAU,MAC5C,EAAmB,IAAG,AACpB,EAAO,KAAK,AAAE,AAAC,EAAO,GAAM,EAAO,WACrC,IACE,AAAI,AAAU,KAAS,AAAU,QAAO,GACxC,EAAQ,KACR,EAAQ,KACR,EAAQ,KACD,EAAO,QAGpB,IAAO,aACL,AAAQ,AAAe,OACvB,AAAQ,AAAe,OACvB,AAAI,EAAK,KAAG,AAAO,EAAI,KACvB,EAAQ,KACR,EAAQ,UAEV,AAAO,6Fa/nBH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,oDA1CH,GAEG,AAAI,GAGJ,AAAI,GAGJ,AACD,EAAe,IAAG,AAAO,EAAO,IAAU,IAyBhD,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,mHnByOP,AAAa,AAAmB,EAAS,KAEzC,AAAI,EAAQ,AAAC,KAAgB,AAAC,MAAK,MACjC,EAAgB,KAChB,AAAO,IAIT,AAAa,AAAM,EAAM,UACzB,AAAY,EAAQ,EAAQ,AAAI,IAAM,iBACtC,AAAO,kBWnQP,AAAa,AAAM,EAAM,OACzB,AAAI,IAAM,AAAY,EAAQ,EAAM,OACpC,AAAO,wvB+BoEL,AAAS,EAA2B,EAAgB,IAAe,KAC/D,GAAgB,AACX,EAAyB,EAA0B,QAvC5D,AAAO,AAAmB,EAA0B,MAA2B,w2CvB3D7E,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,0jBA1CH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,4mBA1CH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,unDA1CH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,g/BYiNL,AAAO,EAAQ,wBYrPjB,AAAO,EAAK,KAAK,AAAC,EAAK,EAAI,IAAO,8B/BiClC,gCAAQ,MACD,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,UAduB,AAAO,MACN,AAAO,MACP,AAAO,MACX,AAAO,MACb,AAAO,MACJ,AAAO,MACG,AAAO,MACf,AAAO,MACF,AAAO,MACX,AAAO,MACf,AAAO,MACD,AAAO,MACJ,AAAO,MACL,AAAO,MACX,AAAO,KAEjC,AAAO,mBACP,AAAO,uWOzDH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,iGam7FP,AAAO,AAAkC,QAqHzC,AAAO,AAAgC,QARvC,AAAO,AAAmC,QAJ1C,AAAO,AAAmC,gBAQ1C,AAAO,AAAmC,QAQ1C,AAAO,AAAW,AAAmC,WAIrD,AAAO,AAA8B,QAIrC,AAAO,AAAgC,QAzHvC,AAAO,AAAmC,QA6H1C,AAAO,AAAiC,QAIxC,AAAO,AAA6B,QArIpC,AAAO,AAAoC,QAQ3C,AAAO,AAAsC,QAQ7C,AAAO,AAAmC,QAI1C,AAAO,AAAmC,QAqI1C,AAAO,AAA+B,QAZtC,AAAO,AAA+B,QAgCtC,AAAO,AAAW,AAA+B,WAIjD,AAAO,AAAsC,QAI7C,AAAO,AAAkC,EAAM,QAQ/C,AAAO,AAA8B,QAIrC,AAAO,AAA+B,QAoBtC,AAAO,AAAkC,QAIzC,AAAO,AAAmC,QAgB1C,AAAO,AAAW,AAAgC,yZb1sG9C,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,+VA1CH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,uZFsKP,AAAO,AAAC,EAAI,KAAW,QAOvB,AAAO,AAAC,EAAI,KAAW,QAKvB,AAAO,IAAW,AAAC,EAAK,IAAU,IAAO,EAAK,wNE5N1C,GAEG,AAAI,GAGJ,AAAI,GAGJ,AACD,EAAe,IAAG,AAAO,EAAO,IAAU,IAyBhD,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,iDam8FP,AAAO,AAAuC,UAuB9C,AAAI,AAAgB,KAAS,KAAoB,AAAO,IACxD,AAAW,AAAkB,OAC7B,AAAI,EAAQ,MAAa,AAAO,AAAiB,KAAS,KAC1D,AAAI,EAAQ,MAAa,AAAO,AAAC,AAAoB,KAAQ,AAAqB,MAAU,KAC5F,AAAI,EAAQ,MAAa,AAAO,AAAiB,KAAS,QAC1D,AAAI,EAAQ,MAAa,AAAO,AAAiB,KAAS,YAC1D,AAAO,MAgJP,AAAO,AAAiC,QAhDxC,AAAO,AAAgC,UA5FvC,AAAI,AAAgB,KAAS,KAAoB,AAAO,IACxD,AAAW,AAAkB,OAC7B,AAAI,EAAQ,MAAa,AAAO,AAAiB,KAAS,KAC1D,AAAI,EAAQ,MAAa,AAAO,AAAC,AAAoB,KAAQ,AAAqB,MAAU,KAC5F,AAAI,EAAQ,MAAa,AAAO,AAAiB,KAAS,QAC1D,AAAI,EAAQ,MAAa,AAAO,AAAiB,KAAS,YAC1D,AAAO,MA0LP,AAAO,AAAqC,QAI5C,AAAO,AAAmC,EAAM,+ZAlhG9C,UAAQ,MACD,QACA,QACA,QACA,SAHe,AAAO,MACJ,AAAO,MACE,AAAO,MACX,AAAO,MAErC,AAAO,oBACP,AAAO,6TbvML,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,2NsB6+EL,AAAO,iKbxnEP,MAAQ,MACD,QACA,SADiB,AAAO,KACL,AAAO,KAEjC,AAAO,4GF5BD,MACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SA/Cc,AAAO,MACX,AAAO,MACC,AAAO,MACd,AAAO,MACJ,AAAO,MACT,AAAO,KACN,AAAO,MACD,AAAO,MACb,AAAO,MACJ,AAAO,MACJ,AAAO,MACH,AAAO,MACJ,AAAO,MACZ,AAAO,MACF,AAAO,MACL,AAAO,MACF,AAAO,MAC5B,AAAO,MACN,AAAO,MACK,AAAO,MAChB,AAAO,MACV,AAAO,IACL,AAAO,MACL,AAAO,MACL,AAAO,MACD,AAAO,MACD,AAAO,MACK,AAAO,MACjC,AAAO,MACb,AAAO,MACL,AAAO,MACD,AAAO,MACb,AAAO,KACO,AAAO,MACnB,AAAO,MACR,AAAO,MACF,AAAO,MACN,AAAO,MACJ,AAAO,MACE,AAAO,MACnB,AAAO,MACL,AAAO,MACG,AAAO,MACD,AAAO,MACK,AAAO,MACjC,AAAO,MACb,AAAO,MACL,AAAO,MACvB,AACP,AAAO,oBACP,AAAO,SExCT,cAAQ,MACD,QACA,QACA,QACA,QACA,QACA,SALY,AAAO,KACN,AAAO,KACD,AAAO,KACb,AAAO,KACH,AAAO,KACL,AAAO,KAEjC,AAAO,UA7CP,8DAAQ,MACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,UA5BmB,AAAO,MAEN,AAAO,MAEJ,AAAO,MAEV,AAAO,MAEL,AAAO,MAEG,AAAO,MAEf,AAAO,MAEb,AAAO,MAEL,AAAO,MAEK,AAAO,MAED,AAAO,MAEK,AAAO,KACpC,AAAO,KACF,AAAO,KACd,AAAO,KACA,AAAO,KACjB,AAAO,KACA,AAAO,KAErC,AAAO,0cT7YL,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,6JaqtGP,AAAO,AAAkC,0GAvUvC,AAA2C,EAAM,EAAM,EAAW,EAAY,eAwfhF,AAAO,AAA2C,EAAM,0XAzdxD,AAAO,AAAiC,kBbv9FpC,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,sMa8+FP,AAAI,AAAgB,KAAS,KAAoB,AAAO,IACxD,AAAW,AAAkB,OAC7B,AAAI,EAAQ,MACV,AAAQ,AAAiB,OACzB,AAAO,EAAK,QAAK,EAAW,IanhG9B,AAAO,AAAiB,MbmhGW,SAEnC,AAAI,EAAQ,MACV,AAAQ,AAAiB,OACzB,AAAO,EAAK,YAAK,EAAY,EAAW,Ia3gG1C,AAAO,AAAiB,Q5CuNxB,AAAO,AAAO,EAAU,e+BszFxB,AAAO,yC/Bx8FP,AAAI,EAAS,KACX,AAAI,EAAQ,KAAI,AAAO,AAAY,EAAI,EAAG,EAAQ,SAClD,AAAO,AAAI,EAAS,IAAK,AAAI,EAAQ,OAEvC,AAAI,EAAS,KAAG,AAAO,IACvB,AAAI,EAAS,KAAG,AAAO,EAAO,KAC9B,AAAkB,IAClB,IAAO,OACL,AAAI,EAAQ,QAAG,EAAU,MACzB,EAAW,KACX,EAAQ,UAEV,AAAO,mE8CykCL,AAAI,AAAiB,GAAM,YACzB,AAAI,EAAK,YAAK,AAAO,EAAI,KACzB,AAAI,EAAK,YACP,AAAO,AACL,AAAiB,AAAkB,IACnC,SACA,EAAK,AAAC,cAGV,AAAI,EAAK,YAAM,AAAO,SAAI,KAC1B,AAAI,EAAK,YAAK,AAAO,IACrB,AAAI,EAAK,YAAK,AAAO,YAEnB,EAAmB,IAAG,AACjB,EAAQ,IAAG,I1CqoBtB,AAAqB,IACrB,AAAS,AAAiB,KAC1B,AAAS,AAAiB,KAC1B,AAAW,EAAM,KACjB,AAAW,EAAM,KAEjB,AAAI,EAAO,GAAS,GAAQ,SAAS,AAAC,EAAO,IAAS,IAAS,GAAQ,QAKrE,AAAI,EAAW,8BACb,AAAI,AAAC,EAAM,GAAM,KAAG,AAAO,YAC3B,AAAI,EAAM,aAAoB,AAAO,YACrC,AAAI,AAAC,EAAM,GAAK,eAAsB,AAAC,EAAM,GAAK,aAAoB,AAAO,EAAI,MACjF,AAAI,AAAC,EAAM,GAAM,cAAoB,AAAO,YAC5C,AAAI,AAAC,AAAC,EAAM,GAAK,YAAuB,AAAE,EAAM,UAAK,AAAO,YAC5D,AAAO,EAAI,MAEb,AAAI,EAAW,IA9LjB,AAAO,AAAC,EAAK,GAAK,GAAK,SAAqB,SA+LxC,AAAS,EAAI,KACb,AAAI,AAAI,EAAM,MAAO,EAAS,gGAAO,SAAG,AAAK,AAAC,MAC9C,AAAO,EAAU,KAAI,SAAI,IAAK,MAGhC,AAAI,EAAU,KAEZ,AAAW,EAAS,IArOxB,AAAQ,EAAM,GAAK,MACnB,AAAI,EAAI,MAAY,AAAO,KAC3B,AAAI,EAAI,GAAQ,MAAI,AAAO,KAC3B,AAAI,EAAW,GAAQ,GAAK,MAC5B,AAAI,EAAM,EAAI,SAAI,AAAO,KACzB,AAAI,EAAM,QAAQ,AAAO,KACzB,AAAO,OAgOH,AAAI,EAAQ,KAAG,AAAO,AAAC,EAAI,GAAM,EAAI,OACrC,AAAI,EAAQ,KAAG,AAAY,OAC3B,EAAQ,cACR,EAAQ,OAEV,AAAI,AAAC,EAAO,IAAS,IAAS,GAAQ,OAEpC,AAAI,EAAM,aAAoB,AAAO,YACrC,AAAI,AAAC,EAAO,IAAS,MAAS,AAAO,YACrC,AAAO,AAAC,EAAK,WAAwB,EAAO,OAAS,UAAW,aAElE,AAAI,EAAQ,KAEV,AAAK,AAAiB,EAAI,aAC1B,EAAM,cACN,EAAM,EAAW,QAIrB,AAAS,EAAW,IA3LpB,AAAU,EAAK,aACf,AAAU,AAAO,EAAQ,EAAK,KAAuB,QACrD,AAAU,EAAY,KACtB,AAAU,EAAM,EAAM,GAAc,OACpC,AAAU,AAAiB,KAC3B,AAAU,KAGV,AAAe,AAAU,IAAoB,EAAM,EAAI,UACvD,AAAe,AAAU,IAAoB,EAAM,EAAI,UACvD,AAAe,AAAU,IAAoB,EAAM,EAAI,UAKvD,AAAU,AAAiB,AAAC,EAAK,OAAmB,UACpD,AAAU,EAAI,KACd,AAAU,EAAM,GAAO,YACvB,AAAU,EAAM,KAChB,AAAU,EAAM,KAGhB,AAAU,EAAK,UAAQ,KACvB,AAAU,EAAK,KACf,AAAU,EAAK,UAAQ,KACvB,AAAU,EAAK,GAAK,KAGpB,AAAU,SAAK,KACf,AAAU,EAAI,KACd,AAAU,EAAI,KAEd,AAAY,SAAM,KAClB,AAAY,EAAM,KAClB,AAAY,EAAM,KAClB,AAAY,EAAO,EAAK,MACxB,AAAY,EAAK,GAAK,KAGtB,AAAS,EAAO,SAAK,EAAI,WAAK,EAAO,SAAK,EAAI,WAAK,EAAO,SAAK,EAAI,kBACnE,AAAS,EAAM,GAAM,GAAM,GAAM,KACjC,AAAS,EAAK,KACd,AAAW,EAAK,GAAI,MAEpB,AAAO,OAgJP,AAAS,KAMT,AAAU,AAAiB,EAAK,SAChC,AAAU,EAAI,KACd,AAAU,AAAiB,AAAiB,GAAM,SAClD,AAAU,EAAK,GAAM,KACrB,AAAM,EAAM,KACZ,AAAM,EAAM,GAAM,EAAI,MAEtB,AAAO,EAAW,IAAK,IAAK,IA7H5B,AAAS,AAAiB,KAC1B,AAAS,AAAI,EAAM,IAAM,MACzB,AAAI,EAAS,IAAS,KACpB,AAAI,EAAS,IAAS,SAGpB,AAAO,AAAO,SAAM,SAAK,MAE3B,AAAI,EAAU,MAEZ,AAAO,EAAU,KACb,EAAM,IAnId,AAAO,EAAM,IAAM,AAAiB,+BAoI5B,EAAM,IA9Hd,AAAO,EAAM,IAAM,AAAiB,cAZpC,AAAO,AAAO,AAAC,GAAG,EAAG,GAAQ,aA6I3B,AAAS,KAKX,AAAI,SAAU,KAYd,AAAM,EAAI,YACV,AAAM,AAAiB,KACvB,EAAM,YAEN,AAAI,EAAI,EAAK,WAAY,EAAK,aAE9B,EAAK,KAEL,AAAM,AAAO,EAAK,KAAW,MAC7B,AAAM,AAAC,EAAK,IAAe,EAAK,OAEhC,AAAO,AAAiB,AAAU,IAAgB,EAAO,UAEzD,AAAQ,AAAU,IAAgB,EAAO,OAAwC,KAGjF,AAAK,EAAI,KAGT,AAAM,EAAO,GAAI,EAAM,SAAK,EAAI,aAAM,EAAK,GAAM,SAAK,EAAI,eAC1D,AAAI,EAAU,KAAG,AAAO,EAAY,IAAK,IAAO,IAztChD,AAAI,AAAE,EAAK,aAET,EAAS,GAAa,MACtB,AAAQ,AAAiB,KACzB,AAAO,SAAY,EAAQ,EAAQ,QAGrC,EAAS,GAAa,MAEtB,AAAQ,AAAiB,KACzB,AAAQ,EAAQ,EAAQ,MACxB,AAAI,AAAI,GAAK,YAKX,AAAU,AAAS,SAAK,KACxB,AAAS,EAAQ,GAAI,EAAQ,MAC7B,AAAS,EAAM,KACf,AAAK,EAAM,GAAK,GAAI,KACpB,AAAK,AAAC,EAAK,GAAM,KAEjB,AAAI,EAAK,YAAK,AAAI,AAAiB,EAAQ,iBAE7C,AAAO,EAAI,gBAksCX,AAAQ,AAAiB,KAGzB,AAAO,EAAQ,EAAQ,csChzDvB,AAAI,AAAC,IAaL,AAAO,AAAS,EAAG,09CX65GnB,AAAO,AAAC,AAAe,EAAM,KAAU,AAAE,EAAyB,OAA6B,mRMpkG7F,AAAO,AAAc,iBAAU,AAAW,GAAU,6WUjUtD,AAAO,iZhBwzCL,AAAO,EAAW,GAAkC,EAAgB,u6Cf5nCtE,AAAO,EAAK,KAAe,EAAK,qBANhC,AAAS,EAAI,KACb,AAAO,EAAM,MAAc,EAAM,YALjC,AAAO,EAAI,AAAI,EAAK,UA+BpB,AAAO,AAAQ,UAAM,AAAU,mDSmGvB,MACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,yBAAY,AAAO,IACf,AAAO,iCTvNV,MACD,OACA,OACA,OACA,OACA,QACA,QACA,QACA,SACA,SACA,SACA,oBAAwB,AACpB,IAEA,AACA,EAAK,OAAmB,EAAK,6JSu2BtC,AAAgB,oJThyBlB,AAAS,EAAI,KACb,AAAO,EAAM,MAAc,EAAM,wBAzGzB,MACD,OACA,OACA,SACA,aAA6B,AACzB,IAEA,AACA,64BA2FX,AAAO,EAAK,KAAe,EAAK,cX0RhC,AAAI,EAAI,MAGN,AAAO,AAAC,AAAC,EAAI,IAAS,SAAU,EAAI,GAAQ,EAAO,OAErD,AAAI,EAAI,KAAU,IAAS,QAAQ,AAAO,IAC1C,gBAAQ,MACD,QACA,SACA,SACA,SACA,SACA,SACA,gBAAQ,AAAO,IAEtB,AAAO,SyCkiFP,AAAU,IACN,EAAmB,IAAG,AACxB,AAAI,EAAK,KACP,AAAO,AAAY,EAAK,GAAG,EAAG,EAAS,MAEzC,AAAI,EAAK,KACP,AAAI,EAAK,KAAI,AAAO,AAAY,EAAI,EAAG,EAAI,MAC3C,AAAO,AAAI,EAAK,GAAK,AAAI,EAAK,MAE3B,AAAI,EAAK,KAAG,AAAO,IACnB,AAAI,EAAK,KAAG,AAAO,EAAI,KACvB,AAAI,EAAI,KACX,AAAU,EAAK,AAAI,MAGnB,YAAQ,MACD,OAKA,OAKA,OAKA,OAKA,QApBG,AACN,AAAI,EAAI,KAAG,EAAO,MAClB,EAAO,KACP,EAAK,MAEC,AACN,AAAI,EAAI,KAAG,EAAO,MAClB,EAAO,KACP,EAAK,MAEC,AACN,AAAI,EAAI,KAAG,EAAO,MAClB,EAAO,KACP,EAAK,MAEC,AACN,AAAI,EAAI,KAAG,EAAO,MAClB,EAAO,KACP,EAAK,MAEC,AACF,EAAI,KAAG,EAAO,OAGtB,AAAO,OAGX,IAAO,IACL,AAAI,EAAI,KAAG,EAAO,MAClB,EAAO,KACP,EAAK,UAEP,AAAO,WAxkDL,AAAQ,IACR,AAAI,EAAI,MACN,EAAK,YACL,EAAK,MACL,AAAI,EAAI,MACN,EAAK,YACL,AAAI,AAAiB,EAAI,MAAM,eAE5B,AAAI,EAAI,MAGb,EAAK,SAAY,aACjB,EAAK,GAAO,MACZ,AAAI,EAAI,MACN,EAAK,SAAY,aACjB,AAAI,AAAiB,EAAI,IAAO,KAAI,gBAGxC,AAAO,EAAI,AAAiB,AAAM,GAAQ,IAAM,uuBEk2FlD,4FAAQ,MACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OACA,OACA,OACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SA5Ca,AAAO,gBAaF,AAAO,IACT,AAAO,IACR,AAAO,IACK,AAAO,IACvB,AAAO,IACL,AAAO,IACH,AAAO,OAIS,AAAO,UAOd,AAAO,MAGU,AAAO,KAErC,AAAO,MAGL,AAAO,IACG,AAAO,KAEb,AAAO,MAGP,AAAO,IAEjC,AAAO,myC9Bt8IH,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,+kBSq0FG,MACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SAZsB,AAAO,MAEC,AAAO,KACP,AAAO,KACN,AAAO,KACb,AAAO,KACX,AAAO,KACN,AAAO,KACL,AAAO,KACL,AAAO,KACV,AAAO,KACV,AAAO,KACL,AAAO,KACzB,AAAO,8uBT73FhB,GAEG,AAAI,GAAkB,AACvB,EAAe,IAAG,AAAO,EAAO,IA8BH,IACnC,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,uJak7EL,AAAqC,2nCMlyErC,AAAO,AAAO,EAAM,0BlCpCtB,AAAI,EAAQ,YACV,AAAI,EAAQ,UACV,AAAO,EAAK,AAAI,EAAS,SAAgB,AAAI,EAAS,UAEtD,AAAO,EAAK,AAAI,EAAS,UAAmB,AAAI,EAAS,cAG3D,AAAI,EAAQ,aACV,AAAO,EAAK,AAAI,EAAS,aAEzB,AAAO,EAAK,AAAI,EAAS,aAAwB,AAAI,EAAS,yBA4DlE,IAAO,EAAO,QACZ,AAAQ,EAAM,QACd,AAAQ,AAAQ,EAAM,EAAI,UAC1B,AAAM,IAEN,AAAQ,EAAI,OACZ,AAAQ,EAAI,OAEZ,AAAS,EAAI,MACb,AAAS,EAAI,MACb,AAAS,EAAI,MACb,AAAS,EAAI,MAEb,AAAc,AAAe,IAAU,EAAa,SACpD,AAAc,AAAe,IAAU,EAAa,SAEpD,EAAU,KACV,AAAW,EAAU,EAAU,IAAI,EAAW,EAAW,OAEzD,AAAU,AAAe,IAAU,EAAa,SAChD,AAAU,AAAe,IAAU,EAAa,SAEhD,EAAU,KACV,AAAW,EAAU,EAAU,IAAI,EAAW,EAAW,YAG3D,AAAe,EAAQ,GAAU,QkCvC/B,AAAO,AAAO,EAAM,SA7GpB,AAAO,AAAO,EAAM,gzBN8nGtB,AAAO,AAAW,AAAkC,ygBuBtqGlD,AAAmB,IACnB,AAAY,EAAY,KACxB,IAAO,EAAQ,KACb,AAAY,EAAM,GAAO,EAAK,MAC9B,EAAS,6oCvBs4EX,AAAmC,QAQnC,AAAiC,QAQjC,AAA+B,QAgB/B,AAAsC,QAQtC,AAA8B,QAgB9B,MAQA,AAAyC,QAQzC,AAA2C,QAQ3C,AAA4C,QAQ5C,AAAqD,QApErD,AAAO,SVv7ET,AAAiB,IACjB,AAAgB,QAChB,AAAO,MAPP,AAAO,mBeyEC,MACD,OACA,OACA,OACA,QAH6B,AAAO,KACX,AAAO,KACJ,AAAO,KACT,AAAO,KAC7B,AACP,AAAO,oBACP,AAAO,mBArBH,MACD,OACA,OACA,OACA,QAH6B,AAAO,MACX,AAAO,MACJ,AAAO,MACT,AAAO,MAC7B,AACP,AAAO,oBACP,AAAO,SrC+OX,AAAI,IACF,AAAU,AAAmB,EAAM,KACnC,AAAI,KAAa,KACC,gBAElB,KACA,EAAW,EAAU,MAEvB,AAAO,QAMP,AAAI,AAAC,KAAK,EACV,AAAU,AAAmB,EAAM,KACnC,AAAI,KAAa,KACC,gBAElB,AAAI,EAAS,KAIX,MAEA,KACA,EAAW,EAAW,SAOxB,AAAI,GACJ,AAAI,EAAQ,OAEH,EAAS,KAAY,SAG9B,IACA,IAAO,EAAS,KAAY,SAC5B,AAAY,AAAQ,GAAa,KAAa,KAAO,MACrD,AAAI,GACJ,AAAI,2wFmD5MJ,IAAQ,AAAyB,QAE1B,QAAoB,AAAO,AAAC,AAAY,QAK/C,AAAO,yBhCnLH,GAEG,AAAI,GAGJ,AAAI,GAGJ,AACD,EAAe,IAAG,AAAO,EAAO,IAAU,IAyBhD,AAAa,EAAa,OAAW,KACrC,EAAK,EAAM,UACX,AAAK,AAAK,EAAG,GAAM,SACnB,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,+O+Bm0CP,gKAAQ,AAAyB,QAC1B,OAWA,OAkBA,OAQA,OAaA,OAaA,OAWA,OAgBA,OAGA,OAQA,OAGA,OAQA,OAQA,OAaA,OAGA,OAQA,OAaA,OAkBA,OAQA,OAQA,OAGA,OAQA,OAGA,OAGA,OAaA,OAkBA,OAkBA,OAaA,OAGA,OAQA,OAaA,OAaA,OAkBA,OAaA,OAQA,OAaA,OAkBA,OAGA,OAkBA,OAkBA,OAGA,OAGA,OAQA,OAGA,OAaA,OAgBA,OAWA,OAGA,OAWA,OAQA,OAQA,OAQA,OAgBA,OAQA,OAQA,OAQA,OAWA,OAQA,OAaA,OAaA,QAWA,QAaA,QAkBA,QAQA,QA4BA,QAQA,QAuBA,QAGA,QAQA,QAkBA,QAaA,QAaA,QAQA,QAkBA,QAaA,QAQA,QAaA,QAkBA,SAt0BoB,AACvB,AAAkB,AAA6B,MAC1C,AAAe,MAAG,EAAI,KACzB,AAAY,AAAyB,EAAQ,MAC7C,AAAI,EAAS,KACX,AAAyB,EAAQ,EAAG,KACpC,AAAO,IAJ6B,AAAE,WAO1C,GAEoB,AACpB,AAAgB,AAAwB,MACxC,AAAI,EAAa,KACf,AAAwB,EAAQ,KAChC,AAAO,IAET,AAAa,AAAqB,MAClC,AAAI,EAAU,KACZ,AAAqB,EAAQ,KAC7B,AAAO,IAET,AAAc,AAAsB,MACpC,AAAI,EAAW,KACb,AAAsB,EAAQ,KAC9B,AAAO,IAET,GAEsB,AACtB,AAAW,AAAqB,OAChC,AAAI,EAAQ,KACV,AAAqB,EAAQ,KAC7B,AAAO,IAET,GAEuB,AACvB,AAAgB,AAA2B,OAC3C,AAAI,EAAa,KACf,AAA2B,EAAQ,KACnC,AAAO,IAET,AAAY,AAAuB,OACnC,AAAI,EAAS,KACX,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAEwB,AACxB,AAAgB,AAA4B,OAC5C,AAAI,EAAa,KACf,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAY,AAAwB,OACpC,AAAI,EAAS,KACX,AAAwB,EAAQ,KAChC,AAAO,IAET,GAEsB,AACtB,AAAkB,AAA4B,MACzC,AAAe,MAAG,EAAI,KACzB,AAAc,AAA0B,EAAQ,MAChD,AAAI,EAAW,KACb,AAA0B,EAAQ,EAAG,KACrC,AAAO,IAJ6B,AAAE,WAO1C,GAE8B,AAC9B,AAAa,AAA+B,OAC5C,AAAI,EAAU,KACZ,AAA+B,EAAQ,KACvC,AAAO,IAET,AAAkB,AAAoC,OACjD,AAAe,MAAG,EAAI,KACzB,AAAc,AAAkC,EAAQ,OACxD,AAAI,EAAW,KACb,AAAkC,EAAQ,EAAG,KAC7C,AAAO,IAJ6B,AAAE,WAO1C,GAE0B,GAGA,AAC1B,AAAY,AAA0B,MACtC,AAAI,EAAS,KACX,AAA0B,EAAQ,KAClC,AAAO,IAET,GAE2B,GAGA,AAC3B,AAAY,AAA2B,OACvC,AAAI,EAAS,KACX,AAA2B,EAAQ,KACnC,AAAO,IAET,GAEsB,AACtB,AAAU,AAAoB,OAC9B,AAAI,EAAO,KACT,AAAoB,EAAQ,KAC5B,AAAO,IAET,GAEuB,AACvB,AAAU,AAAqB,OAC/B,AAAI,EAAO,KACT,AAAqB,EAAQ,KAC7B,AAAO,IAET,AAAY,AAAuB,OACnC,AAAI,EAAS,KACX,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAEuB,GAGA,AACvB,AAAY,AAAuB,MACnC,AAAI,EAAS,KACX,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAEwB,AACxB,AAAW,AAAuB,MAClC,AAAI,EAAQ,KACV,AAAuB,EAAQ,KAC/B,AAAO,IAET,AAAY,AAAwB,MACpC,AAAI,EAAS,KACX,AAAwB,EAAQ,KAChC,AAAO,IAET,GAEwB,AACxB,AAAa,AAAyB,MACtC,AAAI,EAAU,KACZ,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAc,AAA0B,MACxC,AAAI,EAAW,KACb,AAA0B,EAAQ,KAClC,AAAO,IAET,AAAgB,AAA4B,OAC5C,AAAI,EAAa,KACf,AAA4B,EAAQ,KACpC,AAAO,IAET,GAEsB,AACtB,AAAY,AAAsB,OAClC,AAAI,EAAS,KACX,AAAsB,EAAQ,KAC9B,AAAO,IAET,GAEwB,AACxB,AAAY,AAAwB,OACpC,AAAI,EAAS,KACX,AAAwB,EAAQ,KAChC,AAAO,IAET,GAE4B,GAGA,AAC5B,AAAY,AAA4B,OACxC,AAAI,EAAS,KACX,AAA4B,EAAQ,KACpC,AAAO,IAET,GAEqB,GAGQ,GAGF,AAC3B,AAAU,AAAyB,OACnC,AAAI,EAAO,KACT,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAY,AAA2B,OACvC,AAAI,EAAS,KACX,AAA2B,EAAQ,KACnC,AAAO,IAET,GAE+B,AAC/B,AAAU,AAA6B,OACvC,AAAI,EAAO,KACT,AAA6B,EAAQ,KACrC,AAAO,IAET,AAAe,AAAkC,OACjD,AAAI,EAAY,KACd,AAAkC,EAAQ,KAC1C,AAAO,IAET,AAAW,AAAqC,OAChD,AAAI,EAAQ,KACV,AAAqC,EAAQ,KAC7C,AAAO,IAET,GAE4B,AAC5B,AAAU,AAA0B,OACpC,AAAI,EAAO,KACT,AAA0B,EAAQ,KAClC,AAAO,IAET,AAAe,AAA+B,OAC9C,AAAI,EAAY,KACd,AAA+B,EAAQ,KACvC,AAAO,IAET,AAAc,AAA8B,OAC5C,AAAI,EAAW,KACb,AAA8B,EAAQ,KACtC,AAAO,IAET,GAE8B,AAC9B,AAAU,AAA4B,OACtC,AAAI,EAAO,KACT,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAkB,AAAoC,OACtD,AAAI,EAAe,KACjB,AAAoC,EAAQ,KAC5C,AAAO,IAET,GAE6B,GAGA,AAC7B,AAAU,AAA2B,OACrC,AAAI,EAAO,KACT,AAA2B,EAAQ,KACnC,AAAO,IAET,GAE6B,AAC7B,AAAU,AAA2B,OACrC,AAAI,EAAO,KACT,AAA2B,EAAQ,KACnC,AAAO,IAET,AAAY,AAA6B,OACzC,AAAI,EAAS,KACX,AAA6B,EAAQ,KACrC,AAAO,IAET,GAE6B,AAC7B,AAAW,AAA4B,OACvC,AAAI,EAAQ,KACV,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAY,AAA6B,OACzC,AAAI,EAAS,KACX,AAA6B,EAAQ,KACrC,AAAO,IAET,GAE6B,AAC7B,AAAQ,AAAyB,OACjC,AAAI,EAAK,KACP,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAQ,AAAyB,OACjC,AAAI,EAAK,KACP,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAQ,AAAyB,OACjC,AAAI,EAAK,KACP,AAAyB,EAAQ,KACjC,AAAO,IAET,GAE2B,AAC3B,AAAU,AAAyB,OACnC,AAAI,EAAO,KACT,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAY,AAA2B,OACvC,AAAI,EAAS,KACX,AAA2B,EAAQ,KACnC,AAAO,IAET,GAE0B,AAC1B,AAAU,AAAwB,OAClC,AAAI,EAAO,KACT,AAAwB,EAAQ,KAChC,AAAO,IAET,GAEmC,AACnC,AAAU,AAAiC,OAC3C,AAAI,EAAO,KACT,AAAiC,EAAQ,KACzC,AAAO,IAET,AAAU,AAAiC,OAC3C,AAAI,EAAO,KACT,AAAiC,EAAQ,KACzC,AAAO,IAET,GAE4B,AAC5B,AAAW,AAA2B,OACtC,AAAI,EAAQ,KACV,AAA2B,EAAQ,KACnC,AAAO,IAET,AAAa,AAA6B,OAC1C,AAAI,EAAU,KACZ,AAA6B,EAAQ,KACrC,AAAO,IAET,AAAW,AAA2B,OACtC,AAAI,EAAQ,KACV,AAA2B,EAAQ,KACnC,AAAO,IAET,GAE0B,GAGE,AAC5B,AAAW,AAA2B,OACtC,AAAI,EAAQ,KACV,AAA2B,EAAQ,KACnC,AAAO,IAET,AAAa,AAA6B,OAC1C,AAAI,EAAU,KACZ,AAA6B,EAAQ,KACrC,AAAO,IAET,AAAW,AAA2B,OACtC,AAAI,EAAQ,KACV,AAA2B,EAAQ,KACnC,AAAO,IAET,GAE4B,AAC5B,AAAW,AAA2B,OACtC,AAAI,EAAQ,KACV,AAA2B,EAAQ,KACnC,AAAO,IAET,AAAY,AAA4B,OACxC,AAAI,EAAS,KACX,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAW,AAA2B,OACtC,AAAI,EAAQ,KACV,AAA2B,EAAQ,KACnC,AAAO,IAET,GAEqB,GAGI,GAGE,AAC3B,AAAY,AAA2B,OACvC,AAAI,EAAS,KACX,AAA2B,EAAQ,KACnC,AAAO,IAET,GAEyB,GAGF,AACvB,AAAW,AAAsB,OACjC,AAAI,EAAQ,KACV,AAAsB,EAAQ,KAC9B,AAAO,IAET,AAAY,AAAuB,OACnC,AAAI,EAAS,KACX,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAEqB,AACrB,AAAW,AAAoB,OAC/B,AAAI,EAAQ,KACV,AAAoB,EAAQ,KAC5B,AAAO,IAET,AAAqB,AAA8B,OAC9C,AAAe,MAAG,EAAI,KACzB,AAAgB,AAA2B,EAAQ,OACnD,AAAI,EAAa,KACf,AAA2B,EAAQ,EAAG,KACtC,AAAO,IAJgC,AAAE,WAO7C,GAEuB,AACvB,AAAkB,AAA6B,OAC1C,AAAe,MAAG,EAAI,KACzB,AAAc,AAA2B,EAAQ,OACjD,AAAI,EAAW,KACb,AAA2B,EAAQ,EAAG,KACtC,AAAO,IAJ6B,AAAE,WAO1C,GAEyB,GAGE,AAC3B,AAAkB,AAAiC,OAC9C,AAAe,MAAG,EAAI,KACzB,AAAc,AAA+B,EAAQ,OACrD,AAAI,EAAW,KACb,AAA+B,EAAQ,EAAG,KAC1C,AAAO,IAJ6B,AAAE,WAO1C,GAE8B,AAC9B,AAAY,AAA8B,OAC1C,AAAI,EAAS,KACX,AAA8B,EAAQ,KACtC,AAAO,IAET,GAEwB,AACxB,AAAY,AAAwB,OACpC,AAAI,EAAS,KACX,AAAwB,EAAQ,KAChC,AAAO,IAET,GAEwB,AACxB,AAAc,AAAsB,OACpC,AAAI,EAAW,KACb,AAAsB,EAAQ,KAC9B,AAAO,IAET,GAEyB,AACzB,AAAkB,AAA+B,OAC5C,AAAe,MAAG,EAAI,KACzB,AAAc,AAA6B,EAAQ,OACnD,AAAI,EAAW,KACb,AAA6B,EAAQ,EAAG,KACxC,AAAO,IAJ6B,AAAE,WAO1C,AAAa,AAA0B,OACvC,AAAI,EAAU,KACZ,AAA0B,EAAQ,KAClC,AAAO,IAET,GAEyB,AACzB,AAAU,AAAuB,OACjC,AAAI,EAAO,KACT,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAEyB,AACzB,AAAU,AAAuB,OACjC,AAAI,EAAO,KACT,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAEsB,AACtB,AAAU,AAAoB,OAC9B,AAAI,EAAO,KACT,AAAoB,EAAQ,KAC5B,AAAO,IAET,GAE2B,AAC3B,AAAkB,AAAiC,OAC9C,AAAe,MAAG,EAAI,KACzB,AAAc,AAA+B,EAAQ,OACrD,AAAI,EAAW,KACb,AAA+B,EAAQ,EAAG,KAC1C,AAAO,IAJ6B,AAAE,WAO1C,GAE2B,AAC3B,AAAU,AAAyB,OACnC,AAAI,EAAO,KACT,AAAyB,EAAQ,KACjC,AAAO,IAET,GAE2B,AAC3B,AAAU,AAAyB,OACnC,AAAI,EAAO,KACT,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAY,AAA2B,OACvC,AAAI,EAAS,KACX,AAA2B,EAAQ,KACnC,AAAO,IAET,GAE0B,AAC1B,AAAW,AAAyB,OACpC,AAAI,EAAQ,KACV,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAW,AAAyB,OACpC,AAAI,EAAQ,KACV,AAAyB,EAAQ,KACjC,AAAO,IAET,GAE2B,AAC3B,AAAgB,AAA+B,OAC1C,AAAe,MAAG,EAAI,KACzB,AAAY,AAA6B,EAAQ,OACjD,AAAI,EAAS,KACX,AAA6B,EAAQ,EAAG,KACxC,AAAO,IAJ2B,AAAE,WAOxC,GAE0B,AAC1B,AAAU,AAAwB,OAClC,AAAI,EAAO,KACT,AAAwB,EAAQ,KAChC,AAAO,IAET,AAAY,AAA0B,OACtC,AAAI,EAAS,KACX,AAA0B,EAAQ,KAClC,AAAO,IAET,GAE0B,AAC1B,AAAU,AAAwB,OAClC,AAAI,EAAO,KACT,AAAwB,EAAQ,KAChC,AAAO,IAET,AAAY,AAA0B,OACtC,AAAI,EAAS,KACX,AAA0B,EAAQ,KAClC,AAAO,IAET,AAAY,AAA0B,OACtC,AAAI,EAAS,KACX,AAA0B,EAAQ,KAClC,AAAO,IAET,GAE0B,AAC1B,AAAU,AAAwB,OAClC,AAAI,EAAO,KACT,AAAwB,EAAQ,KAChC,AAAO,IAET,GAE2B,AAC3B,AAAc,AAA6B,OAC3C,AAAI,EAAW,KACb,AAA6B,EAAQ,KACrC,AAAO,IAET,AAAgB,AAA+B,OAC/C,AAAI,EAAa,KACf,AAA+B,EAAQ,KACvC,AAAO,IAET,AAAa,AAA4B,OACzC,AAAI,EAAU,KACZ,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAe,AAA8B,OAC7C,AAAI,EAAY,KACd,AAA8B,EAAQ,KACtC,AAAO,IAET,AAAa,AAA4B,OACzC,AAAI,EAAU,KACZ,AAA4B,EAAQ,KACpC,AAAO,IAET,GAEuB,AACvB,AAAY,AAAuB,OACnC,AAAI,EAAS,KACX,AAAuB,EAAQ,KAC/B,AAAO,IAET,GAE2B,AAC3B,AAAU,AAAyB,OACnC,AAAI,EAAO,KACT,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAa,AAA4B,OACzC,AAAI,EAAU,KACZ,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAY,AAA2B,OACvC,AAAI,EAAS,KACX,AAA2B,EAAQ,KACnC,AAAO,IAET,AAAU,AAAyB,OACnC,AAAI,EAAO,KACT,AAAyB,EAAQ,KACjC,AAAO,IAET,GAE6B,GAGE,AAC/B,AAAU,AAA6B,OACvC,AAAI,EAAO,KACT,AAA6B,EAAQ,KACrC,AAAO,IAET,GAE8B,AAC9B,AAAU,AAA4B,OACtC,AAAI,EAAO,KACT,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAU,AAA4B,OACtC,AAAI,EAAO,KACT,AAA4B,EAAQ,KACpC,AAAO,IAET,AAAY,AAA8B,OAC1C,AAAI,EAAS,KACX,AAA8B,EAAQ,KACtC,AAAO,IAET,GAE8B,AAC9B,AAAW,AAA6B,OACxC,AAAI,EAAQ,KACV,AAA6B,EAAQ,KACrC,AAAO,IAET,AAAY,AAA8B,OAC1C,AAAI,EAAS,KACX,AAA8B,EAAQ,KACtC,AAAO,IAET,GAE0B,AAC1B,AAAW,AAAyB,OACpC,AAAI,EAAQ,KACV,AAAyB,EAAQ,KACjC,AAAO,IAET,AAAY,AAA0B,OACtC,AAAI,EAAS,KACX,AAA0B,EAAQ,KAClC,AAAO,IAET,GAE0B,AAC1B,AAAU,AAAwB,OAClC,AAAI,EAAO,KACT,AAAwB,EAAQ,KAChC,AAAO,IAET,GAEmC,AACnC,AAAU,AAAiC,OAC3C,AAAI,EAAO,KACT,AAAiC,EAAQ,KACzC,AAAO,IAET,AAAU,AAAiC,QAC3C,AAAI,GAAO,KACT,AAAiC,EAAQ,KACzC,AAAO,KAET,AAAY,AAAmC,QAC/C,AAAI,GAAS,KACX,AAAmC,EAAQ,KAC3C,AAAO,KAET,GAEgC,AAChC,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,GAEgC,AAChC,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,GAEgC,AAChC,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,GAEgC,AAChC,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,AAAY,AAAgC,QAC5C,AAAI,GAAS,KACX,AAAgC,EAAQ,KACxC,AAAO,KAET,AAAU,AAA8B,QACxC,AAAI,GAAO,KACT,AAA8B,EAAQ,KACtC,AAAO,KAET,GAEiC,AACjC,AAAU,AAA+B,QACzC,AAAI,GAAO,KACT,AAA+B,EAAQ,KACvC,AAAO,KAET,AAAU,AAA+B,QACzC,AAAI,GAAO,KACT,AAA+B,EAAQ,KACvC,AAAO,KAET,GAEO,AAAgB,iBAE3B,AAAO,+9lBR9zDD,GAAgB,AAClB,AAAU,IACV,AAAU,EAAM,AAAmB,EAA0B,SAC7D,IAAO,EAAM,KACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,8gMjCnTX,AAAsB,iBAAe,KACrC,AAAuB,iBAAgB,KACvC,AAAqB,EAAW,KAChC,AAAI,EAAW,KAAU,cAAP,OACR,AAAyB,EAAS,UAC5C,AAAY,EAAwB,EAAyB,MAC7D,AAAY,EAAyB,GAAU,EAA0B,MAClE,aAAP,4BAXO,cAAY,4BAAnB,ueSnEA,AAAI,EAAc,MAAuB,MAAgC,mBAC5D,AAA8B,AAAS,EAAU,KAAW,UACzE,AAAI,EAAe,IAGnB,cAAc,iBACd,cAAiB,KACjB,cAAkB,mFKoIZ,EAAQ,kDAIP,4BAAP,4BA6CA,AAAS,iBAAgB,iBAAa,EAAW,EAAO,KACjD,aAAP,mDAF4B,KAAc,ieQhEb,mBAEQ,mBAEC,mBAEH,mBAEtB,KAIb,cAAY,KACZ,cAAa,KACb,cAAY,KACZ,AAAI,AAAE,EAAQ,OACZ,cAAwB,kBAExB,cAAqB,u+CfuPK,2CAAP,gbqBvWD,sDAKpB,AAAI,iBAAY,oBAA0B,mBAC9B,EACV,iBAAU,oBAAU,kBAAU,kBAC9B,iBAAQ,oBAAQ,kBAAQ,0BAE1B,cAAe,gCACR,aAAP,kCJ4pCoB,sBAEpB,AAAI,IACF,AAAI,AAAmB,qBACd,AAAW,cAAc,gCAAU,cAAc,EAAmB,+CAA3E,KAGG,2CAAP,6BxBhnCA,AAAI,EAA2B,KAAiC,aAAP,IACzD,AAAI,EAA2B,QAAK,EAA4B,MAAU,aAAP,IACnE,AAAiB,mBACjB,AAAI,EAAc,oBAAyC,aAAP,IAE7C,AAAC,AAAY,cAAM,EAAG,cAAO,EAAG,iBAAvC,4BAUO,AAAC,AAAU,cAAM,6BAAxB,6BAsCA,AAAgB,AAAO,mBACvB,AAAI,AAAC,KAAkB,aAAP,IAChB,AAAU,AAAO,mBACjB,AAAI,AAAC,KAAY,aAAP,IACV,AAAkB,AAAI,AAAI,IAAc,YAAI,YACvC,EAAO,OAAW,EAAe,KAEpC,AAAI,AAAC,AAAY,cAAM,EAAa,cAAQ,EAAG,QAAmB,aAAP,IAFlB,AAAE,WAItC,aAAP,qCA6KA,AAAiB,mBACjB,AAAkB,mBAClB,AAAI,EAAO,KACF,EAAM,KAAO,GAAO,AAAe,EAAa,EAAM,cAAU,8BAAvE,IAEF,AAAmB,cAAa,cA5LG,OA6LnC,AAAI,AAAC,OACH,AAAkB,mBAClB,EAAO,KACP,AAAW,EAAM,KACjB,AAAI,OACQ,AAAyB,EAAQ,GAAG,UAC9C,AAAY,EAAwB,EAAyB,EAAS,OACtE,AACE,EAA0B,EAAS,IACnC,EACA,EAAQ,OAEV,AACE,EAA0B,AAAC,EAAQ,GAAS,IAC5C,EAA2B,AAAC,EAAQ,GAAS,IAC7C,AAAC,EAAM,GAAU,OAEZ,aAAP,KAGG,aAAP,iI4BtPoB,mBAEO,KAI3B,cAAY,KACZ,cAAgB,KAChB,cAAe,+DAWD,AAAuB,UACrC,AAAI,cAAQ,UAAgB,cAAgB,gBAAO,uBACnD,AAAI,cAAQ,UAAgB,cAAgB,gBAAO,uBACnD,AAAI,cAAQ,UAAgB,cAAgB,gBAAO,uBAC5C,EAAsB,EAAM,EAAU,4BAA7C,4BAyBA,cAAa,iBACN,aAAP,05BA9GE,iBAAe,oBACf,iBAAc,wBACd,iBAAY,iCAHd,+BA0FA,AAAI,iBAAa,oBAAmB,aAAP,OACb,yBACC,sBACjB,AAAI,IACF,AAAI,AAAC,QAAc,AAAC,cAAiB,qBAAoB,aAAP,KAC7C,AAAI,IACF,aAAP,QAEqB,yBACC,sBACxB,AAAI,IACF,AAAI,AAAC,QAAqB,AAAC,cAAwB,qBAA2B,aAAP,KAClE,AAAI,IACF,aAAP,KAEK,6BAAgB,2CAAvB,6BDvJF,AAAkB,AAAO,mBACzB,AAAI,EAAU,EAAgB,MAC5B,AAAI,EAAU,MAAkB,MAAgC,gBAChE,AAAc,AAAkB,mBAGhC,AAAkB,AAAI,IAAS,UAAa,KAC5C,AAAI,IAAS,AAAc,AAAI,AAAI,EAAe,KAAG,gBAAgB,aACrE,AAAc,AAAQ,EAAS,OAG/B,AAAI,EAAe,IAGnB,AAAI,EAAW,KACb,AAAa,EAAO,KACpB,AAAa,EAAO,KACpB,AAAO,EAAO,EAA4B,MAE5C,AAAW,EAAO,k4EC0TJ,AAAyB,EAAM,EAAU,cAAM,cAAM,sBACnE,AAAI,OAAiB,cAAkB,uBACvC,AAAI,IAAc,cAAuB,kBAKzC,AAAI,OACS,sBACX,AAAI,cAAS,qCACQ,GAAO,cAAS,iEACnC,AAAI,cAAiB,yBACK,GAAO,cAAiB,qDAC3C,AAAQ,IAAO,qBAA0B,EAAI,KAChD,AAAI,cAAkB,iBAAU,6BAAU,EADS,AAAE,WAGvD,cAAuB,mBAEvB,cAAiB,iBAAa,oCAAE,4BAGf,UACnB,cAAiB,iBAAa,oCAAE,uBAChC,cAAS,6BAAc,oBAG3B,6BAAsB,uDAkFtB,cAAoB,EAAM,EAA0B,cAAO,EAAM,cAAM,cAAM,iVrB/C7C,2CAAP,+BWxIJ,sBACrB,AAAI,IAAuB,aAAP,IACb,4BAAP,4BAeO,2CAAP,8mCRjSO,KAAQ,OAqEjB,AAAI,EAA0B,KAAG,AAAO,KAExC,AAAa,iBAAc,KAC3B,AAAiB,IACjB,AAAU,IAEV,AAAI,EAAO,KACT,AAAS,EAAa,OAAW,SACjC,AAAS,EAAa,SACtB,AAAS,IACT,AAAS,EAAa,SAEtB,AAAU,EAAM,GAAM,KACtB,IAAO,EAAO,KACZ,AAAK,EAAI,IAAI,AAAU,kCACvB,AAAK,EAAI,IAAI,AAAU,kCACvB,AAAK,EAAI,IAAI,AAAU,kCACvB,AAAK,EAAI,IAAI,AAAU,OAvB3B,AAAO,AAAK,EAAI,EAAM,QAAU,GAAM,YAwBlC,EAAO,UAET,EAAK,AAAK,EAAI,GAAK,AAAK,EAAI,IAAK,AAAK,EAAI,IAAM,AAAK,EAAI,QAEzD,EAAK,EAAa,WAGpB,AAAU,EAAyB,GAAM,KACzC,IAAO,EAAO,KACZ,EAAK,AAAU,KAAO,UACtB,AAAI,AAAK,EAAG,GAAM,SAClB,EAAO,UAGT,AAAM,EAAyB,KAC/B,IAAO,EAAM,KACX,EAAK,AAAc,KAAO,UAC1B,AAAI,AAAK,EAAG,GAAM,SAClB,YAGF,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,EAAK,SACL,EAAK,EAAK,MACV,AAAO,gBAlHY,qqDYsYiB,AAAC,iBAAa,GAAU,cAA/B,4BAjIpB,cAAQ,iBAAf,4BAUO,cAAQ,EAAoB,kBAAnC,4BAUO,mBACH,kBACA,cAFJ,4BAfO,cAAQ,GAAqB,kBAApC,4BAoDO,mBACH,kBACA,cAFJ,+KzB4qBF,AAAgB,EAAS,KACzB,AAAI,EAAY,KAAU,cAAP,IACnB,AAAI,AAAC,KAEI,GAAa,iBAAc,eAAlC,IAEF,AAAa,IAER,AAAQ,MAAG,EAAI,QACV,AAAa,EAAa,EAAY,YAC9C,AAAI,EAA4B,KAAG,EAAU,qBAFnB,AAAE,WAI9B,AAAa,IACb,AAAa,sBACA,AAAyB,AAAC,EAAS,EAAS,IAAc,GAAG,UACrE,AAAQ,MAAG,EAAI,QACV,AAAa,EAAa,EAAY,YAC9C,AAAI,EAA4B,KAC9B,AAAe,mBACf,AACE,EAA6B,EAAiB,IAC9C,EACA,EAAmB,OAErB,EAAU,MAEZ,AAAI,IACF,AACE,EAA6B,EAAiB,IAC9C,EACA,EAAiB,OAEnB,EAAU,MAjBiB,AAAE,cAoBzB,AAAa,EAAa,EAAoB,YACtD,AAAI,EAA4B,KAC9B,AACE,EAA6B,EAAiB,IAC9C,EACA,AAAO,iBAAgB,QAGpB,aAAP,6B8BvmBE,AAAU,mBACV,AAAU,mBACV,AAAI,GACJ,AAAI,GACJ,AAAI,GAEA,EAAmB,IAAG,AACpB,GAAuB,AAAgB,EAAK,EAAK,4BAAjC,+CL+sBb,YACT,cAAQ,IAAW,KAAQ,qBAC3B,AAAY,OACG,sBACf,AAAI,IACF,cAAQ,IAAW,KAAU,qBAC7B,cAAQ,cAAkB,qBAC1B,AAAQ,QAEO,sBACjB,AAAoB,mBACpB,AAAI,IACF,AAAoB,mBACpB,AAAgB,mBAAe,EAAgB,IAAI,KAC9C,AAAQ,MAAG,EAAI,KAClB,AAAI,IAAO,cAAQ,IAAW,KAAQ,sBACtC,AAAI,EAAK,KAAW,cAAQ,qBAC5B,cAAQ,cAAW,iBAAY,qBAC/B,AAAI,EAAK,KAAiB,EAAK,SAAW,cAAQ,qBAJjB,AAAE,OAAG,AAAE,YAO5C,cAAQ,IAAW,KAAU,qBAC7B,cAAQ,6BAAyB,qBAC1B,cAAQ,6BAAf,4BW7yBA,AAAI,GACJ,AAAI,GACJ,AAAI,GACA,EAAmB,IAAG,AACpB,GAAuB,AAAgB,EAAyB,iBAAa,4BAA7D,+CXwNE,IAAW,KAAU,UAC7C,AAAI,sBACmB,sBACrB,AAAI,IACK,mBACH,6BAA8B,kBAC9B,6BAFJ,OAIyB,sBACzB,AAAI,IACK,sBACC,cAA4B,aAAa,gHAC7C,cAA4B,iBAFhC,MAMN,wDAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAEA,QA1BsB,aAAP,IACK,aAAP,IACQ,aAAP,IACO,aAAP,IACO,aAAP,IACS,aAAP,IACI,aAAP,IACQ,aAAP,IACO,aAAP,IACO,aAAP,IACS,aAAP,IACK,aAAP,IACO,aAAP,IACQ,aAAP,IACU,aAAP,IACS,aAAP,IACI,aAAP,IACM,aAAP,IACW,aAAP,IACM,aAAP,IACK,aAAP,IACU,aAAP,IACY,aAAP,IACQ,aAAP,IACM,aAAP,IACrB,AAAO,qBACW,aAAP,uCAzOtB,AAAO,sCACY,sBACnB,AAAI,AAAC,KACH,AAAO,AAAC,oCACR,iBAAoC,EAAS,iBAAW,iBAAa,IAAoB,0CACzF,cAA8B,gCAC9B,cAAkC,gCAClC,cAAgC,kBAE3B,aAAP,oCHkjFO,6BAAmB,cAAM,gBAAhC,6bAPc,sBACd,AAAI,IAAW,cAAY,uBAAc,GAAO,cAAY,wDAA1B,IAC3B,aAAP,kCa32Ec,cAAkB,4CAAsB,UACtD,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,oDAGT,aAAP,OAES,UACA,sBACX,IAAO,IACL,AAAI,GAAY,cAAkB,yDAChC,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,4CAAsB,kDAG/B,aAAP,OAEK,UACA,2BAEF,aAAP,4Bbk0EmC,AAAC,iBAAa,GAAS,cAA9B,oCAytCrB,AAAC,GAAkB,2EAA1B,23BaxgHsB,IACA,IACjB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAC,cAAe,uBAAgB,AAAE,QACtC,AAAE,OAF8C,AAAE,WAIpD,AAAoB,IAAoB,kBAA2B,KACnE,AAAI,EAAgB,QAAqB,EAAgB,MACvD,AAAI,EAAc,KAChB,cACE,GACA,IACI,AACE,8CAAmB,gCACnB,8CAAmB,EAAgB,qCAErC,8DACJ,AAAC,EAAgB,KAAoB,GAAoB,oBACzD,yBAGG,cAAP,OAEkB,EAAgB,aAClB,AAAS,sBAC3B,iBACK,AAAQ,MAAG,EAAI,QACP,EAAI,KACX,cACE,8CAAmB,iBACnB,cACA,cACA,MAEF,cACE,GAAO,cAAe,4DACtB,cACA,AAAS,6BACT,WAEN,AAAI,AAAC,KAAa,cAAP,IAEX,cAAa,cAAe,+CAAc,kBAC1C,cAAc,EAAK,iBAjBkB,AAAE,WAmBlC,cAAP,gGVmOF,AAAe,mBACf,AAAI,AAAC,KAAiB,cAAP,OACN,EAAkB,UACtB,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAG,EAAK,cAAM,iBAAY,oBADR,AAAE,WAGzB,cAAQ,8BAAf,6bHqzGkB,sBAChB,AAAI,IAAa,cAAc,uBAAqB,AAAO,cAAc,4BAA5B,IACtC,aAAP,2MAx0CmB,mBAEY,oBAEa,mBAEV,KAelC,cAAe,iBACf,cAAY,iBACZ,cAAoB,iBACpB,AAAI,IACF,cAAc,kBAEd,AAAO,iBAAa,qBACpB,cAAc,wjCAuJV,EAAM,cAAM,cAAc,cAAS,sBACzC,eAAqB,MAOrB,cAAmB,iBACnB,cAAa,kGA4CF,mCAgBL,EAAM,cAAM,cAAc,cAAS,cAAQ,sBACjD,eAAkB,iDAqzDpB,YAAQ,qBACD,OAIA,OAKA,OACA,QAVkB,AACrB,AAAI,IAAiB,aAAP,IACP,6BAAsB,6BAAiB,4BAA9C,IAEyB,AACzB,AAAI,IAAiB,aAAP,IACd,AAAO,AAAC,qBACD,6BAAsB,6BAAkB,4BAA/C,QAIS,uBAKP,AAAmB,6BAAa,6BAAe,cAAU,OAAuB,iBAC/E,IAAa,GAAqB,8BAAoB,4BAHlD,8BZzpJF,iBAAe,MAAgB,IAAe,eAArD,4BY0oF6B,+BAAc,wCAgN3C,AAAO,AAAC,cAAQ,2BAChB,cAAY,iBACZ,cAAS,0CA9MuC,AAAC,iBAAsB,GAAS,cAAvC,8xEA+3D3C,AAAO,AAAC,6BAA4B,mDACpC,6BAA4B,6BAAsB,iIAtlB7B,mBAEe,mBAEe,mBAE3B,mBAEe,mBAEgB,mBAEf,mBAErB,mBAEF,mBAEU,mBAEI,mBAEG,mBAEE,mBAEZ,sBA+CpB,IAAe,GAAwB,GACvC,cACA,AAAmB,cAAwB,6BAAkB,cAAa,wBAC1E,6BACA,6BACA,qCAEF,cAAiB,iBACjB,cAAa,oBACb,cAAsB,oBACtB,cAAqB,oBACP,yBACE,wCACL,EAAS,iBAAgB,iBAAkB,AAAC,OAAkB,IAAqB,yBAC9F,cAAsB,iBACtB,cAAa,iBAEb,AAAI,AAAC,cAAkB,SACrB,AAAS,2CACT,cAAW,KACX,6BAA2B,EAAI,sBAIZ,sBACrB,AAAI,IACF,AAAuB,mBACvB,AAAI,AAAC,QAAkB,EAAoB,qBACzB,iBAElB,AAAI,OAC4B,sBAC9B,AAAI,AAAC,KAAyB,iBAAyD,4BAClF,AAAQ,MAAG,EAAI,KAClB,cAA4B,cAAe,+CAAc,cAAc,qBADnC,AAAE,aAIrC,AAAI,IAAkB,iBAAwB,SACnC,kBAElB,AAAwB,cAAS,oGA0d/B,cACA,cACA,cACA,2uCA7lBc,sBAChB,AAAI,AAAC,KAAW,iBAA6B,4BACxC,AAAO,AAAC,cAAc,qCAC3B,cAAc,cAAa,+iCA1oCpB,2CAAP,oCAikCO,AAAC,GAAkB,2EAA1B,gRAgR6B,OAC7B,KACkB,sBAChB,AAAI,AAAC,KAAW,iBAAiC,4BACjD,cAAc,qBACH,sBACJ,q5DAQyB,UAClB,sBAChB,KACqB,sBACnB,AAAI,AAAC,KAAc,iBAAwC,4BAC3D,cAAiB,kBACjB,AAAI,IACG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACvB,cAAiB,kBAFyD,AAAE,eAKpE,GAAkB,+DACvB,4CA3ET,AAAO,AAAC,oCACR,cAAY,oBAGiB,sBAC7B,AAAI,OAC4B,sBAEzB,GAAY,KAAS,gCAA6B,IAAO,qBAAc,EAAI,QAC/D,AAAU,cAAM,aAChB,GAAO,cAA2B,kDACjD,AAAI,AAAC,KACH,iBAAyD,2BACzD,cAA4B,cAAU,mBACjC,AAAI,AAAC,cAA4B,oBACtC,cAA4B,cAAU,oBAPyC,AAAE,YAavF,cAAyB,oBACT,sBAChB,AAAI,IACG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACvB,cAAyB,iBAFiD,AAAE,eAOnD,OAC7B,KACuB,sBACrB,AAAI,IACG,GAAc,KAAW,gCAAqB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UAC5B,cAA4B,iBAFmD,AAAE,eAK1E,sBACJ,kRAryFM,sBACf,AAAI,cAAa,mBAAc,GAAO,cAAa,wDAA3B,IACjB,aAAP,wCAKc,cAAY,sBAC1B,AAAI,AAAC,KAAyB,gBAAuC,8BACrE,AAAI,iBAAgB,oBACb,aAAP,yDam6C6B,WAEJ,8Gb35CT,cAAa,cAAM,aACpB,6BAA2B,iDAA2B,mBACrE,AAAI,AAAC,KAA0B,gBAAmC,8BAC3D,aAAP,kCA9/Ba,sBACb,AAAI,AAAC,KAAQ,iBAAgC,cAAkB,yCACxD,aAAP,2OAqgHO,AAAC,GAAkB,2EAA1B,25CA4SiB,sBACjB,AAAI,AAAC,KAAY,iBAA+B,4BAChD,cAAe,kBAGf,cAA4B,2fSh/H5B,cAAoB,EAAM,EAA0B,cAAO,cAAc,cAAM,cAAM,mDTg+E9C,AAAC,iBAAa,GAAU,cAA/B,4BAoEzB,AAAC,cAAW,GAAsB,mBAAzC,+Ba+KA,AAAgB,IAChB,AAAI,cAAc,SAChB,AAAO,cAAc,yBACrB,AAAI,cAAc,QAChB,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,qCAGJ,AAAY,MAET,AAAI,cAAc,QACvB,AAAI,cAAc,QAChB,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,sBAGJ,AAAY,KAEZ,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,cAAM,6BAAwB,iCAGlC,AAAY,MAET,AAAI,cAAc,QACvB,AAAI,cAAc,QAChB,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,cAAM,6BAAwB,iCAGlC,AAAY,KACP,AAAI,mBACT,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,cAAM,6BAAwB,iCAGlC,AAAY,KAEZ,AAAO,cAAc,2BAElB,AAAI,mBACT,AAAI,cAAc,QAChB,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,cAAM,6BAAwB,iCAGlC,AAAY,KACP,AAAI,cAAc,QACvB,AAAI,EAAc,KAChB,cACE,GACA,4CAAiC,4CACjC,cAAM,6BAAwB,iCAGlC,AAAY,KAEZ,AAAO,yCAGJ,AAAC,cAAR,q6Eb5Oa,sBACb,MAAQ,qBACD,OACA,SAA8B,aAAP,IAEvB,aAAP,goBKn0CmC,AAAC,iBAAa,GAAS,cAA9B,mEL62DD,oBAEY,mBAES,mBAGa,sBAc3D,EACA,cACA,AAAmB,cAAM,cAAQ,cAAe,wBAChD,6BACA,cACA,sBAEF,cAAsB,o/BAyBtB,AAAO,cAAQ,yBACf,AAAO,AAAC,uCACc,sBACtB,AAAI,AAAC,KAAiB,iBAAyC,4BAC1D,AAAI,cAAoB,mBAAuB,GAAO,cAAoB,wDAAlC,QAC3B,sBAClB,AAAO,iBAAoB,wBACf,EACV,6BACA,cACA,iDACA,yBAEF,cAAc,oBACd,cAAqB,oBACrB,cAAyB,gCAEzB,cAAoB,cAAe,kBAC5B,aAAP,kCAmyCe,sBACjB,AAAI,OACgB,sBAClB,AAAI,AAAC,KAAa,iBAA6B,4BAE1C,GAAY,KAAS,gCAAiB,IAAO,qBAAc,EAAI,QACjD,AAAU,cAAM,aACpB,GAAO,cAAe,kDACnC,cAAgB,cAAY,kBAHyC,AAAE,mDAtG3E,AAAO,iBAAiB,oCACxB,AAAI,mBAAsB,cAAP,IACnB,AAAqC,IACrC,cAAQ,qBACD,OAkBA,OACA,OAQA,OAyBA,OAUA,QA9D+B,AAClC,MAAQ,qBACD,OAKA,QALuB,AAC1B,AAAY,cAAO,oBACV,0CACT,GAE+B,AAC/B,AAAI,AAAC,oBACH,cAAmB,oDACnB,AAAY,cAAO,oBACV,2CAEX,GAGJ,IAGqB,AACrB,AAAI,iBAAc,KAChB,AAAY,cAAO,oBACV,0CACT,GAEF,GAE0B,AAC1B,YAAQ,qBACD,OACA,OACA,OAKA,OAKA,UAV+B,AAClC,AAAY,cAAO,oBACV,0CACT,GAE0B,AAC1B,AAAY,cAAO,oBACV,0CACT,GAE+B,AAC/B,AAAI,AAAC,oBACH,cAAmB,oDACnB,AAAY,cAAO,oBACV,2CAEX,GAGJ,GAEuB,AACvB,AAAI,iBAAc,KAChB,AAAI,AAAC,oBACH,cAAmB,oDACnB,AAAY,cAAO,oBACV,4CAGb,GAE+B,AAC/B,QAAQ,qBACD,OACA,OACA,UAAuB,AAC1B,AAAI,AAAC,oBACH,cAAmB,oDACnB,AAAY,cAAO,oBACV,2CAEX,GAGJ,GAGJ,AAAI,IACF,AAAoB,cAAS,YAAuB,cAAmB,SACvE,AAAoB,cAAS,YAAuB,cAAmB,SACvE,AAAI,KAAiB,QACnB,6BACE,GACA,4CAA6B,qDAI5B,cAAP,8FAv3DO,eAAqB,gBAA5B,moCA1F4B,yBACZ,sBACd,AAAI,AAAC,KAAS,iBAAyB,4BAClC,AAAI,cAAY,sBACJ,GAAO,cAAY,kDAClC,AAAI,iBAAmB,UAGR,AAAS,cAAU,sBAChC,AAAI,OACQ,WAEe,IACrB,GACA,uBACJ,AAAI,AAAkB,sBACpB,6BACE,GACA,6BACA,AAAC,4CACD,qCAGF,6BACE,GACA,6BAA0B,qCAGvB,aAAP,OAIN,cAAY,cAAM,qBACJ,sBACd,AAAI,iBAAgB,QAAiC,AAAC,AAAC,yDAErD,6BAA2B,6BAAsB,kBACjD,6BAAkC,cAAqB,mBAElD,aAAP,uqBAs3B0C,mBAEA,mBAEA,mBAEhB,mBAGmC,sBA0E3D,EACA,cACA,AAAmB,cAAM,cAAQ,cAAoB,wBACrD,6BACA,cACA,sBAEF,+BAAc,AAAE,GAAkB,0/BAqDlC,AAAO,cAAQ,yBACf,AAAO,AAAC,uCACc,sBACtB,AAAI,AAAC,KAAiB,iBAAyC,4BAC1D,AAAI,cAAoB,mBAAuB,GAAO,cAAoB,wDAAlC,QACtB,sBACvB,AAAO,iBAAyB,wBACpB,EACV,6BACA,cACA,yDAEF,cAAc,oBACd,cAAyB,mCACH,sBACtB,AAAI,IACF,cAAwB,cAAwB,oCAE5B,sBACtB,AAAI,IACF,cAAwB,cAAwB,iCAElD,cAAoB,cAAe,kBAC5B,aAAP,4BAvEO,iBAAyB,cAAhC,oEAnjBqC,mBAEX,mBAEF,6BActB,EACA,cACA,AAAmB,cAAM,cAAQ,cAAe,wBAChD,6BACA,cACA,sBAEF,cAAa,8ZKtuD8B,sBAHrC,EAAM,sKA+CN,EAAM,cAAM,cAAY,EAAO,wGAsjB/B,EAA8B,cAAM,cAAY,EAAO,cAAM,cAAa,gEArkDzE,EAAwB,cAAM,cAAY,EAAO,cAAM,cAAa,4BAA3E,uFLozGgC,mBAEA,mBAEd,sBAUhB,EACA,6BACA,cACA,mBACI,GAAyC,8CACzC,AACE,6BACA,EACA,iBAAkB,KAClB,EAAM,EACN,oEAGR,cAAiB,iBACjB,cAAa,oBACb,cAAsB,oBACtB,AAAI,cAAQ,SACV,AAAwB,6BAAc,sEAriC3B,sBACb,MAAQ,qBACD,OACA,SAA8B,gDAAP,IAEvB,aAAP,6bA4mBgB,sBAChB,AAAI,IAAa,cAAc,uBAAqB,GAAO,cAAc,wDAA5B,IACtC,aAAP,oCAxCO,AAAC,GAAqB,2EAA7B,oCALO,AAAC,GAAqB,2EAA7B,sOK5uCF,AAAI,iBAAa,QACJ,AAAC,yDACL,AAAE,sBAAa,+CAA8B,gBAApD,IAEK,aAAP,otBF38DE,AAAI,iBAAa,oBACR,aAAP,IAEF,AAAI,sBAC2B,yBACC,sBAG5B,iBAAuB,oBACpB,EAA0B,SAC1B,iBAA4B,iCAHjC,IAMK,aAAP,kCAskBmB,yBACC,sBACpB,AAAI,IACF,AAAI,AAAC,QAAiB,AAAC,cAAoB,qBAAuB,aAAP,KACtD,AAAI,IACF,aAAP,KAIF,AAAI,oBAAgB,uBAAsB,aAAP,IAGnC,AAAI,AAAC,6BAAuB,mCAA0B,aAAP,OAGtB,yBACC,sBAC1B,AAAoB,mBACpB,AAAI,EAAiB,oBAAoC,aAAP,IAE7C,AAAQ,MAAG,EAAI,QACM,AAAU,cAAmB,aAC5B,AAAU,cAAoB,UACvD,AAAI,AAAC,cAAyB,oBAA4B,aAAP,IAHlB,AAAE,WAK9B,aAAP,s+BApGgB,wCACL,EACT,iBACA,iBAAkB,AAAC,OAAkB,IACrC,4BAImB,sBACrB,AAAa,sBAGG,EAAc,cAAS,cAAgB,cAAY,cAAU,EAAoB,EAAS,EAAQ,yBAClG,wBAGhB,AAAI,cAAmB,sBACN,GAAO,cAAmB,kDACzC,AAAO,cAAiB,mCACjB,aAAP,IAIF,cAA0B,EAAS,MACnC,cAA0B,iBAC1B,cAAmB,cAAW,kBACvB,aAAP,uIJxtBoB,mBAED,mBAEF,mBAEY,mBAEH,mBAEa,mBAEd,0CAEuB,mBAEf,mBAES,mBAEC,qaC0zHpC,2CAAP,oCAtoBO,AAAC,GAAkC,2EAA1C,+BAkjBuB,sBACvB,AAAI,IAAyB,4BAAP,IACf,aAAP,4BGpmHqC,AAAC,iBAAa,GAAU,cAA/B,izCJ4Lb,sBACjB,AAAI,IACF,AAAO,6BAAuB,yBAC9B,AAAI,cAAe,mBACjB,AAAY,AAAuB,cAAe,mBAClD,cAAe,cAAO,EAAQ,QAE9B,cAAe,cAAO,QAGxB,AAAO,AAAC,6BAAuB,mEAnDZ,sBACrB,AAAO,cAAkB,4BACZ,sBACb,AAAO,iBAAe,wBACF,0CACpB,cAAsB,uBACR,sBACd,AAAI,IACG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACxD,cAAQ,UACrB,AAAI,iBAAe,KAA+B,MAEnC,AAAC,yDAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,GACpC,AAEE,gCAA6B,QAE7B,uBAEA,gCAAqC,SAErC,6BAAoB,GAAkB,UAEtC,cAAsB,cAAU,OAhBsC,AAAE,8CAzPnD,+BAAc,oDA9F9B,EAAS,cA6BqB,UA5BzC,AAAI,cAAkB,SACpB,kBAEF,AAAI,+CAAqD,KACvD,cAAS,QAEJ,aAAP,6GCq1GE,EACA,cACA,cACA,sBAEF,cAAoB,iBACpB,cAAa,KACb,AAAO,EAAQ,sBACf,cAAa,0DnB78Gb,AAAM,AAAI,AAAI,IAAK,YAAI,2BACvB,AAAmB,AAAO,mBAC1B,AAAkB,EAAa,KAC/B,AAAI,EAAc,KAAU,aAAP,IAEd,AAAC,AAAY,cAAM,EAAa,cAAQ,EAAG,iBAAlD,gDANkC,8EA0HlC,AAAiB,mBACjB,AAAiB,AAAW,AAAI,IAAO,YAAI,YAC3C,AAAe,AAAW,AAAI,IAAK,YAAI,YACvC,AAAc,AAAW,IAAY,UAAa,KAClD,AAAY,AAAW,IAAY,UAAa,KAChD,AAAW,EAAQ,KACnB,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,AAAC,KAAW,EAAS,EAAO,UAAU,aAAP,OACzB,AAAyB,EAAM,UACzC,AAAY,EAAwB,EAA0B,GAAS,MAChE,aAAP,qCwB6nEF,AAAI,cAAc,6BAChB,cAAQ,wBACH,AAAI,cAAc,+BAChB,cAAe,EAAG,iBAAc,aAElC,aAAP,6BxB1rEE,AAAgB,AAAO,mBACvB,AAAI,AAAC,KAAkB,4BAAP,IAChB,AAAU,mBACV,AAAI,AAAC,KAAY,aAAP,IACV,AAAkB,AAAI,AAAI,IAAc,YAAI,EAAa,aACzD,EAAO,EAAe,KAEpB,AAAI,AAAC,AAAY,cAAM,EAAa,cAAQ,EAAG,QAAmB,aAAP,IAFpC,AAAE,WAIpB,aAAP,gDAVuC,iGA8CR,+gBwBk6CP,oCAEJ,mBAES,mBAcG,mBAGR,sBAlClB,EAAiB,EAAU,EAAG,2CACjB,AAAmB,sBACtC,cAAoB,iBACpB,AAAU,cAAyB,0BACnC,cAAkB,EAAO,KAAI,cAAuB,EAAM,cAAK,kBAC/D,6BAAoB,qEAnBP,QACb,AAAI,AAAC,KAAQ,GAA0B,EAAW,EAAyB,cAAiB,+BAAa,8BAClG,aAAP,2OAnfM,EAAqB,8DA55BpB,EAAyB,cAAM,EAAU,4BAAhD,kCLooBY,uBACL,AACL,AAAgC,cAAM,+BACtC,EAAM,EAAO,EAAM,EAAM,4BAF3B,gDAHqB,sGA8sF2B,6BAA6C,85DD1hG7F,AAAI,EAAQ,cAAG,KACE,sBACjB,AAAY,EAAQ,oBAAoB,AAAU,cAAW,MAAU,KACvE,cAAW,EAAS,EAAQ,gMCq8IzB,AAAQ,sBAAoC,EAAK,KACpD,eAAiC,gBAAI,sCADsB,AAAE,WAGxD,eAA4B,gBAAnC,kCA9sCmB,AAAC,GAAqB,oFAChC,iBAAoB,KACvB,cAAW,oCACX,AAAwB,iBAF5B,2GA/GuB,oGAQC,2CAEP,mBAEY,mBAEC,mBAEM,sCAKlB,mBAEG,mBA0IJ,mBACQ,sBA3HvB,EACA,cACA,AAAmB,cAAwB,6BAAkB,cAAa,wBAC1E,6BACA,6BACA,qCAEF,cAAiB,iBACjB,cAAqB,iBACrB,cAAiB,iBACjB,cAAa,iBAAkB,SAC/B,cAAsB,oBACtB,cAA+B,iBAC/B,cAAgB,oBACF,sBACd,cAAY,mCACD,AAAmB,sBAC9B,cAAY,iBACZ,AAAI,AAAC,cAAa,UAChB,AAAiB,OACF,sBACf,AAAI,OACU,EACV,cACA,WACA,cACA,gCAEiB,qCACnB,AAAI,AAAC,KAAc,gCAAwC,4BAC3D,cAAiB,cAAmB,kBACpC,6BAAmB,iBAAe,iBAClC,cAAkB,iBAAa,SAEZ,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,QACzB,cAAe,aACf,cAAsB,aAC9B,EACV,cACA,WACA,cACA,gCAEiB,qCACnB,AAAI,AAAC,KAAc,gCAAwC,4BAC3D,cAAiB,cAAe,kBAChC,6BAAmB,iBAAe,iBAClC,cAAkB,iBAAa,KAbiB,AAAE,YAgBtD,AAAwB,cAAS,mvCAzGjB,sBAChB,AAAI,AAAC,KAAW,iBAA6B,4BACxC,AAAO,AAAC,cAAc,qCAC3B,cAAc,cAAa,qDGp0G3B,AAAI,sBACmB,sBACrB,AAAI,IAAuB,AAAC,cAA4B,kBAApC,IACb,iBAA2B,cAAlC,IAEK,aAAP,4BA3DO,cAAQ,GAAqB,kBAApC,wCA+PgB,yBACA,sBAChB,AAAI,AAAC,QAAa,AAAC,MAAkB,aAAP,IAE9B,AAAI,iBAAkB,oBAAuB,aAAP,IAEtC,AAAI,mBACF,AAAI,AAAC,oBAAiC,aAAP,KAC1B,AAAI,mBACT,AAAI,AAAC,oBAAiC,aAAP,KAExB,aAAP,KAEK,aAAP,4BH+vHO,iBAAa,cAApB,uCAucgB,sBACT,EAAa,KAAQ,cAAc,gCAA1C,4BANO,cAAkB,4BAAzB,uCA4BmB,sBACZ,EAAgB,KAAQ,cAAiB,gCAAhD,4BANO,cAAqB,4BAA5B,qCA9SA,AAAI,mBACF,AAAI,mBAEK,EAAQ,QAAU,cAAa,6BAAtC,IAGO,cAAgB,+DAAvB,MAGF,AAAI,mBAEK,EAAU,4CAAjB,IAGO,EAAQ,QAAU,cAAa,6BAAtC,gCG1wIG,cAAQ,EAAoB,kBAAnC,4BAeO,cAAQ,EAAmB,GAAoB,kBAAtD,4BAoBO,cAAQ,EAAkB,kBAAjC,4BAeO,cAAQ,GAAmB,kBAAlC,+BA4LA,AAAI,mBACF,AAAI,mBACF,AAAI,AAAC,uBAA4B,oBAC/B,GAAmB,0BACjB,GAAkB,0BACT,cAA4B,4BAAnC,KAEG,GAAsB,0BAC3B,GAAqB,0BACZ,cAA+B,cAilBgB,gBAjlBtD,KAEG,AAAI,mBACT,AACE,iBAAa,uBACZ,iBAAe,KAAmB,iBAAa,UAEzC,aAAP,UAKH,AAAI,AAAC,oBACV,AAAI,mBACF,AAAI,mBACF,AACE,AAAC,QACD,uBACA,iBAA6B,qBAEtB,iBAAa,6BAApB,KAEG,AAAI,iBAAe,KACjB,iBAAa,cAApB,IACK,AAAI,iBAAe,KACjB,iBAAa,cAApB,OAEG,AAAI,mBACT,AAAI,mBACK,iBAAa,6BAApB,KAEG,AAAI,mBACT,AAAI,mBACK,iBAAa,6BAApB,SAIC,aAAP,kCA6iBmB,yBACE,sBACrB,AAAI,IAEF,AAAI,IACF,AAAI,AAAC,QAAkB,AAAC,cAAkC,qBACjD,aAAP,KAEG,AAAI,IACF,aAAP,MAIF,AAAI,IACF,AAAI,EAAkB,KAAuB,aAAP,KACjC,AAAI,IACF,aAAP,MAKJ,AAAI,oBAAgB,uBAAuB,aAAP,OAGf,yBACE,sBACvB,AAAI,AAAE,EAAkB,QAAoB,cAA8B,uBACjE,aAAP,OAGuB,yBACE,sBAC3B,AAAoB,mBACpB,AAAI,EAAiB,oBAAoC,aAAP,IAE7C,AAAQ,MAAG,EAAI,QACM,AAAU,cAAmB,aAC3B,AAAU,cAAqB,UACzD,AAAI,EAAqB,KAA4B,aAAP,IAHb,AAAE,WAK9B,aAAP,kCHohEkB,yBACG,sBACrB,AAAI,iBAAoB,QAAgC,iBAAoB,SACtD,AAAC,yDACrB,AAAI,gCAA+B,mCAC1B,AAAW,6BAAsB,2CAAxC,KAGG,4BAAP,iCa7XA,AAAkC,OAChB,IAAgB,AAAc,kBAAiB,SAGjE,AAAI,cAAa,YACC,GAAO,qDAGA,cAA8B,sBACrD,AAAI,IAAyB,cAAP,OAGG,sBACzB,AAAI,OACwB,GAAO,iEACjC,AAA4B,mBAC5B,AAAO,EAAyB,oCAC3B,AAAQ,MAAG,EAAI,QACW,cAAoB,wCAEjD,cAAa,cAAwB,cAAmB,qBAHf,AAAE,aAO/C,AAAO,AAAC,uCACe,cAA8B,sBACrD,AAAI,IAAyB,cAAP,QAIJ,yBACK,sBAEzB,AAAI,IAAiB,AAAC,AAA2B,mBAAwB,SACvE,AAAO,IAAsB,EAA4B,wCACpD,AAAQ,MAAG,EAAI,KAClB,cACE,AAAC,8CAAyC,+CAC1C,cAAc,qBAH4B,AAAE,YAOhD,AAAO,AAAC,QAAsB,iBAA6B,uBAI7D,AAA4B,OACL,sBACvB,AAAI,OACS,cACT,cACA,6BACA,cACA,UAEF,AAAI,AAAC,KAAiB,cAAP,IACf,cAAa,cAAmB,mBAC3B,AAAI,OACE,sBACX,cAAa,cAAmB,uBAIR,sBAC1B,AAA6B,sBACR,EAAgB,UACrC,AAAyB,IACpB,AAAQ,MAAG,EAAI,QACS,cAAoB,UAC/C,AAAI,iBAAsC,KACxC,AAAqB,EAAI,SAEZ,sBACf,AAAI,AAAc,mBAChB,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,cAAP,OAEkB,cAClB,cACA,6BACA,cACA,UAEF,AAAI,AAAC,KAAsB,cAAP,IACpB,AAAI,EAAiB,MACnB,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,cAAP,IAEF,cAAe,EAAK,iBA/BsB,AAAE,WAoC9C,AAAI,cAAa,WACF,SACR,AAAI,cAAa,YACT,0DAEE,sBACf,AAAI,AAAc,mBAChB,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,cAAP,OAES,cACT,cACA,6BACA,cACA,UAEF,AAAI,AAAC,KAAa,cAAP,OACE,YAGC,AAAiB,6BAAc,cAAgB,cAAY,cAAU,eAExD,sBAC7B,AAAI,sBAAoB,cAA0B,GAAI,oGACvC,EACb,cACA,cACA,cACA,cACA,uBAEF,cAA8B,cAAa,iBAG3C,AAAI,OACyB,wDACX,uBAChB,AAAI,OACe,cAAoB,uBACrC,AAAI,IAEF,cAA0B,KAE1B,AAA2B,IAC3B,AAAI,cAAe,GAAkB,SACnC,AAAI,iBAAmB,QACF,cAAqB,mDAA+B,WACvE,AAAI,IACF,AAAI,cAAY,WACG,uBACjB,AAAI,IAAc,6BAAkC,6BAAsB,WACxE,AAAuB,MAGzB,AAAO,cAAY,2BACF,uBACjB,AAAI,IAAc,6BAAkC,6BAAsB,WACxE,AAAuB,SAK1B,AAAI,cAAY,SACrB,AAAuB,KAEvB,AAAI,iBAAmB,QAED,+CACD,cAAqB,cAAe,cAAe,iBAAW,WACjF,AAAI,IAAgB,6BAAkC,6BAAwB,WAC5E,AAAuB,QAI7B,AAAI,IACF,cACE,GACA,6BAAsC,0CAMzC,cAAP,kCAorBe,sBACf,AAAI,IAAiB,aAAP,IACd,iBAAgC,EAC9B,cACA,yDAEoB,sBACtB,AAAI,OACmB,cACnB,cACA,EACA,iBACA,UAEF,AAAI,IACF,cAA0B,iBAC1B,cAAiB,oDAGC,sBACtB,AAAI,OACmB,cACnB,cACA,EACA,iBACA,UAEF,AAAI,IACF,cAA0B,iBAC1B,AAAI,AAAC,cAAY,WACf,AAAO,+CAAkD,qBACzD,cAAiB,4CAAwC,uBAIxD,aAAP,4BVr7GO,iBAAY,GAAM,cAAzB,4BfiIO,AAAC,iBAAgB,GAAY,cAApC,qCYilDA,AAAI,AAAC,6BAAwB,QAC3B,cACE,GACA,6BAAkB,AAAgB,wBAE7B,aAAP,IAEK,aAAP,+BAKA,0BAAQ,qBACD,OACA,OACA,OAEA,OACA,OACA,OACA,OACA,OAIA,OACA,OACA,OACA,QAfsB,cAAyB,EAAc,4BAA9C,KAGX,cAAyB,GAAwB,4BAAxD,QAMO,cAAyB,GAAwB,mBACjD,cAAyB,GAAY,gCAFxB,OAQb,cAAyB,GAAwB,mBACjD,cAAyB,IAAmB,gCAFvB,OAKX,sBACrB,AAAI,IACF,KACsB,sBACpB,AAAI,IACG,AAAQ,IAAO,qBAAsB,EAAI,KAC5C,AAAI,AAAC,cAAwB,cAAc,iBAAI,oBACtC,aAAP,IAF6C,AAAE,eAMpC,sBACV,SAEgB,sBACzB,AAAI,OACa,sBACf,AAAI,IACF,AAAI,AAAC,cAAwB,cAAU,oBAC9B,aAAP,QAGiB,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAC,cAAwB,cAAe,iBAAI,oBACvC,aAAP,IAF8C,AAAE,cAKnC,sBACjB,AAAI,AAAC,cAAwB,cAAY,oBAChC,aAAP,MAIC,aAAP,oOA8iCA,AAAI,iBAAiB,oBAAuB,aAAP,IAE9B,AAAC,iBAAa,IAAS,iBAAc,gBAA5C,yvEAukCE,EACA,gBACA,6BAAsB,+BACtB,6BACA,cACA,6BAA6C,wYaj1BjC,sBACd,AAAI,AAAC,KAAS,iBAA6B,+BAEtB,yBACD,aAEH,sBACjB,AAAI,IACG,GAAc,KAAW,gCAAiB,IAAO,qBAAgB,EAAI,QAC5D,cAAQ,UACpB,AAAO,AAAC,cAAmB,uCACR,sBACnB,AAAI,IACG,GAAY,KAAS,gCAAmB,IAAO,qBAAc,EAAI,UACnD,AAAU,cAAM,aACf,GAAO,cAAiB,qDACrB,cAAmB,sBACxC,AAAI,IAAkB,AAAC,cAA6B,cAAY,cAAgB,cAAU,cAAa,cAAO,YAC5G,GAEF,cAAY,cAAY,kBACxB,cAAkB,cAAY,mBARyC,AAAE,YALF,AAAE,YAoBjF,AAAwB,OACb,sBACX,AAAI,IACF,AAA8B,kCAC9B,AAAO,AAAC,cAAmB,uCACT,sBAClB,AAAI,IAEG,GAAY,KAAS,gCAAkB,IAAO,qBAAc,EAAI,UAClD,AAAU,cAAM,aAChB,GAAO,cAAgB,kDACxC,AAAI,IAA2B,cAAc,WAAqB,MAC7C,cAAmB,sBACxC,AAAI,IAAkB,AAAC,cAA6B,cAAY,cAAgB,cAAU,cAAY,cAAM,YAC1G,GAEF,cAAY,cAAY,kBACxB,AAAI,cAAc,QAChB,cAAkB,cAAY,mBAE9B,cAAqB,oBAZ+C,AAAE,YAgB5E,AAAe,uBAID,yBACe,yBACd,YACjB,AAAI,IAEG,GAAc,KAAW,iCAA+B,IAAO,qBAAgB,EAAI,QACzE,AAAU,cAAQ,cACd,uBACjB,AAAI,OACe,cAAe,uBAChC,AAAI,IAAY,cAA6B,cAAY,cAAQ,cAAU,cAAY,cAAM,QAE/F,QAAQ,qBACD,OAKA,QAL+B,GACb,AAAC,kDAAmC,uBACzD,cAAa,6BAAqB,oBAClC,GAEkC,GACb,AAAC,kDAAmC,uBACzD,AAAI,sBACkB,cAAqB,cAAgB,WACzD,AAAI,OACc,uBAChB,AAAI,EAAa,MAAW,GAC5B,AAAkB,IAClB,AAAI,OACmB,cAAe,sCACpC,AAAI,IAAkB,iBAAuB,YACnB,gDACD,cAAqB,cAAmB,WAC/D,AAAI,IAAoB,uBACtB,AAAI,iBAAyB,oBAE3B,cACE,GACA,8CAAoC,8CACpC,8BAAoB,8BAAuB,kCAE7C,GAEF,cAA6B,oBAC7B,AAAc,OAIpB,AAAI,IACF,AAAe,mBACf,AAAO,AAAW,uBAClB,AAAW,EAAW,KACtB,AAAI,EAAe,KAAM,AAAe,AAAC,EAAe,GAAQ,MAChE,cAA6B,KAC7B,EAAgB,MAElB,cAA0B,iBAC1B,cAAa,6BAAqB,uBAGnB,GAAO,mEACtB,AAAI,IAAU,6BAAgC,cAAW,qBAG3D,cAAa,6BAAqB,qBAEpC,GAEO,AAAO,qBAElB,AAAI,AAAC,cAAU,SACb,cAAqB,mBAhEkE,AAAE,YAsE1F,AAAQ,IAAO,qBAAmB,EAAI,QAC1B,cAAW,cACL,uBACrB,AAAI,AAAC,KACH,cACE,GACA,4CAA+B,wCAGZ,uBACrB,AAAI,IAAkB,AAAC,cAAgC,wBACrD,cACE,GACA,4CAAqC,uDAbC,AAAE,WAmBhD,AAAI,iBAAiB,KAGnB,AAAI,AAAC,cAAY,SAAyB,iBAAqB,SACxD,GAAY,KAAS,kCAAoB,IAAO,qBAAc,EAAI,QACpD,cAAM,cACV,GAAO,cAAkB,oDACtC,cACE,GACA,8CAA+B,8CAC/B,8BAAuB,cAAY,kDANmC,AAAE,YAY9E,cAA4B,QAIN,cAAmB,uBACvC,AAAI,IAAiB,iBAAwB,SAC3C,AAAO,iBAAsB,wBACV,cACjB,kDACA,EACA,GAAO,0DACP,WAEF,AAAI,IAAc,cAA+B,uBAM9B,uBAEpB,GAAY,KAAS,kCAAyB,IAAO,qBAAc,EAAI,OAC1E,AAAmB,AAAU,cAAM,UACX,GAAO,cAAuB,wCACtD,AAAO,EAAgB,sBACvB,AAAI,cAAqB,SAEvB,GAGF,AAAI,cAAqB,YACF,cAA0B,0BAC5B,cACjB,cACA,EACA,iBACA,eAGiB,cACjB,cACA,EACA,iBACA,YAGJ,AAAI,AAAC,KAAkB,MACP,uBAChB,AAAI,AAAC,KAAW,iBAAyC,6BAIzD,AAAI,cAAoB,SACtB,UAAQ,MACD,QACA,QACA,QACA,YAAyB,GACX,sCACjB,AAAI,AAAC,cAA0B,qCAC7B,AAAI,EAAc,KAChB,cACE,GACA,4DAAqD,+BAAuB,uDAOxF,AAAI,AAAC,cAAc,QACjB,cAAc,EAAc,kBAC5B,AAAI,EAAgB,SAA2B,EAAgB,UACjD,uBACZ,AAAI,AAAC,KAAO,iBAAkC,EAAmB,yCACjE,AAAI,EAAgB,MAClB,cAAc,kDAIlB,AAAI,EAAc,KAChB,cACE,GACA,wDA9DuE,AAAE,WAqEjF,AAAO,cAAmB,mCAC1B,cAAsB,kBAMjB,GAAc,KAAW,kCAAqB,IAAO,qBAAgB,EAAI,UAC9D,cAAQ,WACtB,AAAwB,iBAAgB,QACvB,uBACjB,AAAI,IACF,AAAiB,IACZ,GAAe,KAAW,kCAAiB,IAAO,qBAAiB,EAAI,QAC9D,cAAS,WACrB,AAAI,EAAS,KAAU,AAAoB,KACtC,AAAI,cAAmB,mBAAQ,AAAa,MAH4B,AAAE,WAKjF,AAAI,IAAY,IAElB,AAAI,IAAmB,cAAwB,cAAS,OAbuB,AAAE,sDAlejE,IAAgB,AAAc,kBAAiB,YAIlD,cAA8B,sBAC7C,AAAI,IAAiB,cAAP,OAGe,sBAC7B,AAAI,sBAAoB,cAA0B,GAAI,iGACtD,AAAI,iBAAkB,QACT,EAAc,cAAwB,kDAA+B,0BAErE,EAAU,cAAwB,cAAW,cbyvCrC,WavvCrB,cAA8B,cAAa,oBACtB,sBACrB,cAAmB,kBAInB,AAAI,OACuB,GAAO,kDAChC,AAAwB,mBACxB,AAAuB,mBACvB,AAAO,EAAoB,qBACtB,AAAQ,MAAG,EAAI,KAClB,cAAa,cAAmB,+CAAc,cAAc,qBADxB,AAAE,eAIf,sBACzB,AAAO,AAAE,IAAsB,iBAA4B,2BAE7D,cAAmC,iBAEnC,AAAiB,OAGG,sBACpB,AAAI,OACmC,OACrC,EACE,AAAI,EAAW,KACb,cACE,GACA,4CACA,oCAEK,cAAP,OAEQ,sBACH,QACS,GAAO,qDACd,cACT,cACA,6BACA,6BACA,AAAS,6BACT,cACA,UAEF,AAAI,AAAC,KAAa,cAAP,IACX,cAAiB,iBAMjB,AAAI,cAAmB,mBAAO,AAAa,MAGtC,AAAI,mBACT,cAAiB,oDAIO,sBAC1B,AAAI,IACG,AAAQ,IAAO,qBAA4B,EAAI,QACzB,cAAoB,aACR,OACrC,EACE,AAAI,EAAW,KACb,cACE,GACA,4CACA,oCAEK,cAAP,OAEQ,sBACH,QACY,GAAO,6DAA2B,yCAC3C,cACV,cACA,6BACA,6BACA,AAAS,6BACT,cACA,UAEF,AAAI,AAAC,KAAc,cAAP,IACZ,AAAO,iBAAc,qBACrB,cAAsB,oDAGtB,AAAI,cAAmB,mBAAQ,AAAa,KA5BS,AAAE,YA+B3D,AAAI,IAAmB,cAAP,IAGhB,cAAwB,cAAU,KAC3B,cAAP,+BAiZA,AAA2C,IAG3C,AAAI,cAAa,YACS,cACtB,GAAO,yDACP,cACA,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAA8B,aAAP,KAI5B,AAAI,IAAqB,iBAA2B,SAClD,AAAI,EAAc,KAChB,cACE,GACA,6BAAkB,qCAGf,aAAP,KAKG,cACL,cACA,cACA,cACA,gBAJF,kCA2DwB,sBACxB,AAAuB,IACvB,AAAI,AAAC,QAAqB,AAAC,AAAmB,mBAA6B,MACzE,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,gBAAK,yBAGd,aAAP,IAEK,cAAkB,gBAAzB,4BzBj2GO,iBAAe,eAAtB,kCyB2JyB,cAA2B,cAAM,UAC1D,AAAI,AAAC,KAAyB,aAAP,OACJ,cAAiB,cAAkB,cAAY,cAAU,UAC5E,AAAI,AAAC,KAAqB,aAAP,IACnB,kCAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UAZsB,cAAP,IACC,AAAI,AAAC,kDAAsC,cAAP,KAC9B,cAAP,OAIO,cAAP,IACC,AAAI,AAAC,kDAAsC,cAAP,KAC9B,cAAP,IACO,cAAP,IACO,cAAP,IACO,cAAP,IACO,cAAP,IACX,AAAO,qBAEX,aAAP,2Hb6hIA,AAAI,IACF,QAAQ,MACD,QAKA,SALyB,GACJ,cAAoB,aAC5C,AAAI,IAA0B,aAAP,IACvB,GAE4B,GACJ,cAAoB,aAC5C,AAAI,IAA0B,aAAP,IACvB,GAEO,AAAO,yBAGS,OAC7B,KACkB,sBAChB,AAAI,EAAa,KAAQ,cAAc,WAC9B,GAAO,cAAc,4CAA5B,OAES,sBACJ,KACF,aAAP,kCaviIyB,cAA2B,cAAM,UAC1D,AAAI,AAAC,KAAyB,aAAP,OACJ,cAAiB,cAAkB,cAAY,cAAU,UAC5E,AAAI,AAAC,KAAqB,aAAP,OACE,sBACrB,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAwB,uCAGrB,aAAP,OAEa,cAA8B,aAC7C,AAAI,OACmB,qCACrB,AAAI,cAAY,OACd,AAAO,iBAAyB,qBACzB,cAAe,gBAAtB,IAEA,AAAO,iBAAyB,qBACzB,cAAe,gBAAtB,MAGJ,AAAI,EAAc,KAChB,cACE,GACA,6BAAwB,uCAGrB,aAAP,kCbgBa,sBACb,AAAI,AAAC,KAAQ,iBAAmC,GAAgB,cAAa,eAAsB,6DAC5F,aAAP,6ZGjPqB,sBACrB,AAAI,IAEK,aAAP,OAEyB,sBACzB,AAAI,OAES,yBACG,GAAO,6BAA8B,6BAA2B,oCAAE,gEAChF,cAAsB,iBACf,aAAP,OAEqB,sBACrB,AAAI,cAAmB,mBAEd,GAAO,cAAmB,wDAAjC,MAIC,aAAP,kCUwNyB,cAA2B,cAAM,UAC1D,AAAI,AAAC,KAAyB,aAAP,OACJ,cAAiB,cAAkB,cAAY,cAAU,UAC5E,AAAI,AAAC,KAAqB,aAAP,OACE,cAA+B,qCACpD,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,2CAAP,KAEhB,AAAI,EAAc,KAChB,cACE,GACA,6BAAwB,uCAGrB,aAAP,kCAayB,cAA2B,cAAM,UAC1D,AAAI,AAAC,KAAyB,aAAP,OACJ,cAAiB,cAAkB,cAAY,cAAU,UAC5E,AAAI,AAAC,KAAqB,aAAP,OACM,sBACzB,AAAI,IAA2B,4BAAP,IACxB,AAAI,EAAc,KAChB,cACE,GACA,6BAAwB,uCAGrB,aAAP,4BV3MA,AAAI,mBACK,aAAP,IAEK,GAAO,wDAAd,kCUqNyB,cAA2B,cAAM,UAC1D,AAAI,AAAC,KAAyB,aAAP,OACJ,cAAiB,cAAkB,cAAY,cAAU,UAC5E,AAAI,AAAC,KAAqB,aAAP,IACnB,AAAI,AAAC,oBAAyC,aAAP,IAChC,4BAAP,oCbgvFO,AAAC,GAAiB,2EAAzB,oCAKO,AAAC,GAAiB,2EAAzB,oCa7nGe,yBACS,sBACxB,AAAmB,AAAC,oBAGpB,AAAI,OACe,qCACjB,AAAI,IAAY,cAAa,0BAChB,GAAO,cAAa,kDAC/B,AAAI,IAAqB,iBAA2B,SAClD,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wCAIlB,AAAI,mBACF,AAAI,mBAAiC,6BAAP,IAC9B,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wCAIX,cAAP,QAKU,cAAqB,cAAU,cAAY,UACzD,AAAI,AAAC,KAAgB,cAAP,OAGG,sBACjB,AAAI,OACQ,QAKV,AAAI,iBAAgB,KAClB,AAAI,IAAqB,iBAA2B,SAClD,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,sCAIlB,AAAI,mBACF,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAG,qEAId,eAAP,IAIF,AACE,iBAAgB,QAChB,iBAAgB,SAED,cACb,iDACA,cACA,cACA,AAAS,6BACT,cACA,UAEF,AAAI,AAAC,KAAiB,cAAP,IACR,mBAAkB,iCAA6B,8BAAtD,KAKJ,AAAI,iBAAgB,QACG,0CAGrB,AAAI,cAAW,UACb,AAAI,IAAqB,iBAA2B,SAClD,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,yCAIP,sBACX,AAAI,mBACF,AAAI,mBAAiC,6BAAP,IAC9B,AAAI,EAAc,KAChB,cACE,GACA,6BAAgB,qDAIf,cAAP,IAIF,AAAI,OACS,qCACX,AAAI,cAAQ,mBAA6B,cAA8B,cAAM,cAAY,cAAU,iBAAjE,IAClC,AAAI,cAAQ,mBAA6B,cAA+B,cAAM,cAAY,cAAU,iBAAlE,IAClC,AAAI,cAAQ,mBAA6B,cAA+B,cAAM,cAAY,cAAU,iBAAlE,IAClC,AAAI,cAAQ,mBAA6B,cAAkC,cAAM,cAAY,cAAU,iBAArE,IAClC,AAAI,cAAQ,mBAA6B,cAAmC,cAAM,cAAY,cAAU,iBAAtE,QAIX,sBACzB,AAAmC,IACnC,AAAI,OACc,cACd,cACA,cACA,iBACW,AAAS,oCACpB,cACA,UAEF,AAAI,AAAC,KAAsB,cAAP,KACf,AAAI,IAAqB,iBAA2B,SACzD,cACE,GACA,6BAAY,wDAGL,cACT,6BACA,cACA,cACA,UAEF,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,mBACF,AAAI,mBAAiC,6BAAP,IAC9B,AAAI,EAAc,KAChB,cACE,GACA,6BAAgB,qDAIf,cAAP,IAEF,AAAI,EAAc,KAChB,cACE,GACA,6BAAgB,oDAGb,cAAP,kCAcuB,sBACvB,AAA4B,IAC5B,AAAI,OACS,cACT,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAAiB,aAAP,QAEI,sBACrB,AAAoB,sBACC,EAAgB,UACrC,AAAyB,IACzB,AAAc,IACT,AAAQ,MAAG,EAAI,QACE,cAAe,UACnC,MAAQ,qBACD,OAIA,QAJuB,AAC1B,AAAqB,EAAI,KACzB,GAEuB,AACvB,AAAO,EAAK,qBACZ,AAAU,IACV,MAGoB,sBACxB,AAAI,AAAc,mBAChB,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,aAAP,OAEkB,cAClB,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAAsB,aAAP,IACpB,cAAe,EAAK,iBA9Ba,AAAE,cAgChB,sBAErB,AAAI,AAAc,mBAChB,AAAI,EAAc,KAChB,cACE,GACA,0CAGS,YAEA,cACX,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAAmB,aAAP,QAEH,AAAiB,6BAAc,cAAgB,cAAY,cAAU,EAAoB,UAClG,mBAAkB,iCAA8B,6BAAvD,+BA/RA,AAAI,mBACF,cACE,GACA,6BAAY,uBAEP,aAAP,IAEF,cAA0B,KAC1B,AAA4B,IAC5B,QAAQ,qBACD,OASA,QAToB,GACZ,cACT,iDACA,cACA,cACA,UAEF,GAE0B,GACf,cACT,iDACA,cACA,cACA,UAEF,GAEO,AAAO,qBAElB,cAA0B,KACnB,aAAP,iEAjCyB,wGTmvDlB,AAA8B,8BAArC,4BD9sDO,iBAAa,KAAgB,IAAY,cAAhD,4KJoUA,AAAI,EAAQ,KAAU,aAAP,OACE,sBACV,EAAQ,oBAAqB,AAAC,AAAU,cAAW,KAAU,GAAS,kBAA7E,+BA0ZA,AAAI,AAAC,oBAAiC,aAAP,IAI/B,MAAQ,AAAgB,SACjB,OAKA,QALuB,AAC1B,AAAI,AAAC,AAAW,QAAO,MACX,4CAAkC,AAAiB,aACxD,AAAC,sCAAkC,cAAiB,iBAAa,EAAoB,iBAA5F,IAE0B,GACd,4CAAkC,AAAiB,aACxD,AAAC,sCAAkC,cAAiB,iBAAa,EAAoB,iBAA5F,IAGG,aAAP,8BU9gBA,cAAoB,EAAM,EAAyB,cAAO,EAAM,cAAM,cAAM,mDrBH9C,2CAAP,4LYw4GH,sBACpB,AAAiB,sBACD,cAAQ,OAAO,GAAO,aACtC,AAAI,AAAC,QAA2B,6BAA2C,iCAC/D,EAAU,cAAW,EAAY,cAAM,cAAM,sBACzD,AAAI,OACgB,yBACC,sBACnB,AAAI,AAAC,KAAc,iBAA0C,4BAC7D,AAAI,cAAiB,mBAAuB,iBAC5C,cAAiB,cAAM,mBAEzB,cAAc,EAAc,iBACrB,aAAP,6BDzxGA,AAAI,EAAQ,cAAG,KACE,sBACjB,AAAY,EAAQ,oBAAoB,AAAU,cAAW,MAAU,KACvE,cAAW,EAAS,EAAQ,AAAC,uDA9HjB,6BAA6B,cCq4GA,EAAgD,UDp4GzF,cAAoB,iBAAa,AAAC,QAC3B,aAAP,4BIvMO,cAAQ,EAAkB,GAAoB,kBAArD,6BJwsCK,mBACL,AAAC,uBACD,iBAAgB,wBAChB,iBAAiC,kCAHnC,4BAnoCS,2CAAP,6JlBnQA,AAAa,sBACH,AAAyB,EAAiB,GAAG,UACvD,AAAU,mBACL,AAAQ,MAAG,EAAI,KAClB,AAAW,EAA0B,EAAY,IAAI,AAAU,EAAO,EAAY,UADxD,AAAE,WAGvB,aAAP,6BuBwhHF,AAAI,AAAC,KAAY,aAAP,OACA,YAIV,IAAO,AAAK,AAAuB,qBACjC,AAAI,AAAE,EAAK,OACT,cAAS,MACT,GAEF,AAAK,AAAuB,aAAS,KACrC,AAAI,AAAC,EAAK,IAAS,MACjB,cAAS,AAAC,AAAC,EAAK,GAAO,GAAK,OAC5B,GAEF,AAAK,AAAuB,aAAS,KACrC,AAAI,AAAC,EAAK,IAAS,MACjB,AAAK,AAAC,AAAC,EAAK,GAAO,GAAO,EAAM,IAAK,MAErC,AAAK,AAAuB,aAAS,KACrC,AAAI,AAAC,EAAK,IAAS,MACjB,AAAK,AAAC,AAAC,EAAK,GAAM,GAAO,EAAM,IAAO,EAAM,IAAK,MAEjD,AAAO,KAAO,mBAGlB,AAAI,EAAK,OACP,cAAS,OAET,AAAS,EAAK,OACd,cAAS,GAAkB,EAAO,QAClC,cAAS,GAAiB,EAAK,eAI5B,AAAqB,4BAA5B,4BDttGE,AAAW,mBACX,AAAI,AAAC,cAAQ,QAAqB,EAAQ,MACnC,AAAC,KAAO,iBAAkB,eAAjC,4BAhKO,cAAQ,EAAqB,GAAoB,kBAAxD,4BtB5GO,EAA0B,QAAK,AAAC,8BAAvC,4BkBgLiC,AAAC,iBAAa,GAAS,cAA9B,iCA41B1B,AAAI,AAAC,oBAAiC,cAAP,IAG/B,0BAAQ,AAAgB,SAGjB,OAOA,OAMA,OAOA,OA6HA,OAuBA,OAqBA,OAcA,OAUA,OAMA,OAMA,OAgBA,QAjPuB,GACd,4CAAkC,AAAiB,aACxD,AAAC,cAAiB,iBAAa,EAAoB,WACnD,AAAsB,6BAAY,8BADzC,IAK0B,AAC1B,AAAO,AAAW,0BACX,cAAiB,AAAiB,KAAO,6BAAhD,IAI2B,GAEd,GAAO,4CAAgC,GAAO,AAAiB,iFAC5E,AAAO,iBAAe,QAAsB,iBAAe,sBACpD,AAAsB,AAAC,gEAA4B,6BAA1D,IAGwB,AACxB,kFAAQ,AAAY,SAGb,OACA,OACA,OACA,QACA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,OACA,OACA,QAGA,OA0BA,OAmBA,OAOA,OAUA,OAeA,OACA,OACA,uCAlFuB,cAAP,IAIZ,AACL,AACE,AAAgB,AAAU,AAAc,UAAU,KAEhD,AAAiB,KAAY,QAE3B,AAAiB,KAAY,KAC7B,AAAC,cAAiB,AAAe,KAAO,gCAI5C,AAAgB,AAAU,AAAe,UAAU,KAEjD,AAAiB,KAAY,QAE3B,AAAiB,KAAY,KAC7B,AAAC,cAAiB,AAAc,KAAO,yCAjB3B,IA6Bb,AACL,AACE,AACE,AAAgB,AAAU,AAAc,UAAU,KAClD,AAAiB,KAAY,cAA6B,4BACvD,AAAC,cAAiB,EAAS,wBAEhC,AACE,AAAgB,AAAU,AAAe,UAAU,KACnD,AAAiB,KAAY,cAA6B,4BACvD,AAAC,cAAiB,EAAS,iCAbhB,IAmBA,AACpB,AAAY,EAAK,oBACV,AAAgB,AAAU,AAAe,UAAU,QACnD,AAAiB,KAAW,gBADnC,IAKoB,AACpB,AAAY,EAAK,oBACV,cAAiB,AAAc,KAAO,mBAC3C,AAAgB,AAAU,AAAe,UAAU,QACnD,AAAiB,KAAW,oBAF9B,IAQoB,AACpB,AAAY,EAAK,oBACV,mBACH,AACE,AAAgB,AAAU,AAAe,UAAU,KACnD,AAAiB,KAAW,SAE9B,cAAiB,AAAc,KAAO,mBACtC,AACE,AAAgB,AAAU,AAAe,UAAU,KACnD,AAAiB,KAAY,yBARnC,MAgBO,cAAiB,AAAc,KAAO,sBACtC,cAAiB,AAAe,KAAO,8BAF1B,IAKxB,GAGuB,AACvB,sBAAQ,AAAW,SAGZ,OACA,OAGA,OACA,OACA,OAGA,OACA,OACA,OACA,OACA,SAZuB,cAAP,MAKU,iBAAY,eAAnB,IAGQ,iBAAa,mBAA8B,GAAK,gBAAvD,IACO,iBAAa,mBAA8B,IAAK,gBAAvD,IACQ,iBAAa,mBAA8B,GAAK,gBAAvD,IACO,iBAAa,mBAA8B,IAAK,gBAAvD,IACO,iBAAa,mBAA8B,IAAK,gBAAvD,IAE5B,GAIuB,AACvB,AAAiB,IACjB,cAAQ,AAAuB,SACxB,QACA,QACA,QACA,QACA,SAJkB,AAAE,AAAQ,AAAiB,OAAO,GAClC,AAAE,AAAQ,AAAoB,OAAO,GACrC,AAAE,AAAQ,AAAqB,SAAQ,GACvC,AAAE,AAAQ,AAAqB,SAAQ,GAC/B,cAAP,IACf,AAAO,qBAElB,YAAQ,qBACD,OACA,OACA,OACA,OACA,QAJsB,AAAC,EAAQ,AAAC,MAAM,eAAvB,IACO,EAAQ,SAAsB,EAAQ,iBAA7C,IACO,EAAQ,SAAsB,EAAQ,iBAA7C,IACO,EAAQ,QAAK,EAAQ,iBAA5B,IACO,EAAQ,QAAK,EAAQ,iBAA5B,IAEtB,GAIsB,AAEtB,AAAa,AAAa,OAC1B,QAAQ,AAAa,SACd,OACA,QADI,GAAa,IAAS,IAAW,SAAU,GAC3C,GAAa,IAAS,IAAW,SAAU,GAC3C,GAAa,IAAS,IAAW,SAAU,GAE/C,AAAsB,cAAU,6BAAvC,IAMuB,AACvB,AAAI,AAAC,AAAa,sBAChB,AAAW,AAAO,AAAmB,6BACrC,AAAW,AAAgB,EAAM,EAAO,QACjC,cAAiB,EAAM,6BAA9B,IAEF,GAKO,cAAiB,AAAU,KAAO,sBAClC,cAAiB,AAAO,AAAW,4BAAQ,8BAF9B,IAOb,cAAiB,AAAc,KAAO,sBACtC,cAAiB,AAAc,KAAO,8BAFrB,IAMF,GACR,yBACQ,yBACH,GAAO,AAAc,sCACxC,AAAI,cAAoB,sBACP,GAAO,cAAoB,kDAC1C,AAAO,iBAAiB,wBACD,6CACN,qCACV,AAAC,6BAAyB,WAC1B,AAAsB,cAAY,8BADzC,IAGK,cAAP,IAIoC,cAAP,IAE1B,cAAP,kCCtoBa,sBACb,AAAI,AAAC,KAAQ,iBAA+B,cAAkB,yCACvD,aAAP,4BA4BO,2CAAP,kCAtBa,sBACb,AAAI,AAAC,KAAQ,iBAAgC,cAAkB,yCACxD,aAAP,4BA2BO,AAAC,gCAAuC,kBAAqB,IAAW,AAAC,kBAAhF,4BAOO,iBAAqB,6BAA5B,kCA7Ka,sBACb,AAAI,AAAC,KAAQ,iBAAgC,cAAkB,yCACxD,aAAP,ibA8LA,AAAoB,mBACb,AAAC,AAAC,EAAgB,GAAgB,IAAW,AAAC,OAAW,cAAhE,qCAYA,AAAI,IAAW,EAAe,qBAI9B,AAAgB,cAAuB,OAEvC,AAAoB,mBACpB,AAAmB,AAAC,AAAC,EAAI,gDAAkC,GAAgB,IAAW,AAAC,OAAW,KAClG,AAAI,EAAY,KAAc,AAAY,KAG1C,AAAI,EAAa,YAAgB,AAAC,EAAY,GAAa,MACzC,iBAEX,aAAP,4BL/pBA,AAAI,EAAc,AAAK,oBAAsC,gBAC7D,AAAU,iBAAiB,GAAc,uCqBtK3C,cAAO,EAAU,uCAWjB,cAAO,EAAc,KACrB,cAAO,EAAS,GAAK,EAAU,yCAa/B,cAAO,EAAc,KACrB,cAAO,EAAS,GAAK,EAAU,MAC/B,cAAO,EAAS,GAAK,EAAU,MAC/B,cAAO,EAAS,GAAK,EAAU,0CAkB/B,AAAS,EAAQ,UAAQ,cAAQ,KACjC,AAAS,EAAS,aAAQ,cAAQ,EAAS,wCAd3C,AAAS,EAAO,cAAQ,KACxB,AAAS,OAAY,EAAS,MAAI,GAAI,GAAI,cAAQ,EAAS,2CAkB3D,AAAO,IAAW,EAAW,eAAS,EAAW,iDACjD,AAAS,EAAQ,UAAQ,cAAQ,yCAUjC,AAAS,EAAW,UAAQ,cAAQ,2CAUpC,AAAe,EAAW,YAC1B,AAAS,EAAQ,UAAW,cAAQ,KACpC,AAAS,EAAS,aAAW,cAAQ,EAAS,0oChB4qIrC,4BAAP,ooCAqSc,sBACd,AAAkB,iBAAwB,KAC1C,AAAgB,cAAyB,EAAa,UACzC,EAAe,iBAAwB,cACvC,sBACb,cAAkB,gBAAU,EAAW,cAAQ,MAC/C,cAAkB,gBAAU,EAAG,cAAQ,MACvC,cAAkB,gBAAW,EAAG,cAAQ,MACxC,cAAkB,gBAAQ,iBAAS,cAAQ,MAC3C,cAAkB,gBAAU,EAAa,cAAQ,MAC1C,aAAP,4BnB5+IA,AAAI,EAAY,AAAK,oBAAoB,aAAP,IAC3B,AAAU,EAA2B,EAAc,kBAA1D,+BmBovBA,AAAoB,EAAQ,sCACrB,EAAQ,EAAU,EAAQ,IAAe,cAAgB,kEAAU,I3B7uB5E,AAAO,EAAO,iB2B6uBZ,ySZ6gCA,AAAmB,6BAAiC,yBACtC,EAAkB,cAAQ,UACxC,6BAAyB,kBACzB,cAAoB,EAAQ,IAAc,EAAQ,iDAC3C,aAAP,w+BAYc,sBACd,AAAoB,sBACC,GAAO,qDAEb,sBACf,AAAI,cAAa,sBACC,GAAO,cAAa,mDAEpC,AAAU,sBACA,cAA4B,EAAO,WACxC,AAAQ,MAAG,EAAI,KAClB,AAAS,cAAuB,KAAI,cAAK,EAAiB,EAAK,OADxC,AAAE,cAGX,cAA6B,sBAC7C,cAAa,cAAa,mBAErB,EAAQ,mBAAsB,EAAQ,0CAA7C,4BgB9eA,AAAU,mBACV,AAA+B,EAAK,EAAU,IACvC,AAAwB,iBAAU,eAAzC,4BARA,AAAU,mBACV,AAA+B,EAAK,IAC7B,AAAwB,iBAAU,eAAzC,iUhB2dA,AAAU,cAA2B,mBACrC,cAAmB,8DACZ,6BAAkB,gBAAzB,yDyBu4B6B,WAEJ,8GbhkET,cAAY,uBAC5B,AAAI,AAAC,QAAa,iBAAkB,MAAsC,aAAP,IAC5D,6BAA8B,iDAA8B,yBAAnE,y3GAq8FO,AAAC,GAAqB,2EAA7B,+BZ0gMA,AAAgB,OACO,sBACvB,AAAI,IACF,AAAI,AAAC,6BAAgC,GAAO,0DAAqB,oBAC/D,AAAY,SAGK,yBACA,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAE7C,AAAI,iBAAwB,QAAyB,cAAe,cACzC,QAC3B,AAAI,AAAC,6BAAgC,cAAe,iBAAI,oBACtD,AAAY,KALkC,AAAE,WAQpD,AAAI,AAAC,6BAAgC,6BAAsB,mCACzD,AAAY,KAEP,aAAP,4BYrsNoD,AAAC,iBAAsB,GAAU,cAAxC,4BAoKtC,2CAAP,oOKxwBF,AAAI,IACG,AAAQ,IAAO,qBAAmB,EAAI,QACzB,cAAW,UAC3B,AAAI,iBAA2B,KAAa,aAAP,IAFO,AAAE,YAK3C,aAAP,gdNn3D6B,OAC3B,KACc,sBACZ,AAAI,IAAS,cAAU,uBAAc,GAAO,cAAU,wDAAxB,OACpB,sBACH,KACF,aAAP,uqCY3eE,AAAC,IAGE,GACK,UACV,AAAI,IAEG,GAAY,KAAS,gCAAU,IAAO,qBAAc,EAAI,QACnD,AAAU,cAAM,UACxB,AAAQ,AAAO,cAAQ,wCACvB,cAAQ,cAAG,MAHmD,AAAE,YAM7D,aAAP,+CZsTa,EAAS,6BAAqB,qCAC3C,cAAgB,iBAChB,cAAe,oBACf,cAAe,gCACf,AAAI,IACF,+BAAgB,AACd,EACA,YAGF,cAAoB,iCAEtB,AAAI,IACF,+BAAgB,AACd,EACA,YAGF,cAAuB,iCAEzB,cAAoB,wDACpB,AAAI,6BAAuB,YACJ,GAAO,kDAC5B,cAAwB,AAAS,iCAEjC,AAAO,AAAC,qCAEV,cAA2B,gCACpB,aAAP,qDA9B2B,yEA+R3B,AAAO,iBAAwB,oCAC/B,AAAiB,mBAGjB,AAAI,6BAAmB,kCACrB,AAAI,EAAc,EAAmB,OACnC,EAAc,AAAC,UAEjB,EAAc,AAAE,EAAmB,WAErC,AAAI,6BAAsB,kCACxB,EAAc,AAAE,EAAsB,WAGxC,cAAa,iBAAa,MAC1B,cAAkB,gCAClB,cAAsB,kEK+qCf,AAAsB,8BAA7B,giBAysDF,AAAU,IACL,AAAQ,IAAO,qBAAY,EAAI,KAClC,AAAS,cAAe,KAAO,KAC/B,AAAI,EAAM,MACR,EAAO,MACF,AAAI,EAAM,MACf,EAAO,MACF,AACL,AAAgB,OAAO,EAAI,GAAI,SAC/B,AAAe,cAAe,EAAI,eAElC,OACA,EAAO,MAEP,EAAO,QAb4B,AAAE,WAgBlC,aAAP,6BAIA,AAAI,cAAO,OAAa,aAAP,IACjB,AAAU,AAAiB,mBAC3B,AAAU,AAAiB,EAAM,KAAO,KACxC,AAAU,IACV,AAAI,EAAO,oBAEJ,AAAQ,IAAO,qBAAY,EAAI,KAClC,AAAQ,cAAe,KAAO,KAC9B,AAAsB,WAAO,KAFQ,AAAE,YAKpC,AAAQ,IAAO,qBAAY,EAAI,KAClC,AAAS,cAAe,KAAO,KAC/B,AAAI,EAAM,MACR,AAAsB,WAAO,MACxB,AAAI,EAAM,MACf,AAAsB,WAAO,AAAC,GAAS,EAAO,OAC9C,AAAsB,WAAO,AAAC,GAAS,EAAa,QAC/C,AACL,AAAgB,OAAO,EAAI,GAAI,SAC/B,AAAe,AAAK,cAAe,EAAI,iBAEvC,AAAK,AAAkB,EAAI,OAC3B,AAAE,OACF,AAAsB,WAAO,AAAC,GAAS,EAAO,OAC9C,AAAsB,WAAO,AAAC,GAAQ,AAAC,EAAO,GAAM,OACpD,AAAsB,WAAO,AAAC,GAAQ,AAAC,EAAQ,GAAK,OACpD,AAAsB,WAAO,AAAC,GAAS,EAAa,QAEpD,AAAsB,WAAO,AAAC,GAAS,EAAO,OAC9C,AAAsB,WAAO,AAAC,GAAQ,AAAC,EAAQ,GAAK,OACpD,AAAsB,WAAO,AAAC,GAAS,EAAa,UApBjB,AAAE,YAwB3C,AAAsB,EAAK,WACpB,aAAP,m7BAvuBE,AAAI,cAAO,OAAa,aAAP,OACJ,sBACb,AAAI,cAAW,mBAAa,AAAkB,cAAW,4BAApC,IACrB,AAAU,AAAY,mBACtB,cAAW,cAAK,MACT,aAAP,8FA0pBF,AAAI,AAAC,KAAa,aAAP,IAEX,AAAO,EAAc,KACrB,AAAU,mBACV,AAAU,AAAiB,EAAO,OAClC,AAAU,IACL,AAAQ,IAAO,MAAK,EAAI,KAC3B,AAAU,AAAU,cAAK,OACzB,AAAqB,EAAK,AAAK,KAC/B,EAAO,KAHuB,AAAE,WAK3B,aAAP,6BAhyDE,AAAW,cAAuB,mBAClC,AAAW,AAAc,mBACzB,AAAU,AAAwB,iBAAU,EAAM,EAAM,iBAAiB,MACzE,AAAe,IACR,aAAP,6BAQA,AAAa,mBACb,AAAI,EAAU,KAAU,4BAAP,IACjB,AAAI,EAAU,KACZ,AAAa,cAAM,OACnB,QAAQ,AAAgB,SACjB,OACA,OACA,UAEI,aAFsB,IAKjC,AAAiB,AAAkB,OACnC,AAAI,EAAc,MAAuB,EAAc,SAE9C,4BAAP,IAEK,aAAP,IAEK,cAAW,EAAM,cAAO,gBAA/B,gDArBgB,mFhBogBC,yBACD,yBACA,+BAChB,cAAmB,oBAEP,cAAuB,cAlCH,UAmChC,cAAkB,iBAClB,cAAmB,iBACZ,6BAAoB,mCAA3B,4BgB/eA,AAAW,cAAuB,mBAC3B,AAAwB,iBAAU,EAAM,EAAW,eAA1D,kChBofa,yBACG,sBAChB,AAAI,IACF,cACE,GACA,6BACA,uBAEK,4BAAP,OAES,yBACM,sBACjB,AAAI,cAAc,OAChB,cACE,GACA,sCAEK,4BAAP,IAEF,cAAS,KACF,cAAU,gCAAjB,kCAMa,yBACD,sBACZ,AAAI,IACF,cACE,GACA,6BACA,uBAEK,4BAAP,OAGS,yBACS,sBACpB,AAAI,cAAiB,OACnB,cACE,GACA,sCAEK,4BAAP,IAEF,cAAS,EAAsB,OACxB,cAAU,gCAAjB,kCWjsDqB,sBACrB,AAAS,8CACG,sBACZ,AAAI,AAAC,KAAO,cAA4B,oCAAE,uBACrC,cAAW,OACT,aAAP,iTAKqB,yBACT,GAAO,kDACnB,AAAO,mCACP,AAAO,iBAAe,uDAzTc,AAAC,iBAAa,GAAS,cAA9B,wDXy8FF,2FgBlxD3B,AAAI,EAAK,MACP,AAAe,iBAAiB,MAChC,sDAAQ,MACD,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SAxBmB,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAiB,GACpD,AAAK,IAAW,GAAmB,KAAkB,GACrD,AAAK,IAAW,GAAmB,KAAkB,GACrD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GACnD,AAAK,IAAW,GAAmB,KAAgB,GAClE,AAAO,sBAGb,AAAyB,iBAAU,EAAI,EAAM,eAApD,6BAjDA,AAAI,EAAK,MACP,AAAc,iBAAiB,MAC/B,YAAQ,MACD,QACA,QACA,QACA,SAHoB,AAAK,IAAU,GAAoB,KAAgB,GACnD,AAAK,IAAU,GAAoB,KAAgB,GACnD,AAAK,IAAU,GAAoB,KAAmB,GACtD,AAAK,IAAU,GAAoB,KAAgB,GACnE,AAAO,sBAGb,AAAwB,iBAAU,EAAI,eAA7C,kChB4kQa,yBACF,sBACX,YAAQ,qBACD,OAUA,OAcA,OAcA,OASA,QA/Ce,AAClB,AAAI,cAAiB,EAAM,mBAEzB,AAAO,cAAc,EACnB,EACA,cAAW,WAGf,GAEgB,AAChB,AAAI,cAAiB,EAAM,mBACzB,AAAO,6BAAwB,OAC3B,cAAa,EAAoB,MACjC,cAAc,EACZ,cAAc,EACZ,EACA,cAAW,QAEb,cAAW,YAGnB,GAEiB,AACjB,AAAI,cAAiB,EAAM,mBACzB,AAAO,6BAAwB,OAC3B,cAAa,EAAqB,MAClC,cAAc,EACZ,cAAc,EACZ,EACA,cAAW,QAEb,cAAW,YAGnB,GAEgB,AAChB,AAAI,cAAiB,EAAM,mBACzB,AAAO,cAAc,EACnB,EACA,cAAW,YAGf,GAEiB,AACjB,AAAI,cAAiB,EAAM,mBACzB,AAAO,cAAc,EACnB,EACA,cAAW,aAGf,GAGG,aAAP,4BgBjjPO,AAA4B,iBAAU,eAA7C,kChB8rPa,sBACb,wDAAQ,qBACD,OACA,OACA,OACA,OAIA,OACA,OACA,OACA,OACA,OACA,OACA,OAKA,OAmCA,OAmCA,OAGA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAKA,WAvGc,AACV,cAA4B,EAAM,sBAKjB,aAAP,KAEO,cAAc,EAAgB,EAAM,cAAW,qBAAtD,KAGV,iBAAa,MAChB,cAAc,EAAgB,EAAM,cAAW,WAC/C,cAHe,IAKF,GACH,sBACd,AACE,iBAA0B,KAC1B,cAAmB,WAIZ,cAAa,EAClB,cAAa,EACX,cAAa,EACX,cAAa,EACX,cAAa,EAAgB,4BAJrC,IAeO,cAAc,EACnB,cAAc,EACZ,cAAc,EACZ,cAAa,EAA6B,KAC1C,cAAW,QAEb,cAAW,QAEb,cAAW,sBARb,MAYe,GACH,sBACd,AACE,iBAA0B,KAC1B,cAAmB,WAIZ,cAAa,EAClB,cAAa,EACX,cAAa,EACX,cAAa,EACX,cAAa,EAAgB,4BAJrC,IAeO,cAAc,EACnB,cAAc,EACZ,cAAc,EACZ,cAAa,EAA6B,KAC1C,cAAW,UAEb,cAAW,UAEb,cAAW,EAAY,sBARzB,MAaK,cAAa,GAAqB,gBADvB,cAgBX,cAAa,EAAgB,cAAmB,mBAH3B,KAMrB,AACP,cACE,GACA,6BAAkB,sCAEb,cAAW,gBAAlB,8BgB5zOG,AAAoC,8BAA3C,6BAwWA,YAAQ,AAAgB,SACjB,OACA,OACA,OACA,OACA,WAD4B,aAAP,IACA,AACxB,AAAI,iBAAqB,OACvB,cAAQ,AAAY,SACb,OACA,OACA,OACA,OACA,OACA,aAED,cAAuB,AAAc,UACrC,cAAuB,AAAe,uBAFxC,KAMN,GAGG,aAAP,6BAjCA,AAAa,AAAiC,iBAAU,EAAO,EAAU,MACzE,AAAc,AAAwC,EAAQ,MAC9D,AAAI,IACF,AAAI,AAAC,cAAuB,QAAiB,aAAP,IACtC,AAAO,AAAkB,KAAY,AAAkB,yBAElD,aAAP,6BhBgwNA,AAAW,AAAkB,OAC7B,AAAI,EAAQ,MACH,aAAP,IAEF,AAAO,EAAQ,0BACF,sBACb,AAAa,cAAqB,EAAM,WACxC,AAAI,IACK,AAAiB,OACpB,GACA,cAFJ,IAIK,aAAP,gWW7mRA,UAAQ,AAAgB,SACjB,OAUA,OAWA,OA4BA,QAjDoB,AACvB,MAAQ,AAAW,SACZ,OACA,SAAgB,AACnB,cAA0B,AAAc,KAAO,iBAC/C,GAGJ,GAEoB,AACpB,AAAa,AAAU,OACvB,AAAc,AAAW,OACzB,AAAI,IAAW,AAAe,WAG5B,cAA2B,AAAe,KAAO,iBACjD,cAA2B,AAAW,KAAO,kBAE/C,GAEwB,AACxB,UAAQ,AAAY,SAEb,OACA,OAUA,OACA,SAXgB,AACnB,AAAW,AAAc,OACzB,AAAY,AAAe,OAC3B,AAAI,AAAY,OACd,cAA0B,EAAO,kBAC5B,AAAI,AAAY,OACrB,cAA0B,EAAM,mBAElC,IAGmB,AACnB,AAAW,AAAc,OACzB,AAAY,AAAe,OAC3B,AAAI,AAAe,OACjB,cAA0B,EAAO,kBAC5B,AAAI,AAAe,OACxB,cAA0B,EAAM,mBAElC,GAGJ,GAEsB,GAEX,AAAc,UACzB,AAAI,cAAQ,oBACV,AAAO,AAAoB,KAAS,qBACpC,AAAW,AAAiB,EAAM,OAClC,AAAY,AAAiB,EAAM,OACnC,AAAI,AAAY,OACd,cAA0B,EAAO,kBAC5B,AAAI,AAAY,OACrB,cAA0B,EAAM,oBAE7B,AAAI,cAAQ,oBACjB,AAAO,AAAoB,KAAS,qBACpC,AAAW,AAAiB,EAAM,OAClC,AAAY,AAAiB,EAAM,OACnC,AAAI,AAAe,OACjB,cAA0B,EAAO,kBAC5B,AAAI,AAAe,OACxB,cAA0B,EAAM,oBAE7B,AAAI,cAAQ,oBACjB,AAAO,AAAoB,KAAS,qBACpC,cAA0B,AAAiB,EAAM,KAAI,kBAChD,AAAI,cAAQ,oBACjB,AAAO,AAAoB,KAAS,qBACpC,cAA2B,AAAiB,EAAM,KAAI,qBAExD,wCAvLJ,cAAQ,AAAgB,SACjB,OASA,OAOA,OAUA,OAUA,OA2BA,QA/DuB,AAC1B,AAAI,AAAC,AAAW,QAAO,MACX,4CAAkC,AAAiB,aAC/D,AAAI,AAAC,QAAO,cAAgB,iBAAa,UACvC,cAAkB,iBAAa,MAEjC,cAA0B,AAAiB,KAAO,iBAClD,GAE0B,GACd,4CAAkC,AAAiB,aAC/D,AAAI,AAAC,QAAO,cAAgB,iBAAa,UACvC,cAAkB,iBAAa,MAEjC,GAEoB,AACpB,AAAc,AAAW,OACzB,AAAI,IAAW,AAAY,WAGzB,cAA0B,AAAe,KAAO,iBAChD,cAA0B,AAAU,KAAO,kBAE7C,GAEuB,AACvB,MAAQ,AAAW,SACZ,OACA,SAAgB,AACnB,cAA2B,AAAc,KAAO,iBAChD,GAGJ,GAEwB,AACxB,UAAQ,AAAY,SACb,OACA,OAUA,OACA,SAXgB,AACnB,AAAW,AAAc,OACzB,AAAY,AAAe,OAC3B,AAAI,AAAe,OACjB,cAA0B,EAAO,kBAC5B,AAAI,AAAe,OACxB,cAA0B,EAAM,mBAElC,IAGmB,AACnB,AAAW,AAAc,OACzB,AAAY,AAAe,OAC3B,AAAI,AAAY,OACd,cAA0B,EAAO,kBAC5B,AAAI,AAAY,OACrB,cAA0B,EAAM,mBAElC,GAGJ,GAEsB,GAEX,AAAc,UACzB,AAAI,cAAQ,oBACV,AAAO,AAAoB,KAAS,qBACpC,AAAW,AAAiB,EAAM,OAClC,AAAY,AAAiB,EAAM,OACnC,AAAI,AAAe,OACjB,cAA0B,EAAO,kBAC5B,AAAI,AAAe,OACxB,cAA0B,EAAM,oBAE7B,AAAI,cAAQ,oBACjB,AAAO,AAAoB,KAAS,qBACpC,AAAW,AAAiB,EAAM,OAClC,AAAY,AAAiB,EAAM,OACnC,AAAI,AAAY,OACd,cAA0B,EAAO,kBAC5B,AAAI,AAAY,OACrB,cAA0B,EAAM,oBAE7B,AAAI,cAAQ,oBACjB,AAAO,AAAoB,KAAS,qBACpC,cAA2B,AAAiB,EAAM,KAAI,kBACjD,AAAI,cAAQ,oBACjB,AAAO,AAAoB,KAAS,qBACpC,cAA0B,AAAiB,EAAM,KAAI,qBAEvD,2CAvqBO,cAAU,EAAiB,aACtB,sBAChB,AAAI,IAAa,cAAc,WAC7B,cAAa,AAAiB,cAAc,qBAE9C,cAA0B,EA0jBP,KAzjBZ,aAAP,wDAR2B,qIAsgB3B,AAAwB,kCACxB,AAAyB,qCACJ,sBACrB,AAAO,EAAkB,uCACL,sBACpB,AAAO,EAAiB,mDACxB,AAAqB,IAChB,AAAQ,IAAO,AAAS,IAAmB,cAAqB,EAAI,QAC3D,cAAc,aACf,sBACX,AAAI,mBACF,AAAI,cAAiB,EAAG,SAAuB,AAAC,cAAkB,EAAG,cACnE,cAAoB,EAAG,KACvB,AAAiB,MAGrB,AAAI,mBACF,AAAI,cAAiB,EAAG,SAAuB,AAAC,cAAkB,EAAG,cACnE,cAAoB,EAAG,KACvB,AAAiB,MAZqD,AAAE,WAgB9E,AAAI,IAEF,AAAO,iBAAwB,qBAC/B,cAAuB,KACvB,AAAI,gCAAyB,KAC3B,6BAAyB,OAGtB,aAAP,wDKozBgB,+OL55Ca,+BAAc,AAAC,2CK4+C5C,AAAW,cAAuB,mBAC3B,AAAuB,iBAAU,EAAM,eAA9C,oChB0gBa,yBACG,sBAChB,AAAsB,oDAiBX,cAAuC,iBAClD,AAAY,sBACK,gBAAY,2BAC7B,cAAkB,oBACE,gBAAe,2BACnC,cAAqB,oBACL,gBAAW,2BAC3B,cAAmB,oBACH,eACL,sBACX,AAAI,iBAAa,KACf,cAAuB,AAAC,gEAAkC,mBAE1D,cAAe,cAAsB,sBAEvC,cAAyB,KAEzB,AAAwB,cAAW,EAAsB,SACzD,AAAqB,cAAW,EAAmB,SACnD,AAA2B,AAAC,cAAW,GAAuB,SAG9D,AAAI,AAAC,KAAwB,AAAC,SAC5B,cACE,qBAEF,cAAkB,iBAGlB,AAAI,AAAC,KACH,cAAc,QAKhB,AAAe,cAAuB,6BAAqB,2BAC3D,AAAsB,cAAmB,EAAU,6BAAkB,kCACrE,AAAe,cAAuB,OAKtC,AAAoB,EAAY,OAAwB,OAAqB,SAC7E,AAAI,IAAiB,cAAgC,cAAc,0BAAW,WAC5E,cAAmB,iBACZ,cAA0B,6BAAjC,IAGF,AAAI,IACF,cAAU,EAAK,cAAa,cAAe,2BAC3C,cAAmB,KACnB,cAAW,OAEb,cACE,cAAU,cACR,WAGJ,cAAkB,iBAGlB,AAAI,EAAY,KAAsB,AAAC,SACrC,cAAc,QAKlB,cAAmB,iBACnB,AAAW,cAAY,cACrB,cAAe,6BAEjB,AAAI,IACF,AAAO,cAAa,cAAY,qCAC9B,gCAGJ,AAAI,cAAa,QACf,AAAO,cAAa,EAAM,qCAAE,SAAM,+CAE7B,cAAP,4BAzGO,cAA0B,4BAAjC,4BA+GO,2CAAP,oCAMO,cAAuB,6BAAsB,eAAW,gBAA/D,4BgBzpBO,AAAuB,iBAAU,eAAxC,qCL5nCA,AAAO,iBAAwB,oCAE/B,AAAgB,mBAChB,AAAiB,mBACjB,AAAe,IAEf,AAAI,EAAY,KACd,EAAY,MACP,AAAI,EAAa,KACtB,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAIzC,EAAY,EAAY,GAAa,MACrC,EAAY,EAAY,GAAa,MAErC,AAAI,EAAY,KACd,EAAY,MACP,AAAI,EAAa,KACtB,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,AAAI,EAAY,KACd,EAAY,MACP,AAAI,6BAAoB,kCAC7B,AAAI,EAAa,KACf,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,EAAY,EAAY,SAG1B,AAAI,EAAY,KACd,EAAY,MACP,AAAI,6BAAuB,kCAChC,AAAI,EAAa,KACf,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,EAAY,EAAY,SAG1B,AAAI,EAAY,MACd,AAAI,EAAa,MACf,EAAY,OAEZ,EAAY,SAET,AAAI,EAAa,MACtB,EAAY,SAId,EAAY,AAAC,EAAY,GAAc,QAGvC,EAAY,EAAY,GAAa,OAErC,AAAI,EAAY,MACd,EAAY,OAGd,cAAa,EAAY,EAAa,IAA6B,mKAKnE,cAAsB,oBAGD,sBACrB,AAAwB,sBACF,sBACtB,AAAyB,mBACzB,AAAoB,AAAI,IAAmB,YACtC,AAAQ,MAAG,EAAI,KAClB,AAAgB,EAAI,KAAoB,cAAe,MAAK,KAC5D,AAAiB,EAAI,KAAqB,cAAgB,MAAK,KAC/D,cAAe,EAAK,EAAY,GAC9B,EACA,GACA,GACA,OAP+B,AAAE,6CKklC9B,AAAqB,iBAAU,EAAW,EAAQ,eAAzD,oChB8nBa,yBACG,sBAChB,AAAsB,oDAmBX,+BACX,cAAmB,oBACP,eACM,sBAClB,AAAI,IACF,AACE,iBAAoB,QACpB,iBAAoB,sBAEtB,cAAW,cAAsB,yBAOnB,sBAChB,AAAI,IACF,AAAW,cAAuB,cAAW,2BAC7C,AAAkB,cAAmB,EAAU,6BAAkB,mBACjE,AAAW,cAAuB,OAGlC,AAAI,EAAY,KACd,cACE,cAAY,SAEd,cAAkB,iBAClB,cAAmB,iBACZ,cAAe,oCAAtB,KAGF,AAAW,cAAW,OACtB,AAAkB,IAClB,AAAW,QAKE,cAAc,EAAgC,iBAC7D,AAAY,sBACK,gBAAY,2BAC7B,cAAsB,oBACF,gBAAgB,2BACpC,cAAyB,oBACT,gBAAY,2BAC5B,cAAmB,oBACH,eACL,sBACX,AAAI,iBAAa,KACf,cAAuB,AAAC,gEAAkC,mBAE1D,cAAe,cAAsB,sBAEvC,cAA6B,KAC7B,cAAsB,KACtB,cAAyB,KAEzB,AAA2B,AAAC,cAAe,GAAuB,SAClE,AAAwB,cAAe,EAAsB,SAC7D,AAAqB,cAAe,EAAmB,SAEvD,AAAI,IACF,cAAU,EAAK,cAAa,cAAe,2BAC3C,cAAmB,MAIrB,AAAoB,OAAqB,KACzC,AAAI,OACgB,sBAClB,AAAI,IACF,cACE,cAAuB,cAAa,eAAW,EAA2B,WAG9E,cACE,cAAU,yBAMZ,AAAI,cAAgC,cAAkB,0BAAW,OAC/D,cAAmB,iBACZ,cAA2B,6BAAlC,KAKJ,AAAI,EAAY,KACd,cAAa,kBAIb,cAAiB,kBAInB,cAAkB,iBAClB,cAAmB,iBACnB,AAAW,cAAU,EACnB,cAAe,+BAEjB,AAAI,IACF,AAAO,cAAY,cAAW,QAEhC,AAAI,IACF,AAAO,cAAa,cAAY,qCAAE,gCAEpC,cAAW,MACX,AAAI,cAAa,QACf,cAAW,sBAEN,cAAe,oCAAtB,4BA9IO,cAA2B,4BAAlC,qCAoJA,cACE,GACA,6BACA,uBAEK,2CAAP,kCW3qEW,cAjEa,oBAkEP,sBACjB,AAAI,IAAc,cAAe,WAC/B,cAAa,AAAiB,cAAe,qBAE/C,cAA2B,EAupBR,KAtpBZ,aAAP,+BAoVA,AAAO,iBAAuB,oCAC9B,AAAO,iBAAuB,oCAI9B,AAAgB,mBAChB,AAAiB,mBACjB,AAAe,IAEf,AAAI,EAAY,KACd,AAAI,EAAa,KACf,EAAY,MAEZ,EAAY,QAET,AAAI,EAAa,KACtB,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,AAAI,AAAC,EAAY,KAA8B,EAAa,SAC1D,EAAY,MAGd,AAAI,AAAC,EAAY,KAA8B,EAAa,SAC1D,EAAY,MAGd,AAAI,EAAY,KACd,AAAI,EAAa,KACf,EAAY,MAEZ,EAAY,QAET,AAAI,EAAa,KACtB,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,AAAI,EAAY,KACd,AAAI,EAAa,KACf,EAAY,MAEZ,EAAY,QAET,AAAI,EAAa,KACtB,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,AAAI,EAAY,KACd,AAAI,EAAa,KACf,EAAY,MAEZ,EAAY,QAET,AAAI,EAAa,KACtB,EAAY,OAEZ,EAAY,AAAC,EAAY,GAAc,SAGzC,AAAI,EAAY,MACd,AAAI,EAAa,MACf,EAAY,OAEZ,EAAY,SAET,AAAI,EAAa,MACtB,EAAY,QAEZ,EAAY,AAAC,EAAY,GAAc,UAGzC,EAAY,AAAC,EAAY,GAAc,QAEvC,AAAI,AAAC,EAAY,MAA0B,EAAa,UACtD,EAAY,OAGd,AAAI,AAAC,EAAY,MAA0B,EAAa,UACtD,EAAY,OAGd,cAAa,EAAY,iBAAc,IAA6B,aAG/C,sBACrB,AAAI,EAAY,MACd,AAAI,AAAE,EAAa,UACK,sBACjB,AAAQ,IAAO,qBAAwB,EAAI,KAC9C,cAAe,EAAK,cAAgB,QADa,AAAE,aAIlD,AAAI,EAAa,SACD,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,cAAe,EAAK,cAAe,QADa,AAAE,eAI/B,sBACrB,AAAwB,sBACF,sBACtB,AAAyB,mBACzB,AAAoB,AAAI,IAAmB,YACtC,AAAQ,MAAG,EAAI,KAClB,AAAgB,EAAI,KAAoB,cAAe,MAAK,KAC5D,AAAiB,EAAI,KAAqB,cAAgB,MAAK,KAC/D,cAAe,EAAK,EAAY,GAC9B,EACA,GACA,GACA,OAP+B,AAAE,gBAalB,sBACrB,AAAI,OACkB,aACE,GAAO,kDACxB,GAAY,KAAS,gCAAqB,IAAO,qBAAc,EAAI,QAC5D,cAAM,UAChB,AAAgB,AAAuB,cAAmB,mBAC1D,AACE,AAAC,EAAY,GAA2B,KAAK,cAAoB,uBAChE,AAAuB,cAAoB,iBAAQ,SAEpD,cAAkB,cAAK,OAPgD,AAAE,WAU7E,cAAsB,kBAEtB,AAAO,AAAC,+EX6sDG,yBACA,yBACC,sBAad,AAAe,cAAuB,6BAAqB,2BAC3D,AAAsB,cACpB,EACA,6BACA,kCAEF,AAAe,cAAuB,OAGtC,MAAQ,MACD,OAMA,QALI,cAAa,EAAM,qCACxB,cAAY,YACZ,cAAsB,wDAHD,IAOhB,IACH,cAAa,EAAM,qCACjB,cAAY,YACZ,cAAsB,6CAExB,cAAY,kBANQ,OAYjB,yBAGK,eACD,cAAc,mBAC7B,cAAmB,iBACnB,AAAI,iBAAe,KACjB,cAAuB,AAAC,gEAAoC,mBAE5D,cAAe,cAAsB,sBAEvC,cAAmB,oBAGJ,cAAc,UAC7B,AAAI,IACF,cAAmB,oBACH,YAChB,AAAI,iBAAgB,KAClB,cAAuB,AAAC,gEAAqC,mBAE7D,cAAe,cAAsB,sBAEvC,cAAyB,cAAU,iBACnC,cAAmB,iBACZ,cAAU,EACf,cAAe,wBACf,cAAe,uCAFjB,IAKA,AAAI,cAAe,GAAuB,QAExC,cAAa,iBACb,cAAsB,kBAGtB,cAAyB,cAAU,kBAErC,cAAmB,iBACZ,cAAU,EACf,cAAe,yCADjB,sCW52EK,0DAAP,4BArBO,iBAAuB,cAA9B,4BKmiDO,AAAyB,iBAAU,eAA1C,kChBu2Ba,sBACb,AAA0B,OACf,yBACM,yBAEK,sBACtB,AAAI,IACF,AAAkB,IAClB,AAAI,6BAAuB,UAA2B,EAAe,MAErE,AAAO,cAAuB,cAAiB,cAAY,OAC3D,AAAI,AAAC,cAAiB,EAAM,oBAAa,cAAS,MAClD,AAAI,cAAe,EAAM,mBAAa,cAAS,MAC/C,AAAI,6BAAuB,SAA4B,iBAAwB,SAC7E,cAAS,SAEN,AAAI,EAAc,MACvB,cACE,GACA,6BAAiB,eAAQ,oCAE3B,cAAmB,iBACZ,4BAAP,KAIF,cAAS,EAAoB,OAG7B,AAAI,sBACsB,GAAO,kDACxB,IACH,iBAAoB,MAClB,cAAa,EAAM,qCAAE,SAAM,cAAU,iDACrC,cAAU,cAAmB,EAAG,OAClC,cAAU,iCAJd,IAQK,IACH,iBAAoB,MAClB,cAAa,EAAM,qCAAE,SAAM,+CAC3B,cAAc,OAChB,+BAJJ,qFgB12BA,AAAW,cAAuB,mBAClC,AAAW,AAAc,mBACzB,AAAU,IACN,AACE,iBAAU,EAAM,EAAM,IAAW,kBAAkB,GAAG,KAExD,AACE,iBAAU,EAAM,EAAM,IAAW,kBAAkB,GAAG,OAE5D,AAAe,IACR,aAAP,+BA5TA,AAAI,mBACF,AAAW,AAAoC,MAC/C,AAAO,EAAQ,SAAe,EAAQ,uBAC/B,cAAU,eAAsB,qCAAE,mBAAS,kBAAlD,IAEK,aAAP,4BA4IA,AAAI,IAAa,uBACf,AAAQ,cAAa,QAEhB,AAA2B,iBAAU,EAAO,eAAnD,2KCuhBO,iBAAc,cAArB,4BD/qBO,AAA2B,iBAAU,EAAO,eAAnD,oChB0qCa,yBACD,sBACZ,AAAe,mBAGf,AAAe,cAAuB,6BAAqB,eACzD,OAIF,AAAI,AAAC,KAAiB,cAAY,iBAAnB,OAGC,yBACA,cAAuB,uBACvC,AAAqB,sBACR,EAAyB,EAAI,WAC1C,cAAO,EAAK,cAAiB,EAAgB,EAAU,QAIvD,AAAiB,IACjB,AAAmB,IACnB,AAAY,mBACP,AAAQ,MAAG,EAAI,UACN,cAAM,UAClB,AAAI,mBACF,AAAe,IACf,GAEF,cAAO,WAAgB,cAAU,GAAO,eAAK,gIAC3C,cAAc,EACZ,cAAiB,EAAgB,MACjC,cAAuB,GAAO,yDAAc,eAC1C,iBAVsB,AAAE,WAiBhC,cAAO,EAAc,cAAU,EAAgB,QACpC,eAAgB,qHACvB,gBAAS,6CAIb,AAAmB,cAAa,gBAAS,kCAAS,cAAQ,QAC1D,AAAmC,IACnC,AAA4C,IACvC,AAAQ,MAAG,EAAI,QACN,cAAM,aACD,sBACjB,AAAoB,sBAGJ,cAAqC,EAA+B,UACpF,AAAI,IAAiB,cAAsB,kBAC3C,cAAmB,oBACF,gBAAS,2BAC1B,cAAuB,iBAEvB,AAAa,EAAK,EAAW,SACb,IAAS,MAAoB,EAAI,gBAAK,6HAC1C,EAAyB,EAAI,WACzC,cAAM,EAAK,KACX,AAAY,IACZ,AAA2B,IACtB,AAAQ,QAAG,EAAI,KAClB,AAAW,cAAsB,cAAW,sBAC5C,AAAI,AAAgB,KAAS,KAC3B,cAAM,WAAW,MAEnB,AAAI,cAAgB,GAAuB,QACzC,AAAuB,IACvB,GAP+B,AAAE,YAUrC,cAAe,QACG,IAAuB,GAAY,QACrD,AAAqB,cAAgB,EAAmB,SACxD,cAAgB,EAAmB,OAGnC,AAAI,OAAmB,IAAU,SAC/B,AAAI,IAA0B,cAA6C,cAA0B,qBACrE,SAG3B,AAAI,AAAC,KACV,cAA2B,mBAG7B,cAAmB,iBACnB,AAAe,cAAa,cAAW,cAAO,QA5ClB,AAAE,WA8ChC,cAA8B,KAG9B,AAAI,EAAgB,KAClB,AAAI,IAA0B,cAAkB,kBAC3C,cAAc,QAGd,AAAI,IACT,cAAsB,mBAGxB,cAAmB,iBACZ,cAAP,4BgBt5CA,AAAU,mBACV,AAAiC,EAAK,IAC/B,AAAwB,iBAAU,eAAzC,4BAIA,AAAU,mBACV,AAAiC,EAAK,IAC/B,AAAwB,iBAAU,eAAzC,4BTvvCO,AAAS,iBAAiB,iBAAjC,6BS2vCA,AAAO,iBAAgB,qBACvB,AAAU,mBACL,AAAQ,MAAG,EAAI,KAClB,AAAsB,EAAM,GAAG,AAAU,cAAM,QADzB,AAAE,WAG1B,AAAgC,EAAK,IAC9B,AAAwB,iBAAU,eAAzC,6BA+wEF,sDAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OACA,OACA,OACA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,cA5CqB,cAAP,KAEO,cAAP,KAEE,AACnB,AAAI,mBAA0B,GACvB,iBAAa,MAAK,IAAc,eAAvC,IAEwB,cAAP,IACO,cAAP,IACQ,cAAP,IAEX,AAAmC,GAAkB,cAAQ,mBAD/C,IAId,AAAmC,GAAoB,cAAQ,mBAD/C,IAIhB,AAAmC,GAAiB,cAAQ,mBAD/C,IAIb,AAAmC,GAAgB,cAAQ,mBAD/C,IAIZ,AAAmC,GAAoB,cAAQ,mBAD/C,IAIhB,AAAmC,GAAmB,cAAQ,mBAD/C,IAIf,AAAmC,GAAiB,cAAQ,mBAD/C,IAIb,AAAmC,GAAoB,cAAQ,mBAD/C,IAIhB,AAAmC,GAA4B,cAAQ,mBADlD,IAIrB,AAAmC,GAA6B,cAAQ,mBADlD,IAItB,AAAmC,GAA4B,cAAQ,mBADlD,IAGV,AAAO,qBAEtB,aAAP,i0DAKA,YAAQ,qBACD,OACA,OACA,OACA,OACA,UAFoB,cAAP,KAEQ,cAAP,IAEd,cAAP,oEIziHS,AACI,iBAAkB,EAAiB,IAAe,2LJ8vG/D,AAAI,AAAC,KAAa,aAAP,IACX,AAAU,mBACV,AAAU,AAAiB,EAAO,OAClC,AAAU,IACL,AAAQ,MAAG,EAAI,KAClB,AAAU,AAAU,cAAK,OACzB,AAAqB,EAAK,KAC1B,EAAO,KAHgB,AAAE,WAKpB,aAAP,iCAuSA,AAAI,EAAQ,MAAkB,eAAP,IACvB,AAAc,AAAmB,mBACjC,AAAI,IAAgB,cAAP,IAEb,AAAO,AAAC,cAAQ,yBAGhB,AAAI,AAAU,qBAAiB,cAAP,IAGxB,AAAI,cAAS,mBACX,AAAI,IAGG,AAAwB,cAAS,6BAAxC,IAGF,AAAI,OAOiB,sBACrB,AAAI,OAES,sBACX,AAA2B,IAC3B,AAAI,IAAM,AAAU,AAAY,EAAS,cAAM,mCAG/C,AAAY,AAA6B,MACzC,AAA0B,EAAS,IACnC,AAAI,IAGJ,AAAkB,AAAqC,EAAS,MAChE,AAAU,AAAoC,EAAS,EAAa,MACpE,cAAS,cAAM,SAGE,eACC,eACE,eACN,sBACd,AAAI,IACG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACxD,cAAQ,UACrB,AAAI,iBAAe,KAA+B,MAEnC,AAAC,yDAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,MACpB,sBAChB,AAAI,IAGJ,AAAI,cAAa,QACf,cACE,AACE,EACA,AACE,AAAY,EAAS,cAAM,kCAE7B,SAIJ,cAAgB,AAAY,EAAS,cAAM,sBAE7C,cAAiB,AAAoB,qBACrC,cAAmB,OAxBqD,AAAE,YA2B9E,AAAa,AAAc,mBAC3B,AAAa,AAAc,mBAC3B,AAAa,AAAc,mBAC3B,AAAI,IAGJ,AAAmC,EAAS,EAAO,EAAQ,EAAQ,EAAQ,mBAC3E,AAAI,IACF,AAAI,IAGJ,AAAgC,EAAS,EAAO,AAAkC,OAEpF,AAAe,IACf,AAAe,IACf,AAAe,IACR,cAAP,OAIuB,sBACzB,AAAI,IAGF,AAAY,AAA6B,MACzC,AAA0B,EAAS,IACnC,AAAkB,AAChB,EACA,AAAqC,EAAS,IAC9C,MAEF,cAAS,cAAM,SAEE,eACC,eACG,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,QAC7B,cAAe,UAC/B,AAAI,cAAa,QACf,cACE,AACE,EACA,AACE,AAAY,EAAS,cAAM,kCAE7B,SAIJ,cAAgB,AAAY,EAAS,cAAM,sBAbG,AAAE,cAgBnC,sBACjB,cACE,EAAc,MACV,IACA,cAAc,QACZ,AACE,EACA,AACE,AAAY,EAAS,cAAM,kCAE7B,KAEF,AAAY,EAAS,cAAM,uBAGnC,AAAI,iBAAoB,KACtB,AAAa,AAAc,mBAC3B,AAAgB,AAAsC,EAAS,EAAQ,qBACvE,AAAe,KAEf,AAAgB,mBAAoB,cAAW,MAAK,OAGtD,AAAI,iBAAqB,KACvB,AAAa,AAAc,mBAC3B,AAAiB,AAAsC,EAAS,EAAQ,qBACxE,AAAe,KAEf,AAAiB,cAAY,QAE/B,AAAI,IAGJ,AAAsC,EAAS,EAAO,EAAe,IAC9D,cAAP,IAGc,gBAA4B,0WA3T5C,AAAI,EAAQ,MAAkB,eAAP,IACvB,AAAc,AAAmB,mBACjC,AAAI,IAAgB,cAAP,OAIM,UACZ,sBAGP,AAAI,AAAU,qBACL,AACL,AAAkC,IAClC,cAAgB,oBAFlB,IAOE,GAAY,AAEP,EAAmB,IAE5B,AAAO,EAAqC,sBAC5C,AAAc,AAA4B,SAC/B,UACX,AAAY,EAAS,cAAM,kBAC3B,AAAW,AAA6B,MACxC,AAAU,AAAiB,AAAI,EAAI,KAAM,cACzC,AAAI,AAAC,AAAqC,EAAS,EAAK,EAAK,EAAM,QACjE,AAAiB,AAAoB,MACrC,AAAkB,AAAoB,EAAM,OAC5C,AAAe,IACC,GAA+B,eAAe,AAAgC,+HAI3F,GAAY,KAAS,gCAAW,IAAO,qBAAc,EAAI,QAC7C,cAAM,UACrB,AAAO,AAAC,cAAY,yBACpB,AAAe,AAAiC,EAAM,EAAI,QAC1D,AAAe,AAAmC,EAAU,MAC5D,AAAO,AAAC,oCACR,cAAe,KACf,AAAI,OAGgB,sBACpB,AAAI,OACW,qCACb,AAAoC,iBAAY,EAAU,cAAyB,qCACrE,sBACd,AAAI,IACF,AAAsB,AAAyC,MAC/D,AAAuB,IAClB,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACxD,cAAQ,UACrB,AAAI,iBAAe,KAA+B,MAEnC,AAAC,yDAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,GACpC,AAAqC,iBAAY,EAAU,WAAoB,cAAyB,mCANhC,AAAE,WAQ5E,AAAO,EAAmB,uBA1BiC,AAAE,WA8BnE,AAAe,IAGf,AAAI,IAGJ,AAAU,AAAO,0CACV,AACL,AAAkC,IAClC,cAAgB,oBAFlB,6BDtjGE,sDAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,OAGA,cAzCqB,cAAP,KAEE,AAAI,iBAAa,MAAW,cAAP,MAEf,cAAP,IACO,cAAP,IACO,cAAP,IACO,cAAP,IAEX,AAAmC,GAAkB,cAAQ,mBAD/C,IAId,AAAmC,GAAoB,cAAQ,mBAD/C,IAIhB,AAAmC,GAAiB,cAAQ,mBAD/C,IAIb,AAAmC,GAAgB,cAAQ,mBAD/C,IAIZ,AAAmC,GAAoB,cAAQ,mBAD/C,IAIhB,AAAmC,GAAmB,cAAQ,mBAD/C,IAIf,AAAmC,GAAiB,cAAQ,mBAD/C,IAIb,AAAmC,GAAoB,cAAQ,mBAD/C,IAIhB,AAAmC,GAA4B,cAAQ,mBADlD,IAIrB,AAAmC,GAA6B,cAAQ,mBADlD,IAItB,AAAmC,GAA4B,cAAQ,mBADlD,IAGH,cAAP,IAGtB,AAAO,oBACA,AAAW,4BAAlB,4BCuwBO,AAA0B,iBAAU,eAA3C,4BAqpBO,AAAyB,iBAAU,eAA1C,wChB4kPa,sBACb,sDAAQ,qBAED,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,QA5BI,AAAO,4BAOU,cAAW,gBAAlB,KAEE,AAAI,iBAAa,MAAW,cAAW,gBAAlB,MAEhB,cAAW,kBAAlB,IACO,cAAW,mBAAlB,IACO,cAAW,uBAAlB,IACQ,cAAY,6BAAnB,aAYX,cAAgB,+BAFK,IAIR,AACpB,AAAI,cAAQ,QAA4B,cAAgB,+BAAvB,IAC1B,cAAe,cAAW,mBAAjC,oCAmWU,yBACM,sBACpB,AAAI,AAAC,QAAiB,AAAC,cAAqB,uBAAuB,2CAAP,OAEvC,sBAErB,AAAI,IACF,AAAa,cAAuB,cAAS,6BAAqB,QAElE,AAAa,cAAc,mCAGtB,cAAqB,EAAY,4BAAxC,kCAjvOW,sBAGX,cAAS,EAAmB,UAEhB,eACA,sBACZ,AAAiC,IACjC,AAAI,iBAAc,QACF,AAAC,yDACf,AAAI,sBAA0B,cAAQ,YAExC,cACE,cAAe,cAAS,qBAEnB,6BAAoB,mCAA3B,qCAQA,cACE,GACA,6BACA,uBAEK,2CAAP,qOqBl6EA,cAAoB,EAAM,EAA4B,cAAO,EAAM,cAAM,cAAM,yDVE7D,EAAU,cAAM,EAAI,cAAM,+CACzB,sBACnB,AAAI,AAAC,KAAc,iBAAmC,4BACjD,AAAI,cAAiB,mBACxB,6BACE,GACA,6BAAuB,uBAG3B,cAAgB,QAChB,cAAiB,cAAM,kBAChB,aAAP,snBAoCmB,GAAO,kDAC1B,AAAO,cAAiB,sCACZ,GAAO,cAAiB,kDACpC,AAAO,iBAAe,qBACtB,cAAoB,gEU3ZR,EAAU,iBAAU,yBAChC,cAAe,gCACR,aAAP,4BN+JO,cAAQ,gBAAf,6BHitGA,AAAO,mCACP,cAAY,iBACZ,cAAyB,KACzB,cAA4B,KAC5B,cAAS,EAAoB,MAAsB,4CAKnD,AAAO,mCACP,cAAY,iBACZ,cAAyB,KACzB,cAA0B,KAC1B,cAAS,EAAoB,MAAsB,2CK7vDb,AAAC,iBAAa,GAAS,cAA9B,wCN9yCZ,sBACnB,AAAI,IAAgB,cAAiB,uBAAc,GAAO,cAAiB,wDAA/B,IACrC,aAAP,oCMouCO,6BAAqB,4BAA5B,kCN/tCkB,cAAkB,sBACpC,cAAmB,iBACnB,cAA2B,AAAmB,cAAM,6BAAoB,yBACrD,sBACnB,AAAI,AAAC,KAAc,iBAAmC,4BACjD,AAAO,AAAC,cAAiB,qCAC9B,cAAgB,QAChB,cAAiB,cAAM,kBAChB,aAAP,4BK6nCA,AAAI,EAAQ,KAAI,AAAO,AAAoC,OAC3D,AAAI,IAAa,uBACf,AAAQ,cAAa,QAEhB,AAA2B,iBAAU,EAAO,EAAO,eAA1D,gDANgB,0EhBktIH,yBACF,yBACA,sBACX,AAAO,EAAQ,sBACf,AAAiB,mBAEjB,AAAI,mBACF,AAAI,AAAC,uBAAiC,cAAe,EAAW,oBAAO,cAAkB,EAAY,MAChG,cAAoB,EAAY,OAEvC,cAAkB,EAAY,KAC9B,AAAI,mBACF,AAAI,AAAC,cAAiB,EAAW,oBAAO,cAAkB,EAAY,MACjE,cAAoB,EAAY,OAEvC,AAAI,IACF,cAAmB,iBACZ,cAAiB,EAAY,EAAW,sCAA/C,IAEA,cAAmB,kBACZ,cAAiB,EAAY,EAAW,+BAA/C,sCAr7FW,yBACM,sBACnB,AAAsB,sBACX,yBACQ,eACJ,sBAEV,AAAQ,MAAG,EAAI,UACA,cAAa,aACpB,qCACX,AAAwB,IACxB,AAA8B,IAC9B,AAA4B,IAE5B,AAAI,cAAe,SACjB,cACE,GACA,yDAKW,yBACO,sBACtB,AAAI,OACK,cACL,cACA,6BACA,AAAS,2DAEX,AAAI,AAAC,KAAM,GACX,6BAAgC,cAAM,kBAEtC,AAAI,OACoB,yBACV,cAAyB,cAAM,cAAM,sBACjD,cAAoB,kBACpB,AAAW,cAAuB,cAAiB,cACjD,UAES,sBACX,cAAuB,kBACvB,cAA0B,mBAIvB,AAAI,OACa,yBACX,cAAyB,cAAM,eAAW,sBACrD,cAAoB,kBACpB,AAAW,cAAuB,cAAiB,8BACxC,sBACX,cAAuB,kBACvB,cAA0B,iBAE1B,AAAI,iBAAoB,MACtB,cACE,GACA,6BAAmB,8CAA6B,qBAElD,MAEK,QAIP,cACE,GACA,oEAEF,IAIF,AAAc,cAAe,OAC7B,AAAe,IACf,AAAI,IACF,AAAI,IACF,AAAc,cAAqB,EAAU,WAC7C,AAAI,IACF,AAAW,IACX,AAA0B,IAC1B,UAAQ,AAAuB,SACxB,QAWA,QAWA,QAKA,SA3BkB,GACb,EAAU,cAAM,EAAI,cAAM,4CAClC,cACE,EACE,AAAiB,OACjB,iBAEF,iBAEF,GAEqB,GACb,EAAU,cAAM,EAAI,cAAM,4CAClC,cACE,EACE,AAAoB,OACpB,AAAqB,oBAEvB,iBAEF,GAEqB,GACb,EAAU,cAAM,EAAI,cAAM,4CAClC,cAA4B,AAAsB,MAAW,iBAC7D,GAEqB,GACb,EAAU,cAAM,EAAI,cAAM,4CAClC,cAA4B,AAAiB,KAAW,iBACxD,GAGJ,AAAI,OAEiB,sBACnB,AAAI,AAAC,KAAc,iBAAmC,4BACjD,AAAI,cAAiB,sBACT,GAAO,cAAiB,kDACvC,cACE,GACA,4CACA,2DACA,qBAEK,4CAAP,KAEF,cAAiB,cAAM,kBACvB,AAAW,OAIf,cACE,GACA,wCAMN,AAAI,AAAC,KAEH,AACE,cAAkB,EAAkB,WACpC,uBAEoB,cAAoB,sBACxC,AAAI,IACF,AAAI,AAAC,iEACH,cACE,GACA,4CACA,2DACA,sBAGF,cACE,GACA,4CAAwB,yBAGpB,WAEA,cAAoB,cAAM,uBAEpC,AAAI,IAAS,cAAkB,iBAAa,UAE7B,cAAiB,sBAChC,AAAI,IACF,cACE,GACA,4CACA,2DACA,qBAEF,MAEM,6BAA6B,cAAM,cAAM,sBACjD,cAAoB,iBAAa,AAAC,QAClC,AAAI,IAAS,cAAkB,iBAAa,OAE9C,AAAI,IACF,cACE,cAAyB,cAAO,EAAU,IAAW,GAAW,eAAM,UAIxE,AAAI,kCACF,cAAkB,iBAAa,SAxLF,AAAE,WA6LvC,cAAmB,kBACZ,iBAAuB,KAC1B,GACA,cAAe,qCAFnB,oCAQO,cAAuB,6BAAsB,eAClD,EAA2B,iBAD7B,oCAgBa,yBACG,sBAChB,AAAsB,iDAkBtB,AAAe,cAAuB,6BAAqB,2BAC3D,AAAsB,cAAmB,EAAU,6BAAkB,kCACrE,AAAe,cAAuB,OAGtC,AAAI,EAAY,KACP,cAAY,iBAAnB,OAIa,cAAmB,EAAgC,iBAClE,AAAY,sBACK,gBAAe,2BAChC,cAAsB,oBACF,gBAAkB,2BACtC,cAAyB,iBACzB,cAAmB,oBACH,eACL,sBACX,AAAI,iBAAa,KACf,cAAuB,AAAC,gEAAkC,mBAE1D,cAAe,cAAsB,sBAEvC,cACE,cAAU,yBAEZ,cAA6B,KAE7B,AAAwB,cAAe,EAAsB,SAC7D,AAAqB,cAAe,EAAmB,SACvD,AAA2B,AAAC,cAAe,GAAuB,SAKlE,AAAoB,OAAqB,KACzC,AAAI,IAAiB,cAAgC,cAAU,WAC7D,cAAmB,iBACZ,cAA6B,6BAApC,IAIF,AAAuB,IACvB,AAAI,EAAY,KACd,cAAkB,iBAGlB,AAAI,AAAC,KACH,AAAmB,IACnB,cAAc,WAKD,cAAmB,UAClC,AAAI,AAAC,KAAwB,AAAC,SAE5B,cAAkB,iBAClB,cAA2B,kBAG3B,cAA8B,cAAU,mBAK5C,cAAmB,oBACU,qCAC3B,cAAY,cACV,cAAU,EACR,cAAe,0CAIrB,AAAI,IAAkB,cAAW,sBAC1B,cAAa,cAAY,oCAAhC,4BAvGO,cAA6B,4BAApC,4BgBzIA,AAAW,AAAY,mBACvB,AAAU,AAA6C,iBAAU,MACjE,AAAe,IACR,aAAP,4KhB0rNqB,wCACR,sBACb,AAAI,iBAAwB,KAAG,cAAwB,6BAA6B,oCACpF,cAAqB,KACrB,6BAAmC,4DA7gPtB,sBAEb,wCAAQ,qBACD,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAKA,OAIA,OAIA,OAUA,QA3EgB,AACnB,AAAO,cAA2B,sDAClC,GAEmB,AACnB,AAAO,cAA2B,sDAClC,GAEsB,AACtB,AAAO,cAA8B,uDACrC,GAEgB,AAChB,AAAO,cAAwB,sDAC/B,GAEmB,AACnB,AAAO,cAA2B,sDAClC,GAEwB,AACxB,AAAO,cAAgC,uDACvC,GAEiB,AACjB,AAAO,cAAyB,sDAChC,GAEmB,AACnB,AAAO,cAA2B,sDAClC,GAEgB,AAChB,AAAO,cAAwB,sDAC/B,GAEoB,AACpB,AAAO,cAA4B,sDACnC,GAEoB,AACpB,AAAO,cAA4B,sDACnC,GAEmB,AACnB,AAAO,cAA2B,sDAClC,GAEiB,AACjB,AAAO,cAAyB,sDAChC,GAEsB,AACtB,AAAO,cAA8B,uDACrC,AAAI,AAAC,KAAM,AAAO,oBAClB,GAEkB,AAClB,AAAO,cAA0B,sDACjC,GAEmB,AACnB,AAAO,cAA2B,sDAClC,GAE6B,AAE7B,cACE,GACA,6BACA,uBAEF,AAAO,mBACP,GAEoB,AACpB,AAAO,mBACP,GAEO,AACP,AAAO,oBACP,AAAO,oBAGX,AAAI,kCAAwB,cAAsB,EAAM,iCACjD,cAAP,+BAUA,AAAoB,mBACpB,AAAI,AAAC,QACK,EAAyB,UACjC,cAAe,SAEN,sBACN,AAAQ,QAAG,EAAI,KAClB,AAAW,cAAsB,cAAW,sBAC5C,QAAQ,AAAgB,SACjB,OAQA,QARoB,AACnB,AAAC,AAAa,sBACX,AAAe,IAAO,AAAmB,SAAO,EAAI,KAAQ,cAAW,AAAgB,EAAM,SAAtC,AAAE,WAC9D,IAIK,cAAW,QAGtB,AAAI,cAAW,GAAuB,QAAmB,GAbxB,AAAE,YAe9B,aAAP,oCYs5CO,AAAC,GAAqB,2EAA7B,4BZlzGO,iBAAe,MAAgB,IAAc,eAApD,kCYy1CgB,GAAmB,cAAa,cAAM,6CACvC,6BAA8B,cAAW,+BACxD,AAAI,AAAC,KAA0B,gBAAsC,8BAC9D,aAAP,kCA7+Ba,sBACb,AAAI,AAAC,KAAQ,iBAA+B,cAAqB,2CAC1D,aAAP,kCAsBa,sBACb,AAAI,AAAC,KAAQ,iBAA6B,cAAqB,2CACxD,aAAP,kCZwtSc,sBACd,AAAO,iBAAyB,yBACnB,yBACC,sBACd,cAAmB,gCACnB,AAAI,cAA2B,WACT,sBACpB,cAAqB,oBACd,cAAY,6BAA4B,qCAC7C,mBACI,cAAW,uBACX,cAAW,sCACd,iCAJH,OAMkB,sBAClB,cAAqB,oBACd,cAAY,6BAA0B,qCAC3C,mBACI,cAAW,uBACX,cAAW,4BACf,cAAW,qCACV,iCALH,oCAcW,yBACG,sBAChB,AAAmB,mBACnB,AAAO,EAAgB,oDAChB,cACL,cAAa,EAAgB,MAAc,GAAiB,GAC1D,cAAiB,EAAW,QAE9B,cAAiB,EACf,cAAoB,iBACpB,mDANJ,yKYt9LuB,sBACvB,AAAI,IAAyB,4BAAP,IACf,aAAP,wnBQjmHO,AACO,EAAW,EAAU,EAAO,gJT3K/B,EAAS,cAAgB,sBACpC,cAAyB,GAAG,yBAAwC,0KACpE,AAAI,cAAkB,SACpB,kBAEF,AAAI,+CAAqD,KACvD,cAAS,QAEJ,aAAP,kCAiOmB,sBACnB,AAAI,AAAC,KACH,iBAAmC,4BAC9B,AAAI,cAAiB,sBACN,GAAO,cAAiB,kDAC5C,AAAI,IACF,AAAI,AAAC,iEACH,6BACE,GACA,6BACA,2DACA,sBAGF,6BACE,GACA,6BAAkB,uBAIjB,aAAP,KAEF,AAAO,EAAQ,qEACG,EAAU,cAAM,EAAO,cAAM,4CAC/C,cAAgB,QAChB,cAAiB,cAAM,kBAChB,aAAP,wCA8FiB,sBACjB,AAAI,EAAc,KAAQ,cAAe,uBAChC,AAAC,AAAuB,cAAe,iBAAU,GAAS,cAAjE,IAEK,aAAP,8BU5LA,cAAoB,EAAM,EAA6B,cAAO,EAAM,cAAM,cAAM,yDrBwvQlE,sBACd,AAAI,IACG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACvD,cAAQ,UACtB,AAAI,iBAAgB,QAAiC,iBAAkB,MAAe,MAEvE,AAAC,0DAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,GACpC,AAAI,AAAC,oBAA4B,AAAC,cAAqB,cAAU,YAC/D,AAAI,AAAC,cAAY,UACf,AAAI,IACF,cACE,GACA,2DACA,6BACA,qCAGF,cACE,GACA,2DACA,uCAID,AAAI,cAAY,SACrB,AAAI,kCACF,cACE,GACA,4CACA,qCAGF,cACE,GACA,yDAjCkE,AAAE,sDA39EjE,sBACb,AAAmB,IAAW,kBAAkB,QAChC,yBACK,sBACrB,AAAoB,sBAGD,yBACR,AAAkB,6BAA6B,yBAC/C,mBAEX,AAAI,OACW,GAAO,kDACpB,AAAO,iBAAe,wBACF,6CACL,GAAO,oEACN,cAAoB,cAAmB,sBACvD,cACE,cAAiB,iBAAiB,EAAS,wBAE7C,cAAkB,iBAAiB,QACxB,sBACX,AAAI,IAAM,cAAoB,cAAoB,6BAAW,iBWtvLc,QXwvL3E,AAAO,AAAC,oDAEL,AAAQ,MAAG,EAAI,KAClB,AAAgB,8CAAU,UACV,cAAe,aACX,cAAoB,cAA0B,iBAAI,sBAEtE,AAAI,AAAC,cAAyB,EAAW,oBAAY,cAAkB,iBAAqB,MAC5F,AAAI,cAAe,EAAW,mBAAY,cAAkB,iBAAqB,MACjF,cACE,cAAiB,iBAAqB,EAAW,wBAEnD,cAAkB,iBAAqB,KAVP,AAAE,WAepC,cAAmB,iBACnB,AAAoB,cAAY,SAChC,AAAI,IAAe,cAAS,QACvB,AAAQ,MAAc,EAAI,QACd,cAAe,UAC9B,AAAe,cACb,GAAO,2DAA+C,4DACtD,cACA,UAEkB,cAAoB,cAA0B,iBAAI,sBACtE,cACE,cAAyB,cAAe,EAAU,cAAU,SATlB,AAAE,WAYhD,cAAW,OAGX,cAAyB,cAAU,kBAGnC,AAAI,OACW,sBACb,AAAO,iBAAe,qBACtB,cAAoC,iDAAe,cAu5EqC,SAn5EzE,sBACjB,cAAmB,iBAGnB,cAAmB,iBACZ,cAAa,6BAAwB,cAAM,gCAAlD,4KiBl+KA,UAAQ,qBACD,OAQA,OACA,OACA,QAVkB,AACrB,QAAQ,AAAC,GAAoC,qDACtC,OACA,OACA,UAA2B,aAAP,IAE3B,KAI0B,aAAP,IAEhB,aAAP,uCQiJqB,cAAuB,qCAC5C,AAAI,IAAuB,aAAP,IACb,aAAP,+BAmvBA,UAAQ,qBACD,OACA,OAoBA,OAGA,SAvBsB,GACd,cACT,GAAO,yDACP,6BACA,6BACA,UAEF,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,IAAgB,aAAP,IACb,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,uCAGhB,cAA6B,KAC7B,cAAgC,KACzB,aAAP,IAGO,cAAsB,6BAAiB,cAAS,cAAS,gBADtC,IAGF,AAQxB,cACE,GACA,6BACA,uBAEK,aAAP,IAGJ,AAAO,oBACA,aAAP,ioCb4uDO,AAAC,GAAkC,2EAA1C,wCAzgBuB,YAEX,sBACV,AAAI,iBAAgB,KAAyB,gDAAP,IAC/B,kCatpDT,AAAI,cAAU,UAA8B,aAAP,OACtB,yBACJ,IACP,cAAiB,cAAU,6BAAe,EAAM,MAChD,cACE,GAAO,yDACP,2DACA,eACA,WAEN,AAAI,AAAC,KAAa,aAAP,IACX,cAAe,iBACR,aAAP,4Bbq0DK,eAAkB,gBAAzB,+BantEE,AAAW,mBACX,AAAI,EAAQ,KACV,AAAI,AAAC,cAA8B,iDAAiB,QAA4B,aAAP,KAE3E,AAAI,AAAe,UACN,AAAC,4DACS,cAAuB,qCAC5C,AAAI,OACgB,sBAClB,AAAI,OAAoB,SAEnB,aAAP,IAEK,aAAP,+BAkzBA,YAAQ,qBACD,OACA,OAQA,OAIA,SAXI,cACL,GAAO,yDACP,6BACA,6BACA,gBALuB,IAQC,GACf,cAAuB,6BAAiB,cAAS,cAAS,UAC9D,IAAO,kBAAuB,cAArC,IAEwB,GACV,cAAsB,cAAM,cAAS,cAAS,UAC5D,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,IAEO,AAAO,qBAEX,aAAP,+BA4rCA,AAA2C,IAG3C,AAAI,cAAa,SAGf,AAAI,cAAa,YACK,GAAO,qDACF,sBACzB,AAAI,OACuB,GAAO,iEAChC,AAA4B,mBAC5B,AAAO,EAAyB,oCAC3B,AAAQ,MAAG,EAAI,KAClB,cACE,cAAmB,+CACnB,cAAmB,qBAHoB,AAAE,gBASzB,cACtB,GAAO,yDACP,cACA,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAA8B,aAAP,KAI5B,AAAI,IAAqB,iBAA2B,SAClD,AAAI,EAAc,KAChB,cACE,GACA,6BAAkB,qCAGf,aAAP,KAKG,cACL,cACA,cACA,cACA,gBAJF,+BRrpEA,AAAI,iBAAa,QACK,GAAoC,uCACxD,AAAI,AAAC,sCACqB,sBACxB,AAAI,IAAqB,iBAA2B,SAC7C,AAAQ,IAAO,qBAA0B,EAAI,KAChD,AAAI,cAAkB,iBAAuB,mBAA4B,aAAP,IADf,AAAE,eAI5C,oDACN,AAAQ,IAAO,qBAA2B,EAAI,KACjD,AAAI,cAAmB,+CAAgB,mBAAa,aAAP,IADO,AAAE,cAKvD,AAAI,iBAAa,QACC,GAAuC,0CACzC,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,cAAe,gCAA4B,mBAA4B,aAAP,IADpB,AAAE,WAGpD,AAAI,6BAAgD,mBAA4B,aAAP,OAClD,sBACvB,AAAI,IAAoB,cAAqC,uBAA4B,aAAP,KAElF,AAAO,sBAEF,aAAP,wDQ9QyB,+FAoPzB,AAAI,iBAAa,QACK,6CACI,sBACxB,AAAI,IAAqB,iBAA2B,YAC7B,sBACrB,AAAI,OACmB,cAAqB,6BAAoB,6BAC9D,AAAI,AAAC,QAAkB,iBAAuB,gBAA4B,EAC1E,AAAI,iBAA4B,2CACV,sBACpB,AAAI,IAAiB,iBAAwB,wBACtC,AAAQ,IAAO,qBAAsB,EAAI,KAC5C,cACE,cAAkB,iBAClB,cAAc,iBACd,cACA,cACA,iBAN6C,AAAE,qBASnD,QAKK,oDACX,AAAI,cAAa,sBACG,GAAO,cAAa,kDACtC,AACE,EAAe,SACd,cAAuB,mBAAS,cAA2B,0BAC5D,cAAa,cAAM,sBAGpB,AAAI,iBAAa,QACC,6CACF,yBACI,sBACzB,AAAI,OACmB,sBAChB,AAAQ,IAAO,AAAI,mBAAuB,6BAAyB,EAAI,KAC1E,cACE,cAAe,gCACf,cAAe,iBACf,cACA,cACA,iBAN2E,AAAE,cAShE,sBACjB,AAAI,EAAc,MAChB,cACE,6BACA,cACA,cACA,cACA,qBAGW,yBACQ,sBACvB,AAAI,IAAY,QACd,cACE,cACA,cACA,cACA,cACA,4BAGJ,+CArNgB,sBAGpB,AAAI,IACF,AAAI,AAAC,cAAa,UAChB,AAAI,EAAc,KAChB,cACE,GACA,4CAAuB,qCAGpB,cAAP,IAEK,cACL,cACA,cACA,6BACA,AAAS,4CACT,cACA,iBANF,IAWF,AAAI,cAAa,YACe,AAAS,wCAGd,GAAO,kDAChC,AAAwB,sBACC,UACpB,AAAQ,MAAG,EAAI,QACP,cAAmB,wCAC9B,cAA4B,cAAM,mBAClC,cAAuB,kBAHc,AAAE,cAMpB,qCACrB,AAAoB,sBACA,sBACpB,AAAmB,mBAGd,AAAQ,MAAG,EAAI,UACO,EAAI,KACzB,cAAc,MACd,cAAe,0BACnB,AAAI,AAAC,KAEH,AAAI,cAAe,oBAAoB,KACrC,GAGF,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,mBAA0B,yBAGnC,cAAP,OAEa,cAAe,yBAC9B,AAAI,cAA6B,sBACpB,cAAuB,cAAoB,cAAS,eAAW,UAC1E,AAAI,IACF,cACE,cACA,cACA,cACA,cACA,oBA3B2B,AAAE,cAkCT,EAAgB,UACvC,AAAQ,MAAG,EAAI,UACM,cAAmB,aAChC,qCACX,AAAI,cAA4B,sBACX,GAAO,cAA4B,kDACtD,AAAI,EAAgB,MAClB,cAAsB,EAAK,iBAC3B,MAEgB,sBAClB,AAAI,OAEW,sBACb,AAAmE,IACnE,AAAI,iBAAe,QACoB,AAAC,0DACjC,AAAI,iBAAe,QACa,AAAC,8DAEd,cACxB,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAA4B,cAAP,IAC1B,cAAsB,EAAK,iBAC3B,IAKJ,AAAI,EAAc,KAChB,cACE,GACA,qEAGG,cAAP,IAtCqC,AAAE,WAwClC,cACL,cACA,cACA,AAAS,4CACT,iBAJF,IASK,cAAqB,cAAW,EAAM,iBAAW,iBAAxD,gCb00H4B,OAC5B,EACE,AAAI,iBAAqB,KAA0B,4BAAP,OAClC,sBACH,KACF,aAAP,oCa/tEuB,yBACV,cACX,cACA,cACA,cACA,UAEF,AAAI,AAAC,KAAe,cAAP,IACb,YAAQ,qBACD,OAcA,OAGA,OAaA,QA9B+B,GACV,0CAExB,AACE,6BAAkC,oBAClC,gCAAmB,SAEZ,cAAuB,6BAAU,iBAAI,cAAS,cAAS,iBAA9D,OAEqB,cAAoB,cAAM,cAAmB,cAAS,UAC7E,AAAI,AAAC,KAAyB,cAAP,OACd,QAIF,AAAC,+EADiB,IAGS,GACX,cAAqB,kDAA2B,UACvE,AAAI,AAAC,KAAyB,cAAP,OACd,QAGF,AACP,AAAI,AAAC,AAAe,uBAAc,MACd,cAAsB,AAAC,yEAC3C,AAAI,AAAC,QAAiB,iBAAsB,MAAmB,MACtD,QAGa,GACF,AAAC,iDAAkC,oDACvD,AAAI,AAAE,IAAiB,wBAAuB,MAC9B,GAAO,cAAc,qDAC9B,6BAAP,IAGJ,AAAI,EAAc,KAChB,cACE,GACA,6BAAwB,qCAGrB,cAAP,kCA6BkB,sBACX,cAAuB,cAAY,AAAO,uCAAsB,kBAAI,cAAS,cAAS,gBAA7F,kCAl/BuB,yBACN,cAAuB,cAAkB,cAAS,cAAS,UAC5E,AAAI,AAAC,KAAmB,aAAP,OACI,cAA6B,qCAClD,AAAI,IACF,KACuB,sBACrB,AAAI,IACF,cAA6B,iBAC7B,cAAgC,gCACzB,aAAP,OAEe,sBACX,MAEV,AAAI,EAAc,KAChB,cACE,GACA,6BAAwB,uCAGrB,aAAP,kCAcc,cAAmC,cAAM,cAAS,cAAS,UACzE,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,oCAonCoB,yBACF,yBACL,yBACM,cAAiB,cAAW,6BAAwB,6BAAiC,UACxG,AACE,IACA,iBAAyB,SACzB,QAAQ,iBAAa,SACrB,AAAc,yCAGD,AAAC,4DACW,GAAO,qDAEjB,AAAmB,wCACjB,sBAEjB,AAAO,gCAA4C,oCAC9C,AAAQ,IAAO,qBAAmB,EAAI,QACvB,cAAW,aAChB,6BAAkC,UAC/C,cAA6B,4CAAqB,cAAM,kBAHZ,cAKjC,cAAuB,cAAM,cAAU,cAAS,UAC7D,AAAI,IACF,cAAkC,AAChC,6BACA,6BACA,cACA,6BACA,iBACA,qCAIC,cAAP,qCbmmCA,AAAI,AAAC,QACgB,qCACnB,AAAI,IAAgB,cAAiB,uBAC5B,GAAO,cAAiB,wDAA/B,KAGG,cAAa,cAAM,gBAA1B,wCDj0Gc,cAAiB,sBAC/B,AAAI,IAAgB,aAAP,IACN,6BAA2B,cCwzGA,gBDxzGlC,+BcksBA,QAAQ,qBACD,OACA,OACA,UAAe,GACP,cAAiC,cAAM,cAAS,eAAW,cAAY,UAC3E,IAAO,cAAsB,kBAAQ,cAA5C,OAGO,sBAEX,GAAc,cAAe,0BAC3B,cAA6B,KAC7B,cAAgC,KACzB,aAAP,OAEc,sBAChB,AAAI,IACF,GAAc,cAAiB,0BAC7B,cAA6B,KAC7B,cAAgC,KACzB,aAAP,KAGJ,GAAc,cAAkB,cbqvDE,capvDhC,cAA6B,KAC7B,cAAgC,KACzB,aAAP,IAEF,GAAc,6BAAoB,0BAChC,cAA6B,KAC7B,cAAgC,KACzB,aAAP,IAEF,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,sBAGT,aAAP,+BAgBA,QAAQ,qBACD,OACA,OACA,SADuB,cAAP,IACD,GACG,sBACrB,AAAI,IACK,2CAAP,OAEyB,sBACzB,AAAI,IACK,2CAAP,IACK,AAAI,mBACF,aAAP,MAGG,0DAAP,OAGU,cAAgC,cAAM,cAAS,cAAY,UACzE,AAAI,AAAC,KAAgB,aAAP,IACd,AAAI,iBAAgB,QACH,cAAqB,iDAA4B,EAAM,iBAAW,UACjF,AAAI,AAAC,KAAiB,aAAP,OACL,WAED,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,+BA24BA,AAAI,sBACc,cAAoB,sBACpC,AAAI,IACF,cAA6B,KAC7B,cAAgC,KACzB,aAAP,QAGS,qCACb,AAAI,IACF,cAA6B,KAC7B,cAAgC,KACzB,aAAP,IAEF,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,aAAP,kCAcc,cAA0B,cAAM,cAAS,cAAS,UAChE,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,+BAcA,AAAI,sBACe,cAAoB,sBACrC,AAAI,IACF,cAA6B,KAC7B,cAAgC,KACzB,aAAP,QAGyB,qCAC7B,AAAI,IAAU,iBAAe,YAChB,AAAC,yDACZ,AAAI,IACF,cAA6B,KAC7B,cAAgC,KACzB,aAAP,KAGJ,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,aAAP,kCAcc,cAA2B,cAAM,cAAS,cAAS,UACjE,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,4BVhkEO,cAAQ,iBAAf,iCU03CA,AAAe,mBACf,AAAI,IAEF,AAAI,EAAO,EAAQ,IAAU,cAAc,iBAC7B,sBACZ,cACE,GACA,cAAO,4CAA4B,iBAAc,GAAG,wCAEjD,AAAI,EAAO,IAAU,IxCp6ChC,AAAO,EAAQ,QwCs6CT,AAAI,mBACK,iBAAgB,KACnB,IACA,eAFJ,IAGK,AAAI,AAAC,oBAEH,cAAP,OAGJ,AAAW,EAAQ,eAErB,AAAI,mBAEF,4BAAQ,qBACD,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAOA,OAOA,OACA,OACA,OACA,QA7Ce,AAClB,AAAI,EAAY,IxCv0CxB,AAAO,AAAC,EAAQ,AAAC,MAAM,QwCu0CmB,cAAP,IAC3B,GAEgB,AAChB,AAAI,EAAU,IxC/2CtB,AAAO,EAAS,OAAgB,EAAS,cwC+2CD,cAAP,IACzB,GAEgB,AAChB,AAAI,EAAU,IxCj2CtB,AAAO,EAAc,UwCi2CmB,cAAP,IACzB,GAEiB,AACjB,AAAI,EAAW,IxCj3CvB,AAAO,EAAS,OAAiB,EAAS,cwCi3CD,cAAP,IAC1B,GAEiB,AACjB,AAAI,EAAW,IxCn2CvB,AAAO,EAAc,UwCm2CoB,cAAP,IAC1B,GAEiB,AACjB,AAAI,EAAW,6BAAkB,cAAP,IAC1B,GAEiB,AACjB,AAAI,EAAW,gBAAkB,cAAP,IAC1B,GAEmB,AACnB,AAAI,AAAC,kDACH,AAAI,EAAW,6BAAkB,cAAP,IAC1B,GAEK,cAAP,IAEmB,AACnB,AAAI,AAAC,kDACH,AAAI,EAAW,gBAAkB,cAAP,IAC1B,GAEK,cAAP,IAEwB,cAAP,IACO,cAAP,IACO,cAAP,IACO,cAAP,KAIvB,AAAI,EAAW,6BAAkB,cAAP,IAC1B,AAAI,EAAW,gBAAkB,cAAP,IACnB,cAAP,kCbnhCa,sBACb,AAAI,AAAC,KAAQ,iBAAgC,cAAkB,yCACxD,aAAP,kCA1Ia,sBACb,AAAI,AAAC,KAAQ,iBAAgC,GAAgB,cAAa,eAAmB,6DACtF,aAAP,yDa0jBgB,SAES,2GbwyGzB,AAAI,EAAK,KAAU,aAAP,OACK,UACjB,cAAe,kBACf,cAAe,kBACf,IAAO,OACO,yBACA,sBACZ,AAAI,AAAC,KAAS,AAAC,SAAc,aAAP,IACtB,AAAI,IACF,AAAI,cAAe,mBAAe,aAAP,IAC3B,iBAAmB,0BAErB,AAAI,IACF,AAAI,cAAe,mBAAe,aAAP,IAC3B,iBAAmB,6DGzzHvB,AAAI,mBACF,AAAI,AAAC,oBAAkC,aAAP,IAEhC,AAAI,EAAkB,MAAa,cAAoB,yBAAmB,cAAqB,yBACtF,aAAP,OAEc,yBACC,sBACjB,AAAI,IAAa,WACA,AAAsB,cAAW,sBAChD,AAAI,OACQ,cAAQ,WAAuB,cAAS,SAAsB,iCAA6B,uBAC9F,aAAP,MAGC,AAAI,mBACF,aAAP,KAIF,AAAI,cAAqB,cAAM,OAA8B,aAAP,IACjD,AAAI,cAAoB,cAAO,OAA8B,aAAP,KACpD,aAAP,4BArSO,iBAAmB,cAA1B,iCUu/DA,cAA6B,iBAC7B,cAAgC,KAChC,gBAAQ,qBACD,OAQA,OAIA,OACA,OAGA,OAGA,OAgDA,QAnEqB,GACV,cACZ,iDACA,EACA,sBAEK,GAAO,cAA0B,wEAAxC,IAEsB,GACR,EAAW,MAAW,IAAW,SACxC,GAAO,cAA0B,wEAAxC,KAIO,4CADkB,IAIlB,4CADgB,IAGD,GACD,sBACrB,AAAI,IAAkB,iBAA4B,uCACzC,cAAsB,6BAA7B,OAGgB,AAAC,yDACnB,AAAa,sBACK,QAClB,AAAsB,IACjB,AAAQ,IAAO,MAAQ,EAAI,QACb,cAAY,UAC7B,AAAI,IACF,AAAI,iBAAmB,KAAiB,EAAS,SAC/C,AAAE,WAEgB,cAAuB,cAAY,cAAS,6BAC9D,AAAI,AAAC,KAAoB,cAAP,IAClB,AAAI,EAAe,SAAyB,QACvC,AAAI,EAAe,QACL,AAAgB,cAAa,cAAa,wBAC3D,AAAI,OAA0B,YAXH,AAAE,WAiBrC,AAAI,EAA2B,MAC7B,AAAI,EAAmB,QACP,qDAEd,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wBAGT,cAAP,KAGJ,AACE,EAAkB,KAClB,0BAEc,uBAET,GAAO,cAAkB,4CAA6B,oCAAE,uEAA/D,IAEuB,AACvB,AAAI,mBAAwB,6BAAP,IACrB,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,cAAP,IAGJ,AAAO,oBACA,cAAP,kCAcc,cAA6B,cAAM,cAAS,cAAS,UACnE,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,kCAuNc,cAAqB,6BAAe,6BAAwB,UAC1E,AAAI,AAAC,KAAgB,aAAP,IACd,AAAI,iBAAgB,KACX,cACL,iDACA,6BACA,6BACA,AAAS,4CACT,cACA,gBANF,IASF,AAAI,EAAc,KAChB,cACE,GACA,uCAGG,aAAP,kCAcc,cAAyB,cAAM,cAAS,cAAS,UAC/D,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,oCAl1CiB,yBACJ,cAAsB,cAAY,cAAS,cAAS,UACjE,AAAI,AAAC,KAAe,cAAP,OACM,qCAGnB,gBAAQ,qBACD,OACA,OACA,OAiBA,OAMA,OAiBA,OA8BA,QAxEoB,AAAI,AAAC,cAA8B,kDAAgB,QAAoB,cAAP,MAEjE,GACI,6CACf,sBACX,AAAI,EAAQ,MAAkB,cAAP,OACF,cAAuB,qCAC5C,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,4CAAqB,cAAc,oDAGhC,cAAP,OAEO,OACT,GAEkC,GACX,cAAqB,kDAA2B,UACvE,AAAI,AAAC,KAAyB,cAAP,OACd,QAGgB,GACF,6CACF,GAAO,qDACjB,wCACU,cAAuB,qCAC5C,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,4CAAqB,cAAc,qCAGhC,cAAP,OAEO,OACT,GAE+B,GACV,6CACR,sBACb,AAAO,iBAAe,wBACF,6CACI,GAAO,qDACd,cAA6B,aAC9C,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAyB,qCAGtB,cAAP,OAEe,wCACI,cAA6B,qCAClD,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,4CAAqB,cAAc,qCAGhC,cAAP,OAEO,OACT,GAEkC,GAEjB,uBACjB,AAAI,IACF,AAAI,AAAC,cAAc,cACE,cAAiB,6BAAqB,6BAAmB,EAAM,WAClF,AAAI,IAAc,cAAmB,sBAElB,sCACrB,AAAI,OAAyB,uBAC7B,GACK,AAAI,AAAC,cAAU,aAEJ,cAAiB,uBACjC,AAAI,AAAC,QACoB,cAAqB,mDAA2B,EAAM,iBAAW,WACxF,AAAI,OACY,6BAAwC,sCACtD,AAAI,OAAkB,YAI5B,GAKJ,YAAQ,qBACD,OACA,OACA,OACA,WAAuB,AAC1B,OACe,cAAiB,uBAC9B,AAAI,IACF,AAAI,iBAAe,QACM,cAAqB,mDAA2B,WACvE,AAAI,AAAC,KAAyB,cAAP,OACd,QACT,AAAI,cAAoB,OACtB,cAA6B,MAE7B,cAA6B,mBAG/B,cAA6B,kBAE/B,cAAgC,KACzB,cAAP,IAGF,AACE,iBAAe,QACf,iBAAe,SAEM,+CACD,uBACpB,AAAI,OACO,QAET,IAGG,AACL,iBAAe,QACf,iBAAe,SAEK,+CACD,uBACnB,AAAI,OACO,QAET,IAGF,IAEK,MACT,GAEO,GACM,cAAiB,uBAC9B,AAAI,IACF,cAA6B,iBAC7B,cAAgC,KACzB,cAAP,IAEF,GAIJ,AAAI,EAAc,KAChB,cACE,GACA,4CAAqB,cAAc,mCAGhC,cAAP,kCAcc,cAAoC,cAAM,cAAS,cAAS,UAC1E,AAAI,AAAC,KAAgB,aAAP,OACH,cAAsB,sBACjC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,wCAIC,aAAP,kCAmkCe,cAAuB,6BAAa,cAAS,cAAS,UACrE,AAAI,AAAC,KAAiB,aAAP,OACA,cAAuB,6BAAa,cAAS,cAAU,UACtE,AAAI,AAAC,KAAiB,aAAP,OACE,AAAgB,cAAU,cAAU,wBACrD,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,gBAAM,+BAAqB,oCAItC,aAAP,4BVr1EO,sBAAuB,6BAA9B,+BUypDA,AAAe,mBACf,MAAQ,MACD,QACA,UAAmB,GACX,cAAuB,6BAAc,cAAS,cAAS,UAClE,AAAI,AAAC,KAAa,aAAP,OACU,cAAuB,qCAC5C,AAAI,OACa,cAA8B,AAAmC,eAChF,AAAI,IAAiB,2CAAP,KAEhB,AAAI,AAAC,oBACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,iBAAW,qCAG1C,aAAP,IAEK,aAAP,IAGJ,AAAO,oBACA,aAAP,4BR9qCO,iBAAa,KACb,AAAC,GAAoC,iDAAsB,kBADlE,6BFrlBA,AAAI,EAAQ,MAAkB,aAAP,IACvB,8BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UAVuB,cAAP,IACO,cAAP,IACO,cAAP,KAEO,cAAP,IACO,iBAAa,MAAK,IAAe,eAAxC,IACO,cAAP,IACO,cAAP,IACO,cAAP,IACO,cAAP,IACO,iBAAa,MAAK,IAAe,eAAxC,IACL,cAAP,mDUumDG,sBACd,AAAe,mBACf,oBAAQ,MACD,QAWA,QACA,QACA,QAmBA,QAUA,QAmBA,QASA,QAtEa,AAEZ,cAAsB,OACjB,cACL,iDACA,EACA,6BAHF,OAUoB,GACX,cAAuB,cAAS,cAAS,cAAS,UAC7D,AAAI,AAAC,KAAa,cAAP,OACU,cAAuB,qCAC5C,AAAI,OACa,cAA8B,AAAkC,eAC/E,AAAI,IAAiB,4CAAP,KAEhB,AAAI,AAAC,oBACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,iBAAW,qCAG1C,cAAP,IAEK,cAAP,IAEsB,GACX,cAAuB,cAAS,cAAS,cAAS,UAC7D,AAAI,AAAC,KAAa,cAAP,OACU,cAAuB,qCAC5C,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,4CAAP,KAET,eAAP,IAEgB,GACL,cAAuB,cAAS,cAAS,cAAS,UAC7D,AAAI,AAAC,KAAa,cAAP,OACU,cAAuB,qCAC5C,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,4CAAP,KAEhB,AAAI,AAAC,oBACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,eAAK,qCAGd,cAAP,IAEK,6BAAP,IAEsB,AACtB,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wBAGT,cAAP,IAGO,2DADU,IAGV,AAAO,qBAEX,cAAP,iCAryBA,IAAO,iBAAa,QACX,AAAC,8DAEV,wCAAQ,qBACD,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OACA,OACA,OACA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,QA5FI,cACL,iDACA,cAAS,cAAS,iBAHG,IAOhB,cACL,iDACA,cAAS,cAAS,iBAHA,IAOb,cACL,iDACA,cAAS,cAAS,iBAHF,IAOX,cACL,iDACA,cAAS,cAAS,iBAHD,IAOZ,cACL,iDACA,cAAS,cAAS,iBAHO,IAOpB,cACL,iDACA,cAAS,cAAS,iBAHE,OAUf,cACL,iDACA,cAAS,cAAS,6BAAwB,iBAH1B,IAOX,cACL,iDACA,cAAS,cAAS,iBAHF,IAOX,cACL,iDACA,cAAS,cAAS,iBAHD,IAOZ,cACL,iDACA,cAAS,cAAS,iBAHI,IAOjB,cACL,iDACA,cAAS,cAAS,iBAHC,IAOd,cACL,iDACA,cAAS,cAAS,iBAHH,IAOV,cACL,iDACA,cAAS,cAAS,iBAHQ,IAOrB,cACL,iDACA,cAAS,cAAS,iBAHC,IAOd,cACL,iDACA,cAAS,cAAS,iBAHM,IAOnB,cACL,iDACA,cAAS,cAAS,iBAHK,IAO7B,AAAO,oBACA,cAAP,4UAxH6B,sBAC7B,AAAI,cAAyB,mBAAc,aAAP,IACpC,cAAyB,qBACR,cAAyB,cAAM,cAAS,cAAS,UAClE,cAA4B,kBACrB,aAAP,oCAo5BW,yBACC,sBACZ,AAAe,mBAEf,0EAAQ,MAID,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QAMA,QACA,QACA,QACA,QAsBA,QACA,QAaA,QACA,QAMA,OAMA,QACA,QACA,QACA,QACA,QACA,QAwBA,QACA,QACA,QAsBA,QACA,QACA,QAwBA,QAgBA,qBAxJI,cAAuB,cAAM,cAAS,cAAS,iBAD/B,OASM,GACd,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACM,cAA2B,qCAChD,AAAI,OACa,cAA8B,AAA6B,eAC1E,AAAI,IAAiB,4CAAP,KAEhB,AAAI,AAAC,oBACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,iBAAW,qCAG1C,cAAP,IAEK,eAAP,KAM6B,GACd,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACM,cAA2B,qCAChD,AAAI,OACa,cAA8B,AAA6B,eAC1E,AAAI,IAAiB,4CAAP,KAET,eAAP,KAOO,eAD6B,IAO7B,eADM,SAWe,GACb,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACM,cAA2B,qCAChD,AAAI,OACa,cAA8B,AAA6B,eAC1E,AAAI,IAAiB,4CAAP,QAEA,cAAuB,cAAO,cAAS,cAAU,UACjE,AAAI,AAAC,KAAkB,cAAP,OACC,AAAgB,cAAU,cAAW,wBACtD,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,iBAAW,+BAAqB,oCAIjE,cAAP,MAO8C,GAC/B,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACM,cAA2B,qCAChD,AAAI,OACa,cAA8B,AAA6B,eAC1E,AAAI,IAAiB,4CAAP,KAEhB,AAAI,AAAC,oBACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,iBAAW,qCAG1C,cAAP,IAEK,cAAP,MAOgB,GACD,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACM,cAA2B,qCAChD,AAAI,OACa,cAA8B,AAA6B,eAC1E,AAAI,IAAiB,4CAAP,QAEA,cAAuB,cAAO,cAAS,cAAS,UAChE,AAAI,AAAC,KAAkB,cAAP,OACC,AAAgB,cAAU,cAAW,wBACtD,AAAI,AAAC,QAAc,AAAC,qBAClB,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,iBAAW,+BAAqB,oCAIjE,cAAP,IAK8B,GACf,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACC,cAAuB,cAAO,cAAS,cAAU,UACjE,AAAI,AAAC,KAAkB,cAAP,OACC,AAAgB,cAAU,cAAW,wBACtD,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,gBAAM,+BAAqB,oCAItC,cAAP,IAEkB,GACH,cAAuB,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAiB,cAAP,OACC,cAAuB,cAAO,cAAS,cAAU,UACjE,AAAI,AAAC,KAAkB,cAAP,OACC,AAAgB,cAAU,cAAW,yBACtD,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,gBAAM,+BAAqB,mCAGpC,cAAP,IAGK,cAAY,QAAuB,cAAa,YACnD,GACA,8BAFJ,IAKJ,AAAO,oBACA,cAAP,kCA3NW,cAA6B,cAAM,cAAS,cAAS,UAChE,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,IAAgB,aAAP,IACb,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,uCAGT,aAAP,kCAidW,cAA2B,cAAM,cAAS,cAAS,UAC9D,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wCAIX,aAAP,kCAgFkB,sBACX,cAAsB,cAAY,AAAO,uCAAsB,kBAAI,cAAS,cAAS,gBAA5F,kCAsKW,cAA+B,cAAM,cAAS,cAAS,UAClE,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wCAIX,aAAP,oCApJO,GAAO,eAA4B,uEAA1C,kCA4BW,cAA8B,cAAM,cAAS,cAAS,UACjE,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,wCAIX,aAAP,kCA1rBW,cAAmC,cAAM,cAAS,cAAS,UACtE,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,gCAAgB,sCAIjD,aAAP,kCAhIW,cAAkC,cAAM,cAAS,cAAS,UACrE,AAAI,AAAC,KAAa,aAAP,OACG,cAAsB,sBACpC,AAAI,AAAC,KACH,AAAI,EAAc,KAChB,cACE,GACA,6BAAY,AAAsB,gCAAgB,sCAIjD,aAAP,iCAl1BA,IAAO,iBAAa,QACX,AAAC,8DAEV,wCAAQ,qBACD,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OACA,OACA,OACA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,QA5FI,cACL,iDACA,cAAS,cAAS,iBAHG,IAOhB,cACL,iDACA,cAAS,cAAS,iBAHA,IAOb,cACL,iDACA,cAAS,cAAS,iBAHF,IAOX,cACL,iDACA,cAAS,cAAS,iBAHD,IAOZ,cACL,iDACA,cAAS,cAAS,iBAHO,IAOpB,cACL,iDACA,cAAS,cAAS,iBAHE,OAUf,cACL,iDACA,cAAS,6BAAwB,iBAHjB,IAOX,cACL,iDACA,cAAS,cAAS,iBAHF,IAOX,cACL,iDACA,cAAS,cAAS,iBAHD,IAOZ,cACL,iDACA,cAAS,cAAS,iBAHI,IAOjB,cACL,iDACA,cAAS,cAAS,iBAHC,IAOd,cACL,iDACA,cAAS,cAAS,iBAHH,IAOV,cACL,iDACA,cAAS,cAAS,iBAHQ,IAOrB,cACL,iDACA,cAAS,cAAS,iBAHC,IAOd,cACL,iDACA,cAAS,cAAS,iBAHM,IAOnB,cACL,iDACA,cAAS,cAAS,iBAHK,IAO7B,AAAO,oBACA,cAAP,ipBNpT8B,0BAEY,yInBi8S5C,AAA8B,kDAE9B,AAA+B,AAC7B,6BAAc,6BAAgB,cAAW,OAAuB,WAGvC,sBAC3B,AAAI,IAAsB,AAA8B,MAExD,AAAI,AAAC,cAAqB,kBAA0B,KAEtC,yBACE,GAAO,AAAc,GAAwB,qEAClD,sBACX,AAAI,IAAQ,iBAAc,YACd,cAAK,UAGf,AAAI,cAAkB,OACpB,AAA+B,AAAC,yDAChC,AAAI,iBAAe,QACX,cAAK,UACX,AAAI,cAAkB,OACpB,AAA8B,MAC9B,AAA+B,AAAC,yDAChC,AAAI,iBAAc,KAChB,cACE,GACA,6BAAiB,gBAAK,yCAI1B,cACE,GACA,yCAKN,cACE,GACA,wCAIJ,cACE,GACA,6BAAiB,gBAAK,2nDYnhRxB,cAAY,WACQ,sBAEpB,AAAI,cAAkB,sBACX,GAAO,cAAkB,sDAEzB,UACT,cAAkB,cAAY,mBAEhC,cAAW,cAAM,qDIumBjB,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAkC,iBAAU,EAAO,EAAO,EAAO,EAAY,4CJr1DhE,sBACb,AAAI,AAAC,KAAQ,iBAAqC,cAAkB,yCAC7D,aAAP,82CAgrHqC,UAC1B,UACX,IAEE,AAAI,cAAS,mBAAU,GACvB,cAAS,kBACT,AAAI,EAAW,KAAsB,aAAP,OACpB,sBACH,MACF,aAAP,oCAudO,6BAAuB,4BAA9B,kCA1pIa,sBACb,AAAI,AAAC,KAAQ,iBAAyC,cAAkB,yCACjE,aAAP,kCAsBa,sBACb,AAAI,AAAC,KAAQ,iBAAsC,GAAgB,cAAa,eAAyB,6DAClG,aAAP,+BkBk8BF,AAAI,mBAAc,AAAC,uCAAgD,aAAP,OAC9C,sBACd,AAAI,IACG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACrB,AAAI,cAAa,GAAsB,SAA+B,aAAP,IAC/D,AAAI,cAAU,SAEZ,AAAI,gCAA4B,qBAA4B,aAAP,KALiB,AAAE,YASvE,aAAP,+BAuDA,AAAI,AAAC,oBAAiC,aAAP,OACnB,sBACZ,AAAI,AAAC,KAEH,AAAO,mCACA,aAAP,OAGY,sBACd,AACE,cAAuB,oDACvB,cAAuB,qDACvB,cAAuB,qDACvB,cAAuB,sCACvB,cAAuB,mCAEhB,aAAP,IAIK,AAAc,4BAArB,4Bd+kBE,AAAW,cAAuB,mBAC3B,AAA4B,iBAAU,eAA7C,4BD5uDO,iBAAkB,6BAAzB,uCfuyFA,AAAO,cAAW,KAAsB,8BAC7B,sBACX,cAAmB,iBACnB,8BAAQ,qBACD,OAQA,OACA,OAQA,OACA,OAQA,OACA,OAOA,OACA,OAUA,OACA,OAQA,OAQA,QA7DI,6BACL,iBAA6B,KAEzB,EAAY,mBAA8B,If5/FtD,AAAO,EAAQ,Ue6/FH,iBALY,KASD,AACjB,AAAY,cAA8B,oBACnC,6BACL,iBAA6B,KACzB,EAAQ,yBAAiC,GAAS,IAClD,iBAHN,KAOiB,AACjB,AAAW,6BAAqC,oBACzC,6BACL,iBAA6B,KACzB,EAAQ,yBAAgC,IACxC,iBAHN,KAQO,6BACL,iBAA6B,KACzB,EAAQ,0BACR,iBAJW,KAQE,AACf,AAAC,kDACI,6BACL,iBAA6B,KACzB,EAAQ,0BACR,iBAHN,MAUK,iBAA6B,KAChC,6BACE,EAAQ,yBACR,EAAS,gCAEX,6BAAgB,mBANH,IAQA,AAEjB,AAAI,AAAE,cAAqB,QAA2B,EAAkB,WAC/D,6BAAgB,+BAAvB,IAGF,cAAmB,mBAGZ,6BAAgB,AAAK,gCADX,IAGV,AACP,AAAO,oBACA,2CAAP,8BgB1oCJ,AAAW,cAAuB,mBAC3B,AAA4B,iBAAU,EAAM,EAAM,EAAS,eAAlE,4BAxaA,AAAW,cAAuB,mBAC3B,AAA4B,iBAAU,EAAM,eAAnD,iChB3lBA,AAAI,cAAU,UAA8B,AAAC,cAAU,qBAAlB,IACrC,cAAW,WAEW,sBACtB,cAAoB,qBAEP,sBACb,AAA8B,OACf,yBACO,sBAEtB,AAAI,AAAC,cAAU,WAGb,AAAI,OACiB,6BAA0B,cAAU,6ByB39BvB,iBzB49BhC,AAAI,AAAC,KACH,cAAW,QACX,cAAuB,kBAChB,cAAP,IAEF,AAAI,EAAgB,MAClB,cACE,GACA,sCAEF,cAAW,QACX,cAAuB,kBAChB,cAAP,IAEF,cAAe,iBACf,6BAAgC,cAAc,mBAGzC,AAAI,OACU,sBACnB,AAAI,cAAoB,QACtB,cAAmB,+DAErB,AAAW,cAAuB,cAAiB,eACjD,EAAuB,QAEzB,cAAmB,iBACnB,AAAI,iBAAoB,MACtB,cACE,GACA,6BAAuB,8CAA6B,qBAEtD,cAAW,QACX,cAAuB,kBAChB,cAAP,IAEF,cAAe,iCAIf,cACE,GACA,oEAEF,cAAW,QACX,cAAuB,kBAChB,cAAP,MAKJ,AAAI,cAAoB,WACH,sBACnB,AAAI,eAA+B,sBACxB,GAAO,eAA+B,kDAC/C,AAAG,EAA2B,cAAM,2CAApC,SAEF,cAAuB,kBAChB,cAAP,OAGS,sBAYX,AACE,AAAC,KAAmB,AAAC,cAAU,cAC/B,uBAAoB,AAAC,wBAErB,cACE,GACA,sDAIJ,AAAc,mBACd,AAAyB,cAAU,YAAsB,cAAU,EAAqB,UACxF,AAAuB,cAAoB,QAG3C,AAAI,cAAU,SAGZ,AAAI,OAAsB,6BAAwB,QAChD,AAAiB,cAAQ,gCACzB,6BAA8B,eAA6B,eAA8B,iBACzF,cACE,6BACA,eACA,eACA,EACA,AAAC,MAEH,cAAuB,kBACvB,AAAI,AAAC,oBAA6B,AAA2B,uBAC3D,cAA4B,MAEvB,cAAP,IAIF,cACE,GACA,4CAA0B,uBAE5B,cAAW,QACX,cAAuB,kBAChB,cAAP,IAKF,AAAwB,IAGxB,AAAI,IACF,AAAI,AAAC,QACgB,sBACnB,AAAI,cAAoB,QACtB,cAAmB,+DAErB,AAAW,cAAuB,cAAiB,cACjD,EAA2B,GAAuB,QAEpD,cAAmB,kBAIrB,AAAI,AAAC,cAAyB,QAC5B,AAAI,IACF,AAAc,cAAqB,EAAU,WAC7C,AAAI,IACF,AAAW,KAEX,AAAoB,MAGtB,AAAoB,MAKxB,AAAI,IAAqB,AAAgB,KAAa,YACrC,GAAO,AAAiB,sCACvC,AAAI,AAAC,AAAgB,cAAiB,0BACf,qCACrB,AAAI,cAAmB,sBACR,GAAO,cAAmB,kDACvC,AAAI,cAAU,SAAsB,AAAoB,QAM9D,AAAI,IACF,AAAI,IACF,cACE,GACA,uCAGF,AAAO,AAAgB,KAAa,qBACpC,AAAe,AAAkB,OACjC,YAAQ,MACD,QAKA,QAQA,QAKA,SAlBkB,AACrB,cAA2B,KAC3B,cAA8B,EAAQ,AAAiB,OAAW,oBAClE,GAEqB,AACrB,cAA2B,KAC3B,cAA8B,EAC5B,AAAoB,OACpB,AAAqB,uBAEvB,GAEqB,AACrB,cAA2B,KAC3B,cAA4B,AAAiB,SAC7C,GAEqB,AACrB,cAA2B,KAC3B,cAA4B,AAAiB,QAC7C,GAEO,AACP,AAAO,oBACP,cAAW,QACX,cAAuB,kBAChB,cAAP,IAGJ,cAAW,WAMf,AAAI,cAAU,UACZ,AAAW,cAA2B,cAAQ,6BAAa,QAE3D,AAAW,cAAc,wBAIV,sBAEnB,AAAI,IACF,AAAI,IACF,cACE,GACA,GAAc,GAAsB,wFAA+B,wBAGvE,cAAiB,cAAc,EAAS,EAAM,cAAc,qBAC5D,6BACE,cAAkB,cAAc,UAE7B,AAAI,AAAC,KACV,cAAiB,cAAc,EAAS,AAAC,GAAoB,QAE/D,cAAuB,kBAChB,cAAP,+BAtQA,AAAI,cAAU,UAA8B,AAAC,cAAU,oBAAlB,IACrC,AAAI,cAAuB,GAAsB,YAA2B,cAAU,UAC7E,cAAmB,4BAA1B,IAGF,cACE,GACA,6BAAkB,4CAA6B,oCAE1C,aAAP,kCeuEqB,sBACrB,AAAwB,sBACE,EAAgB,UACrC,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAoB,EAAK,cAAe,oBADb,AAAE,WAGlC,AACL,6BACA,cACA,6BACA,6BACA,EACA,gBANF,gDAP8B,oBAAyC,qFHinF5D,EACT,4CAAqB,6BAAiB,6BACtC,6BACA,6BACA,6BAAqB,wBACrB,qCAEF,cAAgB,gCAChB,cAAS,iBAAa,AAAC,SAAuB,UACvC,aAAP,kCZw9EW,QACX,AAAI,AAAC,uBACU,sBACb,cAA8B,cAAiB,cAAM,GAAa,EAAM,cAAW,YAE9E,aAAP,4BgBhsJA,AAAW,cAAuB,mBAC3B,AAA4B,iBAAU,EAAM,eAAnD,+BAsQA,AAAe,sBACJ,EAAqB,UAC3B,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAK,EAAK,cAAuB,cAAM,uBADrB,AAAE,WAGhC,AAAW,AAAc,mBACzB,AAAW,cAAuB,mBAClC,AAAU,AAAyB,iBAAU,EAAM,EAAU,EAAM,EAAW,MAC9E,AAAe,IACR,aAAP,6BAynCF,AAAI,AAAC,KAAc,cAAP,IACZ,MAAQ,qBACD,OACA,QADU,cAAP,IACO,cAAM,gBAAb,IAEV,AAAW,AAAc,mBACzB,AAAU,AAA6B,EAAM,qBAC7C,AAAe,IACR,aAAP,qCD9jEA,AAAe,sBACL,EAAmB,UACxB,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAI,EAAK,cAAM,uBADG,AAAE,WAGzB,aAAP,kCAkFiB,yBACM,sBACrB,AAAwB,mBACxB,AAAI,AAAC,KACI,IAAW,kBAAmB,eAArC,IAEF,AAAI,OACa,EAAmB,EAAI,WACtC,AAAU,cAAS,EAAK,oBACnB,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAS,EAAI,GAAK,cAAe,uBADN,AAAE,WAGlC,AAAW,4BAAlB,IAEK,AAAW,AAAY,2CAA9B,4BAIO,2CAAP,kCHuwFoB,yBACJ,sBAChB,AAAe,mBACf,AAAe,kCACf,AAAI,mBAAoB,AAAE,QAC1B,AAAoB,EAAW,QACnB,EAAgB,UACvB,AAAQ,MAAG,EAAI,KAClB,cAAM,EAAK,cAAc,EAAW,oCADH,AAAE,WAG9B,aAAP,6BI9mDA,AAAW,cAAuB,mBAClC,AAAW,AAAc,mBACzB,AAAU,AACR,iBACA,EACA,EACA,EACA,EACA,IAAW,kBAAkB,GAC7B,MAEF,AAAe,IACR,aAAP,4OC3gBA,AAAO,EAAO,KAAK,EAAM,gCACT,sBAChB,AAAI,AAAC,KACH,iBAA6B,sCAClB,sBACX,AAAU,IACV,AAAU,mBACV,IAAO,EAAM,KACX,AAAI,cAAgB,cAAU,KAAmB,cAAe,YAElE,cAAe,WAEjB,AAAQ,IACR,AAAQ,iBAAmB,KAC3B,IAAO,EAAI,KACT,AAAQ,EAAK,AAAC,EAAI,GAAM,MACxB,AAAQ,AAAU,cAAU,OAC5B,AAAI,EAAM,KAAG,AAAI,KACZ,AAAI,EAAM,AAAU,cAAU,EAAI,SACrC,cAAkB,EAAM,GAAI,MACrB,EAAI,cAAX,IAEG,AAAI,EAAI,YAER,AAAO,mCAAd,4BAKO,4BAAP,4BDkfA,AAAuC,EAAS,EAAO,cAAuB,wDJmqD9E,AAAI,oDACmB,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,QACjC,cAAe,aACd,sBACb,cACE,EACA,iBACA,iBACA,cAAc,oBACd,iBAAoB,MAR0B,AAAE,YAYtD,AAAI,oDACiB,aACC,sBACf,AAAQ,IAAO,qBAAsB,EAAI,QAC5B,cAAc,yBAC9B,AAAI,cAAiB,sBACP,GAAG,UAAa,0HAE9B,cAAiB,kBACjB,cAAoB,EAAK,EAAG,iBANmB,uDAzBnD,cAAW,QACM,sBACjB,AAAO,AAAC,QAAc,AAAC,qCACvB,cAAkB,KAClB,cAAkB,cAAQ,+CZ47Ef,sBACX,AAAI,IAAa,cAAP,OAEc,yBACK,yBACO,uDACnB,sBACjB,AAAiB,cAAY,SAG7B,AAAmB,mBACnB,AAAkB,IAClB,AAAmB,mBACnB,AAAkB,IAClB,AAAI,IACF,AAAE,OACF,AAAE,QAEJ,AAAkB,AAAO,EAAc,8BAEf,EAAyB,UACjD,AAAmB,OACP,eAGC,yBACE,sBACf,AAAI,IACF,cAAkB,EAAK,cAAiB,EAAG,uBAC3C,AAAe,KAIZ,AAAQ,MAAG,EAAI,QACF,cAAuB,UACvC,cAAkB,EAAgB,cAAiB,EAAc,uBAFjC,AAAE,OAAG,AAAE,WAIzC,AAAO,EAAgB,wBAGhB,cAAiB,gBAAW,UAEnC,cAAuB,oBAIJ,yBACR,sBACX,AAAI,cAAY,SAA0B,cAAS,QACnD,cAAmB,iBAGnB,AAAe,EAAc,QACjB,EAAkB,aACpB,gBAAK,2BACV,AAAQ,MAAG,EAAI,KAClB,cAAM,EAAK,AAAG,mBAAI,gCADU,AAAE,cAGV,sBACtB,AAAY,cAAa,cAAM,iBAAI,qCACjC,cAAa,gBAAc,qCACzB,cAAc,cAAO,gBAEnB,IACI,cACE,EACA,cAAkB,cAAiB,MACnC,cAAW,SAEb,cAAkB,cAAiB,8CAG3C,8CAEG,AAAQ,MAAG,EAAI,QACP,cAAuB,EAAe,cAC/B,cAA8B,EAAe,eAC7C,uBAElB,AAAI,IACF,AAAW,cACT,cACA,cACA,OAEF,AAAW,cAAiB,EAAc,EAAU,uBAEpD,cACE,GACA,sCAEF,AAAW,oBAEb,AAAQ,cAAa,cAAM,EAAI,kBAAI,uCACjC,SACA,+BAEF,cAAkB,EAAgB,cAAiB,EAAc,uBAvBlC,AAAE,OAAG,AAAE,WAyBxC,AAAO,EAAgB,qBAEvB,cACE,MAEF,cAEE,cAAoB,cAAU,cAAmB,qDAEnD,cAAmB,iBAEnB,AAAc,cACZ,6BACA,gCACA,gCACA,AAAY,4CACZ,cAAe,cAAO,yBAExB,cAAS,QACT,cAAc,cAAQ,KACf,cAAP,+BAiKA,AAAI,AAAC,4CAAwB,KAChB,sBACb,AAAmB,OACJ,sBACf,AAAI,IACF,AAAI,mBACF,AAAc,cAAS,OACvB,AAAc,cAAqB,EAAS,WAC5C,AAAI,AAAC,AAAY,QACf,cAAS,EAAgB,cAAe,UAG5C,AAAE,QAEJ,AAAqB,OACA,sBACrB,AAAO,iBAAyB,iBAAkB,sBAClD,IAAO,EAAe,uBACJ,cAAe,UAC/B,AAAI,mBACF,AAAc,cAAS,OACvB,AAAc,cAAqB,EAAS,WAC5C,AAAI,AAAC,AAAY,QACf,cAAS,EAAgB,cAAe,UAG5C,AAAE,OACF,AAAE,oDiBxxLO,OACX,AAAI,iBAAa,QACR,AAAC,0DAEV,AAAI,iBAAa,QACF,AAAC,yDACd,AAAI,iBAAe,KAAa,aAAP,KAEpB,aAAP,4BAUO,cAAgB,gBAAvB,gDLk+FiD,gHZknFtC,sBACX,AAAI,IAAa,aAAP,OACH,cAAiB,+BACxB,cAAwB,oBACX,sBACb,cAAW,cACT,6BACA,gCACA,gCACA,EACA,uBAEF,6BAAuB,kBAChB,aAAP,iCAgLA,AAAI,cAAsB,QACxB,AAAI,AAAC,cAAY,YACf,AAAO,AAAC,cAAY,+BACF,sBAClB,AAAI,cAAqB,qBACvB,cACE,GACA,6BAAkB,qCAGpB,cAAiB,kBAEjB,AAAI,cAAY,YACI,GAAO,mCACzB,AAAO,mCACP,AAAO,cAAoB,cAAU,cAAkB,wBAAI,cAAY,KAAI,QAE3E,AAAO,cAAoB,cAAU,cAAU,EAAG,QAEpD,kBACO,cAAP,KAGF,cACE,GACA,6BAAkB,yCAIX,sBACb,AAAkB,IAAW,kBAAkB,KAC/C,AAAmB,IACnB,AAAmB,kCACnB,AAAkB,OACG,qCACrB,AAAmB,mBACnB,AAAkB,IAClB,AAAI,cAAY,SACd,AAAE,OACF,AAAE,OACF,AAAE,QAEJ,AAAO,EAAe,qBAEtB,AAAI,AAAC,cAAqB,sBAAkB,6BAAP,OACpB,qCAGjB,AAAI,EAAc,KAChB,AAAI,AAAC,QACQ,EAAU,UACrB,cAAkB,SAEC,oDACrB,AAAO,iBAAyB,oCAChC,AAA8B,IACzB,AAAQ,MAAc,EAAI,UACX,cAAe,yBACjC,AAAI,IACF,AAAI,mBACF,cAAc,cACZ,cACA,cAAe,iBACf,SAEF,MAEa,6BAA+B,cAAa,6BAAe,cAAe,iBAAI,UAC7F,AAAI,IAAY,iBAAiB,YAClB,0CACb,AAAI,cAAuB,cAAQ,mBAAgB,cAAU,cAC3D,cACE,cAA2B,cAAQ,cAAe,iBAAI,SAExD,KAIN,cAAc,cAAc,cAAe,wBAC3C,AAA0B,KAvBiB,AAAE,WAyB/C,AAAI,AAAC,KAA2B,AAAC,cAAY,kBAC5B,UACJ,cAAuB,sBAClC,AAAI,AAAC,cAAqB,sBAAkB,6BAAP,IACrC,6BAAsB,mCACtB,AAAoB,mBAGpB,AAAkB,cAAS,EAAc,QACzC,AAAO,AAAE,AAAe,EAAa,oBAAc,yBAC7B,cAAe,EAAe,WACpD,cAAS,EAAc,GAAK,cAAa,EAAM,qCAC7C,cAAkB,6BAA8B,cAAW,eAC3D,mBACC,uBACH,cAAqB,6BAAoB,iBACzC,AAAW,cAAY,6BAAuB,cAAU,SACxD,AAAI,EAAc,MAAa,QAC7B,AAAO,cAAY,OACnB,cAAmB,mBAEnB,cAAmB,kBAEd,cAAP,KAKJ,AAAI,cAAY,WAA2B,AAAC,2BAC/B,cAAwB,uBAGrC,AAAI,IAAU,cAAqB,6BAAoB,kBACvD,AAAW,cAAY,6BAAuB,cAAU,wBACxD,cAAmB,iBACZ,cAAP,oCAyxGc,sBACd,AAAI,AAAC,KAAgB,cAAP,OAED,yBACF,sBACX,AAAe,mBACf,AAAqB,IAAW,iBAAiB,+DAA4B,KAC7E,AAAkB,kCAClB,AAA4C,IAGvC,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACxD,AAAU,cAAQ,UAC/B,AAAI,iBAAe,KAA+B,MAEnC,AAAC,0DAChB,AAAI,AAAC,QAAY,AAAC,wBAAoB,iBAAuC,MAAe,GAC5F,AAAO,AAAC,cAAe,4BACF,sBACrB,AAAqB,mBAGrB,AAAI,EAAiB,KACnB,AAAI,AAAC,QAAyC,aAC9C,cAAwB,kBACxB,MAIc,sBAChB,AAAmB,mBACnB,AAAO,AAAC,wCACa,GAAO,mDAC5B,AAAW,cAAoB,cAAgB,qCAC7C,cAAiB,EAAgB,YACjC,cACE,IACI,iBAAiB,8EACjB,EAAI,IACR,sBAED,6BAA+B,OAClC,AAAI,iBAAoB,MACtB,AAAO,cAAY,QAErB,cAAW,OAlC6D,AAAE,WAsC5E,AAAI,IACG,AAAQ,IAAO,qBAA2B,EAAI,QACrC,AAAU,cAAmB,aACzB,yBACK,yBACC,sBACtB,AAAO,iBAAgC,yBAClB,GAAO,mDAC5B,AAAW,cAAoB,cAAgB,uCAC7C,cAAiB,EAAgB,YACjC,IACI,cAAuB,cAAiB,cAAW,MACnD,cAAc,mCACjB,6BAAsB,OACzB,AAAI,iBAAoB,MACtB,AAAO,cAAY,QAErB,cAAW,MAhByC,AAAE,YAoB1D,cAAmB,kBACZ,cAAP,oCAt4Qa,yBACE,GAAO,oEACL,wCACN,yBACK,kCACZ,GAAO,cAAiB,8CACxB,QACJ,AAAqB,mBAGrB,AAAI,iBAAiB,QACX,cAAuB,AAAC,gEAAsC,uBAGtE,AAAO,iBAAiB,qBAGxB,AAAO,kDAGP,AAAO,AAAC,cAAe,IAA0B,IAAkB,0BAEnE,AAAW,cAAuB,AAAC,gEAA2C,cAAY,OAC1F,AAAI,AAAC,cAAiB,EAAM,oBAAa,cAAS,MAClD,AAAI,cAAe,EAAM,mBAAa,cAAS,MAE/C,AAAI,AAAC,QAAe,qCAAE,aACjB,cAAW,OAEhB,AAAI,AAAC,cAAQ,SACX,AAAI,AAAC,cAAiB,EAAM,oBAAa,cAAS,MAClD,AAAI,cAAe,EAAM,mBAAa,cAAS,MAC/C,cAAS,EAAoB,SAMjC,AAAI,cAAY,SACd,AAAO,cAAY,4BACP,GAAO,sCACN,GAAO,kDACpB,AAAO,iBAAe,wBACF,0CAEpB,AAAI,cAAW,GAAyB,aAAwC,AAAC,cAAQ,aAGtE,YACjB,cACE,cAA+B,cAAe,wBAEhD,cAA0C,cAAe,kBAGpD,AAAQ,iBAAe,OAAG,EAAK,KAClC,cAAM,EAAI,GAAK,cAAM,QAD6B,AAAE,WAGtD,cAAM,EAAkB,cAAe,cAAY,SAGnD,AAAI,cAAQ,SACV,AAAI,kCACF,cACE,GACA,wDAOR,AAAI,cAAQ,SAA+B,AAAC,cAA2B,aACrE,cACE,GACA,sDAKJ,AAAI,AAAC,cAAQ,SACX,cACE,cAAiB,iBAAiB,uCAEpC,cAAS,EAAoB,GAA2B,QAI1D,AAAI,mBAAsB,AAAC,uCAAmD,AAAC,cAAQ,aACrF,cACE,GACA,sEAKC,AAAI,EAAc,MAAa,AAAC,cAAQ,aAC7C,cACE,GACA,mFAEK,cAAP,KAGK,cAAP,6BgBsiBA,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAoC,iBAAU,EAAO,EAAO,EAAO,EAAQ,sCAlH3E,AAAW,cAAuB,mBAC3B,AAA8B,iBAAU,eAA/C,kCJxkDa,sBACb,AAAI,AAAC,KAAQ,iBAAuC,GAAgB,cAAa,eAA0B,6DACpG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAuC,GAAgB,cAAa,eAA0B,6DACpG,aAAP,kCAlFa,sBACb,AAAI,AAAC,KAAQ,iBAAoC,GAAgB,cAAa,eAAuB,6DAC9F,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAqC,GAAgB,cAAa,eAAwB,6DAChG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAqC,GAAgB,cAAa,eAAwB,6DAChG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAqC,GAAgB,cAAa,eAAwB,6DAChG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAqC,GAAgB,cAAa,eAAwB,6DAChG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAA4C,GAAgB,cAAa,eAA+B,6DAC9G,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAsC,GAAgB,cAAa,eAAyB,6DAClG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAsC,GAAgB,cAAa,eAAyB,6DAClG,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAAsC,GAAgB,cAAa,eAAyB,6DAClG,aAAP,kCA+iIqB,UACP,yBACO,sBACrB,AAAI,cAAsB,mBACjB,iBAAwB,0DAAiB,gBAAhD,OAEyB,sBAC3B,AAAI,cAAsB,mBACjB,iBAAwB,0DAAuB,gBAAtD,OAEgB,sBAClB,IAAO,iBAAgB,QACX,GAAO,0DAEH,sBAChB,QAAQ,6BAA0B,SAC3B,QAKA,QAOA,SAZY,AACf,AAAI,EAAa,oBAAsC,cAAP,IAChD,AAAI,EAAa,oBAAsC,cAAP,IAChD,GAEe,AACf,AAAI,EAAa,oBAAmC,cAAP,IAC7C,AAAI,EAAa,oBAAoC,cAAP,IAC9C,AAAI,EAAa,oBAAoC,cAAP,IAC9C,AAAI,EAAa,oBAAoC,cAAP,IAC9C,GAEe,AACf,AAAI,EAAa,oBAAoC,cAAP,IAC9C,AAAI,EAAa,oBAA2C,cAAP,IACrD,AAAI,EAAa,oBAAqC,cAAP,IAC/C,AAAI,EAAa,oBAAqC,cAAP,IAC/C,AAAI,EAAa,oBAAqC,cAAP,IAC/C,GAGJ,AAAO,oBACA,cAAP,+BkB/sGF,AAAI,AAAC,oBAAiC,aAAP,OACnB,sBACZ,AAAI,AAAC,KAEH,AAAO,mCACA,aAAP,OAEY,sBAEd,AACE,cAAuB,oDACvB,cAAuB,qDACvB,cAAuB,kDAEhB,aAAP,IAGF,AACE,cAAuB,qCACvB,cAAuB,mCAEhB,AAA0B,2CAAjC,IAIK,aAAP,4Bd+EE,AAAW,cAAuB,mBAC3B,AAAuB,iBAAU,EAAO,EAAQ,EAAQ,EAAO,EAAM,EAAK,eAAjF,oEAJe,QACA,gGhB+KM,GAAO,qDACf,yBACG,sBAChB,AAAmB,mBACnB,AAAkB,kCAClB,cAAmB,QACnB,AAAW,cAAY,iBAAoB,iBACzC,cAAiB,EAAG,KACpB,EAAc,kCAEC,yBACN,sBACX,cAAmB,iBACnB,AAAI,cAAY,SAAmC,uBAAyB,AAAC,wBAC3E,AAAO,cAA6B,EAAM,cAAW,mCAEvD,cAAmB,iBACZ,cACL,6BACA,EACA,EACA,AAAY,4CACZ,gBALF,4BgBjLA,AAAW,cAAuB,mBAC3B,AAAwB,iBAAU,EAAO,EAAQ,EAAO,EAAK,EAAO,EAAM,eAAjF,+DALgB,KACD,QACA,gGJ14BF,sBACb,AAAI,AAAC,KAAQ,iBAA8B,cAAqB,2CACzD,aAAP,oCZskCqB,GAAO,qDACf,yBACG,sBAChB,AAAkB,kCAClB,AAAmB,mBAEnB,AAAe,cAAa,iBAC1B,cAAiB,EAAG,KACpB,cAAiB,EAAG,KACpB,EAAc,+BAEhB,AAAI,sBACW,sBACb,AAAO,iBAAe,qBACtB,AAAI,AAAC,wEACgB,qCACnB,cAAqB,oBACrB,AAAW,cAAa,EAAM,qCAC5B,SACA,cAAY,6BAA2B,qCACrC,cAAiB,EAAG,YACpB,cAAiB,EAAG,YACpB,cAAW,sBACV,yBACF,UAGP,cAAmB,QACZ,cACL,6BACA,AAAW,qCAAE,SAAa,sBAC1B,GACA,EACA,iBALF,wCe7sBe,sBACf,AAAI,IAAY,uBACP,aAAP,OAEmB,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAU,cAAe,sBAA0B,aAAP,IADA,AAAE,WAG7C,aAAP,kCAKc,YACd,AAAY,OACG,sBACf,AAAI,IACF,AAAI,mBAAwB,cAAa,OACzC,AAAE,WAEiB,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAU,cAAe,sBAC3B,cAAa,OAEf,AAAE,OAJ8C,AAAE,WAM7C,aAAP,iCfgVA,AAAI,cAAY,UAA8B,AAAC,cAAY,qBAApB,IAEvC,AAAI,AAAC,KACH,AAAI,cAAsB,QAAgC,cAAP,IACnD,AAAI,cAAsB,QACxB,6BAAuB,kBAChB,cAAP,QAKa,oDACjB,AAAoB,mBACpB,AAAI,EAAiB,QACL,UACd,cAAY,cAAW,mDAClB,AAAQ,MAAG,EAAI,QACI,cAAW,4BACjB,sBAChB,AAAI,AAAC,cAAY,oBACf,cAAY,mBAEZ,cACE,GACA,6BAAuB,sBARM,YAcrC,cAAa,WACS,sBACtB,cAAoB,qBAED,yBACN,yBACG,yBACD,wCACO,sBACtB,AAAO,iBAAwB,QAAgC,iBAAwB,sBACvF,cAA6B,6BAAoB,AAAC,qEAElD,AAA2B,IAG3B,AAAI,IAGF,AAAI,cAAY,SACd,cACE,GACA,sDAKJ,AAAI,cAAyB,GAA0B,YAChC,sBAErB,GAAgB,AAAc,GAAwB,0BACpD,cACE,GACA,6BAAiB,wBAGrB,GAAgB,AAAc,GAA0B,0BACtD,cACE,GACA,6BAAiB,4BAMJ,yBACR,sBACX,cAAmB,oBACP,YAEZ,AAAI,AAAC,cAAyB,cAAU,oBACtC,cAAW,sBAGb,cAAmB,iBAGnB,AAAU,cACR,6BACA,iBACA,iBACA,AAAY,4CACZ,cAAe,cAAO,wDAInB,AAAI,cAAY,SACrB,AAAiB,cAAU,iBAC3B,6BAA8B,eAA6B,eAA8B,iBACzF,cACE,6BACA,eACA,eACA,iBACA,oBAEF,AAAU,cAAmB,kCAC7B,AAAI,AAAC,uBACY,sBACf,AACE,IAAY,AAA0B,0BACtC,AAA2B,mCAE3B,cAA4B,SAEP,sBAChB,AAAQ,IAAO,uBAAuB,EAAI,KAC7C,AAAI,AAA0B,cAAe,sBAC3C,cAA4B,KAC5B,GAH8C,AAAE,eAUnD,AAAI,cAAY,WAAyB,gCAAwB,MACtE,AAAU,cACR,6BACA,iBACA,iBACA,EACA,uBAKF,AAAI,cAAe,GAAkB,YAChB,uDACE,GAAO,6BAA0B,kDACtD,AAAO,iBAAuB,wBACP,AAAC,yDACxB,AAAI,IAAoB,uBACtB,AAAU,cAAY,QAClB,cAA4B,kBAC5B,cAA4B,oBAChC,AAAO,cAAY,4BAGvB,AAAI,AAAC,KACH,cACE,GACA,qDAEF,cAAa,YAIjB,AAAI,cAAY,YAAwB,cAAY,QAElD,AAA6B,mBAC7B,AAAI,OAEe,qCACjB,AAAI,iBAAwB,SAClB,uCAER,AAAiB,6BAAyC,UAClD,6BAAsB,2BAEhC,cACE,GACA,cAAO,wBAKb,cAAkB,cAAQ,KAC1B,cAAmB,iBACnB,cAAuB,kBAChB,cAAP,oCAg7Qc,yBACD,yBACO,sBACpB,AAAI,AAAC,QAAiB,AAAC,cAAqB,uBAAuB,6BAAP,IAE5D,AAAmB,cAAwB,mEAC/B,yBACC,sBACN,cAAa,EAAM,qCACxB,cACE,6BAA4B,qCAC1B,SACA,SACA,cAAW,cAAc,8BACzB,cAAW,qCAEb,eAEF,wDAVF,4BgB//PA,AAAI,AAAe,AAAkB,UAC5B,AAAwB,iBAAU,EAAiB,eAA1D,IAEO,aAAP,oChBmhQW,yBACF,yBACA,cAAkB,sBAC7B,AAAgB,mBAChB,AAAI,AAAC,cAAiB,EAAM,oBAAO,cAAkB,EAAW,MAChE,cAAkB,EAAW,KAE7B,AAA0B,cACxB,cAAwB,mBACxB,mBAGF,AAAI,mBACF,AAAkB,cAAiB,EAAW,sBAC9C,AAAI,6BAAwB,QAC1B,AAAc,cAAsB,QAEtC,AAAO,cACL,cACE,cAAiB,EAAW,EAAM,eAEpC,EACA,QAGF,AAAO,cACL,cAAiB,EAAW,EAAM,2BAClC,cAAiB,EAAW,oBAC5B,QAGJ,cAAmB,gCACZ,aAAP,+BApgNA,AAA2B,EAAc,AAAE,EAA2B,SACtE,YAAQ,qBACD,OACA,OAUA,OAeA,SAzBkB,GACV,yBACE,6BACX,GAAO,yDACP,6BACA,AAAS,2DAEX,AAAI,AAAC,KAAe,2CAAP,IACN,cAAuB,6BAAuB,cAAQ,EAAuB,iBAApF,IAE0B,AAC1B,AAAO,AAAC,oCACR,AAAW,cAAuB,6BAAuB,6BAA2B,UACzE,sBACX,AAAI,6BAA2B,EAAM,mBACnC,cACE,GACA,4CqB3uGc,EACA,EACA,MrB2uGX,AAAI,AAAC,mCACV,AAAO,cAA6B,EAAM,cAAM,qBAElD,cAAmB,gCACZ,aAAP,IAEwB,AAaxB,cACE,GACA,6BACA,uBAEK,2CAAP,IAEO,AAAO,qBAEX,2CAAP,i2CAgxHW,gBAAe,wCACZ,sBACd,AAAI,cAAY,mBAAkB,GAAO,cAAY,wDAA1B,IAC3B,cAAY,cAAU,qBACT,sBACb,cAAmB,cAAM,gCAA0B,GAAa,EAC9D,qBAEK,aAAP,+BgB1iMA,AAAI,EAAO,cACT,AAAI,iBAAiB,MACZ,cAAS,EAAQ,WAAQ,EAAS,4BAAzC,IAEF,AAAO,EAAW,oCACX,cAAS,EAAQ,yBAAxB,IAEK,iBAAiB,MACpB,cAAS,QACT,cAAS,iBAFb,iChB2uRA,AAAO,mBAAsB,6BAAsC,6CACtD,yBACF,yBACA,cAAkB,sBAC7B,AAAgB,mBAEhB,AAA0B,cACxB,cAAwB,mBACxB,mBAGF,AAAI,AAAC,uBAA8B,cAAe,EAAM,oBAItD,AAAO,cACL,cAAY,cAAuB,6EAAyB,qCAC1D,cAAiB,EAAW,EAAM,4CACjC,QACH,cAAiB,EAAW,oBAC5B,QAIF,AAAO,cACL,cACE,EACA,cAAiB,EAAW,EAAM,8BAEpC,cAAa,KACb,cACE,cAAY,cAAuB,6EAAyB,qCAC1D,cAAiB,EAAW,qCAC3B,QACH,cAAiB,EAAW,oBAC5B,WAIN,cAAmB,iBACZ,cAAP,4Be/8TO,cAAQ,GAAiB,GAAoB,kBAApD,4BAeO,cAAQ,EAAoB,GAAoB,kBAAvD,kCfooGa,sBAEb,AAAI,iBAAiB,KACnB,AAAI,iBAAe,KAGV,aAAP,IAGF,cACE,GACA,6BAAkB,+BAAqB,oCAElC,4BAAP,IAIF,AAAI,iBAAe,KAAsB,cAAY,gBAAnB,IAGlC,AAAI,sBAAwB,oBAC1B,AAAI,6BAA2B,EAAM,sBACxB,uBACN,AAAI,IAAY,uBAAgC,AAAC,wBAGtD,AAAI,AAAC,mCACH,AAAO,cAA6B,EAAM,cAAU,uBAE3C,wBAEb,AAAI,cAAwB,qBAC1B,AAAO,sBAA8B,iBAAiB,qCACtD,cAAmB,iBACZ,aAAP,IAEF,AAAI,IAAY,6BAAsC,yBAEpD,AAAI,mBACF,cACE,GACA,6BACA,uBAEF,cAAmB,iBACZ,4BAAP,IAEF,AAAO,iBAAiB,oCACxB,AAAI,AAAC,mCACH,AAAO,cAA8B,EAAM,cAAU,cAAQ,oBAE/D,cAAmB,iBACZ,aAAP,IAEF,cACE,GACA,6BAAkB,+BAAqB,oCAEzC,cAAmB,iBACZ,4BAAP,IAIF,AAAO,AAAC,oBAAwB,AAAC,wCAGjC,AAAI,iBAAe,oBACjB,cAAmB,iBACZ,aAAP,IAQF,AACE,AAAC,oBACA,sBAAwB,wBAEzB,cACE,GACA,6BAAkB,+BAAqB,oCAElC,4BAAP,IAGF,AAAI,AAAC,cAAwB,sBAC3B,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,+BAAqB,sCAK7C,AAAI,mBAGF,AAAI,mBACF,AAAI,iBAAiB,KAGnB,AAAI,iBAAe,KACjB,AAAO,cAAa,EAAyB,SAM1C,AAAI,iBAAe,KACxB,AAAO,cAAa,EAAwB,UAMzC,AAAI,mBAGT,AAAI,iBAAiB,KACnB,AAAI,mBACF,AAAO,cAAmB,EAAM,eAAU,oBACrC,AAAI,mBACT,AAAiB,6BAAwB,OACzC,AAAI,mBACF,AAAO,cAAa,IAAa,GAA2B,GAAuB,QAEnF,AAAO,cAAa,IAAa,GAA2B,GAAuB,SAGrF,AAAiB,6BAAwB,OACzC,AAAI,mBACF,AAAO,cAAa,IAAa,GAA2B,GAAuB,QAEnF,AAAO,cAAa,IAAa,GAA2B,GAAuB,WAMvF,AAAI,mBACF,AAAO,cAAmB,EAAM,eAAU,oBACrC,AAAI,mBACT,AAAiB,6BAAwB,OACzC,AAAI,mBACF,AAAO,cAAa,IAAa,GAA2B,GAAuB,QAEnF,AAAO,cAAa,IAAa,GAA2B,GAAuB,SAGrF,AAAiB,6BAAwB,OACzC,AAAI,mBACF,AAAO,cAAa,IAAa,GAA2B,GAAuB,QAEnF,AAAO,cAAa,IAAa,GAA2B,GAAuB,YAOzF,AAAO,iBAAgB,MAAgB,iBACvC,AAAO,cAAY,UAIhB,AAAI,mBAA2B,uBAGpC,AAAI,iBAAe,KACjB,AAAI,mBACF,AAAO,cACL,mBACI,GACA,GACJ,QAGF,AAAO,cACL,mBACI,GACA,GACJ,SAMJ,AAAI,mBACF,AAAO,cACL,mBACI,GACA,GACJ,QAGF,AAAO,cACL,mBACI,GACA,GACJ,UAMD,AAAI,EAAY,MAAa,uBAClC,AAAO,cAAmB,EAAM,eAAW,oBAK3C,AAAI,mBAGF,AAAI,mBACF,AAAO,cAAc,EAAgB,EAAM,cAAW,aACjD,AAAI,AAAC,oBACV,AAAO,cAAa,EAAsB,UAIvC,AAAI,mBACT,AAAO,cACL,mBAAgC,GAAyB,GACzD,cAA4B,EAAM,uBAMpC,AAAI,mBAEF,AAAI,iBAAgB,oBAClB,AAAO,cAA4B,EAAM,qBAI3C,AAAI,AAAC,KAAY,AAAC,uCAAyB,uBAAkC,AAAC,wBAC5E,cACE,GACA,6BAAkB,+BAAqB,2CAOjD,cAAmB,iBACZ,aAAP,kCA4zDgB,yBACK,sBACrB,AAAI,cAAoB,SACtB,AAAW,cAAuB,EAAU,cAAU,GAAO,yDAAqB,EAAO,sBAC7E,cAAe,WAE3B,AAAW,cAAuB,EAAU,cAAU,cAAe,iBAAI,EAAO,sBACpE,cAAe,WAE7B,AAAgB,cAAuB,cAAO,cAAW,OAClD,cAAoB,cAAkB,qCAAE,SAAU,mBAAa,8BAAtE,wCAp0Ba,sBACb,4BAAQ,qBACD,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,SAnBc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,MAGF,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,GAAgB,EAAU,gBAA/C,IAErB,AAAO,oBACA,4BAAP,wCAKa,sBACb,4BAAQ,qBACD,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,SAnBc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,MAGF,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,GAAgB,EAAU,gBAA/C,IAErB,AAAO,oBACA,4BAAP,wCAKa,sBACb,4BAAQ,qBACD,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,SAnBc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,MAGF,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,GAAgB,EAAU,gBAA/C,IAErB,AAAO,oBACA,4BAAP,wCAKa,sBACb,4BAAQ,qBACD,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,SAnBc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,MAGF,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,EAAgB,EAAU,gBAA/C,IACS,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,GAAgB,EAAU,gBAA/C,IAErB,AAAO,oBACA,4BAAP,+BgB5qDF,AAAS,AAAgB,OACzB,AAAW,AAAkB,OAC7B,AAAI,EAAQ,SAAe,EAAQ,OACjC,AAAI,EAAM,KACD,AACL,EAAQ,MACJ,AAAiB,OACjB,AAAiB,sBAHvB,IAKK,AAAI,EAAM,KACf,AAAc,cAAqB,EAAM,EAA+B,SACxE,AAAI,IACK,AACL,EAAQ,MACJ,AAAiB,OACjB,AAAiB,sBAHvB,OAQC,aAAP,4BAtoDS,AAAwB,iBAAU,EAAM,eAA/C,4BAIO,AAA2B,iBAAU,EAAkB,EAAM,eAApE,kChB+xGa,sBACb,oDAAQ,qBACD,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,YA5Bc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,qBAI3B,cAAc,EAAgB,EAAU,gBAA/C,KAEO,cAAc,EAAgB,EAAU,gBAA/C,KAES,cAAc,GAAiB,EAAU,gBAAhD,IACK,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,GAAgB,EAAU,gBAA/C,IAEV,cAAa,GAClB,cAAc,GAAkB,EAAU,mBAF1B,OAQS,cAAc,EAAU,gBAA/B,IACU,cAAiB,EAAU,gBAAlC,SAMH,AACpB,cACE,GACA,6BACA,gBACA,oCAEK,4BAAP,IAGJ,AAAO,oBACA,4BAAP,kCAKa,sBACb,oDAAQ,qBACD,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OAKA,OAKA,OACA,OACA,OACA,OACA,OACA,YApCc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,qBAI3B,cAAc,EAAgB,EAAU,gBAA/C,KAEO,cAAc,EAAgB,EAAU,gBAA/C,KAES,cAAc,GAAiB,EAAU,gBAAhD,IACK,cAAc,EAAgB,EAAU,gBAA/C,IACO,cAAc,GAAgB,EAAU,gBAA/C,IAEV,cAAa,GAClB,cAAc,GAAkB,EAAU,mBAF1B,OASX,cAAa,EAClB,cAAc,EAAU,mBAFN,IAMb,cAAa,EAClB,cAAiB,EAAU,mBAFN,SAUH,AACpB,cACE,GACA,6BACA,gBACA,oCAEK,4BAAP,IAGJ,AAAO,oBACA,4BAAP,yDyBh5HgB,SAES,gHZz1BlB,cAAU,cAAK,AAAQ,oBAAS,cAAvC,4BI2iDA,AAAW,mBACJ,EAAQ,QAAsB,EAAQ,eAA7C,qCjBy7IA,AAAI,kCAAyB,AAAC,sDAC5B,AAAI,IACF,cACE,GACA,6BAAkB,uCAGpB,cACE,GACA,8FyB9/EmB,kFzB+sEZ,yBACF,sBACX,AAAO,EAAQ,sBACf,AAAc,mBAEd,AAAY,cAA4B,EAAW,mBACnD,AAAI,IACF,cAAmB,iBACZ,cAAa,EAAM,qCACxB,cAAkB,6BAAqB,YACvC,cAAkB,6BAAqB,sBACtC,gBAHH,IAKA,cAAmB,kBACZ,cAAkB,6BACvB,gBADF,sCA/OW,yBACF,sBAEX,cAAQ,qBACD,OAYA,OAgBA,OAMA,OA8DA,QAhGmB,GACV,0CACZ,AAAI,cAAiB,iBAAa,EAAqB,OACrD,cACE,GACA,6BAAuB,oCAEzB,cAAmB,IAAM,kBAAa,mBAC/B,6BAAP,IAEK,cAAyB,cAAO,EAAW,cAAW,iBAA7D,IAEuB,GACV,0CACb,AAAI,AAAC,cAAuB,cAAQ,oBAC3B,6BAAP,IAEF,AAAI,cAAa,EAAoB,SACnC,cACE,GACA,6BACA,oCAEF,cAAmB,IAAM,kBAAc,mBAChC,6BAAP,IAEK,cAA0B,cAAQ,EAAW,cAAW,iBAA/D,IAEkC,GACX,6BAA8B,iEACrD,AAAI,AAAC,KAAyB,6BAAP,OACd,QAGgB,GACF,0CACvB,AAAI,mBAEF,AAAoB,6BAAuB,SAC3C,AAAI,cAAoB,WACA,sBACtB,AAAI,AAAC,QAAiB,KACpB,cACE,GACA,6BAAuB,oCAElB,6BAAP,QAIa,GAAO,mCACxB,AAAI,IAAiB,iBAAuB,SAC1C,cAAsB,cAAkB,UAGvB,sBACrB,AAAI,AAAC,KACH,cACE,GACA,6BAAuB,oCAElB,6BAAP,IAEF,AAAO,+CAAkD,qBACzD,AAAI,cAAoB,YACP,GAAO,iEACtB,AAAe,cACb,GAAO,0CACP,cACA,EAA2B,QAE7B,AAAI,AAAC,KAAY,cAAoB,cAAgB,qCAAE,SAAU,mBAAa,+BAApE,OACW,GAAO,AAAC,qFAC7B,AAAO,gCAAqC,wBAC3B,qCACjB,AAAoB,sBACL,cAAkB,sBACjC,AAAU,cAAa,EAAM,qCAC3B,cAAoB,cAAgB,uCAClC,eAAiB,kBAAgB,EAAU,mCAC3C,mBACC,2BACH,cAAoB,cAAgB,uCAClC,eAAiB,kBAAgB,sBAChC,qCACF,OACI,cAAP,IAEA,AAAI,AAAC,KAAY,cAAoB,cAAgB,uCAAE,mBAAa,+BAA1D,OACW,GAAO,AAAC,wFACtB,cAAa,EAAM,uCACxB,cAAoB,cAAgB,uCAAE,mBAAa,2BACnD,cAAoB,cAAgB,EAAM,qCACzC,8DAHH,MAM6B,GACV,+CACR,uBACb,AAAO,iBAAe,wBACF,4CACpB,AAAO,iBAAsB,qBAC7B,AAAkB,cAAQ,YACL,cAA6B,GAAyB,WAC3E,AAAI,AAAC,KACH,cACE,GACA,6BAAuB,oCAElB,6BAAP,OAEmB,cAA6B,GAAyB,WAC3E,AAAI,AAAC,KACH,cACE,GACA,6BAAuB,oCAEzB,cAAmB,IAAM,iCAAsC,mBACxD,6BAAP,IAEF,AAAO,+CAAkD,wBAC1C,uBACf,AAAe,cACb,GAAO,2CACP,cACA,EAA2B,WAEP,4CAAwC,cACxC,4CAAwC,WAC9D,AAAI,AAAC,cAAuB,oBAC1B,cACE,GACA,6BACA,6BACA,oCAEF,cAAmB,IAAM,iCAAsC,mBACxD,6BAAP,IAEF,AAAkB,cAAuB,GAAO,2CAAkB,cAAiB,UACjE,uBAClB,AAAI,OACe,cAAkB,0BACjB,cAAkB,0BACnB,sCACjB,AAAU,cAAa,EAAM,uCAC3B,cAAoB,cAAgB,uCAClC,eAAiB,kBAAkB,EAAU,mCAC7C,eAAiB,kBAAmB,EAAa,mCACjD,mBACC,2BACH,cAAoB,cAAgB,uCAClC,eAAiB,kBAAkB,4CACnC,eAAiB,kBAAmB,sDACnC,qCACF,sBACI,cAAP,IAEO,cAAoB,cAAgB,uCACzC,SACA,SACA,mBACC,+BAJH,MAOK,AACP,cACE,GACA,uCAIC,6BAAP,oCA1Tc,yBACC,yBACJ,yBACE,cAA0B,cAAY,+BACnD,AAAI,AAAC,KAAe,4CAAP,OACQ,yBACG,sBAIxB,cAAQ,qBACD,OAMA,OAaA,OAOA,OAyBA,QAnDoB,AACnB,AAAC,cAAuB,iDAAgB,oBACnC,4CAAP,KAIoB,AACtB,AAAI,6BAAyB,mBAC3B,cACE,GACA,6BACA,oCAEK,4CAAP,OAEW,AAAC,yDACd,AAAI,cAAoB,QAAwB,cAAiB,oBACjE,GAEkC,GACV,6CACD,cAAyB,6BAChD,AAAI,AAAC,KAAyB,4CAAP,OACd,QAGgB,GACF,0CACvB,AAAI,mBACF,AAAI,6BAAyB,mBAC3B,cACE,GACA,6BACA,oCAEK,4CAAP,QAGiB,sBACrB,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,oCAEb,4CAAP,IAEF,AAAO,+CAAkD,wBAC5C,4CAAwC,UACrD,AAAI,cAA4B,QAAwB,cAAiB,oBACzE,GAE+B,GAClB,AAAC,yDACd,AAAO,iBAAe,wBACF,0CACpB,AAAkB,cAAQ,YACT,cAA6B,GAAyB,UACvE,AAAI,AAAC,QACc,cAA6B,GAAyB,UACvE,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,qCAGpB,cACE,GACA,6BAAkB,qCAGf,4CAAP,OAEmB,qCAErB,AAAO,iBAAyB,wBACnB,cAAe,UAE5B,AAAI,cAAwB,QAAwB,cAAiB,oBACrE,AAAI,AAAC,KAAe,sCAClB,cACE,GACA,uCAGJ,GAEO,AACP,cACE,GACA,6BAAkB,oCAEb,4CAAP,IAKJ,AAAO,EAAc,sBACrB,AAAgB,cAAuB,cAAiB,6BACxC,sBACT,cACL,cACA,cAAuB,EAAW,cAAW,cAAY,EAAO,kBAChE,cACA,cACA,cACA,cACA,EAAkB,mBAPpB,gCAttBa,sBACb,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cANqB,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,EAAiB,EAAU,gBAAhD,IAErB,AAAO,oBACA,4BAAP,gCAKa,sBACb,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cANqB,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,GAAiB,EAAU,gBAAhD,IAErB,AAAO,oBACA,4BAAP,gCAKa,sBACb,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cANqB,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAkB,EAAU,gBAAjD,IACK,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,GAAiB,EAAU,gBAAhD,IAErB,AAAO,oBACA,4BAAP,4BgBplGO,AAAyB,iBAAU,EAAW,EAAQ,EAAS,eAAtE,4BhBz/CO,iBAAyB,QAAK,iBAAuB,eAA5D,0CAklJa,sBACb,4BAAQ,qBACD,OAQA,OACA,OACA,OACA,OAKA,OACA,OAyCA,OACA,OAiCA,OACA,OAsDA,OAyCA,QA3LI,cACL,cAAW,KACX,cAAc,EAAgB,EAAW,cAAW,QACpD,EACA,kBALgB,OAWD,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,qBAIlC,AACjB,AAAI,kCAGF,AACE,AAAgB,KAAc,KAC9B,AAAgB,KAAc,SAE9B,AAAiB,AAAiB,OAClC,AAAiB,AAAiB,OAClC,cAAmB,iBACZ,cAAW,EAAQ,AACxB,EAAQ,qBACR,EAAQ,+CAFV,QAMW,sBACf,AAAI,AAAC,QACa,6BAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,sBAEb,6BAAP,IAEF,AAAO,iBAAkB,qBACzB,iBAAiC,6BAA8B,kDAA8B,qCAE/F,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEF,AAAW,cAAoB,cAAU,qCAAE,SAAU,mBAAa,qBAClE,AAAI,iBAAY,KAGd,AAAO,cAA4B,EAAM,oBAEpC,cAAP,KAGiB,AACjB,AAAI,kCAGF,AACE,AAAgB,KAAa,KAC7B,AAAgB,KAAc,SAE9B,AAAgB,EAAQ,AAAoB,OAAW,AAAqB,sBAC5E,AAAiB,EAAQ,AAAoB,OAAY,AAAqB,sBAC9E,AAAa,AAAQ,EAAW,OAChC,cAAmB,iBACZ,cAAW,EAAQ,UAAS,EAAS,4BAA5C,QAGW,sBACf,AAAI,AAAC,QACa,6BAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,sBAEb,6BAAP,IAEF,AAAO,iBAAkB,qBACzB,iBAAiC,6BAA8B,kDAA8B,qCAE/F,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEK,cAAoB,cAAU,qCAAE,SAAU,mBAAa,+BAA9D,KAGmB,AACnB,AAAe,kCACf,AAAI,kCAGF,AACE,AAAgB,KAAa,KAC7B,AAAgB,KAAc,SAE9B,AAAI,IACF,AAAiB,EAAQ,AAAoB,OAAW,AAAqB,sBAC7E,AAAiB,EAAQ,AAAoB,OAAY,AAAqB,sBAC9E,AAAa,AAAQ,EAAW,OAChC,cAAmB,iBACZ,cAAW,EAAQ,UAAS,EAAS,4BAA5C,IAEA,AAAiB,AAAiB,OAClC,AAAiB,AAAiB,OAClC,cAAmB,iBACZ,cAAW,EAAQ,AACxB,EAAQ,qBACR,EAAQ,+CAFV,UAOS,IACX,kBACA,uBACJ,AAAI,AAAC,QACa,6BAAoB,IAChC,IACA,wBAEJ,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,IAAW,IAAW,uBAEnC,6BAAP,IAEF,AAAO,iBAAkB,wBACd,6BAA8B,kDAA8B,mBACvE,AAAI,IACF,cAAsB,kBAEtB,cAAsB,mBAG1B,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEK,cAAoB,cAAU,qCAAE,SAAU,mBAAa,+BAA9D,IAEiB,AACjB,AAAI,kCAGF,AACE,AAAgB,KAAc,KAC9B,AAAgB,KAAc,SAE9B,AAAiB,AAAiB,OAClC,AAAiB,AAAiB,OAClC,cAAmB,iBACZ,cAAW,AAAkB,GAAW,sBAA/C,QAGW,sBACf,AAAI,AAAC,QACa,6BAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,sBAEb,6BAAP,OAEc,cAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,uBAEb,6BAAP,IAEF,AAAO,iBAAkB,qBACzB,iBAAiC,6BAA8B,kDAA8B,qCAE/F,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEK,cAAoB,cAAU,qCAAE,SAAU,mBAAa,+BAA9D,IAGiB,AACjB,AAAI,kCAGF,AACE,AAAgB,KAAc,KAC9B,AAAgB,KAAc,SAE9B,AAAiB,AAAiB,OAClC,AAAiB,AAAiB,OAClC,cAAmB,iBACZ,cAAW,AAAc,EAAW,oBAA3C,QAGW,sBACf,AAAI,AAAC,QACa,6BAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,sBAEb,6BAAP,OAEc,cAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,uBAEb,6BAAP,IAEF,AAAO,iBAAkB,qBACzB,iBAAiC,6BAA8B,kDAA8B,qCAE/F,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEK,cAAoB,cAAU,sCAAE,SAAU,mBAAa,+BAA9D,IAGJ,AAAO,oBACA,6BAAP,wCAKa,sBACb,4BAAQ,qBACD,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OACA,SAnBc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,EAAiB,EAAU,gBAAhD,IACS,cAAc,GAAmB,EAAU,gBAAlD,MAGF,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,EAAiB,EAAU,gBAAhD,IACS,cAAc,GAAmB,EAAU,gBAAlD,IACK,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,GAAiB,EAAU,gBAAhD,IAErB,AAAO,oBACA,4BAAP,oCAKa,sBACb,4BAAQ,qBACD,OACA,OAKA,OACA,OACA,OACA,OACA,OACA,OAKA,OACA,OACA,OACA,OA2BA,SA7Cc,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAiB,EAAU,iBAAhD,IACO,cAAc,EAAiB,EAAU,iBAAhD,IACS,cAAc,GAAmB,EAAU,iBAAlD,MAGF,AACjB,AAAY,cAA4B,EAAU,mBAClD,AAAY,cAA4B,EAAW,oBAG3B,cAAc,EAAiB,EAAU,iBAAhD,IACO,cAAc,EAAiB,EAAU,iBAAhD,IACS,cAAc,GAAmB,EAAU,iBAAlD,IACF,GACF,sBACf,AAAI,AAAC,QACa,6BAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,sBAEb,6BAAP,OAEc,cAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,uBAEb,6BAAP,IAEF,AAAO,iBAAkB,qBACzB,iBAAiC,6BAA8B,kDAA8B,qCAE/F,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEK,cAAoB,cAAU,qCAAE,SAAU,mBAAa,+BAA9D,IAEiB,GACF,sBACf,AAAI,AAAC,QACa,6BAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,sBAEb,6BAAP,OAEc,cAAoB,uBACpC,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,uBAEb,6BAAP,IAEF,AAAO,iBAAkB,qBACzB,iBAAiC,6BAA8B,kDAA8B,qCAE/F,AAAI,AAAC,QAAY,AAAC,cAAqB,uBAC9B,6BAAP,IAEK,cAAoB,cAAU,qCAAE,SAAU,mBAAa,+BAA9D,IAGJ,AAAO,oBACA,6BAAP,kCAKa,sBACb,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OAYA,OACA,OACA,OACA,OACA,OACA,QArBsB,aAAP,OAMX,cACL,EACA,EACA,cACE,EACA,EACA,cAAW,iBAAY,uBARV,KAaO,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAkB,EAAU,gBAAjD,IAEvB,AAAO,oBACA,4BAAP,kCAMa,sBACb,wBAAQ,qBACD,OACA,OACA,OAYA,OACA,OAYA,OACA,OACA,OACA,OACA,OACA,QAhCsB,aAAP,KAIX,cACL,EACA,cAA4B,EAAU,iBACtC,cACE,EACA,EACA,cAAW,iBAAY,uBARV,KAeV,cACL,EACA,cAA4B,EAAU,iBACtC,cACE,EACA,EACA,cAAW,iBAAY,uBARV,IAYO,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,EAAiB,EAAU,gBAAhD,IACS,cAAc,GAAmB,EAAU,gBAAlD,IACK,cAAc,EAAiB,EAAU,gBAAhD,IACO,cAAc,EAAiB,EAAU,gBAAhD,IACS,cAAc,GAAmB,EAAU,gBAAlD,IAEvB,AAAO,oBACA,4BAAP,kCAKa,sBACb,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OAYA,OACA,OACA,OACA,OACA,OACA,QArBsB,aAAP,OAMX,cACL,EACA,cAA4B,EAAU,iBACtC,cACE,EACA,EACA,cAAW,iBAAY,uBARV,KAaO,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAmB,EAAU,gBAAlD,IAEvB,AAAO,oBACA,4BAAP,gCAKa,sBACb,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cAJqB,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAkB,EAAU,gBAAjD,IAEvB,AAAO,oBACA,4BAAP,gCAKa,sBACb,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,YANqB,cAAc,EAAgB,EAAU,gBAA/C,KAEO,cAAc,EAAgB,EAAU,gBAA/C,KAEO,cAAc,EAAgB,EAAU,gBAA/C,KAES,cAAc,GAAiB,EAAU,gBAAhD,IAEvB,AAAO,oBACA,4BAAP,gCAKa,sBACb,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,YANqB,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAEO,cAAc,EAAiB,EAAU,gBAAhD,KAES,cAAc,GAAkB,EAAU,gBAAjD,IAEvB,AAAO,oBACA,4BAAP,gpCW9gKgB,sBAChB,AAAI,AAAC,KAAW,iBAA6B,4BAC7C,cAAc,EAAU,oDKy/EjB,AAAiC,EAAM,8BAA9C,6BAhBA,kBAAQ,AAAkC,QACnC,OACA,OACA,OACA,OACA,OACA,OACA,OACA,eAA6B,cAAoB,gBAA3B,IAEtB,aAAP,wCLh+EiB,sBACjB,AAAI,AAAC,KAAY,iBAA+B,4BAChD,cAAe,EAAU,qDI4FzB,AAAI,mBAAyB,cAAoB,8BAA3B,IACjB,AAAI,mBAA2B,aAAP,KAE7B,AAAI,mBACK,mBAAyB,iBAAe,wBAC7C,AAAC,QACD,iBAA6B,kCAF/B,IAKK,iBAAa,6BAApB,qCfsrGa,yBACF,yBACC,sBASZ,AAAe,IAEf,AAAe,mBACf,4EAAQ,MACD,QAmCA,QAmCA,QAmCA,QAoCA,QACA,QAmDA,QACA,QAmDA,QAGA,QACA,QA2CA,QACA,QA4CA,QACA,QA4CA,QACA,QA4CA,QACA,QA4CA,QACA,QA4CA,QACA,QA0BA,QACA,QA2BA,QACA,QA0BA,QACA,QA4CA,QACA,QA4CA,QACA,QA+CA,QA+EA,QAmFA,QAn4BgB,AACnB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,cAAgB,UAClE,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAGF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAEZ,AAAO,cAAY,EAAU,EAAW,mBACxC,cAAmB,kBACnB,GAEsB,AACtB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,cAAgB,UAClE,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAGF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAEZ,AAAO,cAAY,EAAU,EAAW,mBACxC,cAAmB,kBACnB,GAE0B,AAC1B,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,cAAgB,UAClE,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAM,+BAAqB,kCAE/C,cAAmB,iBACZ,6BAAP,IAGF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAEZ,AAAO,cAAY,EAAU,EAAW,mBACxC,cAAmB,kBACnB,GAE6B,AAC7B,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,cAAgB,UAClE,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAM,+BAAqB,kCAE/C,cAAmB,iBACZ,6BAAP,IAGF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAEZ,AAAO,cAAY,EAAU,EAAW,mBACxC,cAAmB,kBACnB,IAIwB,AACxB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,AAAsB,gCAAsB,+BAAqB,kCAErF,cAAmB,iBACZ,6BAAP,IAEF,AAAI,mBACF,AACE,AAAqB,cAAQ,UAC7B,AAAqB,cAAQ,QAE7B,cACE,GACA,uCAGJ,AAAI,AAAe,UAAc,AAAe,QAC9C,cACE,GACA,wCAIN,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAEZ,AAAO,cAAY,EAAU,EAAW,cAAY,mBACpD,cAAmB,kBACnB,IAG6B,AAC7B,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,sBACrB,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,AAAsB,gCAAsB,+BAAqB,kCAErF,cAAmB,iBACZ,6BAAP,IAEF,AAAI,mBACF,AACE,AAAqB,cAAQ,UAC7B,AAAqB,cAAQ,QAE7B,cACE,GACA,uCAGJ,AAAI,AAAe,UAAc,AAAe,QAC9C,cACE,GACA,wCAIN,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAEZ,AAAO,cAAY,EAAU,EAAW,cAAY,mBACpD,cAAmB,kBACnB,GAGO,cAAuB,cAAM,cAAO,6BAD1B,IAGK,AAAW,KAClB,AACf,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAGJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,mBACzC,GAEuB,AAAW,KAClB,AAChB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,mBACzC,GAE0B,AAAW,KAClB,AACnB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,mBACzC,GAEmC,AAAW,KAClB,AAC5B,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,qCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAM,oCAEnB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAM,+BAAqB,kCAE/C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,cAAY,mBACrD,GAEuB,AAAW,KAClB,AAChB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,cAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,cAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,mBACzC,GAEyB,AAAW,KAClB,AAClB,AAAW,cAAuB,cAAM,6BAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,cAAY,mBACrD,GAEmC,AAAW,KAClB,AAC5B,AAAW,cAAuB,cAAM,4CAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAGJ,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAM,oCAEnB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,UACxC,sBAEZ,AAAO,cAAa,EAAU,EAAW,mBACzC,GAEyC,AAAW,KAClB,AAClC,AAAW,cAAuB,cAAM,4CAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAGJ,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAM,oCAEnB,4CAAP,IAGF,AAAY,cAAuB,cAAO,cAAU,UACxC,sBAEZ,AAAO,cAAa,EAAU,EAAW,mBACzC,GAEqD,AAAW,KAClB,AAC9C,AAAW,cAAuB,cAAM,4CAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAGJ,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAO,oCAEpB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,UACxC,sBAEZ,AAAO,cAAc,EAAU,EAAW,mBAC1C,GAE2B,AAAW,KAClB,AACpB,AAAW,cAAuB,cAAM,4CAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,mBACzC,GAEqB,AAAW,KAClB,AACd,AAAW,cAAuB,cAAM,4CAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAY,EAAU,EAAW,mBACxC,GAEuB,AAAW,KAClB,AAChB,AAAW,cAAuB,cAAM,4CAC7B,yBAGU,cAA2B,sCAChD,AAAI,OACa,cAA8B,cAC7C,AAAI,IACF,AAAO,cAA2B,cAAU,cAAM,EAAU,cAAU,cAAO,mBAC7E,IAIJ,AAAI,IACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,gBAAK,oCAElB,6BAAP,IAEF,AAAY,cAAuB,cAAO,cAAU,aAC3B,8BAEzB,AAAY,cAAuB,cAAO,6BAC9B,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,QAAc,AAAC,qBAClB,cACE,GACA,6BAAkB,gBAAK,+BAAqB,kCAE9C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,QAEd,AAAO,cAAa,EAAU,EAAW,mBACzC,GAK8B,GACnB,uBACX,AAA2B,EAAc,KACzC,AAAW,cAAuB,cAAM,6BAA2B,UACxD,yBAEK,cAAc,oBAC9B,cAAmB,iBAGnB,AAAI,EAAkB,SAAa,EAAkB,OACnD,AAAW,cAAmB,EAAU,cAAU,mBAGlD,AAAe,cAAuB,OACtC,AAAI,EAAY,KACd,AAAO,KAGP,AAAY,cAAuB,cAAO,cAAU,UACxC,sBACZ,AAAY,cAAmB,EAAW,cAAW,mBAGrD,AAAI,EAAY,KACd,AAAO,IACP,cAAa,kBAEb,AAAO,cAAU,EAAU,EAAW,cAAW,UACjD,cAAiB,iBACjB,cAAc,EAAM,mBAGxB,cAAmB,iBACnB,cAAmB,mBAGnB,AAAY,cAAuB,cAAO,cAAU,UACxC,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,gBAAM,+BAAqB,kCAE/C,cAAmB,iBACZ,6BAAP,IAEF,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAGZ,AAAI,AAAO,cAAgC,SACzC,AAAO,cACL,cAAmB,EAAU,6BAAkB,iBAC/C,EACA,WAKc,cAAkB,uBAClC,AAAI,AAAC,cAAiB,EAAU,oBAAW,cAAkB,iBAAiB,MAC9E,AAAI,cAAe,EAAU,mBAAW,cAAkB,iBAAiB,MAC3E,AAAO,cACL,cAAmB,cAAiB,iBAAiB,EAAU,2BAAqB,cAAU,iBAC9F,EACA,cAAiB,iBAAiB,0BAGtC,cAAiB,iBACjB,cAAc,EAAM,iBACpB,cAAmB,iBACnB,cAAmB,kBAErB,GAEkB,GACP,uBACX,AAA2B,EAAc,KACzC,AAAW,cAAuB,cAAM,6BAA2B,UACxD,yBAEK,cAAc,WAC9B,cAAmB,iBAGnB,AAAI,EAAkB,SAAa,EAAkB,OACnD,AAAW,cAAmB,EAAU,cAAU,mBAGlD,AAAe,cAAuB,OACtC,AAAI,EAAY,KACd,AAAO,KAGP,AAAY,cAAuB,cAAO,cAAU,UACxC,sBACZ,AAAY,cAAmB,EAAW,cAAW,mBAGrD,AAAI,EAAY,KACd,AAAO,IACP,cAAa,kBAEb,AAAO,cAAU,EAAU,cAAW,KAAI,OAC1C,cAAiB,iBACjB,cAAc,EAAM,mBAGxB,cAAmB,iBACnB,cAAmB,mBAGnB,AAAY,cAAuB,cAAO,cAAU,UACxC,yBACC,AAAgB,cAAU,cAAW,wBAClD,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,gBAAM,+BAAqB,kCAE/C,cAAmB,iBACZ,6BAAP,IAEF,AAAmB,cAAY,UAAuB,cAAa,YACnE,AAAW,cAAuB,EAAU,cAAU,cAAY,EAAO,sBAC9D,OACX,AAAY,cAAuB,EAAW,cAAW,cAAY,EAAO,sBAChE,OAGZ,AAAI,AAAO,cAAgC,SACzC,AAAO,cACL,cAAmB,EAAU,cAAU,iBACvC,EACA,WAKS,cAAkB,uBAC7B,AAAgB,mBAChB,AAAI,AAAC,cAAiB,EAAU,oBAAW,cAAkB,EAAW,MACxE,AAAI,cAAe,EAAU,mBAAW,cAAkB,EAAW,MACrE,AAAO,cACL,cAAmB,cAAiB,EAAW,EAAU,2BAAqB,cAAU,iBACxF,cAAiB,EAAW,oBAC5B,QAGJ,cAAiB,iBACjB,cAAc,EAAM,iBACpB,cAAmB,iBACnB,cAAmB,IACf,GACA,kCAEN,GAEa,AACb,cACE,GACA,6BAAkB,uBAEpB,cAAmB,kBACZ,6BAAP,IAEO,AACP,AAAO,oBACP,AAAO,mCAGX,AAAI,AAAC,KAAiB,cAAP,OACA,0BACF,cAA0B,cAAM,+CAC7C,AAAI,AAAC,KAAe,6BAAP,OACI,cAA0B,uBAC3C,AAAI,AAAC,QAAyB,UAC9B,AAAI,AAAC,6BAAwC,sBAC3C,cACE,GACA,6BAAkB,8CAA6B,oCAE1C,6BAAP,IAEK,cACL,cACA,EACA,6BACA,cACA,6BACA,6BACA,EAAkB,mBAPpB,+BAyhIA,AAAI,4BAA2C,EAC/C,cAA4C,QACjC,GAAO,mDAClB,cAAoC,cAAe,6BAAW,6MiB1lNxD,EAA8B,cAAM,cAAY,EAAO,iEAWtD,EACL,6BACA,6BACA,iBACA,6BACA,6BACA,6BACA,iBACA,2CARF,yDLmiDiC,sNKztF3B,EAAmB,sEApuBlB,EAAa,AAAgC,cAAM,+BAAQ,EAAM,4BAAxE,2FAurByB,sBAJnB,EAAM,2KAiEN,EAAoB,EAAY,sEA3uB/B,EAAkB,cAAM,cAAe,EAAY,4BAA1D,wKAwwBM,EAAuB,EAAY,sEA9vBlC,EAAqB,cAAY,cAAY,cAAkB,EAAY,4BAAlF,+BAwdO,EAAwB,cAAM,cAAY,EAAO,cAAgB,cAAW,cAAM,EAAW,4BAApG,kCLmQY,0BACI,sBAChB,AAAI,AAAC,KACH,iBAAwC,AAAwB,0BAC9D,AACE,AAA0B,cAAmB,6BAC7C,EAAM,EAAO,6BAEf,EAAM,EAAO,wCAGV,AACL,AAAgC,cAAM,+BACtC,EAAM,EAAO,EAAM,cAAW,EAAM,EAAgB,4BAFtD,kEG6ByB,sBAEN,cAIO,IAAiB,kBAAwB,wHf6kPpD,sBACf,AAAI,IAEF,AAAI,cAAY,UAA8B,cAAP,IAEvC,AAAI,AAAC,cAAsB,SAAwB,cAAqB,yBAIxD,yBACc,AAAS,qCACvC,AAAI,OACa,cAAuB,cAAW,sBACjD,cAA8B,cAAW,oBAC9B,EACT,cACA,EACE,cACA,cAEA,AAAC,GAAqB,mGAExB,EACA,AACE,6BACA,4CACA,6BACA,6BACA,gCACA,+CAEF,0BAKS,EACT,cACA,EACE,cACA,cACA,6BAA2C,cACzC,IAAuB,0CAG3B,EACA,AAAiB,6BAAc,yBAAI,6BAAoB,qDACvD,uBAIJ,cAAa,QACb,6BAAuC,eAAI,iBAC3C,AAAI,cAAiB,UACnB,cAAa,SAEf,cAAoC,oBACtB,sBACd,AAAI,AAAC,KAAS,iBAAkC,4BAChD,cAAY,eAAe,oCAER,yBACR,sBACX,cAAmB,oBAGH,yBACH,sBACb,AAAkB,qCACN,YASZ,cACE,cAA+B,cAAe,SAEhD,AAAI,OACmB,sBACrB,AAAoB,sBACL,EAAyB,EAAI,WAC5C,cAAS,EAAK,cAAiB,EAAG,QAC7B,AAAQ,MAAG,EAAK,KACnB,cAAS,EAAK,cAAiB,EAAG,cAAe,EAAI,2BADnB,AAAE,WAGtC,cACE,cAAiB,EACf,cAAoB,GAAO,0DAAgC,cAAU,cAAY,KACjF,wCAIN,cAA0C,cAAe,kBACzD,cACE,cAAiB,EAAG,SAEtB,cAAmB,oBAGN,yBACE,YACf,AAAkB,EAAI,mCACtB,AAAgB,mBAChB,AAAI,EAAY,KACT,AAAQ,MAAa,EAAI,KAAgB,cAAc,cAAO,uCAA1B,AAAE,YAE7C,AAAc,cACZ,6BACA,iBACA,iBACA,cACA,cAAe,cAAO,UAExB,cAAkB,cAAQ,MAGrB,cAAP,kCA1lFe,sBACf,AAAI,KAAY,EAAY,MAC1B,cACE,GACA,sCAEK,aAAP,IAIF,AAAc,mBACd,AAAI,IACF,cACE,GACA,6BAAkB,uBAEb,aAAP,IAGF,AAAc,mBACd,AAAc,kCAGd,AAAI,EAAe,KACjB,cACE,EAAU,KACN,IACA,IACJ,6BAAkB,mBAAoB,wBAEjC,aAAP,IAIF,AAAI,EAAe,KAAW,AAAC,SAC7B,cACE,GACA,6BAAkB,mBAAoB,wBAEjC,aAAP,IAGK,aAAP,4BiBtxKO,cAAgB,gBAAvB,+BjBmzKA,AAAmB,sBACH,sBAChB,AAAI,AAAC,cACH,cACA,EACA,EAAW,GACX,oBAEA,cAAmB,gCACZ,2CAAP,IAEF,AAAI,cAAsB,QAAwB,cAAiB,uBAG9C,qCACrB,AAAI,cAAkB,SAA4B,0BACnC,sBACb,AAAO,iBAAe,qBACtB,cAA8B,iDAAe,kBAI/C,AAAI,cAAsB,QAA2B,AAAC,cAAY,eAA2B,wBAC3F,AAAO,AAAC,cAAY,+BACF,sBAClB,AAAI,cAAqB,qBACvB,cACE,GACA,6BAAkB,wCAGC,sBACrB,AAAO,EAAgB,uCAGZ,EAAyB,UAC/B,AAAQ,MAAG,EAAI,KAClB,cAAK,EAAK,cAAuB,cAAoB,iBAAI,cAAe,iBAAI,QAD5C,AAAE,WAIpC,cAAiB,kBACjB,AAAW,cAAoB,cAAU,cAAM,EAAS,AAAC,EAAc,GAAyB,QAChG,kBACO,aAAP,KAKJ,AAA2B,IAAU,EAAe,IAAI,QACzC,EAAyB,UACxC,AAAY,IACZ,AAAI,IACF,cAAS,EAAK,KACd,AAAQ,QAEW,sBAChB,AAAQ,MAAG,EAAI,QACF,cAAe,UAC/B,AAAgB,cAAuB,cAAoB,iBAAI,cAAW,OAC1E,cAAS,EAAS,KAHc,AAAE,OAAG,AAAE,WAKzC,AAAO,EAAS,qBACT,cAAoB,cAAU,cAAU,cAAY,AAAC,EAAc,GAAyB,iBAAnG,iEAhE2B,0IyB79KE,WAEQ,KAEZ,i1BzBu1KzB,AAAI,cAAuB,QAAwB,cAAiB,oBAEpE,AAAmC,OAIV,yBACD,sBACxB,AAAI,mBACF,AAAI,AAAC,cAAa,UAChB,cACE,GACA,6BAAkB,wCAGN,6BACd,GAAO,0CACP,cACA,2DACA,AAAS,2DACT,iCAGS,yBACH,EACR,cACA,cACA,cACA,6BACA,iBAAe,KACX,AAAC,qDACD,eACJ,cACA,cACA,UAGF,AAAI,cAAa,YAEF,GAAO,qDACL,GAAG,wCAAiC,uIAEpC,uBAEjB,AAAO,eAAqB,sCACnB,GAAO,eAAqB,kDAC9B,AAAG,mBAAH,oBAAP,yDyB70KyB,iHTorCzB,AAAW,cAAuB,cAAa,OAC3C,GACA,qBAEJ,AAAW,AAAc,mBACzB,AAAU,IACN,AACE,iBAAU,EAAM,EAAO,EAAM,IAAW,kBAAkB,GAAG,EAAQ,KAEvE,AACE,iBAAU,EAAM,EAAO,EAAM,IAAW,kBAAkB,GAAG,EAAQ,OAE3E,AAAe,IACR,aAAP,oChBy2Ja,sBACb,AAAkB,IAAW,kBAAkB,KAC/C,AAAmB,IACnB,AAAmB,mBACnB,AAAkB,OACG,yBACJ,sBACjB,AAAmB,mBACnB,AAAkB,IAClB,AAAI,mBACF,AAAE,OACF,AAAE,OACF,AAAE,QAEJ,AAAO,EAAe,qBAGtB,AAAI,EAAc,KAChB,AAAI,AAAC,QACQ,EAAU,UACrB,cAAkB,SAEC,sBAChB,AAAQ,MAAc,EAAI,KAC7B,cAAc,cAAc,cAAe,wBADA,AAAE,eAQ3B,sBACtB,AAAkB,kCAClB,AAAI,AAAe,EAAa,oBAAc,QACjC,yBACA,cAAkB,oDAC7B,AAAgB,mBAChB,AAAc,cAAa,EAAM,qCAC/B,cAAiB,EAAW,EAAa,YACzC,cAAkB,cAAiB,cAAW,eAC9C,cAAiB,EAAW,sBAC3B,QAEH,AAAc,cAAa,EAAM,qCAC/B,cAAkB,cAAiB,cAAW,eAC9C,mBACC,QAEL,AAAI,IAAU,cAAqB,cAAW,kBAC9C,AAAW,cACT,EACA,cAAY,EAAG,EAAO,EAAa,iBACnC,cACA,iBACA,wBAEF,cAAmB,iBACZ,cAAP,+BA7FA,AAAmB,mBAEnB,AAAI,AAAC,cACH,cACA,EACA,EAAW,GACX,oBAEO,2CAAP,IAGF,AAA2B,IAAU,EAAe,IAAI,QACzC,EAAyB,UACxC,AAAY,IACZ,AAAI,IACF,cAAS,EAAK,KACd,AAAQ,QAEW,sBAChB,AAAQ,MAAG,EAAI,KAClB,cAAS,EAAS,cAAuB,cAAoB,iBAAI,cAAe,iBAC9E,QAF8B,AAAE,OAAG,AAAE,WAKzC,AAAO,EAAS,qBACT,cAAsB,cAAW,EAAa,cAAY,cAAU,gBAA3E,8BqBjzMA,cAAoB,EAAM,EAAyB,cAAO,cAAc,cAAM,cAAM,2DrBs5KvE,yBACF,sBAGX,AAAI,gCAA8B,QACrB,yBACU,sBACrB,AAAI,AAAC,cAAkB,UACrB,cACE,GACA,sCAEK,6BAAP,OAGW,GAAO,kDACpB,AAAO,iBAAe,wBACF,6CACI,sBACxB,AAAI,AAAC,QAAqB,mCACxB,cACE,GACA,qDAEK,6BAAP,OAEc,GAAO,cAAiB,kDACxC,AAAkB,qCAEK,cAAuB,cAAmB,sBACjE,cAA8B,cAAmB,iBACjD,AAAgB,cACd,cACA,6BACA,cACA,cAAiB,iBAAiB,iBAIpC,AAAI,cACF,GACA,UAEA,cACE,GACA,sCAEK,6BAAP,IAEF,cAAS,GAAyB,OAClC,cAAmB,kBACZ,cAAiB,iBAAiB,EAAW,+CAApD,OAIW,6BAA+B,6BAAuB,+BACnE,AAAI,AAAC,KAAe,6BAAP,OACQ,qCAGrB,MAAQ,qBACD,OAWA,QAX+B,GACV,0CACxB,AAAI,cAA+B,QAE1B,cAAkC,cAAmB,cAAY,6BAAxE,OAEqB,6BAA6B,cAAY,cAAmB,6BACnF,AAAI,AAAC,KAAyB,4CAAP,OACd,QAGgB,GACF,0CACvB,AAA6B,IAC7B,AAAI,cAAoB,SACtB,AAAU,cACR,GAAO,0CACP,GAAO,wEACP,EAA2B,SAGxB,cACL,cACA,6BACA,cACA,EACA,iBALF,IAWJ,AAAkB,cAAuB,6BAAuB,8BAChD,qCAChB,AAAI,IACK,cACL,cACA,EACA,6BACA,cACA,EACA,EAAkB,mBANpB,IASF,cACE,GACA,6BAAkB,qDAEpB,AAAI,iBAAe,QACK,AAAC,yDACvB,AAAI,IACF,cACE,GACA,6BAAkB,4CqB5gLF,EACA,EACA,OrB8gLf,6BAAP,kCAi3BkB,sBAClB,AAAqB,sBACT,EAAyB,mBAChC,AAAQ,MAAG,EAAI,KAClB,cAAM,EAAK,cAAuB,cAAY,iBAAI,eAChD,EAA2B,SAFK,AAAE,WAKtC,cAAM,EAAkB,cAAuB,cAAY,iBAAiB,cAAgB,QACrF,6BAAoB,cAAO,8CAAlC,+LAQa,yBACU,yBACN,6BAAgC,cAAkB,8CACnE,AAAI,OACmB,cAA6B,qCAClD,AAAI,IACF,AAAkB,6BAAoB,YACrB,cAA8B,GAAyB,UACxE,AAAI,OACa,GAAO,iEACtB,AAAc,cAAuB,cAAkB,cACrD,OAEF,AAAI,AAAC,KAAe,sCAClB,cACE,GACA,uCAGG,cAAuB,cAAY,oCACxC,kCACC,cAAY,EAAS,gBAFxB,KAKJ,cACE,GACA,4CAA6B,uCAG1B,4BAAP,uYAv2JA,AAAO,cAAY,UAAyB,AAAC,cAAY,mCAC3C,yBACM,sBACpB,AAAI,AAAC,QAGiB,sBACpB,AAAgB,kCAChB,AAAI,AAAC,KAAW,AAAY,KAC5B,AAAY,EAAY,oBACxB,cAAmB,qBAGF,GAAO,6BAA2B,6BAA2B,oCAAE,kFACtE,wBACV,AAAO,cAAsB,gBAAU,EAAO,0CAC9C,AAAO,cAAsB,gBAAQ,EAAG,0CACxC,iBAAyC,cAA6B,wCAEjE,EAAQ,mBAAsB,EAAQ,yDAA7C,sCA41JkB,qCAClB,AAAO,AAAC,uCACG,yBACU,sBACrB,AAAc,+CAA+B,KAC7C,AAA8B,AAAC,UAAW,EAAkB,UAC5C,EACd,OACO,IAAU,iCAAwB,aAAe,4JACpD,6CACJ,cACA,cACA,cAG4B,AAAS,wCAC1B,yBAIa,sBAC1B,AAAI,OACkB,yBACC,sBACrB,AAA2B,sBAGN,sBACrB,AAAoB,mBACpB,AAAI,EAAuB,KACzB,cACE,GACA,6BAAkB,mBAA0B,wBAEvC,6BAAP,IAIG,AAAQ,MAAG,EAAI,QACE,cAAe,UACnC,AAAI,AAAC,AAAc,sCACE,6BACjB,6BACA,6BACA,6BAEF,AAAI,AAAC,KAAqB,6BAAP,IACnB,AAAI,AAAC,cAAe,iBAA0B,sBAC5C,cACE,GACA,6BAAqB,cAAe,kCAAe,oCAE9C,6BAAP,KAdoC,AAAE,cAqB3B,sBACjB,AAAI,AAAC,AAAc,sCACE,6BACjB,6BACA,6BACA,6BAEF,AAAI,AAAC,KAAqB,6BAAP,IACnB,AACE,EAAc,MACV,EAAgB,KAChB,AAAC,cAAoC,uBAEzC,cACE,GACA,4CAAgC,+BAAyB,oCAEpD,6BAAP,QAKW,yBACI,sBACnB,AAAI,IACF,AAAI,AAAC,KACH,cACE,GACA,sCAEK,6BAAP,OAEiB,6BACjB,cACA,6BACA,6BAEF,AAAI,AAAC,KAAqB,6BAAP,IACnB,AAAI,AAAC,cAAgC,sBACnC,cACE,GACA,6BAAoB,+BAAqB,oCAEpC,6BAAP,QAIY,AAAiB,6BAAc,cAAgB,cAAY,cAAU,eAC1E,EACT,6BACA,cACA,EACA,cACA,sBAEF,6BAAsB,iBACtB,AAAa,cAAqB,qBAClC,cAAmB,gCACnB,AAAI,AAAC,KAAe,6BAAP,QAIF,6BAA8B,cAAW,EAAM,6BAC1D,AAAI,AAAC,KAAiB,4CAAP,IACf,6BAAsB,iBACtB,AAAa,cAAqB,qBAClC,cAAmB,+CACnB,AAAI,AAAC,KAAe,6BAAP,KAGf,AAAa,cAA2B,mBACxC,AAAW,kCACP,cAAW,EAAQ,UAAS,EAAS,iBACrC,cAAW,EAAQ,gBAGvB,AAAI,AAAC,QACS,yBACQ,cAAoB,sBACxC,AAAI,IACF,AAAI,AAAC,iEACH,cACE,GACA,4CACA,2DACA,sBAGF,cACE,GACA,4CAAwB,0BAIhB,yBACA,cAAoB,6BAAe,sBAC/C,cAAkB,iBAAa,EAAsB,MACrD,AAAO,cAAiB,iBAAa,EAAM,+BAIxC,cAAP,k2BYnkM4B,sBACrB,cAA0B,mBAC7B,GAAO,cAA0B,8CACjC,cAFJ,oCAojFO,AAAC,GAAsB,2EAA9B,mCZ9oEA,AAAI,cAAW,UAA8B,AAAC,cAAW,qBAAnB,IACtC,cAAY,WAEU,sBACtB,cAAoB,qBAEP,yBACQ,sBACrB,cAAqB,iBACrB,AAAsC,IACtC,AAAyB,IACzB,AAAe,cAAW,YAAsB,cAAqB,YAEvD,sBACd,AAAI,IAEG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACxD,AAAU,cAAQ,UAC/B,AAAI,iBAAe,KAAuB,GAC1C,AAAkB,OACF,6CACA,sBAChB,cAAc,WACK,sBACnB,AAAI,cAAqB,QACvB,cAAmB,+DAGrB,AAAI,IACF,AAAW,cAAuB,cAAW,eAC3C,OAEF,AAAI,AAAgB,KAAa,KAC/B,AAAc,cAAqB,EAAU,WAC7C,AAAI,IACF,AAAW,KAEX,AAAI,cAAW,OACb,cACE,GACA,uCAGJ,AAAc,OAGb,AAAI,EAAiB,KAC1B,AAAW,cAAW,QAEtB,AAAI,IACF,cACE,GACA,qEAGJ,AAAI,IACF,AAAY,EAAQ,mBAAoC,EAAQ,iCAChE,AAAO,AAAC,EAAS,gCACjB,AAAW,cAAW,EAAQ,gBAE9B,AAAW,cAAc,EACvB,cAAkB,6BAA4B,MAC9C,cAAW,UAEb,AAAc,cAAqB,EAAU,WAC7C,AAAI,IACF,AAAW,KAEX,AAAI,cAAW,OACb,cACE,GACA,sDAGJ,AAAc,QAIpB,cAAmB,iBACnB,AAAI,IACF,cAAiB,6BAAwB,GAAa,EAAM,cAAW,SACvE,6BACE,cAA0B,cAAW,EAAU,eAAU,SAE3D,AAAqB,KAErB,AAAI,IACF,cAAkC,EAAQ,AAAiB,wBAAY,kBACvE,AAAI,cAAa,UACf,cAAiB,6BAAwB,GAAa,EAAO,QAG/D,cAAiB,6BAAwB,GAAa,EAAO,OAE/D,cAAwB,KACxB,AAAqB,QAEP,QAjFwD,AAAE,YAoF9E,cAAqB,iBACrB,cAAuB,kBAChB,cAAP,iCAikBA,8BAAQ,qBACD,OAOA,OAQA,OAeA,OAcA,OAOA,OAQA,OAIA,OAKA,OACA,OACA,OACA,QACA,QAxE2B,GACP,AAAC,yDACnB,AAAQ,IAAO,qBAAyB,EAAI,KAC/C,cAA8B,cAAiB,iBAAI,iBADD,AAAE,WAGtD,GAE6B,GACf,6BAAqC,0DACnD,AAAI,IACF,AAAO,iBAAgB,qBACvB,AAAI,AAAC,cAAqB,SAAsB,cAAiB,wDAEnE,GAEkC,GAChB,6CACJ,6BAAqC,sBACnD,AAAI,OAEmB,sBACrB,cAAqB,oBACE,sBAClB,AAAQ,IAAO,qBAAyB,EAAI,KAC/C,cAA8B,cAAiB,iBAAI,iBADD,AAAE,WAGtD,cAAqB,kBAEvB,GAEsB,GACH,AAAC,yDACf,AAAQ,IAAO,qBAAqB,EAAI,QAC7B,6BAAqC,cAAa,yBAChE,AAAI,IACF,AAAO,iBAAgB,qBACvB,AACE,AAAC,cAAW,UACZ,AAAC,cAAqB,aACtB,cAAmB,uDAPuB,AAAE,WAUlD,GAE8B,GAChB,6BAAqC,0DACnD,AAAI,IAAW,iBAAgB,SAC7B,AAAI,AAAC,cAAqB,SAAsB,cAAmB,wDAErE,GAEoB,GACE,6CACH,sBACnB,AAAI,cAAgB,OAClB,cAAuB,cAAc,GAAO,6DAE9C,GAE2B,AAC3B,cAA8B,AAAC,iEAAgD,iBAC/E,GAEoB,GACE,0CACtB,cAAuB,6BAA8B,gCACrD,OAM6B,GACtB,AACP,AAAW,cAAsB,mBACjC,AAAI,AAAgB,KAAS,KAAkB,cAAU,OACzD,yCA/iCJ,AAAI,cAAQ,mBAAuB,EACnC,cAAS,WAGW,yBACC,yBACF,yBACK,YACxB,cAAmB,oBAGA,yBACR,sBACX,cAAmB,iBACd,GAAiB,qCAA4B,IAAO,qBAAmB,EAAI,KAC9E,cAA8B,cAAW,iBAAI,iBADoC,AAAE,WAIrF,cAAmB,iBACnB,cAAmB,iBAGnB,AAAI,sBACW,yBACA,sBACb,AAAgB,sBACD,EAAmB,UAC7B,AAAQ,MAAG,EAAI,KAAgB,cAAS,EAAK,cAAO,sCAA1B,AAAE,WACjC,AAAgB,cACd,6BACA,iBACA,iBACA,cACA,cAAe,6BAEjB,cAAuB,cAAQ,KAC/B,cACE,cAAY,6BAA4B,EAAM,qDAvDhC,qCAElB,AAAI,cAAgB,sBACX,GAAO,cAAgB,mDACzB,AAAI,iBAAgC,cAAiC,4CACnE,GAAO,cAAgB,mDAE9B,cACE,GACA,6BAAkB,8BAEpB,GAEF,cAAiB,yDAi+LE,uDACD,qCAClB,AAAO,cAAgB,sCACH,GAAO,cAAgB,kDAC3C,AAAI,AAAC,cAAiB,WACpB,cAAuB,cAAc,iFyB70LjB,uBAEG,ggBzB+lMzB,AAAI,cAAqB,QAAwB,cAAiB,cAAY,oCAC3D,sBACnB,AAAO,eAA8B,sCAC5B,GAAO,eAA8B,kDACvC,AAAG,EACR,cACA,cACA,cACA,kCAJK,mBAAP,4BgBrtKA,AAAW,cAAuB,mBAC3B,AAA0B,iBAAU,EAAM,eAAjD,sChBq8Ja,yBACF,yBACU,sBAGrB,YAAQ,qBACD,OAwBA,OAIA,OAIA,OA4BA,QA5De,GACJ,sBACd,AAAI,sBACmB,sBACrB,AAAI,IACF,cAAmB,+CACZ,mBAAmB,cAAW,QAAK,cAAW,kBAArD,OAEuB,sBACzB,AAAI,IACF,cAAmB,+CACZ,mBAAmB,cAAW,QAAK,cAAW,kBAArD,IAEK,cAAc,6BAArB,IAEF,cAAmB,gCACnB,cACE,GACA,6BAAkB,qDAEb,mBACH,cAAW,QACX,cAAW,kBAFf,IAIkB,AAClB,cAAmB,kBACZ,cAAW,iBAAlB,IAEmB,AACnB,cAAmB,kBACZ,cAAW,iBAAlB,IAEkB,GACH,qCACf,AAAI,AAAC,KACH,cACE,GACA,sCAEF,cAAmB,+CACZ,6BAAP,IAEF,AAAI,cAAkB,SACpB,AAAI,cAAQ,SACV,cACE,GACA,uCAGJ,AAAI,AAAE,EAAc,SACL,sBACb,AAAO,iBAAe,qBACtB,cAA8B,iDAAe,sBAGjC,GAAO,cAAiB,kDACxC,cAAS,MACT,cAAmB,iBACZ,cAAiB,iBAAiB,gCAAzC,IAEmB,AACnB,AAAI,cAAkB,SACpB,AAAI,cAAQ,SACV,cACE,GACA,uCAEG,AAAI,AAAC,cAAQ,SAElB,cACE,GACA,yCAIN,AAAI,sBACe,cAAiB,sBAClC,AAAI,OACoB,GAAO,oEAClB,sBACX,AAAI,IACF,cAAmB,gCACZ,cAAiB,iBAAkB,+CAA1C,MAIN,AAAI,cAAkB,YACP,GAAO,kDACpB,AAAO,iBAAe,wBACF,6CACI,sBACxB,AAAI,OACc,sBAChB,cAAmB,iBACZ,cAAiB,EAAG,gCAA3B,KAGJ,cACE,GACA,sCAEF,cAAmB,+CACZ,6BAAP,IAIJ,cAAiC,oBAGb,sBACpB,AAAI,AAAC,QAA+B,WACvB,6BACX,cACA,cACA,6BAEF,AAAI,AAAC,KAEH,AAAI,iBAAoB,MAAW,cAAmB,mBAC/C,6BAAP,IAGF,UAAQ,qBACD,OAwCA,OA6BA,OAiBA,QAtFmB,GACV,6CACI,sBAChB,AAAO,EAAa,sBACpB,AAAI,6BAAyB,mBAC3B,cACE,GACA,6BACA,oCAEF,cAAmB,iBACZ,6BAAP,IAEF,AAAI,cAAS,UACJ,cAA2B,cAAO,cAAgB,iBAAzD,IAEF,AAAiB,mBACjB,AAAI,AAAC,cAAiB,EAAY,EWlqN2B,QXmqN3D,cACE,GACA,6BAAkB,qCAGtB,AAAO,EAAc,qBACrB,AAAI,mBAAiC,cAAiB,EAAY,EAAoB,cACxE,uBAEd,cAAmB,iBAEnB,AAAI,iBAAiB,oBAEnB,cACE,GACA,6BACA,uBAEK,6BAAP,IAEK,cAAiB,EAAY,gCAApC,IAEuB,GACV,2CACb,AAAI,AAAC,cAAuB,cAAQ,oBAC3B,6BAAP,OAEe,uBACjB,AAAI,6BAAyB,mBAC3B,cACE,GACA,6BACA,oCAEF,cAAmB,iBACZ,6BAAP,IAEF,AAAO,EAAc,sBACrB,AAAI,cAAoB,QACf,cAAwC,cAAQ,cAAY,6BAAnE,IAEF,AAAI,cAAU,UACL,cAA2B,cAAQ,cAAgB,iBAA1D,IAEF,AAAW,cAAkB,6BAAqB,sBAClD,AAAI,cAAU,SAAmC,uBAA0B,AAAC,wBAC1E,AAAO,cAA6B,EAAM,cAAY,oBAExD,cAAmB,iBACZ,cAAP,IAE0B,GACV,4CAChB,AAAI,AAAC,cAAU,WACb,cACE,GACA,sCAEF,cAAmB,kBACZ,6BAAP,IAEF,cAAmB,kBACnB,AAAI,cAAa,UACf,AAAO,iBAA+B,qBAC/B,cAAW,EAAQ,wCAA1B,IAEK,cAAkB,6BAAwB,kBAAjD,IAEkC,GACV,+CACC,uBAEzB,AAAI,IAAsB,iBAA6B,SACrD,cACE,GACA,sCAEF,MAGqB,6BACrB,cACA,EACA,AAAS,4DAEX,AAAI,AAAC,QAAoB,AAAC,cAAqB,uBAA0B,6BAAP,IAClE,AAAI,cAA8B,QAChC,cACE,GACA,6BAAkB,uBAEpB,cAAmB,gCACZ,6BAAP,IAEF,AAAI,mBAIF,cAAmB,kBACZ,cAAgB,6BAA+B,AAAW,+CAAjE,IAEF,AAAa,cAA2B,mBACxC,cAAmB,+CACZ,kCACH,cAAW,EAAQ,UAAS,EAAS,iBACrC,cAAW,EAAQ,0BAFvB,IAKJ,cACE,GACA,sCAEK,6BAAP,+BiBz4MoB,sBACb,EAAiB,KAAQ,iBAAuB,kBAAvD,qCDo4BA,AAAI,AAAC,AAAe,EAAW,oBAAY,AAAE,EAAyB,OAA6B,KAC1F,cAAW,EAAM,qCACtB,cAAU,YACV,mBACC,AAAkB,mBAHrB,IAKK,aAAP,kChB6yLW,gBAAkB,wCACf,sBACd,AAAI,cAAY,mBAAmB,GAAO,cAAY,wDAA1B,IAC5B,cAAY,cAAW,qBACV,sBACb,cAAmB,cAAM,gCAA0B,GAAa,EAC9D,qBAEK,aAAP,kCAhEa,sBACb,AAAW,cAAuB,6BAAuB,8BACxC,sBACjB,AAAkB,mBAElB,cAAmB,qBAGE,sBACrB,AAAI,IAGF,AAAI,cAAgC,mBAGlC,AAAI,mBACK,cACL,EAAe,MACX,GACA,GACJ,EACA,cAAc,+BALhB,IAUO,cAA0B,EAAM,cAAW,mBAAlD,MAIG,AAAI,cAAkB,qCAChB,yBACA,cAAkB,sBAC7B,AAAgB,mBAET,cACL,cACE,EAAe,MACX,GACA,GACJ,cAAiB,EAAW,EAAM,8BAEpC,cAAW,KACX,cAAY,cAA0B,6BAAY,qCAChD,cAAiB,EAAW,sBAC3B,sBAVL,MAgBG,cAA0B,EAAM,cAAW,mBAAlD,kCYtzFmB,sBACnB,AAAI,IACG,GAAc,KAAW,gCAAmB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UAC1B,AAAI,cAAuB,mBAAe,aAAP,IAF0C,AAAE,YAK5E,aAAP,kCA9BgB,sBAChB,AAAI,IACG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACvB,AAAI,cAAoB,mBAAe,aAAP,IAF0C,AAAE,YAKzE,aAAP,qCAnRA,AAAI,mBACF,AAAI,mBAEK,cAAgC,+DAAvC,IAGO,cAA6B,+DAApC,MAGF,AAAI,mBAEK,cAAoB,4BAA3B,IAGO,cAAiB,4BAAxB,4CGj/HY,yBACE,sBAClB,AAAI,AAAC,QAAa,AAAC,MAAoB,aAAP,IACzB,cAAkC,4BAAzC,+BA5KqB,sBACd,EAAkB,KAAQ,cAA4B,qBAA7D,oCfk/Na,yBACF,sBACX,AAAW,cAAuB,6BAAuB,6BACxC,sBACjB,cAAmB,kBAGnB,AAAI,mBACK,cAA0B,EAAM,cAAW,EAAc,KAAe,GAAI,qBAAnF,IAIF,AAAI,mBACK,cAA0B,EAAM,cAAW,oBAAlD,IAIF,AAAkB,mBAGlB,AAAI,mBAAkC,AAAC,wBAGrC,AAAI,6BAA0C,qBACrC,cACL,EAAe,MACX,GACA,GACJ,EACA,cAAc,gCALhB,IAUF,AAAI,6BAAkD,mBACpD,AAAI,AAAE,sBAA0B,qBAC9B,AAAI,kCACF,cACE,GACA,0CAGO,cAAkB,sBAC7B,AAAgB,mBACT,cACL,cACE,EAAe,MACX,GACA,GACJ,cAAiB,EAAW,EAAM,8BAEpC,cAAW,KACX,cAAY,cAAuB,4EAA+B,qCAChE,cAAiB,EAAW,sBAC3B,uBAVL,IAaA,cACE,GACA,6BAAkB,gBAAc,+BAAuB,qCAS7D,AAAI,cAA0B,qBACrB,cAA0B,EAAM,cAAW,oBAAlD,IAIF,AAAI,cAAkC,mBACpC,AAAI,AAAE,sBAA0B,wBACnB,cAAkB,sBAC7B,AAAgB,mBACT,cACL,cACE,EAAe,MACX,GACA,GACJ,cAAiB,EAAW,EAAM,8BAEpC,cAAW,KACX,cAAY,cAAuB,4EAA+B,qCAChE,cAAiB,EAAW,sBAC3B,uBAVL,IAaA,cACE,GACA,6BAAkB,gBAAc,+BAAuB,qCAOxD,cAA0B,EAAM,cAAW,oBAAlD,kCAlIW,yBACE,sBAGb,AAAI,iBAAe,QACD,0CAChB,AAAI,AAAE,sBAAwB,wBACd,6BAA8B,6BAAgB,6BAAqB,UACjF,AAAI,IAAW,iBAAgB,YACb,0CAChB,AAAI,cAAa,SACR,cAAyB,cAAY,4BAA5C,UAOW,6BACjB,6BACA,6BACA,AAAS,2DAEX,AAAI,AAAC,KACH,cAAmB,kBACZ,2CAAP,IAEK,cAAwB,cAAY,4BAA3C,4Be/nOO,EAAK,AAAS,8BAArB,4BCqzFF,AAAW,AAAiB,MAC5B,AAAoC,EAAM,OAChC,EAAe,UACpB,AAAQ,MAAG,EAAI,KAClB,cAAI,EAAK,AAAuB,EAAO,YADjB,AAAE,WAG1B,AAAe,IACR,aAAP,qCT1uFE,KAAI,UAAM,OAAQ,IAglDpB,AAAI,GAGJ,AAAgB,mBAChB,AAAI,EAAS,QAAK,EAAY,GAAS,qBAEhB,gBAGvB,AAAkB,iBAAoB,EAAkB,MAExD,AAAkB,mBAGhB,AAEE,IACF,AACY,EAAa,EAAa,EAAqB,0CqBxxD7D,AAAO,iBAAgB,qBACvB,cAAW,cAAO,wC5B4wDhB,AAAa,mBACb,AAAe,mBACf,AAAqB,mBACrB,gBAAQ,MACD,QAoCA,QAUA,QAUA,QAUA,QAUA,SA5EkB,AACrB,UAAQ,MACD,OAUA,OAUA,QApBG,AACD,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAQ,AAAiB,KAAQ,cAAK,KACtC,EAAO,KALmB,AAAE,WAO9B,GAEM,AACD,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAS,AAAiB,KAAQ,cAAK,KACvC,EAAO,KALmB,AAAE,WAO9B,GAEM,AACD,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAS,AAAiB,KAAQ,cAAK,KACvC,EAAO,KALmB,AAAE,WAO9B,GAEO,AAAO,qBAElB,GAEqB,AAChB,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAS,EAAQ,AAAoB,OAAQ,AAAqB,oBAAS,cAAK,KAChF,EAAO,KALmB,AAAE,WAO9B,GAEqB,AAChB,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAS,AAAiB,KAAQ,cAAK,KACvC,EAAO,KALmB,AAAE,WAO9B,GAEqB,AAChB,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAS,AAAiB,KAAQ,cAAK,KACvC,EAAO,KALmB,AAAE,WAO9B,GAEsB,AACjB,AAAQ,MAAG,EAAI,KAClB,AAAY,cAAO,OACnB,AAAO,AAAkB,KAAU,qBACnC,AAAO,AAAgB,KAAU,qBACjC,AAAU,AAAkB,iBAAQ,cAAK,KACzC,EAAO,KALmB,AAAE,WAO9B,GAEsB,GAIf,AAAO,qBAEX,aAAP,kCAKc,yBACY,yBAChB,cAAiC,iBAAgB,0BAC3D,4CAAuC,gBAAQ,EAAI,cAAK,MACxD,cAAuB,cAAK,iBAAuB,cAAa,kBACzD,cAA6B,4BAApC,kCYxuCa,sBACb,AAAI,AAAC,KAAQ,iBAAmC,cAAqB,2CAC9D,aAAP,sCZu3Oa,yBACF,yBACG,yBAGM,GAAO,sDACX,yBACI,GAAO,cAAiC,qEAC1C,cAAc,aAGjB,cAAkB,uDAGf,sBAClB,AAAa,sBACA,EAAyB,UACtC,AAAe,AAAC,oBACX,AAAQ,MAAG,EAAI,QACM,cAAY,UACpC,AAAI,iBAA0B,KAC5B,AAAW,cAAuB,cAAmB,cAAa,OAClE,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAO,KAEP,AAAW,KAEb,cAAO,EAAK,MAEZ,cAAO,EAAK,cAAc,qBAZF,AAAE,WAgB9B,AAAe,kCACf,AAAiB,iBAAiB,oBAGlC,AAAI,OACkB,cAAqB,cAAa,cAAQ,yBAC9D,AAAoB,EAAQ,mBAAsB,EAAQ,gDAG1D,AAAI,EAAc,KAChB,AAAW,kCACP,cAAW,EAAQ,UAAgB,EAAS,iBAC5C,cAAW,EAAQ,gBACvB,cAAmB,iBACZ,cAAP,IAKA,AAAW,cAAoB,6BAA2B,qCACxD,IACI,cAAW,QACX,cAAW,aACf,cAAW,2BACX,IACI,cAAW,EAAQ,UAAgB,EAAS,iBAC5C,cAAW,EAAQ,+BACtB,qBACH,cAAmB,iBACZ,cAAP,SAKa,cAA6B,GAAyB,UACvE,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,oCAEpB,cAAmB,iBACZ,6BAAP,IAEF,AAAmB,sBAEP,YAEZ,cACE,cAAiB,iBACf,cAAoB,6BAA2B,qCAC7C,IACI,cAAW,QACX,cAAW,aACf,cAAW,qCACV,mBACH,wBAGC,AAAQ,MAAG,EAAI,KAElB,cACE,cAAY,6BAAyB,qCACnC,cAAiB,iBAAgB,YACjC,cAAW,YACX,cAAO,sBACN,YAPqB,AAAE,WAW9B,cACE,cAAiB,iBAAgB,SAEnC,AAAI,IAAQ,cAAqB,qBACjC,cAAmB,iBACZ,cAAe,cAAO,iBAA7B,yDAnwMoE,6IYmlFvD,GAAO,cAAe,kDACnC,AAAO,iBAAe,wBACN,6CACD,sBACf,AAAI,IACF,AAAO,mBAAoB,iBAAyB,yBAC7C,4BAAP,IAEK,aAAP,4BL73IA,AAAI,EAAc,AAAK,oBAAsC,gBACtD,AAAS,iBAAiB,iBAAjC,6BqB1IK,AAAI,cAAO,KACX,AAAI,cAAO,EAAS,MAAO,IAC3B,AAAI,cAAO,EAAS,MAAO,IAC3B,AAAI,cAAO,EAAS,MAAO,eAHlC,oChB0hJe,cAAe,sBAC5B,AAAI,IAAU,iBAAe,YACX,6CACD,sBACf,AAAI,AAAC,KAAiB,aAAP,IACf,AAAO,mBAAoB,iBAAyB,yBACpD,AAAa,EAAa,oBAC1B,AAAe,kCACf,0BAAQ,MACD,OACA,OAKA,OACA,OAKA,OACA,OAKA,OACA,OAiBA,OACA,OAQA,OAKA,SAjDa,AAChB,AAAO,AAAC,EAAO,+BACf,AAAQ,GAAY,cAAQ,KACrB,aAAP,KAGiB,AACjB,AAAO,AAAC,EAAO,+BACf,AAAS,GAAY,cAAQ,KACtB,aAAP,KAGiB,AACjB,AAAO,AAAC,EAAO,+BACf,AAAS,GAAY,cAAQ,KACtB,aAAP,KAGmB,AACf,iDACF,AAAI,EAAO,cACT,AAAS,EAAO,cAAQ,MAExB,AAAc,GAAY,cAAQ,EAAQ,EAAY,OAEjD,aAAP,IAEA,AAAI,EAAO,cACT,AAAc,EAAO,cAAQ,EAAQ,EAAY,OAEjD,AAAS,GAAY,cAAQ,MAExB,aAAP,OAIe,AACjB,AAAI,EAAO,cACT,AAAS,EAAO,cAAQ,MAExB,AAAc,GAAY,cAAQ,EAAQ,EAAY,OAEjD,aAAP,IAEiB,AACjB,AAAO,AAAC,EAAO,+BACf,AAAS,GAAY,cAAQ,KACtB,aAAP,IAEiB,AACjB,AAAO,AAAC,EAAO,I3B1lJvB,AAAO,AAAkB,EAAe,yB2B2lJhC,AAAS,GAAY,cAAQ,KACtB,aAAP,KAIN,AAAO,oBACA,aAAP,yDApE0E,kIZ9lF5D,sBACd,AAAI,AAAC,QACa,GAAO,6BAA2B,4CAA6B,oCAAE,iEAEnF,AAAmB,AAAQ,6BAAsB,6BAAgC,wBACjF,AAAkB,AAAI,EAAe,oBACrC,AAAoB,EAAQ,mBAAsB,EAAQ,mDAChD,cYwkFiB,UZvkF3B,AAAO,cAAyB,gBAAU,EAAe,0CACzD,AAAO,cAAyB,gBAAa,EAAe,0CAC5D,AAAO,cAAyB,gBAAc,EAAc,0CAC5D,AAAO,cAAyB,gBAAW,EAAa,0CACjD,cAA6B,4BAApC,kCYtvCa,sBACb,AAAI,AAAC,KAAQ,iBAAkC,cAAqB,2CAC7D,aAAP,oCZq1Oc,yBACD,sBACb,AAAO,AAAC,cAA+B,uDACrB,sBAGlB,AAAW,cAAoB,6BAA0B,qCACvD,cAAW,YACX,kCACI,cAAW,uBACX,cAAW,4BACf,cAAW,2BACX,kCACI,cAAW,EAAQ,UAAS,EAAS,iBACrC,cAAW,EAAQ,+BACtB,qBACH,cAAmB,gCACZ,aAAP,sCA1Ja,yBACF,yBACG,yBAGQ,sBACtB,AAAI,IAAmB,cAAiC,sCAC/C,cAA+B,cAAY,cAAgB,iBAAlE,OAIY,6BAA+B,cAAY,cAAM,4CAC/D,AAAI,AAAC,KAAgB,6BAAP,IACd,AAAO,iBAAgB,wBACH,6CACJ,yBACE,iBAAiC,yEAAyB,aAClD,GAAO,qDAGlB,cAAkB,uDACb,cAAkB,wCAGpB,sBAClB,AAAa,sBACA,EAAyB,UACtC,AAAe,AAAC,oBACX,AAAQ,MAAG,EAAI,QACM,cAAY,UACpC,AAAI,iBAA0B,KAC5B,AAAW,cAAuB,cAA+B,cAAa,OAC9E,AAAI,AAAkB,KAAS,oBAC7B,AAAW,KAEX,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAO,KAEP,AAAW,MAGf,cAAO,EAAK,MAEZ,cAAO,EAAK,cAAc,qBAhBF,AAAE,WAqB9B,AAAI,IACF,AAAoB,sBACA,cAAqB,cAAa,6BACtD,AAAoB,EAAQ,mBAAsB,EAAQ,iCAI1D,AAAI,EAAc,QACG,cAA0B,cAAa,wBAC1D,AAAmB,EAAQ,mBAAqB,EAAQ,iCACxD,cAAmB,iBACZ,kCACH,6BAAgB,EAAQ,UAAe,EAAS,iBAChD,6BAAgB,EAAQ,0BAF5B,IAMO,cAAkB,cAAe,EAAQ,EAAe,6BAA/D,SAKa,cAA6B,GAAyB,UACvE,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,oCAEpB,cAAmB,iBACZ,6BAAP,IAEF,AAAmB,sBAEP,YAEZ,cACE,cAAiB,iBACf,cAAkB,cAAe,EAAQ,EAAQ,qBAAI,iBACrD,2BAIkB,GAAO,cAAwB,qDACrD,AAAO,iBAAwB,yBAEP,AAAC,0DACzB,AAAI,AAAC,KAA0B,6BAAP,IACxB,AAAO,mBAA6B,iBAAkC,0BACtE,cACE,cAAiB,iBACf,cAAY,iBAAoB,EAC9B,cAAiB,iBAAgB,KACjC,EACA,6BAEF,SAGC,AAAQ,MAAG,EAAI,KAElB,cACE,cAAY,6BAAyB,sCACnC,cAAiB,kBAAgB,YACjC,cAAW,YACX,cAAO,sBACN,YAPqB,AAAE,WAW9B,cACE,cAAiB,iBAAgB,SAEnC,AAAI,IAAQ,cAAqB,qBACjC,cAAmB,iBACZ,cAAe,cAAO,iBAA7B,oCA9UO,cAAwB,2CAA/B,kCYvtGa,cAAe,sBAC5B,AAAI,IAAU,iBAAe,SACpB,4CAAsC,kDAA2B,qCAAxE,IAEK,aAAP,kCZg1KiB,oDACjB,AAAI,EAAQ,KACH,aAAP,OAEc,cAAuB,qCACvC,AAAI,OACqB,cAAoB,0BAC3C,AAAI,OACsB,sBACxB,AAAI,AAAC,cACH,cACA,EACA,EACA,oBAEA,cAAmB,iBACZ,2CAAP,IAEF,AAAI,AAAC,cAA4B,GAAO,kEACtC,cACE,GACA,6BAAkB,sCAEpB,cAAmB,iBACZ,2CAAP,OAEuB,sBACzB,AAAI,AAAC,cAA0C,sBAC7C,cACE,GACA,6BAAkB,6BAA8C,+BAA+B,oCAEjG,cAAmB,iBACZ,2CAAP,IAEK,cAAoB,cAAkB,qCAAE,mBAAQ,8BAAvD,KAGJ,cACE,GACA,6BAAkB,+BAAiB,oCAErC,cAAmB,iBACZ,2CAAP,oVY5vSa,sBACb,AAAI,AAAC,KAAQ,iBAA8C,cAAkB,yCACtE,aAAP,6BQlSA,AAAU,mBACV,AAAQ,EAAQ,KAAI,AAAI,EAAQ,KAAK,WAAK,AAAI,IAAO,aACrD,AAAQ,EAAQ,KAAI,AAAI,EAAQ,KAAK,WAAK,AAAI,IAAO,aACrD,AAAM,AAAI,EAAM,KAAO,eACX,AAAgC,EAAK,EAAc,YAC/D,AAAgB,mBAChB,AAAe,iBAAkB,EAAgB,MAC7C,GAAgB,AAClB,AAAU,IACV,AAAU,EAAc,KACxB,IAAO,EAAM,KACX,AAAU,AAAY,EAAW,QACjC,AAAa,EAAY,GAAK,KAC9B,AAAO,EAA0B,EAAK,KACtC,EAAO,UAKJ,aAAP,gDApBiB,KAAc,mKHqtCzB,EAAmB,8DAtpClB,EAAuB,EAAM,cAAM,4BAA1C,8GGtEoB,AACX,EAAyB,EAA0B,8MHm2BtD,EAAe,sEAn9Bd,EAAmB,cAAY,cAAe,cAAM,4BAA3D,kCjBwsLW,sBACX,AAAI,IACF,cAAkB,iBAClB,cAAqB,iBACrB,cAAY,iBACZ,cAAa,kBAEb,iBAAsC,AAA0B,cAAY,cAAe,cAAM,wCAE5F,cAA2B,cAAM,cAAgB,gBAAxD,mDAZ2B,8IA6yDjB,yBACE,sBACZ,AAAe,sBACG,sBAClB,AAAqB,mBACrB,AAAO,EAAkB,EAAW,yBAEvB,yBACQ,wCACJ,sBAEjB,AAAI,AAAC,KAEH,AAAI,EAAY,KACP,cAAwB,cAAM,gCAArC,IAIF,AAAI,EAAY,QACG,cAAY,UAC7B,AAAa,cAAM,sBACnB,AAAa,cAAM,sBAEnB,AAAI,AAAC,KAAU,AAAC,SACP,cACL,cAAuB,cAAY,wBACnC,6BAAkB,6BAFpB,IAQF,AAAgB,EAAU,KAE1B,AAAI,EAAa,EAAU,MAGzB,AAAW,cACT,cAAuB,cAAY,wBACnC,6BAAkB,mBAEpB,AAAI,IACF,AAAM,cAAwB,cAAM,sBACpC,AAAM,KAGN,AAAM,IACN,AAAM,cAAwB,cAAM,0BAEnB,GAAO,cAAyB,sDAC5C,cAAoB,cAAc,qCAAE,SAAK,mBAAO,+BAAvD,KAKJ,AAAI,EAAY,KAAK,AAAC,cAAM,2BAAa,AAAC,cAAM,2BAAa,AAAC,cAAM,8BACtD,cAAY,aACZ,cAAY,UAExB,AAAU,cACR,cAAuB,cAAO,wBAC9B,6BAAkB,mBAEpB,AAAU,cACR,cAAuB,cAAO,wBAC9B,6BAAkB,sBAED,GAAO,cAAyB,sDAC5C,cAAoB,cAAc,qCAAE,SAAK,mBAAO,+BAAvD,OAIwB,EAAe,aAC5B,YACb,AAAI,cAAM,oBAAY,KAAG,cAAY,cAAwB,cAAM,yBAC9D,AAAQ,MAAG,EAAI,KAClB,cAAoB,EAAI,GAAK,oBAC7B,cAAY,cAAa,SACzB,AAAI,cAAM,oBAAY,KAAG,cAAY,cAAwB,cAAM,yBAHvC,AAAE,cAKZ,GAAO,6BAA2B,4CAAmC,oCAAE,mEAC7E,cAAqB,cAAY,cAAQ,yBACvD,4CAAuC,gBAAU,EAAG,6BAAgB,MACpE,AAAa,EAAQ,mBAAgB,EAAQ,kEAC1B,GAAO,cAAwB,gBYnzGC,yCZozG1B,GAAO,cAA6B,GAAyB,2CAC1E,EAAyB,EAAI,GAAiB,eAG9C,EAAiB,cAClB,uBACN,AAAQ,MAAG,EAAI,QACD,cAAY,cAClB,cAAkB,uBAC7B,cAAM,EAAK,iBACX,cAAM,EAAK,cAAiB,iBAC1B,cACE,cAAuB,eAAY,yBACnC,6BAAkB,iBAEpB,QATgC,AAAE,WAajC,AAAQ,MAAG,EAAI,KAClB,cAAM,EAAiB,GAAK,cAAoB,cAAoB,uCAClE,cAAa,YACb,cAAW,eAAoB,eAC/B,cAAiB,eAAM,qBAAU,sCAChC,sBAL+B,AAAE,WAOtC,cAAM,EAAI,GAAkB,cAAoB,cAAc,uCAC5D,cAAa,YACb,cAAwB,oCACvB,sBACI,cAAe,cAAO,gCAA7B,OAMqB,yCACH,WACP,6BAA+B,cAAK,6BAAkB,eAAW,WAC9E,AAAI,IACF,MAAQ,qBACD,OAWA,QAX+B,GACnB,6BACb,kDACA,EACA,iBACA,WAEF,AAAI,AAAC,KAAU,MACN,SAGgB,GACV,+CACM,sCACrB,AAAI,sBACU,cAAe,0BAC3B,AAAI,IAAS,AAAC,cAAuB,0CACnB,GAAO,6BAA2B,4CAA6B,sCAAE,oEAGrF,OAMS,uBACf,AAAO,iBAAmB,wBACV,EAAyB,WACpC,AAAQ,MAAG,EAAI,KAClB,cAAU,EAAK,cAAwB,cAAM,uBADjB,AAAE,WAIhC,AAAI,EAAiB,QACJ,EAAyB,WACnC,AAAQ,MAAG,EAAI,KAClB,cAAS,EAAK,cAAwB,cAAS,uBADnB,AAAE,cAGjB,cAA0B,cACvC,cAAqB,8CAAwB,qCAC7C,0BAEqB,cAA0B,cAC/C,cAAqB,8CAAwB,oCAn8LnB,WAq8L5B,cAAyB,gBACvB,EAAQ,mBAAyB,EAAQ,6DACzC,4CAGa,cAA0B,cACvC,cAAqB,8CAAwB,qCAC7C,2BAKO,gCACX,cACE,AACE,cAAa,EAAQ,mBAAqB,EAAQ,iEAClD,6BACA,iDAIJ,cACE,GACA,6BAAkB,uBAEb,cAA+B,cAAK,EAAM,cAAM,6BAAkB,oCAAzE,g9Ca/yPA,AAAY,cAAU,cAAK,AAAQ,sBACnC,AAAI,AAAC,KAAc,aAAP,IACZ,OAAoB,MACpB,AAAE,qCAEF,AAAsB,iBAAoB,KAC1C,AACE,EAAkB,GAAK,AAAS,IAAkB,4BAClD,iBAAoB,iBAAuB,GAAgB,UAC3D,cAAY,MACP,aAAP,6PbkiRA,AAAO,cAAgB,6BACV,sBACb,AAAO,iBAAe,yBACF,2CACpB,AAAI,qCAAkC,cAA0B,SAAwB,cAAiB,oBACzG,AAAW,cACT,cACA,cACA,cACA,cAAc,+CACd,OAEF,AAAI,AAAkB,KAAS,MAC7B,cAAmB,iCAEd,aAAP,6BoB51QA,AAAU,iBAAe,KACzB,AAAe,EAAyB,EAAK,OAC7C,AAAU,mBACV,AACE,EAAM,GACN,EACA,AAAQ,EAAM,GAAM,OAEtB,AAAS,EAAK,KACd,AAAI,GAGJ,cAAe,KACR,aAAP,oCpB81Pa,yBAGQ,sBACrB,AAAI,AAAC,KACH,cACE,GACA,6BAAkB,gBAAY,oCAEzB,6BAAP,OAEc,sBAChB,cAAmB,gCACnB,AAAI,iBAAuB,KACzB,cACE,GACA,6BAAkB,uBAEb,6BAAP,IAEF,AAAI,cAAkB,QACpB,cACE,GACA,sCAEK,6BAAP,OAIkB,qCACpB,AAAI,IACF,cACE,GACA,6BAAkB,4CAAoC,sCAEjD,6BAAP,IAGF,AAAgB,mBAChB,AAAI,AAAC,KACH,cAAiB,cAAY,AAAc,GAAyB,mDAI1D,sBACZ,AAAe,sBACF,yBACC,sBACd,AAAgB,OACJ,eACD,yBACK,cAAkB,sBAClC,AAAmB,mBACnB,AAAO,EAAY,wCAGC,UACpB,AAAI,IACG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,QAC/C,cAAM,aACT,GAAO,cAAY,mDAChC,AAAI,IAAU,iBAAe,YAEZ,AAAC,0DAChB,AAAI,IAAY,uBACd,cAAkB,oBAP4C,AAAE,eAc/C,YACpB,AAAQ,MAAG,EAAI,UACD,cAAM,4BACV,cAAyB,sBACtC,AAAI,AAAC,QAAU,iBAAe,MAC5B,cACE,GACA,cAAM,gCAAU,cAAY,oCAE9B,AAAY,IACZ,GAEF,AAAI,cAAU,QACZ,cACE,GACA,cAAM,gCAAU,cAAY,oCAE9B,AAAY,IACZ,GAEF,AAAI,cAAU,QACZ,cACE,GACA,cAAM,gCAAU,cAAY,oCAE9B,AAAY,IACZ,MAEqB,6BAA8B,kEACrD,AAAI,AAAC,KAAkB,MACF,sBACrB,AAAI,AAAC,KACH,cACE,GACA,cAAM,gCAAU,cAAY,oCAE9B,AAAY,IACZ,GAIF,cAAqB,kBAGrB,AAAI,AAAC,oBACH,cAAwB,kBACxB,MAGiB,sBACnB,AAAW,cAAoB,cAAgB,sCAC7C,cAAiB,iBAAiB,YAClC,cAAuB,eAAO,iBAAI,eAAc,sBAC/C,6BAA+B,OAClC,AAAI,iBAAoB,MACtB,AAAO,cAAY,QAErB,cAAW,OAxDiB,AAAE,WA4D3B,AAAQ,IAAO,qBAA2B,EAAI,QAC1B,cAAmB,cACrB,GAAO,qDAC5B,cACE,cAAoB,cAAgB,uCAClC,cAAiB,kBAAiB,YAClC,cAAuB,eAAO,kBAAI,+BAAuB,sBACxD,6BA9xDoB,SAuxD2B,AAAE,WAWxD,cAAmB,gCACnB,AAAI,IAAkB,6BAAP,IAGV,GAAc,KAAW,kCAAoB,IAAO,qBAAgB,EAAI,UACpD,cAAQ,WAC/B,AAAO,uCACY,uBAEnB,AAAI,mBACF,GAGF,AAAI,mBACF,AAAI,AAAC,oBACH,cACE,GACA,6BAAkB,6BAAuB,gBAAY,kCAEvD,AAAY,IACZ,IAIJ,4BAAQ,qBAED,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,oBAAc,AAEjB,cACE,cACE,iBACA,cAAiB,iBAAiB,KAClC,cAAc,iBACd,iBACA,iCAGJ,GAKJ,cACE,GACA,6BAAkB,6BAAuB,gBAAY,kCAEvD,AAAY,KAtDkE,AAAE,WAwDlF,AAAI,IAAkB,6BAAP,OAGJ,cAAuB,cAAgB,uBAKlD,cACE,cAAiB,iBACf,cAAwB,cAAM,yBAAI,EAAkB,kBACpD,wBAKJ,cACE,cAAiB,iBAAiB,SAGpC,cAAmB,gCACZ,cAAe,cAAO,iBAA7B,sCAjxBa,sBACb,gBAAQ,qBACD,OAQA,OAWA,OAuBA,OAIA,OAIA,OAIA,QAtDmB,AACtB,AAAO,AAAC,qBACD,cACL,iDACA,cACA,gBAHF,IAMsB,AACtB,AAAiB,AAAC,sDAClB,AAAI,IACF,AAAa,AAAC,MAEhB,AAAI,EAAkB,MACb,cAAW,iBAAlB,IAEF,cAAmB,kBACZ,cAAW,gBAAlB,IAEwB,GACb,6CACA,6BAA0C,cAAM,EAAkB,sBAC7E,cAAmB,iBACnB,AAAe,mBACf,AAAW,WACX,AAAI,IACF,AAAI,mBACF,AAAO,YAEP,AAAW,EAAQ,If7oP7B,AAAO,EAAC,UegpPF,gBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,QALgB,AAAI,AAAC,mCAA8B,cAAW,EAAQ,wBAA1B,KACvB,cAAW,EAAQ,UAAW,EAAS,2BAA9C,IACE,AAAI,AAAC,mCAA8B,cAAW,EAAQ,wBAA1B,KACvB,cAAW,EAAQ,UAAW,EAAS,2BAA9C,IACO,cAAW,GAAY,EAAW,If75OpE,AAAO,qBe65OoB,IACO,cAAW,EAAO,EAAW,Ifx5O/D,AAAO,qBew5OoB,IACH,cAAW,EAAQ,wBAA1B,MAGY,AACvB,AAAO,AAAC,qBACD,cAA0B,kDAAqC,gBAAtE,IAEyB,AACzB,AAAO,AAAC,qBACD,cAA4B,kDAAuC,gBAA1E,IAEuB,AACvB,AAAO,AAAC,qBACD,cAA0B,kDAAqC,4BAAtE,IAEuB,AACvB,cACE,GACA,6BACA,uBAEF,cAAmB,iBACZ,4BAAP,IAGJ,AAAO,oBACA,4BAAP,mDyB7rIyB,4IzBm5JZ,yBACF,yBAGE,6BAA8B,6BAAqB,4CAChE,AAAI,AAAC,KAAe,6BAAP,IACb,AAAI,iBAAe,KACjB,cACE,GACA,qDAEK,4CAAP,IAEF,AAAI,cAAU,QACZ,cACE,GACA,qDAEK,4CAAP,OAEmB,2CACrB,AAAkC,OACd,sBAEpB,AACE,AAAC,QACiB,8BAClB,iBAA4B,SAC5B,cAAkB,gBAGF,6BACd,cACA,6BACA,AAAS,+DAGK,6BACd,cACA,cACA,4CACA,AAAS,4CACT,8BAGJ,AAAI,AAAC,KAAsB,6BAAP,IACpB,AAAI,EAAkB,MAAW,EAAe,SACrC,cAAuB,cAAe,sBACjD,AAAI,AAAC,cAAkB,SAGrB,cAA8B,cAAe,kBAExC,cAAwB,cAAM,6BAAiB,EAAa,6BAAnE,sCA2Na,yBACF,sBAEX,cAAiC,oBAElB,yBACF,cAA0B,cAAY,cAAM,6BACzD,AAAI,AAAC,KAAe,6BAAP,OACQ,sBACrB,AAAI,cAAoB,QAAwB,cAAiB,cA9oFI,MAgpFrE,YAAQ,qBACD,OA0BA,OAiBA,OAOA,OA6BA,QA/EoB,GACV,2CACb,AAAI,AAAC,cAAuB,cAAQ,oBAC3B,6BAAP,OAEe,sBACjB,AAAO,EAAc,uBACrB,AAAI,6BAAyB,mBAC3B,cACE,GACA,6BACA,oCAEF,cAAmB,iBACZ,6BAAP,IAEF,AAAI,cAAU,UACL,cAA2B,cAAQ,cAAS,iBAAnD,IAEF,AAAW,cAAkB,6BAAqB,sBAClD,AAAI,cAAU,SAAmC,uBAA0B,AAAC,wBAC1E,AAAO,cAA6B,EAAM,cAAY,oBAExD,cAAmB,iBACZ,cAAP,IAE0B,GACV,8CACH,GAAO,mDACpB,AAAO,iBAAe,yBACL,2CACjB,AAAI,AAAC,cAAiB,oBACpB,cAAmB,kBACZ,4CAAP,IAEF,cAAmB,kBACnB,AAAI,cAAa,UACf,AAAO,iBAA+B,sBAC/B,cAA2B,cAAW,cAAS,iBAAtD,IAEF,AAAO,iBAAkB,uBAClB,cAAkB,6BAAwB,kBAAjD,IAEkC,GACV,8CACD,6BAA8B,6BACrD,AAAI,AAAC,KAAyB,6BAAP,OACd,QAGgB,GACF,2CACvB,AAAI,mBACF,AACE,6BAAuB,SACvB,GAAO,8CAAwB,SAC/B,AAAC,cAAqB,cAAkB,YACxC,AAAC,cAAoB,cAErB,cACE,GACA,6BACA,4CACA,yCAIe,sBACrB,AAAI,AAAC,KAAuB,6BAAP,IACrB,AAA6B,IAC7B,AAAI,cAAkB,SACpB,AAAU,cACR,GAAO,2CACP,GAAO,yEACP,EAA2B,SAGxB,cAAuB,cAAgB,yBAAI,cAAY,wBAA9D,IAEkC,GACV,8CACD,6BAA8B,cAAmB,mBACxE,AAAI,AAAC,KAAyB,6BAAP,IACvB,AAAI,AAAC,cAAqB,sBAA0B,6BAAP,IAC7C,cAAmB,gCACnB,AAAa,cAA2B,mBACjC,kCACH,cAAW,EAAQ,UAAS,EAAS,iBACrC,cAAW,EAAQ,0BAFvB,IAKJ,cACE,GACA,sCAEK,4CAAP,kCAQa,yBACA,yBACA,sBAEb,AAAe,cAAuB,6BAAsB,2BAC5D,AAAsB,cAAmB,EAAU,6BAAkB,kCAGrE,AAAe,cAAuB,OACtC,AAAI,EAAY,KACP,cAA0B,EAAiB,cAAuB,cAAQ,sCAAjF,IAEF,AAAI,EAAY,KACP,cAA0B,EAAiB,cAAuB,cAAQ,sCAAjF,OAGc,yBACC,cAAmB,EW99QZ,iBX+9QxB,cAAmB,iBACnB,AAAiB,cAAuB,cAAQ,6BAC/B,yBAEA,cAAmB,UACpC,cAAmB,iBACnB,AAAiB,cAAuB,cAAQ,EAAkB,MAAY,GAAa,8BAC1E,sBAEjB,AAAI,EAAkB,MACpB,AAAI,EAAc,MAChB,AAAa,cAAY,UACZ,SAEf,AAAI,EAAc,MAChB,AAAa,cAAY,UACZ,SAEf,cAAmB,sBAEF,AAAgB,cAAY,cAAY,cepzQ9B,UfqzQ3B,AAAI,AAAC,KACH,cACE,GACA,6BAAc,+BAAuB,oCAEvC,cAAmB,iBACZ,4BAAP,IAEF,AAAa,cAAuB,EAAY,cAAY,cAAY,EAAO,sBAClE,OACb,AAAa,cAAuB,EAAY,cAAY,cAAY,EAAO,sBAClE,OACb,cAAmB,kBAGrB,cAA8B,cAAY,iBAC1C,cAAmB,iBAEZ,cAAU,EAAiB,EAAY,gBAA9C,+BA99GO,cAAoB,cAAkB,qCAAE,mBAAa,cAAY,gBAAxE,wCA2yIa,sBACb,gCAAQ,qBAED,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QAdI,AAAO,4BAOU,cAAW,gBAAlB,KAEE,AAAI,iBAAa,MAAW,cAAW,gBAAlB,MAEhB,cAAW,kBAAlB,IACO,cAAW,mBAAlB,IACO,cAAW,uBAAlB,IACU,cAAe,cAAW,mBAAjC,sCAr1BX,yBACF,sBAGX,AAAe,cACb,6BACA,6BACA,OAKF,AAA8B,IAC9B,AAAI,EAAkB,SACR,cAAkB,qCAC9B,AAAW,cACT,iBACA,EACA,6CAMJ,QAAQ,qBACD,QAoFA,SApFiB,GAGC,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAiB,cAAY,SAC7B,AAAI,IAAa,AAAC,SAChB,AAAW,AAAiB,OAC5B,AAAY,KAEd,AAAO,cAA0B,cAAU,6BAAoB,EAAU,mBACzE,AAAI,IAAY,GACT,cAAP,KAGJ,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,gBAAM,mDAEnB,6BAAP,IAGF,8BAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,OAQA,OACA,OAQA,OAQA,cAlCc,AACjB,AAAO,cACL,EACA,EACA,cAAW,UAEb,IAGiB,AACjB,AAAO,cACL,EACA,EACA,cAAW,YAEb,IAGmB,AACnB,AAAO,cACL,GACA,EACA,cAAa,qCAEf,GAEiB,AACjB,AAAO,cACL,EACA,EACA,cAAW,aAEb,GAEiB,AACjB,AAAO,cACL,EACA,EACA,cAAW,iBAEb,GAEO,AACP,cACE,GACA,6BAAkB,gBAAM,mDAEnB,6BAAP,IAGJ,GAEsB,GAGD,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAiB,cAAY,SAC7B,AAAI,IAAa,AAAC,SAChB,AAAW,AAAiB,OAC5B,AAAY,KAEd,AAAO,cAA0B,cAAU,6BAAoB,EAAU,mBACzE,AAAI,cAAY,SAAuB,GAChC,cAAP,KAGJ,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,gBAAM,mDAEnB,6BAAP,IAGF,8BAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,OAQA,OACA,OAQA,OAQA,cAlCc,AACjB,AAAO,cACL,EACA,EACA,cAAW,UAEb,IAGiB,AACjB,AAAO,cACL,EACA,EACA,cAAW,YAEb,IAGmB,AACnB,AAAO,cACL,GACA,EACA,cAAa,qCAEf,GAEiB,AACjB,AAAO,cACL,EACA,EACA,cAAW,aAEb,GAEiB,AACjB,AAAO,cACL,GACA,EACA,cAAW,iBAEb,GAEO,AACP,cACE,GACA,6BAAkB,gBAAM,mDAEnB,6BAAP,IAGJ,GAEO,AACP,AAAO,qBACA,6BAAP,OAIW,yBACF,cAA0B,6BAAoB,+BAC3D,AAAI,AAAC,KACI,6BAAP,IAIF,AAAI,AAAC,KACI,cACL,cACA,EACA,6BACA,6BACA,6BACA,6BACA,iBAPF,IAYF,AAAe,cACb,cACA,EACA,6BACA,6BACA,6BACA,6BACA,OAGF,cAAmB,gCACnB,AAAc,kCAEP,cAAa,EAAM,qCACxB,SACA,cAAiB,iBAAiB,sBACjC,iBAHH,6BiBp2QA,AAAI,iBAAa,KACf,MAAQ,AAAC,GAAoC,qDACtC,OACA,SAA4B,aAAP,KAGvB,aAAP,wCjBi9Ra,sBACb,gCAAQ,qBAED,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QAdI,AAAO,2BAMU,cAAW,gBAAlB,KAEE,AAAI,iBAAa,MAAW,cAAW,gBAAlB,MAEhB,cAAW,EAAI,gBAAtB,IACO,cAAW,mBAAlB,IACO,cAAW,uBAAlB,IACQ,cAAY,6BAAnB,IACS,cAAe,cAAW,mBAAjC,sCApRV,sBACd,AAA0B,OACL,qCAErB,AAAI,iBAAgB,QACL,aAEC,6BAA+B,cAAS,6BAAkB,eAAW,UACnF,AAAI,AAAC,KACH,UAAQ,qBACD,OACA,OACA,QAFqB,IAEG,GACjB,iBAAgB,KACtB,AAAC,sDACD,AAAC,8DACY,6BAAgC,cAAS,6BAAkB,eAAW,UACvF,AAAI,AAAC,KACH,cAAmB,gCACZ,4CAAP,KAIK,AACP,AAAO,cAAuB,cAAS,2BACvC,AAAO,cAAuB,EAAM,6BAAkB,eAAW,EAAM,uBAG9D,UAEb,YAAQ,qBACD,OACA,OACA,OAIA,UAJkB,GACR,SACb,GAEkC,GACrB,SACb,GAEO,AACP,AAAO,cAAuB,cAAS,8BAC5B,sBACX,AAAO,cAAuB,EAAM,cAAM,eAAW,EAAM,mBAC3D,AAAI,sBACuB,sBACzB,AAAI,OACW,aAEQ,sBACrB,AAAI,IACF,AAAI,iBAA4B,uBACjB,YAEA,cAGF,WAGZ,AAAI,EAAQ,SACJ,SACR,AAAI,sBACI,YAEA,YAEf,KAKR,cAAmB,gCACZ,IACH,6BAAkB,EAAM,qCAAE,SAAM,cAAwB,kCAAe,oCACvE,cAAwB,8BAF5B,oCA9aa,sBACb,AAAe,IAGf,oBAAQ,qBACD,QAwBA,QAyEA,QAqEA,QAqEA,QAmBA,QA8DA,OAGA,SA/TY,AACf,AAAO,cACL,6BACA,6BACA,UAImB,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,cAA0B,cAAU,6BAAoB,EAAM,6BAArE,KAEhB,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,gBAAK,mDAElB,6BAAP,IAIF,GAEgB,GACF,sBACd,AAAI,mBAEF,AAAO,cAA8B,mDAA4B,cAAgB,EAAkB,OAEnG,AAAI,kCAAwB,cAAsB,EAAM,iCACxD,GAGF,AAAO,cACL,6BACA,6BACA,UAImB,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,cAA0B,cAAU,6BAAoB,EAAM,6BAArE,KAEhB,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,gBAAK,mDAElB,6BAAP,IAGF,8BAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,OACA,OAQA,OAIA,cAtBc,AACjB,AAAO,cAAc,EAAiB,cAAW,KAAI,OACrD,IAGiB,AACjB,AAAO,cAAc,EAAiB,cAAW,OAAI,OACrD,IAGmB,AACnB,AAAO,cACL,GACA,cAAc,gCACd,OAEF,GAEiB,AACjB,AAAO,cAAa,EAAgB,OACpC,GAEiB,AACjB,AAAO,cAAa,EAAgB,OACpC,GAEO,AACP,cACE,GACA,6BAAkB,gBAAK,mDAEzB,AAAO,oBAGX,GAEoB,AACpB,AAAW,IACX,AAAO,cACL,6BACA,6BACA,UAImB,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA0B,cAAU,6BAAoB,EAAM,mBACrE,AAAI,cAAY,SAAuB,GAChC,cAAP,KAGJ,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,gBAAM,mDAEnB,6BAAP,IAGF,8BAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,OACA,OAQA,OAIA,cAtBc,AACjB,AAAO,cAAc,EAAiB,EAAM,6BAAgB,UAC5D,IAGiB,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,YACvD,IAGmB,AACnB,AAAO,cACL,GACA,EACA,cAAa,qCAEf,GAEiB,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,aACvD,GAEiB,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,iBACvD,GAEO,AACP,cACE,GACA,6BAAkB,gBAAM,mDAE1B,AAAO,oBAGX,GAEsB,AACtB,AAAW,IACX,AAAO,cACL,6BACA,6BACA,UAImB,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IACF,AAAO,cAA0B,cAAU,6BAAoB,EAAM,mBACrE,AAAI,cAAY,SAAuB,GAChC,cAAP,KAGJ,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,gBAAM,mDAEnB,6BAAP,IAGF,8BAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,OACA,OAQA,OAIA,cAtBc,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,UACvD,IAGiB,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,YACvD,IAGmB,AACnB,AAAO,cACL,GACA,EACA,cAAa,qCAEf,GAEiB,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,aACvD,GAEiB,AACjB,AAAO,cAAc,GAAiB,EAAM,cAAW,iBACvD,GAEO,AACP,cACE,GACA,6BAAkB,gBAAM,mDAE1B,AAAO,oBAGX,GAEsB,AACtB,AAAO,cACL,6BACA,6BACA,UAImB,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,cAA0B,cAAU,6BAAoB,EAAM,6BAArE,KAIhB,AAAO,cAAa,EAAgB,cAAmB,EAAM,6BAAkB,qCAC/E,cAAmB,kBACnB,GAEgB,AAChB,AAAO,cACL,6BACA,EAAkB,MACd,IACA,mBACE,IACA,gBACN,UAImB,6BAAmC,qCACxD,AAAI,OACa,cAA8B,aAC7C,AAAI,IAAiB,cAA0B,cAAU,6BAAoB,EAAM,6BAArE,KAEhB,AAAI,AAAC,mCACH,cACE,GACA,6BAAkB,eAAK,mDAElB,6BAAP,IAGF,AAAO,cAAuB,EAAM,6BAAkB,4CAA0B,EAAO,kCAEvF,0BAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,OACA,cAVc,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,UACvD,IAGiB,AACjB,AAAO,cAAc,EAAiB,EAAM,cAAW,EAAI,UAC3D,IAGmB,AACnB,AAAO,cACL,GACA,EACA,cAAgB,qCAElB,GAEO,AACP,cACE,GACA,6BAAkB,eAAK,mDAEzB,AAAO,oBAGX,GAGO,cAAmB,cAAY,cAAgB,iBADrC,IAGK,AACtB,cACE,GACA,6BAAkB,uBAEb,6BAAP,IAEO,AACP,AAAO,qBACA,6BAAP,IAGJ,AAAI,AAAC,KAAiB,cAAP,OACA,yBACF,cAA0B,6BAAoB,8CAC3D,AAAI,AAAC,KAAe,6BAAP,IACN,cACL,cACA,EACA,6BACA,6BACA,6BACA,6BACA,EAAkB,mBAPpB,iCA/sMA,IAAO,iBAAmB,QACX,AAAC,8DAEhB,cAAmB,iBACnB,AAAI,EAAkB,MAAW,EAAe,MAEhD,8CAAQ,qBACD,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OACA,OACA,OACA,OACA,OACA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAMA,QAnEoB,AACvB,AAAO,cAAgC,kDAAiC,cAAgB,OACxF,GAEoB,AACpB,AAAO,cAA6B,iDAA8B,cAAgB,OAClF,GAEkB,AAClB,AAAO,cAA2B,iDAA4B,cAAgB,OAC9E,GAEmB,AACnB,AAAO,cAA4B,iDAA6B,cAAgB,OAChF,GAE2B,AAC3B,AAAO,cAAoC,kDAAqC,cAAgB,OAChG,GAEsB,AACtB,AAAO,cAA+B,kDAAgC,cAAgB,OACtF,QAOkB,AAClB,AAAO,cAAiC,kDAAkC,cAAgB,OAC1F,GAEwB,AACxB,AAAO,cAAiC,kDAAkC,cAAgB,OAC1F,GAEqB,AACrB,AAAO,cAA8B,kDAA+B,cAAgB,EA43I/D,OA33IrB,GAEiB,AACjB,AAAO,cAA0B,iDAA2B,cAAgB,OAC5E,GAE4B,AAC5B,AAAO,cAAqC,kDAAsC,cAAgB,OAClG,GAEqB,AACrB,AAAO,cAA8B,kDAA+B,cAAgB,OACpF,GAE0B,AAC1B,AAAO,cAAmC,kDAAoC,cAAgB,OAC9F,GAEyB,AACzB,AAAO,cAAkC,kDAAmC,cAAgB,OAC5F,GAEsB,GACP,0CACf,AAAO,mBACP,cAAmB,gCACnB,GAEmB,AAEnB,cACE,GACA,6BACA,uBAEF,AAAO,kCACP,GAEO,AACP,AAAO,oBACP,AAAO,sCAIO,sBAClB,AAAW,AAAC,EAAc,GAAyB,KACnD,AAAI,EAAe,oBACjB,AAAI,EAAc,KAChB,AAAO,cAAuB,EAAM,cAAa,cAAgB,EAAM,mBACvE,iBAAiC,yBAC5B,AAAI,EAAc,KACvB,AAAO,cAAuB,EAAM,cAAa,cAAgB,EAAO,mBACxE,iBAAiC,2BAGrC,AAAI,IAAM,AAAO,cAA4B,EAAM,oBAGnD,AAAI,kCAAwB,cAAsB,EAAM,iCACjD,cAAP,kCiB3nEW,sBACX,AAAmB,mBACnB,AAAI,IACK,AAAW,cAAK,gCAAU,cAAK,EAAe,+CAArD,IAEK,2CAAP,kCE4pSa,yBACA,yBACK,sBACpB,AAAyB,KACzB,AAAI,iBAAmB,KACrB,AAAI,AAAC,QAAiB,iBAAwB,MAC5C,cACE,GACA,4CAAmC,gBAAK,IAAgB,uBAAkC,qBAErF,aAAP,IAEK,cAAc,gBAArB,IAEF,AAAI,iBAAmB,KACrB,AAAI,IAAiB,iBAAuB,SAC1C,AAAI,iBAAuB,KACzB,cACE,GACA,4CAAmC,gBAAK,uCAEnC,aAAP,IAEF,AAAyB,cAA2B,cAAS,iBAAI,cAAc,iBAAI,SAEnF,AAAyB,cAA2B,cAAS,iBAAI,6BAE5D,4BAAP,IAEF,AAAI,IAAiB,iBAAuB,SAC1C,cACE,GACA,4CAAmC,gBAAK,wCAG5C,cACE,GACA,4CAA+B,gBAAK,uCAE/B,aAAP,4BH1qRE,AAAW,AAAoC,MAC/C,AAAI,EAAQ,MAAgB,EAAQ,UAC3B,AAAuB,iBAAU,eAAxC,IAEK,aAAP,kCG2qRW,qCACb,AAAI,KAA0B,AAAwB,GAAwB,0BAC5E,AAAO,cAAa,EAAM,qCACxB,cAAiB,aACjB,mBACC,AAAkB,WAEhB,aAAP,kCA5pTe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAsB,GAAI,oBAAnE,s+BAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAsB,GAAI,oBAAnE,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAA4B,GAAI,oBAAzE,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAoB,GAAI,oBAAjE,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAqB,GAAI,oBAAlE,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAmB,GAAI,oBAAhE,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,OACU,sBACd,AAAkB,cACvB,cACE,IAAkB,cAA8B,qDAC5C,GACA,oBAJR,kCAYe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,OACU,sBACd,AAAkB,cACvB,cACE,IAAkB,cAAgC,qDAC9C,GACA,oBAJR,wCPqyGgC,qCACvB,IAA2B,cAAa,+CAA/C,4BA8GO,2CAAP,+BAKA,AAAI,mBAA4B,aAAP,OACP,cAAe,wBACjC,AAAI,AAAC,KAAoB,aAAP,IACX,AACL,AACE,iBAAoB,KACpB,AAAC,oDAAyC,YAE1C,iBAAoB,KACpB,AAAC,oDAAmD,UAGtD,cAAoB,QAA4B,QAChD,cAAoB,GA2N6B,KA3NQ,mBAV3D,kCOh5Ga,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,OACU,sBACd,AAAkB,cACvB,cACE,IAAkB,uBACd,GACA,oBAJR,4BJhkBS,iBAAuB,cAA9B,kCI4kBa,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAkB,GAAI,oBAA/D,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAA2B,GAAI,oBAAxE,kCAooToB,sBACpB,AAAI,OACc,sBAChB,6BACE,GACA,4CAAmC,oCAE9B,aAAP,IAEK,aAAP,kCAKe,sBACf,AAAI,iBAAmB,KACrB,6BACE,GACA,4CAAsB,mBAAqB,uCAEtC,aAAP,IAEK,aAAP,kCAhpTe,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,OACY,6BACZ,6BAAa,iBACb,6BACA,eACA,UAEK,cAAW,IAAU,GAAI,iBAAhC,kCAMe,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,IACF,AAAW,cAA2B,6BAAa,iBAAI,2BACvD,cAAuB,kBACvB,AAAI,AAAC,AAAwB,EAAM,uBAC1B,cAAW,cAAyB,OAAQ,GAAI,iBAAvD,IAEK,cAAa,EAAM,qCACxB,cAAiB,YACjB,cAAW,sBACV,AAAkB,mBAHrB,kCASe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,mBAAiB,GAAI,oBAA9D,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,IACJ,AAAkB,cAAK,cAAW,iBAAa,KAAgB,GAAI,oBAA1E,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,OACc,sBACzB,AAAI,AAAC,KACH,cACE,GACA,4CAAsB,sCAEjB,4BAAP,IAEK,AAAkB,cAAK,cAAW,iDAAzC,kCAugTe,yBACK,sBACpB,AAAI,IACF,AAAuB,mBACvB,AAAI,EAAoB,KAAU,aAAP,IAC3B,AAAO,qBACP,AAAI,IAAuB,cAAuB,cAAc,qBAChE,cACE,GACA,4CAAmC,gBAAK,yBAG1C,cACE,GACA,4CAAsB,gBAAK,qBAGxB,aAAP,0CAsEa,sBAEb,AAAI,EAAkB,MAAa,uBACjC,UAAQ,qBACD,OAOA,OAOA,OACA,QAfc,AACjB,AAAI,EAAW,IlC31UrB,AAAO,EAAS,OAAiB,EAAS,ckC41UlC,cAAuB,kBAChB,cAAW,EAAQ,wBAA1B,IAEF,GAEiB,AACjB,AAAI,EAAW,IlCh1UrB,AAAO,EAAc,UkCi1Ub,cAAuB,kBAChB,cAAW,EAAQ,wBAA1B,IAEF,IAGiB,AACjB,cAAuB,iBAChB,cAAW,EAAQ,UAAQ,EAAS,2BAA3C,KAON,AAAI,kCACF,cAAuB,kBAChB,cAAW,EAAQ,UAAQ,EAAS,2BAA3C,IAEA,cAAuB,kBACvB,AAAO,AAAC,EAAS,iCACV,cAAW,EAAQ,wBAA1B,oCA1nTa,yBACF,sBACb,cAAuB,+CACvB,AACE,AAAkB,mBAClB,AAAkB,cAAK,QAChB,4BAAP,OACS,6DAAmB,UAC9B,AAAe,mBACf,AAAI,AAAC,KACH,cACE,GACA,4CAAmC,gBAAU,oCAExC,4BAAP,IAEK,AAAgB,cAAU,EAAQ,qBAAW,2CAApD,kCAMe,yBACF,sBACb,cAAuB,+CACvB,AACE,AAAkB,mBAClB,AAAkB,cAAK,QAChB,4BAAP,OACS,6DAAmB,UAC9B,AAAe,mBACf,AAAI,AAAC,AAAW,QACd,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,IAEK,AAAgB,cAAU,EAAQ,AAAS,sBAAY,2CAA9D,kCA8hTe,sBACf,AAAkB,mBAClB,AAAI,EAAc,KAChB,6BACE,GACA,4CAAsB,mBAA4B,wBAE7C,aAAP,IACK,AAAI,EAAc,KACvB,6BACE,GACA,4CAAsB,mBAA4B,wBAE7C,aAAP,KAEK,aAAP,oCAviTe,yBACF,sBACb,cAAuB,+CACvB,AACE,AAAkB,mBAClB,AAAkB,cAAK,EAAG,QACnB,6BAAP,OACa,yBACM,yBACV,6DAAmB,aACT,cAAuB,qCAC5C,AAAI,AAAC,KACH,cACE,GACA,4CAAmC,gBAAY,oCAEjD,AAAI,kCACF,AAAI,mBAAiC,iBAAuB,SAC1D,cAAuB,oBAGzB,AAAI,mBAAiC,iBAAuB,UAC1D,cAAuB,oBAGpB,6BAAP,IAEF,AAAI,sBACiB,cAAS,UAC5B,AAAI,AAAC,cAA2B,QAC9B,cACE,GACA,cAAS,yCAEJ,6BAAP,OAEc,AAAC,4DACC,cAAyB,sBAC3C,AAAI,IAAe,iBAAoB,YACtB,AAAC,yDAChB,AAAI,IAAY,uBACd,AAAO,iBAAyB,qBACzB,AAAgB,cAAU,EAAQ,oCAAwB,6BAAjE,KAGJ,cACE,GACA,6BAAoB,6BAA6B,mBAE5C,6BAAP,IAEK,AAAgB,cAAU,EAAQ,oCAAkC,6BAA3E,kCAMe,yBACF,yBACI,AAAkB,sBACnC,AAAI,AAAC,KACH,cAAuB,8DAChB,4BAAP,IAGF,AAAI,sBACmB,sBACrB,AAAI,OACM,uBAER,AAAO,sCACC,aAGF,yBAEH,AAAkB,cAAK,cAA4B,+BAA1D,kCAMe,yBACF,yBACF,AAAkB,sBAC7B,cAAuB,kBACvB,AAAI,AAAC,KAAa,4BAAP,OACc,sBACzB,AAAI,IACK,AAAkB,cAAK,cAAW,kCAAzC,OAEmB,cAAuB,qCAC5C,AAAI,IAAkB,AAAC,cAA4B,aAC1C,AAAkB,cAAK,cAAW,kCAAzC,IAEF,cACE,GACA,4CAAmC,gBAAQ,oCAEtC,4BAAP,kCAw4SoB,sBACpB,AAAI,OACa,sBACf,AAAuB,mBACvB,AAAI,EAAoB,KAAU,aAAP,IAC3B,AAAO,qBACP,AAAI,IAAuB,cAAuB,cAAc,qBAChE,cACE,GACA,4CAAmC,gBAAK,wBAEnC,aAAP,IAEK,aAAP,6BJtoUE,YAAQ,qBACD,OACA,OACA,OACA,OACA,QAJuB,cAAP,IACO,cAAP,IACO,cAAP,IACO,cAAP,IACO,iBAAa,MAAK,IAAe,eAAxC,IAEhB,aAAP,oCIgvBa,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,6BAAP,OAEkB,sBACpB,AAAW,IACP,cACE,6BAAa,iBACb,cAAc,gCACd,EAA2B,OAE7B,cACE,6BAAa,iBACb,eACA,WAGK,sBACX,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OAyBA,OACA,OACA,OACA,OAgCA,OACA,UA/DoB,cAAP,KAEC,GAEN,yBACA,cAAkB,sBAC7B,cAAkB,iBAAY,KAE9B,AAAU,cACR,EACA,cACE,EACA,cAAiB,iBAAY,EAAM,YACnC,cAAW,QAEb,cACE,EACA,cAAiB,iBAAY,MAC7B,cAAW,aAIf,AAAI,iBAAa,KACf,AAAM,cAAgC,EAAK,qBAEtC,cAAP,OAKmB,AACf,iBAAa,QAEJ,yBACA,cAAkB,sBAC7B,cAAkB,iBAAY,KAE9B,AAAU,cACR,EACA,cACE,EACA,cACE,EACA,cAAiB,iBAAY,EAAM,YACnC,cAAW,WAEb,cAAW,QAEb,cACE,EACA,cACE,EACA,cAAiB,iBAAY,MAC7B,cAAW,WAEb,cAAW,aAGR,cAAP,MAKe,GAWN,yBACC,cAAkB,sBAC9B,cAAkB,iBAAa,QACnB,cAAkB,sBAC9B,cAAkB,iBAAa,KAG/B,AAAW,cACT,iBACA,cACE,EACA,cACE,EACA,cACE,EACA,cAAiB,iBAAa,EAAM,YACpC,cAAW,UAEb,cAAW,KAAY,WAEzB,cACE,EACA,cACE,EACA,cAAiB,iBAAa,MAC9B,cAAW,KAAY,WAEzB,cAAW,aAGf,cAIF,AAAU,cACR,EACA,cACE,EACA,cACE,EACA,EACA,cAAW,UAEb,cAAW,IAAY,UAEzB,cACE,EACA,cACE,EACA,cAAiB,iBAAa,MAC9B,cAAW,IAAY,UAEzB,cAAW,eAKf,AAAM,cACJ,EACA,EACA,cAAW,YAEN,cAAP,KAIN,cACE,GACA,4CAAmC,gBAAS,oCAEvC,6BAAP,kCAQc,sBACd,AAAI,cAAW,aACA,qCACb,cAAiB,6BAAsB,GAAa,EAAO,cAAW,mgCAOzD,yBACF,sBACb,AAAI,iBAAsB,MACxB,cAAuB,kBAChB,cAAW,mBAAlB,IAEF,cAAuB,kBAChB,cAAW,uBAAlB,s+BAMc,sBACd,AAAI,cAAW,aACA,qCACb,cAAiB,6BAAsB,GAAa,EAAO,cAAW,+DAOzD,yBACF,sBACb,AAAI,iBAAsB,MACxB,cAAuB,kBAChB,cAAW,mBAAlB,IAEF,cAAuB,kBAChB,cAAW,uBAAlB,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACkB,sBACpB,AAAW,IACP,cAA2B,6BAAa,iBAAI,cAAc,iBAAI,EAA2B,OACzF,cAA2B,6BAAa,iBAAI,eAAU,WAC/C,sBACX,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cAJqB,cAAa,EAAgB,gBAApC,KAES,cAAa,GAAiB,gBAArC,KAEK,cAAa,EAAgB,gBAApC,KAGvB,cACE,GACA,4CAAmC,gBAAO,oCAErC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,EAA2B,OACrF,cAA2B,cAAS,iBAAI,eAAU,WAC3C,sBACX,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cAJqB,cAAa,EAAgB,gBAApC,KAES,cAAa,GAAiB,gBAArC,KAEK,cAAa,EAAgB,gBAApC,KAGvB,cACE,GACA,4CAAmC,gBAAO,oCAErC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,EAA2B,OACrF,cAA2B,cAAS,iBAAI,eAAU,WAC3C,sBACX,AAAI,mBACF,wBAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QAVsB,aAAP,SAMM,cAAa,EAAmB,gBAAvC,KAEO,cAAa,EAAmB,gBAAvC,KAES,cAAa,GAAoB,gBAAxC,KAGzB,cACE,GACA,4CAAmC,gBAAU,oCAExC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,EAA2B,OACrF,cAA2B,cAAS,iBAAI,eAAU,WAC3C,sBACX,AAAI,mBACF,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OAmCA,OACA,OACA,OACA,OACA,OACA,QA5CsB,aAAP,OAID,GAEN,yBACC,cAAkB,sBAC9B,cAAkB,iBAAa,QACnB,cAAkB,sBAC9B,cAAkB,iBAAa,KAE/B,AAAU,cAAc,EACtB,cACE,EACA,cAAiB,iBAAa,EAAM,YACpC,cACE,EACA,cAAiB,iBAAa,EAAM,YACpC,cAAW,iBAAY,YAG3B,cACE,EACA,cAAiB,iBAAa,MAC9B,cACE,EACA,cACE,EACA,cAAW,KACX,cAAiB,iBAAa,SAEhC,cAAW,iBAAY,iBAKtB,aAAP,KAGwB,cAAc,EAAkB,EAAM,gBAA7C,KAEO,cAAc,EAAkB,EAAM,gBAA7C,KAES,cAAc,GAAmB,EAAM,gBAA9C,KAGzB,cACE,GACA,4CAAmC,gBAAQ,oCAEtC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,EAA2B,OACrF,cAA2B,cAAS,iBAAI,eAAU,WAC3C,sBACX,AAAI,mBACF,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OAmCA,OACA,OACA,OACA,OACA,OACA,QA5CsB,aAAP,OAID,GAEN,yBACC,cAAkB,sBAC9B,cAAkB,iBAAa,QACnB,cAAkB,sBAC9B,cAAkB,iBAAa,KAE/B,AAAU,cAAc,EACtB,cACE,EACA,cAAiB,iBAAa,EAAM,YACpC,cACE,EACA,cAAiB,iBAAa,EAAM,YACpC,cAAW,iBAAY,YAG3B,cACE,EACA,cAAiB,iBAAa,MAC9B,cACE,EACA,cACE,EACA,cAAW,KACX,cAAiB,iBAAa,SAEhC,cAAW,iBAAY,iBAKtB,aAAP,KAGwB,cAAc,EAAkB,EAAM,gBAA7C,KAEO,cAAc,EAAkB,EAAM,gBAA7C,KAES,cAAc,GAAmB,EAAM,gBAA9C,KAGzB,cACE,GACA,4CAAmC,gBAAQ,oCAEtC,4BAAP,oCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,6BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,EAA2B,OACrF,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBACF,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAuBA,OAwBA,OAsBA,OACA,aAzEuB,cAAP,MAGF,GACN,yBAGC,cAAkB,0BAClB,cAAkB,uBAE9B,AAAU,cAAc,EACtB,cAAc,EACZ,cACE,iBACA,cAAc,EACZ,cAAiB,iBAAa,EAAM,YACpC,cAAW,QAEb,YAEF,cAAiB,iBAAa,SAEhC,cAAiB,iBAAa,WAEzB,cAAP,IAEmB,GACL,yBACH,yBAEC,cAAkB,wCAClB,cAAkB,qCAC9B,AAAU,cAAc,GACtB,cAAc,GACZ,cACE,iBACA,cAAc,GACZ,cAAiB,iBAAa,EAAM,YACpC,kCACI,cAAW,QACX,cAAW,SAEjB,YAEF,cAAiB,iBAAa,uBAEhC,cAAiB,iBAAa,yBAEzB,cAAP,IAEiB,GACN,yBAEC,cAAkB,0BAClB,cAAkB,uBAE9B,AAAU,cAAc,EACtB,cAAc,EACZ,cACE,iBACA,cAAc,EACZ,cAAiB,iBAAa,EAAM,YACpC,cAAW,UAEb,YAEF,cAAiB,iBAAa,SAEhC,cAAiB,iBAAa,WAEzB,cAAP,IAEwB,cAAa,EAAgB,iBAApC,IACO,cAAa,EAAgB,iBAApC,KAGvB,cACE,GACA,4CAAmC,gBAAO,oCAErC,6BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cAA2B,cAAM,cAAc,iBAAI,EAA2B,OAC9E,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBACpB,AAAO,cAA2B,cAAS,iBAAI,cAAM,OACrD,AAAI,iBAAwB,KAC1B,AAAO,cAA2B,iBAAa,oCAAsB,EAA2B,UAGlG,AAAO,cAA2B,cAAS,iBAAI,cAAM,EAA2B,SAElF,AAAmB,IACnB,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UAVgB,AAAE,AAAK,IAAgB,MAIvB,AAAE,AAAK,IAAgB,GACvB,AAAE,AAAK,IAAgB,GACvB,AAAE,AAAK,IAAgB,GACvB,AAAE,AAAK,KAAkB,GACzB,AAAE,AAAK,KAAkB,GACpB,cAAc,EAAiB,EAAM,gBAA5C,IACO,cAAc,GAAiB,EAAM,gBAA5C,IAErB,AAAI,EAAa,QACJ,sBACX,AAAc,sBACF,cAAkB,sBAC9B,cAAkB,iBAAa,QACnB,cAAkB,sBAC9B,cAAkB,iBAAa,KAC/B,AAAU,cACR,cAAiB,iBAAa,EAAM,YACpC,cAAiB,iBAAa,EAAM,YACpC,cAAc,EACZ,cAAiB,iBAAa,KAC9B,cAAiB,iBAAa,QAEhC,OAEK,aAAP,KAGJ,cACE,GACA,4CAAmC,gBAAO,oCAErC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cAA2B,cAAM,cAAc,iBAAI,EAA2B,OAC9E,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBACpB,AAAO,cAA2B,cAAS,iBAAI,cAAM,OACrD,AAAI,iBAAwB,KAC1B,AAAO,cAA2B,iBAAa,oCAAsB,EAA2B,UAGlG,AAAO,cAA2B,cAAS,iBAAI,cAAM,EAA2B,SAElF,AAAmB,IACnB,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UAVgB,AAAE,AAAK,IAAgB,MAIvB,AAAE,AAAK,IAAgB,GACvB,AAAE,AAAK,IAAgB,GACvB,AAAE,AAAK,IAAgB,GACvB,AAAE,AAAK,KAAkB,GACzB,AAAE,AAAK,KAAkB,GACpB,cAAc,EAAiB,EAAM,gBAA5C,IACO,cAAc,GAAiB,EAAM,gBAA5C,IAErB,AAAI,EAAa,QACJ,sBACX,AAAc,sBACF,cAAkB,sBAC9B,cAAkB,iBAAa,QACnB,cAAkB,sBAC9B,cAAkB,iBAAa,KAC/B,AAAU,cACR,cAAiB,iBAAa,EAAM,YACpC,cAAiB,iBAAa,EAAM,YACpC,cAAc,EACZ,cAAiB,iBAAa,KAC9B,cAAiB,iBAAa,QAEhC,OAEK,aAAP,KAGJ,cACE,GACA,4CAAmC,gBAAO,oCAErC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBACF,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,kBAFuB,aAAP,IACK,cAAa,EAAiB,gBAArC,IACO,cAAa,EAAiB,gBAArC,KAGvB,cACE,GACA,4CAAmC,gBAAQ,oCAEtC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBACF,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,kBAFuB,aAAP,IACK,cAAa,EAAkB,gBAAtC,IACO,cAAa,EAAkB,gBAAtC,KAGvB,cACE,GACA,4CAAmC,gBAAS,oCAEvC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,eAAU,WAC3C,sBACX,AAAI,mBACF,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,MAAQ,qBAED,OACA,QADqB,cAAc,EAAsB,EAAM,gBAAjD,IACO,cAAc,GAAsB,EAAM,gBAAjD,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBACF,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,kBAFuB,aAAP,IACK,cAAa,EAAoB,gBAAxC,IACO,cAAa,EAAoB,gBAAxC,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,yBACT,8CAAe,UAC1B,AAAI,mBACF,kBAAQ,qBACD,OACA,OAKA,OACA,OAKA,OACA,OAcA,OAKA,SA/Bc,AACjB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,iBAChB,cAAa,EAA6B,gBAAjD,KAGiB,AACjB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,iBAChB,cAAa,EAA6B,gBAAjD,KAGmB,AACnB,AAAe,kCACf,AAAW,cAA2B,cAAS,iBAC7C,IAAW,IAAW,gBACtB,OAEF,cAAuB,iBAChB,cACL,IACI,GACA,GACJ,gBAJF,IAOiB,AACjB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,kBAChB,cAAa,EAA6B,gBAAjD,IAEiB,AACjB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,kBAChB,cAAa,EAA6B,gBAAjD,KAIN,cACE,GACA,4CAAmC,gBAAe,oCAE7C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,eAAU,WAC3C,sBACX,AAAI,mBACF,MAAQ,qBAED,OACA,QADqB,cAAa,EAAiB,gBAArC,IACO,cAAa,EAAiB,gBAArC,KAGvB,cACE,GACA,4CAAmC,gBAAQ,oCAEtC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,AAAI,mBACF,4BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,kBAFuB,aAAP,IACK,cAAa,EAAkB,gBAAtC,IACO,cAAa,EAAkB,gBAAtC,KAGvB,cACE,GACA,4CAAmC,gBAAS,oCAEvC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,mBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,+BACjC,sBACX,cAAuB,kBACvB,AAAI,mBACF,0BAAQ,qBAED,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OAeA,iBAlBI,cAA0B,EAAM,cAAW,mBAD/B,IAIF,AACjB,AAAI,AAAgB,KAAS,KACpB,cAAc,EACnB,EACA,cAAiB,AAAiB,KAAO,oBAF3C,OAKS,yBACA,cAAkB,uBAC7B,AAAU,cAAc,EACtB,cAAiB,iBAAY,EAAM,YACnC,cAAiB,iBAAY,WAExB,aAAP,IAEiB,AACjB,AAAI,AAAgB,KAAS,KACpB,cAAc,GACnB,EACA,cAAiB,AAAiB,KAAO,oBAF3C,OAKS,yBACA,cAAkB,uBAC7B,AAAU,cAAc,GACtB,cAAiB,iBAAY,EAAM,YACnC,cAAiB,iBAAY,WAExB,aAAP,KAIN,cACE,GACA,4CAAmC,gBAAS,oCAEvC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,mBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,+BACjC,sBACX,cAAuB,kBACvB,AAAI,mBACF,0BAAQ,qBAED,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAIA,OAqBA,iBAxBI,cAA0B,EAAM,cAAW,mBAD/B,IAIF,AACjB,AAAI,AAAgB,KAAS,KACpB,cAAc,EACnB,cAAc,EACZ,EACA,cAAiB,AAAiB,KAAO,SAE3C,cAAW,sBALb,OAQS,yBACA,cAAkB,uBAC7B,AAAU,cAAc,EACtB,cAAc,EACZ,cAAiB,iBAAY,EAAM,YACnC,cAAiB,iBAAY,SAE/B,cAAW,aAEN,aAAP,IAEiB,AACjB,AAAI,AAAgB,KAAS,KACpB,cAAc,GACnB,cAAc,GACZ,EACA,cAAiB,AAAiB,KAAO,SAE3C,cAAW,0BALb,OAQS,yBACA,cAAkB,uBAC7B,AAAU,cAAc,GACtB,cAAc,GACZ,cAAiB,iBAAY,EAAM,YACnC,cAAiB,iBAAY,SAE/B,cAAW,iBAEN,aAAP,KAIN,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAQe,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAiB,6BAAsB,iBAAc,EAAM,cAAkB,6DAM9D,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAuB,iBAChB,cAAkB,6BAAsB,+BAA/C,kCAMe,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAiB,6BAAsB,iBAAc,EAAM,cAAkB,6DAM9D,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAuB,iBAChB,cAAkB,6BAAsB,+BAA/C,kCAMe,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAiB,6BAAsB,iBAAc,EAAM,cAAkB,6DAM9D,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAuB,iBAChB,cAAkB,6BAAsB,+BAA/C,kCAMe,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAiB,6BAAsB,iBAAc,EAAM,cAAkB,6DAM9D,yBACF,yBACC,yBACH,sBACX,+BAA4B,MAC5B,cAAuB,iBAChB,cAAkB,6BAAsB,+BAA/C,6BJjhEE,8BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,qBAAsB,aAAP,IAEf,aAAP,wCIilUW,sBAEb,AAAI,kCACF,AAAW,cAA2B,cAAY,eAAc,OAChE,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAO,AAAqB,KAAY,sBACxC,AAAQ,AAAoB,QAE5B,cACE,GACA,sCAEF,AAAQ,MAGV,AAAW,cAA2B,cAAY,eAAc,OAChE,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAQ,AAAiB,QAEzB,cACE,GACA,sCAEF,AAAQ,MAGL,aAAP,+BAKA,AAAY,AAAwB,cAAY,mBAChD,AAAI,EAAQ,KAAU,aAAP,IACf,AAAI,EAAQ,QAAK,EAAe,MAC9B,cACE,GACA,6BAAkB,gBAAa,gBAAK,sBAE/B,aAAP,IAEF,AAAI,AAAC,AAAW,QACd,cACE,GACA,6BAAkB,uBAEb,aAAP,IAEK,aAAP,kCA3nQe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yBACC,yBACV,8CAAe,aAEZ,AACZ,EAAkB,MAClB,uBACA,uBACA,iBAAsB,wBACpB,GAAiB,QAErB,AAAI,AAAC,oBACH,cACE,GACA,4CAAmC,gBAAQ,oCAE7C,cAAuB,kBAChB,4BAAP,IAGF,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAkB,mBAClB,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,iBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,iBAChB,4BAAP,MAIN,cAAuB,iBAChB,cACL,iBACA,iBACA,EACA,iBACA,EACA,uBANF,kCAae,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAkB,mBAClB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,sBACf,AAAkB,sBACE,yBACC,yBACV,8CAAe,UAC1B,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,mBACP,cAA2B,cAAS,iBAClC,cACA,MAEF,cACE,cAAS,iBACT,cACA,mBACI,GACA,YAEG,sBACb,AAAI,AAAC,oBACH,cACE,GACA,4CAAmC,gBAAS,oCAE9C,cAAuB,kBAChB,4BAAP,IAEF,AACE,mBAEE,AAAC,uBACD,iBAAc,yBAIhB,AAAO,cAA2B,EAAM,cAAQ,cAAM,EAAO,cAAS,yBAC7D,QAEX,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,kBAChB,4BAAP,MAIN,cAAuB,kBAChB,cAAa,iBAAe,EAAM,EAAM,iBAAgB,EAAW,uBAA1E,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACK,cAAiB,EAAM,EAAM,cAAM,2CAA1C,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACK,cAAiB,EAAM,EAAM,4BAApC,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACK,cAAiB,EAAM,EAAM,4BAApC,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACK,cAAiB,EAAM,EAAM,4BAApC,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACK,cAAiB,EAAM,EAAM,4BAApC,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACF,cAAuB,kBAChB,cAAgB,EAAM,EAAM,cAAM,2CAAzC,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCAMe,yBACF,sBACb,AAAI,AAAkB,cAAK,KAAQ,AAAkB,cAAK,QACjD,4BAAP,OAEa,yBACK,yBACT,cAAS,UACpB,AAAW,IACP,cACE,cACA,cAAc,iBACd,MAEF,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,mBAEF,AAAI,AAAC,KAAiB,uBAEpB,AAAO,cACL,cAAS,iBACT,0BAEF,AAAI,iBAAwB,KAC1B,AAAO,cACL,iBACQ,oCACR,SAIJ,AAAO,cACL,cAAS,iBACT,cACA,QAGJ,AAAI,mBACF,cAAuB,kBAChB,cAAgB,EAAM,EAAM,cAAM,2CAAzC,KAGJ,cACE,GACA,4CACA,gBACA,oCAEK,4BAAP,kCA2oPe,sBACf,AAAI,AAAC,6BAA4B,QAC/B,cACE,GACA,4CAAsB,AAAgB,wBAEjC,aAAP,IAEK,aAAP,4BHp5RE,AAAW,cAAuB,mBAC3B,AAA6B,iBAAU,EAAO,EAAQ,EAAM,EAAK,eAAxE,2DAJgB,QACD,4FG2wCF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yBACC,yBACV,8CAAe,aACZ,AACZ,mBACA,uBACA,iBAAsB,wBACpB,GAAiB,QACrB,AAAI,AAAC,oBACH,cACE,GACA,4CAAmC,gBAAe,oCAEpD,cAAuB,iBAChB,4BAAP,IAEF,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAgB,iBAAmB,KAAI,AAAwB,cAAS,iBAAI,kBAAY,KACxF,AAAI,EAAY,KACd,cAAuB,iBAChB,4BAAP,IAEF,cAAuB,iBAChB,cACL,iBACA,EACA,iBACA,uBAJF,4BH5xCE,AAAW,cAAuB,mBAC3B,AAA8B,iBAAU,EAAO,EAAQ,EAAK,EAAO,EAAM,eAAhF,2DAJgB,QACD,8FGyyCF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yBACC,yBACV,8CAAe,UAC1B,AAAI,AAAC,oBACH,cACE,GACA,4CAAmC,gBAAgB,oCAErD,cAAuB,kBAChB,4BAAP,IAEF,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,mBACP,cACE,cAAS,iBACT,cACA,MAEF,cACE,cAAS,iBACT,cACA,mBACI,GACA,YAEG,sBACb,AACE,mBAEE,AAAC,uBACD,iBAAc,yBAIhB,AAAO,cAA2B,EAAM,cAAQ,cAAM,EAAO,cAAS,yBAC7D,QAEX,AAAgB,iBAAmB,KAAI,AAAwB,cAAS,iBAAI,kBAAY,KACxF,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,cAAuB,kBAChB,cAAoB,iBAAe,EAAM,EAAM,iBAAgB,uBAAtE,4BH70CE,AAAW,cAAuB,mBAC3B,AAA4B,iBAAU,EAAI,EAAO,EAAQ,EAAK,EAAO,EAAM,eAAlF,2DAHe,gGGq1CF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yBACC,yBACV,8CAAe,UAC1B,AAAI,AAAC,uBAAuB,iBAAY,MACtC,cACE,GACA,4CAAmC,cAAQ,oCAEtC,4BAAP,IAEF,AAAW,cAA2B,cAAS,iBAC7C,4CACA,OAEF,AAAW,mBACP,cAA2B,cAAS,iBAClC,cACA,MAEF,cACE,cAAS,iBACT,cACA,mBACI,GACA,YAEG,sBACb,AACE,mBAEE,AAAC,uBACD,iBAAc,yBAIhB,AAAO,cAA2B,EAAM,cAAQ,cAAM,EAAO,cAAS,yBAC7D,QAEX,AAAgB,iBAAmB,KAAI,AAAwB,cAAS,iBAAI,kBAAY,KACxF,AAAI,EAAY,KACd,cAAuB,iBAChB,4BAAP,IAEF,cAAuB,iBAChB,cAAkB,EAAI,iBAAe,EAAW,EAAM,EAAM,sCAAnE,4BAKO,AAAsB,cAAK,EAAiB,8BAAnD,4BAMO,AAAsB,cAAK,EAAiB,8BAAnD,4BAMO,AAAsB,cAAK,EAAiB,8BAAnD,4BAMO,AAAsB,cAAK,EAAgB,8BAAlD,4BAMO,AAAsB,cAAK,EAAiB,8BAAnD,4BAMO,AAAsB,cAAK,EAAkB,8BAApD,4BH75CE,AAAW,cAAuB,mBAC3B,AAAgC,iBAAU,EAAO,EAAQ,EAAK,EAAU,EAAa,EAAM,eAAlG,2DAHe,gGGq6CF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yBACC,yBACV,8CAAe,UAC1B,AAAI,AAAC,uBAAuB,iBAAY,MACtC,cACE,GACA,4CAAmC,gBAAkB,oCAEhD,4BAAP,IAEF,AAAW,cAA2B,cAAS,iBAC7C,4CACA,OAEF,AAAW,mBACP,cAA2B,cAAS,iBAClC,cACA,MAEF,cACE,cAAS,iBACT,cACA,mBACI,GACA,YAEG,sBACb,AAAW,cAA2B,cAAS,iBAC7C,cACA,OAEF,AACE,mBAEE,AAAC,uBACD,iBAAc,yBAIhB,AAAO,cAA2B,EAAM,cAAQ,cAAM,EAAO,cAAS,sBACtE,AAAO,cAA2B,EAAM,cAAQ,cAAM,EAAO,cAAS,yBAC7D,QAEX,AAAgB,iBAAmB,KAAI,AAAwB,cAAS,iBAAI,kBAAY,KACxF,AAAI,EAAY,KACd,cAAuB,iBAChB,4BAAP,IAEF,cAAuB,iBAChB,cAAsB,iBAAe,EAAW,EAAM,EAAM,EAAM,sCAAzE,4BHj9CE,AAAW,cAAuB,mBAC3B,AAA6B,iBAAU,EAAK,EAAU,EAAS,EAAc,eAApF,2DAHe,4FGy9CF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,EAAG,QAE1B,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yBACT,8CAAe,UAC1B,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,AAAW,iBAAmB,KAC1B,cAA2B,cAAS,iBAAI,eAAU,MAClD,cAAW,EAAI,QACnB,cAAuB,kBACvB,cAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,aAAuB,cAAmB,EAAM,EAAM,EAAM,sCAA5C,IAEvB,cACE,GACA,4CAAmC,gBAAe,oCAE7C,4BAAP,4BH7+CE,AAAW,cAAuB,mBAC3B,AAA+B,iBAAU,EAAK,EAAa,eAAlE,2DAHe,wFGq/CF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,EAAG,QAE1B,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,iBAAmB,KAC1B,cAA2B,cAAS,iBAAI,eAAU,MAClD,cAAW,QACf,cAAuB,kBAChB,cAAqB,EAAM,uBAAlC,4BH9/CE,AAAW,cAAuB,mBAC3B,AAA8B,iBAAU,eAA/C,wCGmgDa,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAChB,4BAAP,IACK,cH7gD4B,gBG6gDnC,kCAQe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,sBACpB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,MAC1D,cAA2B,cAAS,iBAAI,+BACjC,sBACX,AAAI,AAAC,cAAW,GAAkB,UAChC,cACE,GACA,4CAAmC,gBAAU,oCAExC,4BAAP,IAEF,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,AAAW,cACT,cAA2B,cAAS,iBAAI,yBACxC,6BACA,cAAS,sBAEX,cAAuB,iBAChB,cAAc,EAAM,EAAM,EAAM,+BAAvC,qCAMA,AAAgB,kBAChB,AAAkB,cAAK,MAChB,0DAAP,4BHvtDE,AAAW,cAAuB,mBAC3B,AAA6B,iBAAU,EAAM,gBAApD,2DAFyB,SAAwC,wFGguDpD,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,IACK,qCAAP,4BHjuDE,AAAW,cAAuB,mBAC3B,AAA6B,iBAAU,EAAO,EAAM,gBAA3D,8DAF+C,SAAwC,oFGwuD1E,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,IACK,cAAmB,cAA2B,6BAAa,iBAAI,eAAU,4BAAhF,6BHl2CE,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBAC5B,AAA6B,iBAAU,EAAM,EAAQ,EAAM,EAAO,gBAAzE,yDALmB,YACE,wGG02CR,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,OACa,sBACf,AAAI,AAAC,6BAA4B,WAEhB,6BAAkC,6BAAe,mBAChE,cAAuB,kBACvB,AAAI,AAAC,QAAY,AAAC,cAAyB,cAAU,SAAc,4BAAP,IACrD,cAA2B,cAAU,cAAU,oDAAtD,OAEc,qCAChB,AAAW,cAA2B,cAAS,iBAAI,cAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,cAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,cAAW,OAC9D,cAAuB,kBAChB,cAAmB,EAAM,EAAM,yBAAtC,4BHj3CE,AAAW,cAAuB,mBAC3B,AAA6B,iBAAU,EAAM,EAAO,EAAM,gBAAjE,2DAHe,0FGy3CF,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,OACa,sBACf,AAAI,AAAC,6BAA4B,WAEhB,6BAAkC,6BAAe,mBAChE,cAAuB,kBACvB,AAAI,AAAC,QAAY,AAAC,cAAyB,cAAU,SAAc,4BAAP,IACrD,cAA2B,cAAU,cAAU,6BnBszF7B,uBmBtzFzB,OAEc,qCAChB,AAAW,cAA2B,cAAS,iBAAI,cAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAS,OAC5D,AAAW,cAA2B,cAAS,iBAAI,cAAW,OAC9D,cAAuB,kBAChB,cAAmB,EAAM,EAAM,uBAAtC,uCnB3+CE,AAAO,AAAW,uBAClB,AAAmB,EAAU,mBAAmB,oEAClC,EAAkB,cAAQ,UACxC,6BAAyB,kBACzB,cAAoB,EAAQ,IAAc,EAAQ,iDAC3C,aAAP,sCmB6+Ca,yBACF,sBACb,cAAuB,kBACvB,AACE,AAAkB,mBAClB,AAAkB,cAAK,EAAG,QACnB,6BAAP,OACkB,yBACL,sBACf,AAAkB,sBACF,qCAEhB,AAAI,IAAiB,iBAAuB,YACxB,cAAc,UAChC,AAAI,AAAC,oBACH,cACE,GACA,4CAAmC,gBAAe,oCAEpD,cAAuB,iBAChB,6BAAP,OAEkB,cAAS,UAC7B,AAAI,iBAAsB,QAAoB,AAAC,qDAAiD,MAC9F,cACE,GACA,cAAS,yCAEX,cAAuB,iBAChB,6BAAP,OAEgB,AAAC,yDACnB,AAAkB,sBACN,EAAyB,UACrC,AAAe,IACV,AAAQ,MAAG,EAAI,QACM,cAAY,UACpC,AAAI,iBAA0B,KAC5B,AAAW,cAA2B,cAAmB,cAAa,OACtE,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAO,KAEP,AAAW,KAEb,cAAM,EAAK,MAEX,cAAM,EAAK,cAAkB,qBAZA,AAAE,WAenC,AAAI,AAAC,KACH,cACE,GACA,sCAEF,cAAuB,iBAChB,6BAAP,IAEF,AAAY,mBACZ,AAAI,EAAe,KACjB,AAAQ,AAAuB,cAAS,iBAAI,EAAO,mBACnD,AAAI,EAAQ,KACV,cAAuB,iBAChB,6BAAP,QAGM,EAAe,EAAc,0BACvC,AAAO,cAA2B,cAAK,EAAG,cAAa,iBAAU,oCACjE,AAAS,cAAiC,cAAK,uBAE/C,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,AAAc,cAAqB,EAAM,WACzC,AAAI,AAAC,KACH,cACE,GACA,cAAS,yCAEX,cAAuB,iBAChB,6BAAP,IAEF,AAAW,AAAiB,OAC5B,AAAI,EAAO,KACT,cACE,GACA,cAAS,gCAAU,gBAAK,yBAE1B,cAAuB,iBAChB,6BAAP,IAEF,AAAY,IACZ,AAAI,EAAe,KACjB,AAAQ,AAAuB,cAAS,iBAAI,EAAO,mBACnD,AAAI,EAAQ,KACV,cAAuB,iBAChB,6BAAP,KAGJ,AAAS,cAAiC,EAAe,iBAAO,uBAGlE,cAAuB,iBACvB,AAAI,EAAa,MACf,AAAO,AAAC,EAAS,gCACV,cAAW,EAAQ,yBAA1B,IAEO,cAAW,EAAQ,UAAS,EAAS,4BAA5C,oCAQa,yBACF,sBACb,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,OACa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,kBAChB,cAAe,gBAAtB,4BHt1CS,AAAyB,iBAAU,EAAM,gBAAhD,kCG21Ca,yBACF,sBACb,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,OACa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAa,OAChE,AAAI,6BAAsB,OACxB,cAAuB,kBAChB,cAAe,EAAM,gBAA5B,IAEA,cAAuB,kBAChB,cAAe,EAAM,gBAA5B,+BJt7FA,AAAI,cAAQ,OAAsB,cAAU,WAC1C,AAAW,mBACJ,EAAQ,oBACb,EAAQ,QACR,cAAQ,KAAqB,cAAU,sBAFzC,IAKK,iBAAa,6BAApB,kCIw7Fa,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,yDACP,cAAc,UAC3B,AAAW,cAA2B,cAAS,iBAAI,8BACpC,sBACf,cAAuB,iBACvB,AAAI,AAAC,cAAwB,oBAC3B,cACE,GACA,4CAAsB,+BAAqB,oCAEtC,4BAAP,IAEK,aAAP,oCAMe,yBACF,yBACO,sBACpB,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,EAAG,QAE1B,AAAI,IACF,AAAO,mCACP,cAAuB,cAAc,oCAEhC,6BAAP,OAEa,yBACM,sBACrB,AAAW,IACP,cAA2B,cAAS,iBAAI,cAAc,iBAAI,EAA2B,OACrF,cAA2B,cAAS,iBAAI,eAAW,WAC5C,sBACX,cAAuB,gCAGvB,AAAI,kCACK,cAAP,IAIF,AAAa,cAAqB,EAAM,WACxC,AAAI,IACF,UAAQ,AAAuB,SACxB,QAMA,QAMA,QAMA,SAlBkB,AACrB,AAAI,AAAiB,OACZ,cAAP,IAEF,GAEqB,AACrB,AAAI,AAAoB,KAAU,AAAqB,QAC9C,cAAP,IAEF,GAEqB,AACrB,AAAI,AAAiB,oBACZ,cAAP,IAEF,GAEqB,AACrB,AAAI,AAAiB,wBACZ,cAAP,IAEF,IAMN,AAAY,cAAmB,iBAAmB,KAAI,cAAS,MAAK,eAAM,kCAC1E,cAAuB,gCACvB,AAAI,EAAkB,MACpB,cAAuB,kBACvB,kDAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAEA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cAlBqB,cAAU,cAAa,EAAgB,KAAO,mBAArD,KAEO,cAAU,cAAa,EAAgB,KAAO,mBAArD,KAES,cAAU,cAAa,GAAiB,KAAO,mBAAtD,IAEK,cAAU,cAAc,EAAgB,EAAM,cAAW,WAAK,mBAArE,IACO,cAAU,cAAc,GAAgB,EAAM,cAAW,eAAK,mBAArE,cAWkB,cAAU,cAAmB,KAAO,mBAA3C,KAGhC,cAAuB,mCACZ,sBACX,kDAAQ,oCACD,OACA,OACA,OACA,OACA,OACA,OACA,OAUA,OACA,OAWA,OACA,OAYA,OAYA,OAYA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,cArEc,GACN,cAAkB,sBAC7B,cAAkB,iBAAY,KAC9B,AAAU,cACR,cAAiB,iBAAY,EAAM,YACnC,cAAiB,iBAAY,MAC7B,OAEK,cAAP,KAGiB,GACN,cAAkB,uBAC7B,AAAU,cACR,cAAa,EACX,cAAiB,iBAAY,EAAM,eAErC,EACA,cAAiB,iBAAY,WAExB,cAAP,KAGmB,GACR,cAAkB,oDAC7B,AAAU,cACR,cACE,GACA,cAAiB,iBAAY,EAAM,8BAErC,EACA,cAAiB,iBAAY,wCAExB,cAAP,IAEiB,GACN,cAAkB,uBAC7B,AAAU,cACR,cAAc,EACZ,cAAiB,iBAAY,EAAM,YACnC,cAAW,WAEb,EACA,cAAiB,iBAAY,WAExB,cAAP,IAEiB,GACN,cAAkB,uBAC7B,AAAU,cACR,cAAc,GACZ,cAAiB,iBAAY,EAAM,YACnC,cAAW,eAEb,EACA,cAAiB,iBAAY,WAExB,cAAP,cAY4B,GACjB,cAAkB,sBAC7B,AAAU,cACR,cACE,cAAiB,iBAAY,EAAM,eAErC,EACA,cAAiB,iBAAY,yBAExB,cAAP,KAIN,cACE,GACA,4CACA,gBAAU,mDAEL,cAAP,kCAMe,yBACF,sBACb,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAChB,4BAAP,OACS,sBACX,AAAsB,gCAAuC,KAC7D,AAAuB,cAAQ,SAC/B,AAAI,IAAiB,AAAO,AAAC,sBACxB,cAAS,QAEd,AAAW,cAA2B,6BAAa,iBAAI,yCACvD,AAAI,AAAC,KAAkB,cAAW,QAC3B,aAAP,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,KACvB,AAAkB,cAAK,EAAG,SACnB,4BAAP,OACa,yBACK,sBAEpB,AAAI,IACF,AAAO,sCACM,cAAc,cAEd,uBAEf,AAAe,cAA2B,cAAS,iBAAI,eAAU,OACjE,AAAkB,iBAAkB,QACjB,EAAyB,aACxB,EAAmB,UAClC,AAAQ,MAAG,EAAI,KAClB,cAAa,EAAK,cAA2B,cAAS,EAAI,kBAAI,4BAC9D,cAAc,EAAK,mCAFY,AAAE,WAInC,cAAuB,iBAChB,cAAqB,EAAiB,EAAU,cAAc,AAAW,iBAAgB,iBHh2D7E,gBGg2DnB,kCAMe,yBACF,sBACb,AACE,AAAkB,cAAK,OAChB,4BAAP,OACa,yBACK,yDACD,cAAc,aACb,sBACpB,AAAI,AAAC,KACH,cACE,GACA,oEAEK,4BAAP,IAEF,cAAuB,mCACZ,cAA2B,cAAe,qCACrD,cAAkC,cAAe,gCAC1C,cAA4B,cAAM,cAAU,EAAkB,2CAArE,oCElpHS,4CAA2B,iBAAY,+BAA9C,kCFypHa,yBACF,sBACb,AAAgB,qBACD,yBACE,sBACjB,cACE,GACA,EACA,6BACA,EACA,mBACI,cAAS,oCACT,6CE75GkB,EACA,KF85GjB,EAAY,KACf,kBACA,6BAFJ,4BAOO,AAAmB,cAAK,gBAA/B,4BAMO,AAAmB,cAAK,gBAA/B,4BAMO,AAAmB,cAAK,gBAA/B,mNAQe,yBACF,qCACb,AAAO,iBAAe,wBACF,0CACpB,AAAO,iBAA2B,sDACd,GAAO,kDAC3B,AAAO,iBAAwB,wBACnB,cAAc,aACV,GAAO,qDACN,sBACjB,AACE,AAAgB,iBAChB,AAAkB,cAAK,EAAI,kBAA8B,EAAI,uCAE7D,cAAuB,iBAChB,4CAAP,IAEF,AAAkB,cAA2B,GAAO,yDAAkB,cAAO,UAC3D,GAAO,oEACV,sBACf,AAAqB,IACrB,AAAI,IACF,AAAU,cAA2B,cAAa,cAAU,QACvD,AAAI,iBAAoB,KAC7B,cACE,GACA,sCAEK,4CAAP,KAEK,cAA6B,cAAW,EAAa,6BAAc,6BAAgB,EAAS,iBAAsB,mBAAzH,kCAMe,yBACF,sBACb,cAAuB,6EACvB,cACE,GACA,4CAAsB,uBAEjB,4BAAP,kCAOe,sBACf,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAEvB,cAAuB,iBAChB,2CAAP,IAEK,cAA2B,6BAAa,iBAAI,cAAQ,gBAA3D,4BAKO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BnBnjHS,iBAAe,MAAgB,IAAe,eAArD,8BmByjHK,AAAmB,cAAK,yEAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,8BAMO,AAAmB,cAAK,yEAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BAMO,AAAmB,cAAK,6BAA/B,4BHz6DS,AAA8B,iBAAU,EAAI,EAAK,EAAK,gBAA7D,kCGu7Da,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACH,EAAe,aACf,EAAyB,UACrC,AAAc,IAET,AAAQ,MAAG,EAAI,KAClB,AAAW,cAA2B,cAAS,iBAAI,eAAS,OAC5D,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAQ,AAAiB,KAAU,cAAO,MAE1C,cAAK,EAAK,KACV,QAPoB,AAAE,WAU1B,cAAuB,kBACvB,AAAI,EAAW,KAEN,cAAY,4BAAnB,IAGA,AAAe,EAAW,KAC1B,AAAI,IAEF,AAAM,cAAa,EAAoB,cAAK,WAG5C,AAAM,cAAY,oBAEf,AAAQ,MAAe,EAAI,KAC9B,AAAW,cAAK,OAChB,AAAI,IAAM,AAAM,cAAoB,EAAgC,EAAK,EAAO,QAF9C,WAI7B,aAAP,8BAnDK,AAAc,4BAArB,kCA0De,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACH,EAAe,aACf,EAAyB,UACrC,AAAc,IAET,AAAQ,MAAG,EAAI,KAClB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAS,AAAiB,KAAU,cAAO,EAAK,OAEhD,cAAK,EAAK,KACV,QAPmB,AAAE,WAUzB,cAAuB,kBACvB,AAAI,EAAW,KAEN,cAAY,4BAAnB,IAGA,AAAe,EAAW,KAC1B,AAAI,IAEF,AAAM,cAAa,EAAoB,cAAK,WAG5C,AAAM,cAAY,oBAEf,AAAQ,MAAe,EAAI,KAC9B,AAAW,cAAK,OAChB,AAAI,IAAM,AAAM,cAAoB,EAAgC,EAAK,EAAO,QAF/C,WAI5B,aAAP,oCAOa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACH,EAAe,aACf,EAAyB,UACrC,AAAc,IAET,AAAQ,MAAG,EAAI,KAClB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAS,AAAiB,KAAU,cAAO,EAAK,OAEhD,cAAK,EAAK,KACV,QAPmB,AAAE,WAUzB,cAAuB,kBACvB,AAAI,EAAW,KAEN,cAAY,4BAAnB,IAGA,AAAe,EAAW,KAC1B,AAAI,IAEF,AAAM,cAAa,EAAoB,cAAK,WAG5C,AAAM,cAAY,oBAEf,AAAQ,MAAe,EAAI,KAC9B,AAAW,cAAK,OAChB,AAAI,IAAM,AAAM,cAAoB,EAAgC,EAAK,EAAO,QAF/C,WAI5B,aAAP,oCAOa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACH,EAAe,aACf,EAAyB,UACrC,AAAc,IAET,AAAQ,MAAG,EAAI,KAClB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAU,EAAK,KACf,AAAS,AAAoB,KAAW,cAAO,EAAM,MACrD,AAAS,AAAqB,KAAU,cAAO,EAAM,OAErD,cAAK,EAAK,KACV,QATmB,AAAE,WAYzB,cAAuB,kBACvB,AAAI,EAAW,KAEN,cAAY,4BAAnB,IAGA,AAAe,EAAW,KAC1B,AAAI,IAEF,AAAM,cAAa,EAAoB,cAAK,WAG5C,AAAM,cAAY,oBAEf,AAAQ,MAAe,EAAI,KAC9B,AAAW,cAAK,OAChB,AAAI,IAAM,AAAM,cAAoB,EAAgC,EAAK,EAAO,QAF/C,WAI5B,aAAP,oCAOa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACH,EAAe,aACf,EAAyB,UACrC,AAAc,IAET,AAAQ,MAAG,EAAI,KAClB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAS,AAAiB,KAAU,cAAO,EAAK,OAEhD,cAAK,EAAK,KACV,QAPmB,AAAE,WAUzB,cAAuB,kBACvB,AAAI,EAAW,KAEN,cAAY,4BAAnB,IAGA,AAAe,EAAW,KAC1B,AAAI,IAEF,AAAM,cAAa,GAAoB,cAAK,WAG5C,AAAM,cAAY,oBAEf,AAAQ,MAAe,EAAI,KAC9B,AAAW,cAAK,OAChB,AAAI,IAAM,AAAM,cAAoB,EAAgC,EAAK,EAAO,QAF/C,WAI5B,aAAP,oCAOa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACH,EAAe,aACf,EAAyB,UACrC,AAAc,IAET,AAAQ,MAAG,EAAI,KAClB,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAS,AAAiB,KAAU,cAAO,EAAK,OAEhD,cAAK,EAAK,KACV,QAPmB,AAAE,WAUzB,cAAuB,kBACvB,AAAI,EAAW,KAEN,cAAY,4BAAnB,IAGA,AAAe,EAAW,KAC1B,AAAI,IAEF,AAAM,cAAa,GAAoB,cAAK,WAG5C,AAAM,cAAY,oBAEf,AAAQ,MAAe,EAAI,KAC9B,AAAW,cAAK,OAChB,AAAI,IAAM,AAAM,cAAoB,EAAgC,EAAK,EAAO,QAF/C,WAI5B,aAAP,oCAOa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,cAAuB,kBACvB,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,SAjBoB,cAAa,EAAoB,gBAAxC,KAEQ,cAAa,EAAoB,gBAAxC,KAEO,cAAa,EAAoB,gBAAxC,KAEO,cAAa,EAAoB,gBAAxC,KAGV,cACL,kCACI,GACA,GACJ,gBALiB,IAQK,cAAa,GAAoB,gBAAxC,IACO,cAAa,GAAoB,gBAAxC,KAGvB,cACE,GACA,4CAAmC,gBAAc,oCAE5C,4BAAP,4BHxxES,AAA8B,iBAAU,EAAI,EAAK,gBAAxD,kCG8xEa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,QAChB,4BAAP,OACa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAS,OAC5D,cAAuB,iBACvB,AAAU,IACV,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAM,AAAiB,QAEvB,cACE,GACA,cAAS,0CAGb,AAAI,mBACF,AAAa,AAAC,EAAK,AAAO,wCAAkB,KAC5C,AAAI,EAAM,QAAK,EAAM,MACnB,cACE,GACA,cAAS,gCAAU,gBAAc,eAAK,sBAExC,AAAM,KAER,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,QAlBoB,cAAoB,EAAgC,EAAM,gBAAjE,IACO,cAAoB,EAAgC,EAAM,gBAAjE,IACQ,cAAoB,EAAgC,EAAM,gBAAjE,IACO,cAAoB,EAAgC,EAAM,gBAAjE,KAEO,cAAoB,EAAgC,EAAM,gBAAjE,KAEO,cAAoB,EAAgC,EAAM,gBAAjE,KAGV,cACL,kCACI,GACA,GACJ,EAAM,gBALW,IAQK,cAAoB,EAAgC,EAAM,gBAAjE,IACO,cAAoB,EAAgC,EAAM,gBAAjE,KAGvB,cACE,GACA,4CAAmC,gBAAqB,oCAEnD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAS,OAC5D,AAAW,cAA2B,cAAS,iBAAI,cAAM,OACzD,cAAuB,kBACvB,AAAU,IACV,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAM,AAAiB,QAEvB,cACE,GACA,cAAS,0CAGb,AAAI,mBACF,AAAa,AAAC,EAAK,AAAO,wCAAkB,KAC5C,AAAI,EAAM,QAAK,EAAM,MACnB,cACE,GACA,cAAS,gCAAU,gBAAc,eAAK,sBAExC,AAAM,KAER,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,SAjBoB,cAAoB,EAAgC,EAAM,EAAS,gBAA1E,KAEQ,cAAoB,EAAgC,EAAM,EAAS,gBAA1E,KAEO,cAAoB,EAAgC,EAAM,EAAS,gBAA1E,KAEO,cAAoB,EAAgC,EAAM,EAAS,gBAA1E,KAGV,cACL,kCACI,GACA,GACJ,EAAM,EAAS,gBALE,IAQK,cAAoB,EAAgC,EAAM,EAAS,gBAA1E,IACO,cAAoB,EAAgC,EAAM,EAAS,gBAA1E,KAGvB,cACE,GACA,4CAAmC,gBAAqB,oCAEnD,4BAAP,6BHz8BA,AAAI,AAAC,KAAY,aAAP,IACV,AAAU,mBACV,AAAU,AAAiB,MACtB,AAAQ,MAAG,EAAI,KAClB,AAAsB,EAAM,GAAG,AAAU,cAAI,QADtB,AAAE,WAGpB,aAAP,6BAx8CE,AAAO,iBAAe,qBACtB,AAAW,AAAa,mBACxB,AAAU,AAA8B,iBAAU,EAAM,EAAM,OAC9D,AAAe,IACR,aAAP,kCG64Ea,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,sBAElB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAI,mBACF,AAAgB,mBAChB,AAAgB,EAAK,KACrB,AAAO,AAAiB,QAAc,AAAW,2BACjD,AACE,AAAkB,cAAK,EAAI,QAE3B,cAAuB,kBAChB,4BAAP,IAEF,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,mBAAc,GACN,EAAe,UAC1B,AAAa,AAAC,EAAa,GAAK,KAC3B,AAAQ,MAAG,EAAI,QACJ,cAAS,EAAI,WAC3B,AAAW,cAA2B,cAAS,eAAS,OACxD,AAAc,cAAqB,EAAM,WACzC,AAAU,IACV,AAAI,IACF,AAAM,AAAiB,OACvB,AAAI,EAAM,QAAK,EAAM,MACnB,cACE,GACA,6BAAe,gBAAc,eAAK,sBAEpC,AAAM,MAGR,cACE,GACA,uCAGJ,YAAQ,MACD,OAIA,OAOA,OASA,QApBG,AACN,AAAQ,EAAK,cAAM,KACnB,GAEM,AACN,AAAW,EAAK,KAChB,AAAW,EAAO,KAClB,AAAQ,EAAU,cAAM,KACxB,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,GAEM,AACN,AAAW,EAAK,KAChB,AAAW,EAAO,KAClB,AAAQ,EAAU,cAAM,KACxB,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,GAEM,AACN,AAAW,EAAK,KAChB,AAAW,EAAO,KAClB,AAAQ,EAAU,cAAM,KACxB,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,AAAQ,EAAO,GAAG,cAAM,EAAO,MAC/B,GAEO,AAAO,qBAtDW,AAAE,WAyDjC,cAAuB,kBAChB,cAAoB,EAAM,EAAM,4BAAvC,KAIN,cACE,GACA,4CAAmC,gBAAgB,oCAErD,cAAuB,kBAChB,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OACvD,cAAc,GAAuB,EAAM,gBAAlD,4BH/+EE,AAAW,cAAuB,mBAC3B,AAA2B,iBAAU,EAAI,EAAQ,EAAO,EAAK,gBAApE,2DAHe,4FGu/EF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAkB,mBAClB,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,kBAChB,4BAAP,MAIN,cAAuB,kBACvB,AAAI,mBACF,0BAAQ,qBACD,OACA,OAGA,OACA,OAGA,OACA,OACA,OAGA,OACA,OAMA,OACA,OACA,SApBI,cAAiB,EAAuB,EAAM,EAAW,uBADhD,KAKT,cAAiB,EAAwB,EAAM,EAAW,uBADhD,MAMV,cAAiB,EAAwB,EAAM,EAAW,uBADhD,KAIE,AACf,AAAC,mCACI,cAAiB,EAAwB,EAAM,EAAW,uBAAjE,OAOK,cAAiB,EAAwB,EAAM,EAAW,uBADhD,KAKvB,cACE,GACA,4CAAmC,gBAAmB,oCAEjD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAkB,mBAClB,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,kBAChB,4BAAP,MAIN,cAAuB,kBACvB,AAAI,mBACF,kBAAQ,qBACD,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,QAboB,cAAiB,EAAqB,EAAM,EAAW,uBAA9D,IACO,cAAiB,EAAqB,EAAM,EAAW,uBAA9D,IACQ,cAAiB,EAAsB,EAAM,EAAW,uBAA/D,IACO,cAAiB,EAAsB,EAAM,EAAW,uBAA/D,IACE,AACf,kCAA2B,IAGP,cAAiB,EAAsB,EAAM,EAAW,uBAA/D,IACE,AACf,kCAA2B,IAGP,cAAiB,EAAsB,EAAM,EAAW,uBAA/D,KAGvB,cACE,GACA,4CAAmC,gBAAiB,oCAE/C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAkB,mBAClB,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,kBAChB,4BAAP,MAIN,cAAuB,kBACvB,AAAI,mBACF,kBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UALqB,cAAiB,EAAuB,EAAM,EAAW,uBAAhE,MAGO,cAAiB,EAAuB,EAAM,EAAW,uBAAhE,KAGV,cACL,kCACI,GACA,GACJ,EACA,EACA,uBAPiB,KAYzB,cACE,GACA,4CAAmC,gBAAkB,oCAEhD,4BAAP,4BH3pFE,AAAW,cAAuB,mBAC3B,AAAoC,iBAAU,EAAI,EAAQ,EAAO,EAAO,EAAK,EAAK,gBAAzF,2DAHe,gGGmqFF,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAS,OAC5D,AAAU,IACV,AAAc,cAAqB,EAAM,WACzC,AAAI,IACF,AAAM,AAAiB,QAEvB,cACE,GACA,cAAS,0CAGb,AAAkB,mBAClB,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,kBAChB,4BAAP,MAIN,cAAuB,kBACvB,AAAI,mBACF,AAAa,AAAC,EAAK,AAAO,wCAAkB,KAC5C,AAAI,EAAM,QAAK,EAAM,MACnB,cACE,GACA,cAAS,gCAAU,gBAAc,eAAK,sBAExC,AAAM,KAER,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SAVoB,cAA0B,EAA+B,EAAM,EAAW,EAAU,EAAS,uBAApG,KAEQ,cAA0B,EAAgC,EAAM,EAAW,EAAU,EAAS,uBAArG,MAGO,cAA0B,EAAgC,EAAM,EAAW,EAAU,EAAS,uBAArG,MAGO,cAA0B,EAAgC,EAAM,EAAW,EAAU,EAAS,uBAArG,KAGV,cACL,kCACI,GACA,GACJ,EACA,EACA,EACA,EACA,uBATiB,KAczB,cACE,GACA,4CAAmC,gBAAkB,oCAEhD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAAK,MACvB,AAAkB,cAAK,EAAG,QACnB,4BAAP,OACa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAS,OAC5D,AAAU,IACV,AAAc,cAAqB,EAAM,EH76DvB,EACS,OG66D3B,AAAI,IACF,AAAM,AAAiB,QAEvB,cACE,GACA,cAAS,0CAGb,AAAkB,mBAClB,AAAgB,IAChB,AAAe,mBACf,AAAI,EAAe,KACjB,AAAY,AAAwB,cAAS,iBAAI,mBACjD,AAAI,EAAY,KACd,cAAuB,kBAChB,4BAAP,IAEF,AAAI,EAAe,KACjB,AAAW,AAAuB,cAAS,iBAAI,EAAU,mBACzD,AAAI,EAAW,KACb,cAAuB,kBAChB,4BAAP,MAIN,cAAuB,kBACvB,AAAI,mBACF,AAAa,AAAC,EAAK,AAAO,wCAAkB,KAC5C,AAAI,EAAM,QAAK,EAAM,MACnB,cACE,GACA,cAAS,gCAAU,gBAAc,eAAK,sBAExC,AAAM,KAER,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SAVoB,cAA0B,EAAgC,EAAM,EAAW,EAAU,EAAS,uBAArG,KAEQ,cAA0B,EAAiC,EAAM,EAAW,EAAU,EAAS,uBAAtG,MAGO,cAA0B,EAAiC,EAAM,EAAW,EAAU,EAAS,uBAAtG,MAGO,cAA0B,EAAiC,EAAM,EAAW,EAAU,EAAS,uBAAtG,KAGV,cACL,kCACI,GACA,GACJ,EACA,EACA,EACA,EACA,uBATiB,KAczB,cACE,GACA,4CAAmC,gBAAmB,oCAEjD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,SAjBoB,cAAc,GAAmB,EAAM,gBAA9C,KAEQ,cAAc,GAAmB,EAAM,gBAA9C,KAEO,cAAc,GAAmB,EAAM,gBAA9C,KAEO,cAAc,GAAmB,EAAM,gBAA9C,KAGV,cACL,kCACI,IACA,IACJ,EAAM,gBALW,IAQK,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,SAjBoB,cAAc,GAAmB,EAAM,gBAA9C,KAEQ,cAAc,GAAmB,EAAM,gBAA9C,KAEO,cAAc,GAAmB,EAAM,gBAA9C,KAEO,cAAc,GAAmB,EAAM,gBAA9C,KAGV,cACL,kCACI,IACA,IACJ,EAAM,gBALW,IAQK,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SARqB,cAAc,GAAmB,EAAM,gBAA9C,KAEO,cAAc,GAAmB,EAAM,gBAA9C,KAEO,cAAc,GAAmB,EAAM,gBAA9C,KAES,cAAc,kCAA4B,IAAoB,IAAmB,EAAM,gBAA9F,IACK,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OACA,OACA,OACA,QAHoB,cAAc,GAAsB,EAAM,gBAAjD,IACO,cAAc,GAAsB,EAAM,gBAAjD,IACQ,cAAc,GAAsB,EAAM,gBAAjD,IACO,cAAc,GAAsB,EAAM,gBAAjD,KAGvB,cACE,GACA,4CAAmC,gBAAgB,oCAE9C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OACA,OACA,OACA,QAHoB,cAAc,GAAsB,EAAM,gBAAjD,IACO,cAAc,GAAsB,EAAM,gBAAjD,IACQ,cAAc,GAAsB,EAAM,gBAAjD,IACO,cAAc,GAAsB,EAAM,gBAAjD,KAGvB,cACE,GACA,4CAAmC,gBAAgB,oCAE9C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,OACA,OACA,QAfoB,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,IACQ,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,IACE,AACf,kCAA2B,IAGP,cAAc,GAAmB,EAAM,gBAA9C,IACE,AACf,kCAA2B,IAGP,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,OACA,OACA,QAfoB,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,IACQ,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,IACE,AACf,kCAA2B,IAGP,cAAc,GAAmB,EAAM,gBAA9C,IACE,AACf,kCAA2B,IAGP,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,IACO,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAc,GAAoB,EAAM,gBAA/C,IACO,cAAc,GAAoB,EAAM,gBAA/C,KAGvB,cACE,GACA,4CAAmC,gBAAa,oCAE3C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAc,GAAoB,EAAM,gBAA/C,IACO,cAAc,GAAoB,EAAM,gBAA/C,KAGvB,cACE,GACA,4CAAmC,gBAAa,oCAE3C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,IAAQ,qBACD,QAAqB,cAAc,GAAmB,EAAM,gBAA9C,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAc,GAAoB,EAAM,gBAA/C,IACO,cAAc,GAAoB,EAAM,gBAA/C,KAGvB,cACE,GACA,4CAAmC,gBAAa,oCAE3C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SAVoB,cAAc,GAAkB,EAAM,gBAA7C,KAEQ,cAAc,GAAkB,EAAM,gBAA7C,KAEO,cAAc,GAAkB,EAAM,gBAA7C,KAEO,cAAc,GAAkB,EAAM,gBAA7C,KAES,cAAc,kCAA4B,IAAmB,IAAkB,EAAM,gBAA5F,IACK,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SAVoB,cAAc,GAAkB,EAAM,gBAA7C,KAEQ,cAAc,GAAkB,EAAM,gBAA7C,KAEO,cAAc,GAAkB,EAAM,gBAA7C,KAEO,cAAc,GAAkB,EAAM,gBAA7C,KAES,cAAc,kCAA4B,IAAmB,IAAkB,EAAM,gBAA5F,IACK,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OAEA,OACA,OAIA,OACA,QAdoB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACQ,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IAES,cAAc,kCAA4B,IAAmB,IAAkB,EAAM,gBAA5F,IACA,AACnB,AAAI,kCAA2B,GACxB,cAAc,GAAkB,EAAM,gBAA7C,IAEwB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OAEA,OACA,OAIA,OACA,QAdoB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACQ,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IAES,cAAc,kCAA4B,IAAmB,IAAkB,EAAM,gBAA5F,IACA,AACnB,AAAI,kCAA2B,GACxB,cAAc,GAAkB,EAAM,gBAA7C,IAEwB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OAEA,OACA,OAIA,OACA,QAdoB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACQ,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IAES,cAAc,kCAA4B,IAAmB,IAAkB,EAAM,gBAA5F,IACA,AACnB,AAAI,kCAA2B,GACxB,cAAc,GAAkB,EAAM,gBAA7C,IAEwB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,wBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OAEA,OACA,OAIA,OACA,QAdoB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACQ,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,IAES,cAAc,kCAA4B,IAAmB,IAAkB,EAAM,gBAA5F,IACA,AACnB,AAAI,kCAA2B,GACxB,cAAc,GAAkB,EAAM,gBAA7C,IAEwB,cAAc,GAAkB,EAAM,gBAA7C,IACO,cAAc,GAAkB,EAAM,gBAA7C,KAGvB,cACE,GACA,4CAAmC,gBAAW,oCAEzC,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OACA,OACA,OACA,QAHqB,cAAc,GAA6B,EAAM,gBAAxD,IACO,cAAc,GAA6B,EAAM,gBAAxD,IACO,cAAc,GAA6B,EAAM,gBAAxD,IACO,cAAc,GAA6B,EAAM,gBAAxD,KAGvB,cACE,GACA,4CAAmC,gBAAe,oCAE7C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,OACA,SAjBoB,cAAa,GAAkB,gBAAtC,KAEQ,cAAa,GAAkB,gBAAtC,KAEO,cAAa,GAAkB,gBAAtC,KAEO,cAAa,GAAkB,gBAAtC,KAGV,cACL,kCACI,IACA,IACJ,gBALiB,IAQK,cAAa,GAAkB,gBAAtC,IACO,cAAa,GAAkB,gBAAtC,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,0BAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QAXoB,cAAa,GAAkB,gBAAtC,IACQ,cAAa,GAAkB,gBAAtC,IACO,cAAa,GAAkB,gBAAtC,IACO,cAAa,GAAkB,gBAAtC,IACS,cAAa,kCAA4B,IAAmB,IAAkB,gBAArF,QAKO,aAAP,IACK,cAAa,GAAkB,gBAAtC,IACO,cAAa,GAAkB,gBAAtC,KAGvB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAa,GAAmB,gBAAvC,IACO,cAAa,GAAmB,gBAAvC,KAGvB,cACE,GACA,4CAAmC,gBAAa,oCAE3C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAa,GAAmB,gBAAvC,IACO,cAAa,GAAmB,gBAAvC,KAGvB,cACE,GACA,4CAAmC,gBAAa,oCAE3C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAa,GAAoB,gBAAxC,IACO,cAAa,GAAoB,gBAAxC,KAGvB,cACE,GACA,4CAAmC,gBAAc,oCAE5C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAa,GAAoB,gBAAxC,IACO,cAAa,GAAoB,gBAAxC,KAGvB,cACE,GACA,4CAAmC,gBAAc,oCAE5C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,MAAQ,qBACD,OACA,QADqB,cAAa,GAAsB,gBAA1C,IACO,cAAa,GAAsB,gBAA1C,KAGvB,cACE,GACA,4CAAmC,gBAAgB,oCAE9C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OAIA,OACA,OAIA,QATgB,AACf,kCAA2B,IAGP,cAAa,GAA6B,gBAAjD,IACE,AACf,kCAA2B,IAGP,cAAa,GAA6B,gBAAjD,KAGvB,cACE,GACA,4CAAmC,gBAAgB,oCAE9C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OAIA,OACA,OAIA,QATgB,AACf,kCAA2B,IAGP,cAAa,GAAgC,gBAApD,IACE,AACf,kCAA2B,IAGP,cAAa,GAAgC,gBAApD,KAGvB,cACE,GACA,4CAAmC,gBAAoB,oCAElD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OAIA,OACA,OAIA,QATgB,AACf,kCAA2B,IAGP,cAAa,GAA8B,gBAAlD,IACE,AACf,kCAA2B,IAGP,cAAa,GAA8B,gBAAlD,KAGvB,cACE,GACA,4CAAmC,gBAAkB,oCAEhD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,UAAQ,qBACD,OAIA,OACA,OAIA,QATgB,AACf,kCAA2B,IAGP,cAAa,GAAkC,gBAAtD,IACE,AACf,kCAA2B,IAGP,cAAa,GAAkC,gBAAtD,KAGvB,cACE,GACA,4CAAmC,gBAAuB,oCAErD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,kBAAQ,qBACD,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,QAboB,cAAa,GAA+B,gBAAnD,IACO,cAAa,GAA+B,gBAAnD,IACQ,cAAa,GAA+B,gBAAnD,IACO,cAAa,GAA+B,gBAAnD,IACE,AACf,kCAA2B,IAGP,cAAa,GAA+B,gBAAnD,IACE,AACf,kCAA2B,IAGP,cAAa,GAA+B,gBAAnD,KAGvB,cACE,GACA,4CAAmC,gBAAmB,oCAEjD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,kBAAQ,qBACD,OACA,OACA,OACA,OACA,OAIA,OACA,OAIA,QAboB,cAAa,GAAgC,gBAApD,IACO,cAAa,GAAgC,gBAApD,IACQ,cAAa,GAAgC,gBAApD,IACO,cAAa,GAAgC,gBAApD,IACE,AACf,kCAA2B,IAGP,cAAa,GAAgC,gBAApD,IACE,AACf,kCAA2B,IAGP,cAAa,GAAgC,gBAApD,KAGvB,cACE,GACA,4CAAmC,gBAAoB,oCAElD,4BAAP,4BHvhIS,AAA4B,iBAAU,EAAI,EAAK,gBAAtD,kCG6hIa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACJ,6DAAmB,UAC9B,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,kBACvB,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SARoB,cAAkB,EAAsB,EAAM,gBAArD,KAEQ,cAAkB,EAAsB,EAAM,gBAArD,KAEO,cAAkB,EAAsB,EAAM,gBAArD,KAEO,cAAkB,EAAsB,EAAM,gBAArD,KAGV,cACL,kCACI,GACA,GACJ,EAAM,gBALW,KAUzB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACJ,6DAAmB,UAC9B,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,cAAuB,kBACvB,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAQA,QAhBoB,cAAkB,EAAsB,EAAM,gBAArD,IACO,cAAkB,EAAsB,EAAM,gBAArD,IACQ,cAAkB,EAAsB,EAAM,gBAArD,IACO,cAAkB,EAAsB,EAAM,gBAArD,IACO,cAAkB,EAAsB,EAAM,gBAArD,IACO,cAAkB,EAAsB,EAAM,gBAArD,IACO,cAAkB,EAAsB,EAAM,gBAArD,IACO,cAAkB,EAAsB,EAAM,gBAArD,IAEV,cACL,kCACI,GACA,GACJ,EAAM,gBALW,IASZ,cACL,kCACI,GACA,GACJ,EAAM,gBALW,KAUzB,cACE,GACA,4CAAmC,gBAAY,oCAE1C,4BAAP,kCAKe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OACvD,cAAc,EAAI,EAAM,gBAA/B,4BAKO,AAA4B,cAAK,iBAAxC,4BAMO,AAA4B,cAAK,iBAAxC,4BAMO,AAA4B,cAAK,iBAAxC,4BAMO,AAA4B,cAAK,iBAAxC,kCAKe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAW,OACvD,cAAa,EAAI,gBAAxB,4BAKO,AAA2B,cAAK,iBAAvC,4BHjsIS,AAA8B,iBAAU,EAAI,EAAG,EAAG,gBAAzD,kCGssIa,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OACvD,cAAoB,EAAI,EAAM,EAAM,gBAA3C,4BAKO,AAA6B,cAAK,gBAAzC,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAgB,kBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBAChB,cAAa,GAAqB,gBAAzC,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACJ,6DAAmB,UAC9B,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBACvB,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SARoB,cAAa,GAAsB,gBAA1C,KAEQ,cAAa,GAAsB,gBAA1C,KAEO,cAAa,GAAsB,gBAA1C,KAEO,cAAa,GAAsB,gBAA1C,KAGV,cACL,kCACI,IACA,IACJ,gBALiB,KAUzB,cACE,GACA,4CAAmC,gBAAiB,oCAE/C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACJ,6DAAmB,UAC9B,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBACvB,AAAI,mBACF,sBAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,SARoB,cAAa,GAAsB,gBAA1C,KAEQ,cAAa,GAAsB,gBAA1C,KAEO,cAAa,GAAsB,gBAA1C,KAEO,cAAa,GAAsB,gBAA1C,KAGV,cACL,kCACI,IACA,IACJ,gBALiB,KAUzB,cACE,GACA,4CAAmC,gBAAgB,oCAE9C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACJ,6DAAmB,UAC9B,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBACvB,AAAI,mBACF,MAAQ,qBACD,OACA,SAAoB,cAAa,GAAqB,gBAAzC,KAGtB,cACE,GACA,4CAAmC,gBAAe,oCAE7C,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACJ,6DAAmB,UAC9B,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBACvB,AAAI,mBACF,UAAQ,qBACD,OACA,OACA,OACA,QAHoB,cAAa,GAAoC,gBAAxD,IACO,cAAa,GAAoC,gBAAxD,IACQ,cAAa,GAAoC,gBAAxD,IACO,cAAa,GAAoC,gBAAxD,KAGvB,cACE,GACA,4CAAmC,gBAAwB,oCAEtD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yBACT,IAAgB,cAAc,MAAK,SAC9C,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBACvB,AAAI,mBACF,IAAQ,qBACD,QAAqB,cAAa,GAAgC,gBAApD,KAGvB,cACE,GACA,4CAAmC,gBAAoB,oCAElD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cAgmIgE,MA/lIlF,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yBACT,IAAgB,cAAc,MAAK,SAC9C,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,cAAuB,kBACvB,AAAI,mBACF,IAAQ,qBACD,QAAqB,cAAa,GAAgC,gBAApD,KAGvB,cACE,GACA,4CAAmC,gBAAoB,oCAElD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,IAAQ,qBACD,QAAqB,cAAc,GAA0B,EAAM,gBAArD,KAGvB,cACE,GACA,4CAAmC,gBAAoB,oCAElD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,oBAClB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,cAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,QALoB,cAAc,GAAyB,EAAM,gBAApD,IACO,cAAc,GAAyB,EAAM,gBAApD,IACQ,cAAc,GAAyB,EAAM,gBAApD,IACO,cAAc,GAAyB,EAAM,gBAApD,IACO,cAAc,GAAyB,EAAM,gBAApD,IACO,cAAc,GAAyB,EAAM,gBAApD,KAGvB,cACE,GACA,4CAAmC,gBAAmB,oCAEjD,4BAAP,kCAMe,yBACF,sBACb,AACE,AAAoB,cAAK,KACzB,AAAkB,cA2+HgE,MA1+HlF,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,yBACK,yDACT,cAAc,UACzB,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAW,cAA2B,cAAS,iBAAI,eAAW,OAC9D,AAAI,mBACF,cAAQ,qBACD,OACA,OACA,OACA,OACA,OACA,QALoB,cAAc,GAA0B,EAAM,gBAArD,IACO,cAAc,GAA0B,EAAM,gBAArD,IACQ,cAAc,GAA0B,EAAM,gBAArD,IACO,cAAc,GAA0B,EAAM,gBAArD,IACO,cAAc,GAA0B,EAAM,gBAArD,IACO,cAAc,GAA0B,EAAM,gBAArD,KAGvB,cACE,GACA,4CAAmC,gBAAoB,oCAElD,4BAAP,kCAQe,yBACF,sBACb,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,+BAA4B,MAC5B,cAAuB,kBAChB,cAAY,eAA4B,qCAAE,mBAAQ,mBAAzD,kCAMe,yBACF,sBACb,AACE,AAAgB,iBAChB,AAAkB,cAAK,QAEvB,cAAuB,kBAChB,4BAAP,OAEa,sBACf,AAAW,cAA2B,cAAS,iBAAI,4CAA4B,OAC/E,AAAW,cAA2B,cAAS,iBAAI,eAAU,OAC7D,+BAA4B,MAC5B,cAAuB,kBAChB,cAAY,eAA4B,qCAAE,SAAM,mBAAQ,mBAA/D,qCAaA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAe,4BAAtB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAe,4BAAtB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAY,4BAAnB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAW,4BAAlB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACf,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAa,4BAApB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACrB,cAAqB,KACd,AAAc,4BAArB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,4BAMA,cAAoB,KACpB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAoB,4BAA3B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA6B,4BAApC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA6B,4BAApC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,4BAMA,cAAoB,KACpB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAuB,4BAA9B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA4B,4BAAnC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA4B,4BAAnC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA6B,4BAApC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA6B,4BAApC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,4BAMA,cAAoB,KACpB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAsB,4BAA7B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAwB,4BAA/B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,4BAMA,cAAoB,KACpB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,4BAMA,cAAoB,KACpB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAA0B,4BAAjC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAiB,4BAAxB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAkB,4BAAzB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAmB,4BAA1B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAgB,4BAAvB,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAyB,4BAAhC,qCAMA,AAAgB,kBAChB,cAAoB,oCAAE,uBACtB,cAAqB,kBACd,AAAqB,4BAA5B,4BAMA,cAAoB,KACpB,cAAqB,kBACd,AAAqB,4BAA5B,ki3BnBt1TiB,oBAEE,oBAED,mBAED,mBAEI,mBAEA,mBAEA,mBAEA,mBAEA,mBAEI,mBAEL,mBAEA,mBAEF,mBAEqB,mBAEV,mBAEX,mBAED,mBAE0B,mBAEvB,EACA,GACA,GACA,oBAEH,mBAEA,mBAEK,mBAEA,mBAEL,mBAES,mBAEA,mBAEA,mBAGD,mBAEF,mBAEA,iCAEF,6CgC/OrB,cAAiB,uCAIjB,cAAkB,uCAKlB,cAAmB,uCAKnB,cAAuB,uCAKvB,cAAuB,uCAKvB,cAAwB,uCAKxB,cAAwB,uCAKxB,cAAuB,uCAKvB,cAAsB,uCAKtB,cAAsB,uCAKtB,cAAoB,uCAKpB,cAA4B,uCAK5B,cAAqB,uCAKrB,cAAoB,s5CAKA,sBACpB,AAAI,AAAC,KAAe,iBAAwC,4BAC5D,cAAkB,cAAO,yWAKL,sBACpB,AAAI,IAAe,cAAqB,qDAKxC,cAAsB,mDAKtB,cAAmB,uCAKnB,cAAyB,uCAKzB,cAAwB,uCAQxB,cAAoB,uCAUpB,cAA6B,KAC7B,cAA6B,KAC7B,cAA6B,uCAoC7B,+BAAoB,wCAKpB,+BAAoB,AAAC,2CAKrB,cAA4B,KAC5B,cAA0B,uCAK1B,cAAuB,mDAKvB,cAAuB,uCAKvB,cAAmB,uCAInB,cAAoB,8UX+FqC,oBAIvD,AAAI,AAAC,QAA2B,mBAChC,cAAmB,ioBL02DgB,mBAmoBgB,kCACO,oBA99C1D,AAAO,EAAY,SAAe,EAAY,uBAC9C,cAAW,AAAiB,QAC5B,AAAgC,kUiBzvCd,oCAEG,kCAEA,kCAEY,mBAEJ,mBAEI,qDAIA,mBA8jBU,mBAkhBO,sBAzkC5C,sBACN,cAAe,gWRJ0B,mBAEI,mBAEpB,mBAy6BqB,kCAg/DN,qCAl5FlC,qCACN,cAAe,ggCbiyBR,EACL,cACA,EACE,cACA,cACA,cAAmC,cAAM,iBACzC,iBAEF,EACA,cA8wFiD,gBAvxFnD,4DANkB,uBAEG,KAEY,keA2uEW,mBAEjB,sCAIO,uCAUhC,EACA,6BACA,6BACA,cACA,UAEF,cAAc,iBACd,AAAO,AAAC,6BAAwB,mDAChC,6BAAwB,6BAAmB,qBACvB,6BAClB,gBAAS,4CACT,AAAiB,cAAS,yBAAI,yCAC9B,+BAEF,cAA6B,gCAC7B,cAAqB,wiDA9uFH,0CAEK,sCAIN,mBAEI,mBAEH,mBAKY,kCAEM,kCAE6B,kCAE5B,kCAEL,kCAED,kCAEU,kCAEM,kCAUA,mBAQJ,mBAQI,mBAQM,mBAQR,mBAQA,mBAQK,mBAQC,mBAQC,mBAQA,mBAQA,mBAQA,mBAQO,mBAQN,mBAQA,mBAQA,mBAQC,mBAQA,mBAQhB,mBAQA,mBAQU,mBAQV,mBAQc,mBAiBZ,mBAQE,mBAQH,mBAQD,mBAQE,mBAQD,mBAQG,mBAQF,mBAQI,mBAQD,mBAQN,mBAQC,mBAiHgB,sBAjchD,sBACN,cAAc,AAAc,iBAAoB,GAAG,mCACnD,cAAc,EAAW,6BAAkB,+CAC3C,cAAgB,EAAa,mCACZ,EAAS,cAAM,uBAChC,cAAkB,iBAClB,6BAAqB,6BAAyB,0DoBrMzC,EAAY,cpB6LyB,gBoB7L5C,qCAKO,iBAA4B,mCAC/B,6BAAoB,6CACpB,cAFJ,yOpBghBgB,sBACT,AAAQ,MAAG,EAAI,uBACL,cAAQ,UACrB,AAAI,6BAAuB,mBAAqB,4BAAP,IAFP,AAAE,WAI/B,aAAP,4BoB9gBK,cAAkB,4BAAzB,4BAQO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,4BAAP,4BAKO,iBAAoB,cAA3B,4BAKO,iBAAoB,cAA3B,4BAKO,iBAAoB,cAA3B,qC3B1SA,AAAU,IACV,AAAU,mBAGV,IAAO,EAAM,GAAI,KACf,cAAgB,KAAQ,SACxB,cAAgB,EAAM,MAAM,UAE5B,EAAO,UAGT,AAAI,EAAM,QAAK,EAAM,wBACZ,cAAe,EAAK,UAC3B,EAAO,KACP,AAAM,KAIR,IAAO,EAAM,GAAI,KACf,AAAQ,IAGR,AACE,cAAgB,KAAQ,MACxB,cAAgB,EAAM,MAAM,SAG5B,AAAQ,EAAM,GAAK,KACnB,AAAI,OACF,EAAM,GAAI,KACV,cAAgB,EAAM,MAAM,cAErB,IACH,cAAe,EAAG,MAClB,cAAe,EAAG,iBAAO,cAAe,EAAM,kCAClD,EAAO,KACP,GAIF,AAAQ,EAAM,GAAK,KACnB,AAAI,IAAS,cAAgB,EAAM,MAAM,YACvC,EAAM,GAAI,KACV,cAAgB,EAAM,MAAM,SAC5B,cAAgB,EAAM,MAAM,WAG5B,AAAW,IACX,IAAO,AAAE,OAAQ,KACf,AAAI,cAAgB,KAAS,MAC3B,AAAI,EAAM,GAAQ,QAChB,cAAgB,EAAO,MAAM,SAC7B,cAAgB,EAAO,MAAM,SAEtB,IACH,cAAe,EAAG,MAClB,cAAe,EAAG,iBAAQ,cAAe,EAAM,kCACnD,EAAO,EAAM,GAAI,MACjB,AAAM,EAAO,MAEf,QAKJ,AAAI,EAAO,KAAK,EAAM,SACpB,AAAI,EAAO,QACT,cAAgB,KAAM,SACtB,cAAgB,KAAM,SAEf,cAAe,EAAM,kBAC5B,AAAM,mBACN,MAKR,YAEK,EAAM,KAAI,GAAO,eAAxB,kbZqGE,AAAU,AAAO,mBACjB,AAAkB,AAAI,AAAI,IAAc,YAAI,YAC5C,AAAmB,AAAO,mBAC1B,AAAI,EAAe,GAAc,KAAY,aAAP,IAE/B,AAAC,AAAY,cAAM,EAAa,cAAQ,EAAG,iBAAlD,gOiBiQS,mBAEA,mBACI,mBACC,mBAEG,mBACC,mBACY,oBAEG,mBAymBL,mBACP,mBACF,sBAvmBb,sBAEN,AAAI,AAAC,QAA2B,mBAChC,cAAmB,iBACnB,cAAc,oBAEH,sBACX,AAAU,mBACV,AAAU,IAEV,AACE,EAAM,KACN,cAAgB,KAAQ,WAExB,AAAE,QAIJ,AACE,EAAM,GAAI,KACV,cAAgB,KAAQ,SACxB,cAAgB,EAAM,MAAM,SAE5B,EAAO,KACP,IACE,EAAM,KACN,cAAgB,KAAQ,SAExB,AAAE,aAIN,cAAW,KACX,cAAW,sDA0iBX,AAAI,EAAQ,KACV,AAAQ,mBACR,AAAM,oBACD,AAAI,EAAM,KACf,AAAM,SAEI,EAAU,EAAO,UAC7B,cAAe,gCACR,aAAP,gDATiB,KAAe,4EA4NrB,qCACX,AAAU,mBACV,AAAU,mBACV,AAAI,EAAM,GAAI,KAAO,cAAgB,KAAQ,SAC3C,QAAQ,cAAgB,EAAM,MAAK,OAC5B,QACA,QACA,WAAmB,aAAP,KAGrB,IAAO,EAAM,KACX,AAAQ,cAAgB,OACxB,AAAI,EAAK,QAAgB,AAAC,EAAI,GAAO,OAAmB,aAAP,IACjD,AAAI,EAAK,MAAe,EAAI,QAAe,EAAI,UAAc,GAE7D,YAEK,aAAP,6BTjoBF,AAAS,IACT,AAAS,mBACT,IAAO,EAAK,GAAI,KACd,AAAU,EAAM,AAAC,EAAK,GAAQ,MAC9B,EAAQ,EAAM,MACd,AAAa,cAAI,OACjB,AAAI,EAAU,KAAQ,EAAQ,cAAI,EAAM,aAC/B,aAAP,IAEF,AAAI,EAAO,KACT,AAAK,KAEL,AAAK,EAAM,WAGR,aAAP,4BA3ZO,AAAQ,UACR,EAAM,UACN,EAAM,SACN,EAAM,MAA6B,EAAM,UACtC,AAAmB,EAAI,kCAJjC,6BR3LE,AAAU,mBACV,AAAI,EAAY,KAAiB,aAAP,IAC1B,AAAY,AAAe,EAA2B,EAAc,SACpE,AAAI,AAAC,EAAQ,KAAW,UAAU,EAAM,GAAK,MAAY,aAAP,IAClD,AAAa,AAAe,EAA2B,EAAc,SACrE,AAAI,AAAC,EAAS,KAAW,OAAe,aAAP,IAC1B,AAAC,EAAQ,KAAU,GAAO,EAAS,MAAU,gBAApD,4BQ8LK,AAAiB,UACjB,EAAM,UACN,EAAM,SACN,EAAM,MAA4B,EAAM,UACrC,AAAmB,EAAI,kCAJjC,6BStFA,AAAU,mBACV,AAAO,oBACP,0CAAQ,cAAgB,SACjB,QAUA,QAIA,QAYA,QAWA,QAUA,QAWA,QAIA,QA2BA,QAIA,QAIA,QAIA,QAMA,QAKA,QAUA,QAKA,QAUA,QAYA,QAKA,QAKA,SA/JY,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAgB,aAAP,IACrB,AAAI,cAAQ,qBAAgB,aAAP,IACrB,GAEF,AAAI,cAAQ,qBAAa,aAAP,IAClB,AAAI,cAAQ,qBAAmB,aAAP,IACxB,GAEe,AACf,AAAI,cAAQ,qBAAgB,aAAP,IACrB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAgB,aAAP,IACrB,AAAI,cAAQ,qBAAgB,aAAP,IACrB,AAAI,cAAQ,qBAAgB,aAAP,IACrB,GAEF,AAAI,cAAQ,qBAAe,aAAP,IACpB,AAAI,cAAQ,qBAAmB,aAAP,IACxB,AAAI,cAAQ,oBAAsB,aAAP,IAC3B,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAkB,aAAP,IACvB,AAAI,cAAQ,qBAAkB,aAAP,IACvB,GAEF,AAAI,cAAQ,qBAAa,aAAP,IAClB,AAAI,cAAQ,qBAAiB,aAAP,IACtB,AAAI,cAAQ,qBAAmB,aAAP,IACxB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAe,aAAP,IACpB,AAAI,cAAQ,qBAAe,aAAP,IACpB,GAEF,AAAI,cAAQ,qBAAiB,aAAP,IACtB,AAAI,cAAQ,qBAAkB,aAAP,IACvB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,oBAAgB,aAAP,IACrB,AAAI,cAAQ,qBAAc,aAAP,IACnB,AAAI,cAAQ,qBAAe,aAAP,IACpB,GAEF,AAAI,cAAQ,qBAAmB,aAAP,IACxB,AAAI,cAAQ,qBAAkB,aAAP,IACvB,GAEe,AACf,AAAI,cAAQ,qBAAc,aAAP,IACnB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAa,aAAP,IAClB,AAAI,cAAQ,qBAAa,aAAP,IAClB,AAAI,cAAQ,qBAAa,aAAP,IAClB,GAEF,UAAQ,cAAgB,SACjB,QAIA,QAIA,QAIA,SAZY,AACf,AAAI,cAAQ,qBAAqB,aAAP,IAC1B,GAEe,AACf,AAAI,cAAQ,qBAAiB,aAAP,IACtB,GAEe,AACf,AAAI,cAAQ,qBAAqB,aAAP,IAC1B,GAEe,AACf,AAAI,cAAQ,qBAAoB,aAAP,IACzB,GAGJ,GAEe,AACf,AAAI,cAAQ,qBAAgB,aAAP,IACrB,GAEe,AACf,AAAI,cAAQ,qBAAc,aAAP,IACnB,GAEe,AACf,AAAI,cAAQ,qBAAiB,aAAP,IACtB,GAEe,AACf,AAAI,cAAQ,qBAAc,aAAP,IACnB,AAAI,cAAQ,oBAAe,aAAP,IACpB,AAAI,cAAQ,qBAAoB,aAAP,IACzB,GAEe,AACf,AAAI,cAAQ,qBAAa,aAAP,IAClB,AAAI,cAAQ,qBAAmB,aAAP,IACxB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAkB,aAAP,IACvB,AAAI,cAAQ,qBAAkB,aAAP,IACvB,GAEF,AAAI,cAAQ,qBAAiB,aAAP,IACtB,AAAI,cAAQ,qBAAoB,aAAP,IACzB,GAEe,AACf,AAAI,cAAQ,qBAAiB,aAAP,IACtB,AAAI,cAAQ,qBAAmB,aAAP,IACxB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,qBAAiB,aAAP,IACtB,AAAI,cAAQ,qBAAiB,aAAP,IACtB,GAEF,AAAI,cAAQ,qBAAc,aAAP,IACnB,AAAI,cAAQ,oBAAgB,aAAP,IACrB,GAEe,AACf,AAAI,EAAO,KACT,AAAI,cAAQ,oBAAe,aAAP,IACpB,AAAI,cAAQ,oBAAe,aAAP,IACpB,AAAI,cAAQ,qBAAe,aAAP,IACpB,GAEF,AAAI,cAAQ,qBAAc,aAAP,IACnB,AAAI,cAAQ,qBAAgB,aAAP,IACrB,AAAI,cAAQ,qBAAiB,aAAP,IACtB,GAEe,AACf,AAAI,cAAQ,qBAAc,aAAP,IACnB,AAAI,cAAQ,oBAAe,aAAP,IACpB,GAEe,AACf,AAAI,cAAQ,qBAAgB,aAAP,IACrB,AAAI,cAAQ,qBAAe,aAAP,IACpB,GAEe,AACf,AAAI,cAAQ,qBAAgB,aAAP,IACrB,GAGG,cAAP,kCA6Ka,qCACX,AAAU,mBACV,AAAU,mBACV,IAAO,EAAM,KACX,cAAgB,KAChB,AAAQ,cAAgB,OACxB,4FAAQ,MACD,OAOA,OACA,OACA,OACA,OACA,OAIA,OAoBA,OACA,OAIA,QAIA,OAYA,OAgBA,OAIA,OAIA,OAwBA,OAgBA,OAIA,OAgBA,OAoBA,OAiEA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAMA,OAIA,OAIA,OAyBA,OAyBA,OAoCA,OAIA,QAIA,QAIA,QAYA,QAIA,QAgBA,QAIA,QAIA,SAlYyB,AACxB,AACF,AAAE,OAAM,KACR,cAAgB,KAAQ,UACvB,QAOgB,AACnB,AAAE,OACF,GAEyB,AACzB,AAAE,OACF,AACE,EAAiB,KAAK,EAAM,SAC5B,cAAgB,KAAQ,SAExB,AAAE,OACF,AACE,EAAiB,KAAK,EAAM,SAC5B,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,IAEF,cAAW,KACJ,cAAP,KAGyB,AACzB,cAAW,KACJ,cAAP,IAEsB,AACtB,cAAW,KACJ,cAAP,IAEqB,AACrB,AAAE,OACF,AACE,EAAiB,KAAK,EAAM,SAC5B,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,IAEuB,AACvB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEuB,AACvB,cAAW,EAAM,MACV,cAAP,IAEwB,AACxB,cAAW,EAAM,MACV,cAAP,IAEsB,AACtB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,IAEF,AAAI,EAAO,KACT,AAAE,OACF,AACE,EAAiB,KAAK,EAAM,SAC5B,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEkB,AAClB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEmB,AACnB,cAAW,EAAM,MACV,cAAP,IAEmB,AACnB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEiB,AACjB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,AAAU,OACZ,cAAW,EAAM,MACV,cAAP,IAEF,AACE,EAAiB,KAAK,EAAM,GAAI,SAChC,EAAO,SACP,cAAgB,EAAM,MAAM,SAE5B,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEmB,AACnB,AAAsB,IACtB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,AAAkB,IAClB,AACE,EAAM,GAAI,KACV,cAAgB,EAAM,MAAM,SAE5B,AAAE,OACF,AAAc,KAEhB,IAAO,AAAE,OAAM,KACb,AAAI,cAAgB,KAAQ,KAC1B,AAAE,OACF,QAGJ,AAAI,mBACF,AACE,EACA,cAAe,EAAiB,iBAChC,cAAW,EAAiB,sBAH9B,wBAMF,GAEF,AAAI,EAAO,KACT,AAAa,IACb,IAAO,AAAE,OAAM,KACb,AAAI,cAAgB,OACpB,AACE,EAAK,KACL,EAAM,GAAI,SACV,cAAgB,EAAM,MAAM,SAE5B,EAAO,KACP,AAAS,IACT,QAGJ,AAAI,AAAC,KACH,cACE,GACA,cAAW,wBAAM,wBAEd,AAAI,mBACT,AACE,EACA,cAAe,EAAiB,iBAChC,cAAW,EAAiB,sBAH9B,yBAMF,GAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,aAWgB,AAChB,cAAW,KACJ,mBACH,IACA,eAFJ,IAImB,AACnB,cAAW,EAAM,MACV,cAAP,IAEuB,AACvB,cAAW,EAAM,MACV,cAAP,IAEsB,AACtB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,AAAE,OACF,AACE,EAAiB,KACjB,EAAM,SACN,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEoB,AACpB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,AAAE,OACF,AACE,EAAiB,KACjB,EAAM,SACN,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEyB,AACzB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,KACT,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAM,cAAgB,OACtB,AAAI,EAAO,KACT,AAAE,OACF,AACE,EAAiB,KAAK,EAAM,SAC5B,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEsB,AACtB,cAAW,EAAM,MACV,cAAP,IAEyB,AACzB,cAAW,EAAM,MACV,cAAP,IAE0B,AAC1B,cAAW,EAAM,MACV,cAAP,IAEmB,AACnB,AAAE,OACF,AACE,EAAiB,KAAK,EAAM,SAC5B,cAAgB,KAAQ,SAExB,cAAW,EAAM,MACV,cAAP,IAEF,cAAW,KACJ,cAAP,IAEuB,AACvB,cAAW,EAAM,MACV,aAAP,IAEiB,AACjB,AAAE,OACF,AAAI,EAAiB,KAAK,EAAM,SAC9B,AAAU,cAAgB,OAC1B,AAAI,EAAO,MACT,cAAW,EAAM,MACV,cAAP,IAEF,AAAI,EAAO,KACT,cAAW,EAAM,MACV,cAAP,KAGJ,cAAW,KACJ,cAAP,IAEwB,AACxB,cAAW,EAAM,MACV,aAAP,IAEmB,AACnB,cAAW,EAAM,MACV,cAAP,IAEgB,AAChB,cAAW,EAAM,MACV,cAAP,IAEO,AAEP,AAAI,AAAgB,OAAM,EAAM,GAAI,SAClC,AAAI,AAAkB,EAAG,cAAgB,EAAM,YAEjD,AAAI,AAAkB,OACpB,AAAgB,IAChB,IACE,AAAC,EAAO,AAAa,QAAM,KAC3B,AAAiB,AAAI,AAAK,cAAiB,qBAE7C,AAAI,EAAsB,KACxB,AAAwB,AAAiB,cAAe,EAAW,sBACnE,AACE,EAAqB,MACrB,AACE,EAAsB,KACtB,AAAsB,gBAGxB,cAAW,KACJ,aAAP,KAGJ,cAAW,KACJ,cAAP,IACK,AAAI,AAAa,OACtB,AAAE,OACF,IAEF,AAAY,IACZ,EAAO,AAAa,QACpB,cACE,GACA,cAAW,EAAO,0BAEpB,cAAW,KACJ,cAAP,SAIN,cAAW,KACJ,cAAP,4BA6FA,cAAiB,KACjB,cAAoB,KACpB,cAA0B,yCAjD1B,AAAgB,mBAChB,AAAkB,mBAClB,AAAqB,mBACrB,AAAwB,KACxB,AAAI,EAAS,MACX,AAAoB,KAGtB,EAAG,AAAY,cAAgB,EAAoB,OAC5C,EAAa,OACpB,AAAI,EAAa,KACf,cAAa,KACb,iBACO,aAAP,IAEA,cAAW,KACX,cAAa,KACb,cAAgB,KACT,aAAP,+DAnBwD,gEAHnD,cAAU,GAAkB,gBAAnC,6CADsD,0EAsE3C,qCACX,AAAU,mBACV,AAAU,mBACV,AAAY,IACZ,AAAQ,AAAK,cAAiB,OAC9B,AAAO,AAAkB,uBACzB,IACE,AAAC,EAAO,AAAa,QAAM,KAC3B,AAAiB,AAAI,AAAK,cAAiB,gBAC5C,MACD,cAAW,KACJ,cAAe,EAAO,gBAA7B,0IOyWM,EAAyB,sEAhkCxB,EAA6B,cAAY,cAAU,4BAA1D,iWPmKyC,KACnB,iEAVtB,iBAEA,EAAG,AAAQ,cAAgB,cACpB,EAAS,OAChB,cAAa,KACN,aAAP,8HOyhCM,EAAM,6GA4BN,EAAsB,EAAU,cAAS,8DAhpCxC,EAA0B,EAAU,cAAS,4BAApD,kCgB8CY,AAA0B,6BAAqB,iDAC7C,OACd,IAAO,cAAQ,eACb,AAAI,cAAQ,kBACC,AAA0B,6BAAqB,8CAC1D,cAAe,oBACL,QAEV,cACE,GACA,cAAS,gDAEJ,aAAP,SAGG,aAAP,8JvBiiBY,QACZ,AAAI,IACF,AAAgB,KAChB,cAAY,oBACZ,cAAc,oBACd,cAAiB,wBAET,EAAU,iBAAU,iBAAY,0BAEnC,aAAP,6BAvEA,AAAgB,mBAChB,AAAI,EAAY,KACd,AAAgB,mBAChB,AAAkB,mBAClB,AAAqB,mBACrB,EAAG,AAAY,cAAgB,EAAoB,OAC5C,EAAa,OACpB,cAAiB,KACjB,cAAoB,oBACpB,cAA0B,MAC1B,cAAW,KACX,cAAa,KACb,cAAgB,MAEX,aAAP,gDAjByC,KAChB,kFAzcmB,+DA0hB5C,cAAW,oBACX,cAAa,oBACb,cAAgB,oBAChB,gNO9EkD,mBAE/B,sBANb,EAAoB,sEAjxBnB,EAAkB,EAAe,cAAM,cAAM,cAAa,4BAAjE,2UAnBO,EAAkB,AAA0B,eAAI,6BAAQ,EAAM,EAAO,4BAA5E,oCgBuhBY,sBACZ,AAAe,mBACf,AAAyC,IACzC,AAAqC,IACrC,AAAwB,IACxB,AAAwD,IACxD,AAAoC,IAEpC,AAAI,cAAQ,eACV,AAAc,IACd,cAAW,oBACE,oBAGb,AAAc,IACd,IACE,AAAiB,IACjB,AAAW,IACX,AAAI,cAAQ,eACV,AAAa,mBACb,AAAc,IACd,cAAW,iBACX,AAAO,KAET,AAAI,cAAQ,cACV,AAAI,EAAa,KAAG,AAAa,oBACjC,AAAI,cAAQ,eACV,AAAc,IACd,cAAW,oBACA,cAAe,cAAI,YAC9B,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,iBAAa,KACf,cACE,GACA,sCAEF,cAAoC,KAC7B,cAAP,OAES,2CAEX,cAAS,iBACT,cAAoC,KAC7B,cAAP,KAEG,AAAI,0BACT,AAAI,EAAa,KAAG,AAAa,uBACtB,AAAgC,6BAAqB,cAAS,iBAAa,0CACtF,AAAI,cAAQ,eACV,AAAc,IACd,cAAW,iBACX,AAAI,EAAQ,KACV,cACE,GACA,gDAGF,AAAO,MAGX,AAAI,cAAQ,eACV,AAAc,IACd,cAAW,oBACA,cAAe,0BAC1B,AAAI,AAAC,KACH,cAAoC,KAC7B,cAAP,OAEU,AAAqB,EAAM,cAAM,cAAM,EAAM,cAAS,EAAY,wCAC9E,AAAI,AAAC,QAAyB,qCAAE,aAC3B,cAAgB,oBAErB,AAAI,AAAC,KACH,AAAI,0BAAa,MACf,AAAc,IACd,cAAW,mBAGf,AAAI,OACU,AAAqB,EAAM,cAAM,AAAuB,cAAS,sDAAU,EAAM,cAAS,EAAY,wCAClH,AAAI,AAAC,QAAyB,qCAAE,aAC3B,cAAgB,mBACrB,cACE,GACA,sDAEG,AAAI,AAAC,QAIa,OACvB,AAAiB,QAIrB,AAAI,IACF,AAAI,0BAAa,MAAkB,GACnC,cACE,GACA,gDAGF,cAAS,kBAEX,cAAoC,KAC7B,cAAP,KAEK,cAAQ,iBACjB,AAAI,AAAC,cAAQ,gBACX,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,cAAS,kBAEX,cAAoC,KAC7B,cAAP,KAKJ,AAAI,cAAQ,eACV,AAAI,AAAC,KACH,AAAc,IACd,cAAW,iBACX,AAAI,OACU,AACV,EACA,cACA,AAAuB,2DACvB,EACA,qCAEF,AAAI,AAAC,QAAyB,qCAAE,aAC3B,cAAgB,mBACrB,cACE,GACA,0DAIO,cAAe,0BAC5B,AAAI,AAAC,KACH,cAAoC,KAC7B,cAAP,KAGF,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,cAAS,kBAEX,cAAoC,KAC7B,cAAP,IAEF,cAAoC,KAEpC,AAAI,AAAC,QAAyB,oBAEvB,AACL,cACA,cACA,cACA,EACA,cAAS,EAAU,+CALrB,oCvBqdW,qCACX,AAAU,mBACV,AAAU,mBACV,AAAY,IACZ,AAAa,IACb,AAAY,IACZ,AAAY,EAAQ,uBACpB,AAAgB,IAChB,AAAuB,IAEvB,IAAO,EAAM,KACX,AAAQ,cAAgB,OACxB,AAAI,AAAU,OAEZ,AAAY,EACV,EAAQ,IAAO,cACf,EAAQ,EAAI,mCAET,AAAI,AAAU,OAEnB,AAAY,EACV,EAAQ,IAAO,cACf,EAAQ,AAAC,EAAI,GAAO,EAAK,qCAEtB,AAAI,EAAK,MACd,AAAI,EAAU,KACZ,cACE,EAAU,KACN,IACA,IACJ,cAAW,kCAGf,AAAS,EAAM,MAEf,KAEF,AAAI,EAAS,IAAO,cAElB,AAAmB,KAErB,AAAQ,IACR,AAAE,YAEJ,AAAI,EAAO,KACT,cACE,GACA,cAAW,kCAER,AAAI,EAAU,KACnB,cACE,GACA,cAAW,EAAS,oCAGxB,AAAI,IACF,cACE,GACA,cAAW,EAAQ,GAAG,iBACtB,4CAA2B,EAAQ,GAAG,yBAG1C,cAAW,KACJ,aAAP,iCA+UA,AAAY,mBACZ,AAAY,mBACZ,AAAc,EAAQ,YACtB,AAAc,IAEd,AAAO,AAAC,EAAS,gCACjB,AAAI,EAAU,QACZ,AAAI,EAAyB,KAC3B,cACE,GACA,cAAW,EAAO,0CAGtB,AAAU,KAGZ,AAAU,sBACC,qCACX,AAAI,iBAAY,KACd,AAAI,EAAyB,KAC3B,cACE,GACA,cAAW,EAAO,2BAGtB,AAAU,KACL,AAAI,cAAgB,oBAAa,MACtC,AAAE,sCAEF,AAAI,EAAyB,KAC3B,cACE,GACA,cAAW,EAAO,0CAGtB,AAAU,MAGZ,AAAI,IACK,AAAC,OACJ,cAAe,EAAuB,qBACtC,eAFJ,IAIK,AAAqB,gBAA5B,qCAjGA,AAAY,OACD,qCACX,AAAU,mBACV,AAAU,mBACV,IAAO,EAAM,KACX,AAAQ,cAAgB,gBACxB,AAAI,AAAU,OACZ,AAAQ,AAAC,EAAS,GAAK,GAAI,MACtB,AAAI,AAAU,OACnB,AAAQ,AAAC,EAAS,GAAM,EAAI,IAAO,EAAK,QACnC,AAAI,AAAC,OACV,cAAW,AAAE,UACN,cAAe,EAAuB,gBAA7C,IAEA,cAAW,KACX,cACE,GACA,cAAW,EAAM,GAAG,0BAEf,cAAP,OAEF,AAAI,AAAE,OAAU,KAAG,QAErB,AAAI,IACF,cAAW,KACX,AAAI,AAAC,OACI,cAAe,EAAuB,gBAA7C,IAEF,cACE,GACA,cAAW,iCAEN,cAAP,IAEF,cAAW,KACJ,AAAqB,gBAA5B,4BAeO,cAA2B,EAAG,gBAArC,qCAjkBA,AAAY,mBACZ,AAAU,mBACV,AAAI,AAAE,wDAAY,KAChB,cACE,GACA,cAAW,iCAEN,cAAP,OAGS,qCACX,AAAQ,cAAgB,8CACxB,kCAAQ,MACD,OAOA,QACA,QACA,QACA,QACA,QACA,QACA,OACA,OACA,QAUA,QAGA,OASA,OACA,SACA,UAvCa,AAChB,AAAI,IAAoB,iBAAW,SAAO,AAAU,cAAgB,6BAClE,AAAE,qCACK,cAAe,EAAO,+BAA7B,IAEK,eAAP,IAEsB,eAAP,IACO,eAAP,IACO,eAAP,IACO,eAAP,IACO,eAAP,IACO,eAAP,IACiB,eAAP,IACO,eAAP,IACV,AACf,AACE,iBAAW,KACX,cAAgB,oBAAa,UAE7B,AAAE,qCACK,cAA+B,IAAmB,GAAQ,iBAAjE,IAEK,cAAuB,IAAmB,GAAQ,iBAAzD,IAGO,cAA2B,EAAG,IAAmB,GAAQ,iBADjD,IAGa,AAE1B,iBAAW,KACX,cAAgB,oBAAa,SAE7B,AAAE,yCAMmC,cAAP,IAClB,AAAqB,gBAA5B,oCA/GA,qCACX,AAAU,mBACV,AAAU,mBACV,AAAI,AAAC,KAAO,AAAQ,cAAgB,iBACpC,AAAY,IACZ,cAAuB,QACV,QAEb,IAAO,IACL,AAAI,EAAO,QACT,cAAU,cAAe,EAAO,yBAChC,cACE,GACA,cAAW,EAAQ,GAAG,0BAExB,cAAqB,KACrB,GAEF,AAAQ,cAAgB,OACxB,AAAI,EAAK,KACP,cAAqB,QACrB,cAAU,cAAe,EAAO,kCAChC,GAEF,AAAI,EAAK,SACP,cAAU,cAAe,EAAO,yBAChC,cAAW,QACX,cAAU,cAAwB,yBAClC,AAAM,mBACN,AAAQ,IACR,GAEF,AAAI,EAAS,MACX,AAAI,EAAK,KAAmB,EAAM,GAAI,SAAO,cAAgB,EAAM,MAAM,aACvE,cAAU,cAAe,EAAO,yBAChC,cAAqB,KACrB,cAAW,EAAM,MACjB,cAA6B,KACtB,aAAP,KAEG,AAAI,AAAY,UACrB,cAAU,cAAe,EAAO,yBAChC,cACE,GACA,cAAW,EAAQ,GAAG,0BAExB,cAAqB,KACrB,IAEF,AAAE,YAEJ,cAAW,KACX,cAA6B,KACtB,aAAP,qUO9OO,2DAA6B,6BAApC,iCgBxZA,AAAY,0BACZ,AAAe,mBAKf,AAAI,EAAS,MAGX,AAA2B,cAAQ,kBAEnB,cAA0B,sBAC1C,AAAI,IACF,AAAI,IACF,AAAI,AAAC,cAAQ,gBACX,AAAI,AAAC,KACH,cACE,GACA,sCAAY,wBAGT,cAAP,QAGG,QACF,AAAI,OAAwB,oBACjC,AAAI,AAAC,KACH,cACE,GACA,gDAGG,cAAP,IAEK,AAAI,OACO,cAAe,cAAI,EAAO,UAC1C,AAAI,AAAC,KAAkB,cAAP,IAChB,AAAI,AAAC,cAAQ,gBACX,AAAI,AAAC,KACH,cACE,GACA,cAAS,uCAAS,wBAGf,cAAP,OAEK,OACP,6BAAmB,KACnB,6BAAiB,qBAEjB,AAAI,AAAC,KACH,cACE,GACA,gDAGG,cAAP,OAIG,AAAI,EAAS,QACX,AACL,AAA0B,eAAQ,qDAAa,yBAAI,EAAO,cAAS,EAAU,yCAI1E,AAAI,EAAS,QACX,AACL,AAA0B,eAAQ,qDAAa,yBAAI,EAAO,cAAS,EAAU,yCAI1E,AAAI,EAAS,QAAc,EAAS,SAClC,AACL,AAA0B,eAAQ,qDAAa,yBAAI,EAAO,cAAS,EAAU,yCAI1E,AAAI,EAAS,QACX,AACL,AAA0B,eAAQ,qDAAa,yBAAI,EAAO,cAAS,EAAU,yCAI1E,AAAI,EAAS,MAClB,yBACO,AACL,AAA0B,eAAU,qDAAa,yBAAI,EAAO,cAAS,EAAU,yCAI5E,AAAI,EAAS,SACP,cAAmB,sBAC9B,AAAI,AAAC,KAAa,cAAP,IACX,AAAoC,IAGpC,AAAI,cAAQ,eACV,KACkB,cAAe,cAAI,EAAM,UACzC,AAAI,AAAC,KAAkB,cAAP,IAChB,AAAI,AAAC,QAAyB,oCAAE,aAC3B,cAAgB,mBACd,cAAQ,gBACjB,AAAI,AAAC,cAAQ,gBACX,AAAI,AAAC,KACH,cACE,GACA,cAAS,uCAAS,wBAGf,cAAP,KAGJ,AAAI,AAAC,QAAyB,sBACvB,AAAqB,cAAM,cAAY,EAAO,cAAS,EAAU,yCAExE,AAAI,AAAC,KACH,cACE,GACA,gDAGG,cAAP,UAGF,IAAO,cAAQ,kBACE,cAAe,cAAI,EAAO,UACzC,AAAI,AAAC,KAAiB,cAAP,IACf,AAAiB,iBAAa,OAAsB,AAAC,2DACrD,AAAqB,iBAAiB,OAAsB,AAAC,2DAC7D,AAAI,AAAC,KAAc,AAAC,SAClB,AAAI,AAAC,KACH,cACE,GAAkC,6BAAgB,wBAG/C,cAAP,IACK,AAAI,IACT,cAAkB,KAClB,6BAAiB,oCACZ,AAAI,IACT,6BAAuB,mCACvB,cAAsB,QACf,QAGP,6BAAiB,2CAIrB,IAAO,cAAQ,eACb,AAAmB,mBACnB,AAAI,AAAC,cAAQ,gBACX,AAAI,AAAC,KACH,cACE,GACA,sCAAY,wBAGT,cAAP,OAEiB,cAAS,EAAc,yBAG1C,AAAe,IACf,AAAI,cAAQ,eACV,AAAI,cAAQ,cACV,AAAW,KAEX,AAAI,AAAC,KACH,cACE,GACA,sCAAY,wBAGT,cAAP,QAGG,AACL,AAA0B,eAAS,6BACnC,oCAAE,mBACF,EACA,cAAS,EAAU,wCAErB,AAAI,IAAU,QAGT,cAAP,kCAsvGY,sBACZ,AAAI,AAAC,cAAQ,gBAAwB,aAAP,IAC9B,AAAY,mBACZ,AAAuC,IACvC,IACE,AAAI,0BAAa,MACf,MAES,cAAe,cAAI,EAAM,UACpC,AAAI,AAAC,KACH,cAAS,iBACF,aAAP,IAEF,AAAI,AAAC,QAA+B,oCAAE,aACjC,cAAmB,mBACjB,cAAQ,iBACjB,AAAI,cAAQ,eACV,AAAU,mBACV,AAAI,cAAQ,eACV,AAAI,AAAC,KACH,cACE,GACA,cAAS,EAAO,2BAGb,aAAP,KAGJ,cAAS,iBACF,aAAP,yKhB9mFM,EAAc,sEAlhCb,EAAkB,cAAU,cAAe,cAAM,4BAAxD,4EAgjCM,eAAQ,EAAO,sBACrB,cAAY,6CA3iCL,EAAmB,4BAA1B,4EAyrCM,eAAQ,EAAO,sBACrB,cAAY,6CAzmCL,EAAmB,4BAA1B,4EAmnCM,eAAS,EAAO,sBACtB,cAAY,6CAhvCL,EAAoB,4BAA3B,4EAytCM,eAAQ,EAAO,sBACrB,cAAY,6CApmCL,EAAmB,4BAA1B,4EAk3BM,eAAe,EAAO,sBAC5B,cAAY,6CAv/BL,EAA0B,4BAAjC,4BArDO,EAAyB,eAAI,EAAO,4BAA3C,qCPiwBA,MAAQ,qBACD,QACA,SADqB,aAAP,IACQ,aAAP,IAEtB,8BACW,qCACN,AAAU,mBAAgB,qBAAmB,EAAM,KACtD,AAAI,AAAY,cAAgB,UAC9B,cAA0B,MACnB,aAAP,IAHyD,AAAE,WAM/D,cAA0B,MACnB,aAAP,2GOmyBM,EAAgB,8DA10Cf,EAAmB,cAAO,4BAAjC,+BgB0gFA,AAA8C,IAC9C,AAAI,0BAAa,MAAoB,AAAC,wBACpC,cAAQ,SACK,AAAgC,6BAAqB,oDAE1D,AAA0B,cAAY,8CAChD,cAAQ,cACD,aAAP,+UvBxlFF,AAAO,mCACP,YAAQ,cAAgB,SACjB,QACA,QACA,QACA,QACA,SAJmB,cAAQ,8BAAf,IACO,cAAQ,8BAAf,IACO,cAAQ,8BAAf,IACO,cAAQ,6BAAf,IACO,cAAQ,6BAAf,IAEZ,aAAP,+BuBqjBE,AAAI,AAAC,2BACH,cACE,GACA,+CAEK,aAAP,OAEe,AAAgC,6BAAqB,gDACtE,AAAI,AAA4B,kCAC9B,cACE,GACA,uCAGJ,AAAY,IACZ,AAAI,cAAQ,eACV,EAAS,QAGX,AAA4B,IAC5B,AAAI,cAAQ,kBACH,cAAe,cAAI,aAG5B,AAAqC,IACrC,AAAI,cAAQ,eACV,AAAI,EAAQ,OACV,cACE,GACA,mDAGU,cAAqB,cAAI,EAAmB,WAC1D,AAAI,AAAC,KAAoB,aAAP,IAClB,AAAI,EAAQ,OACV,cACE,GACA,wCAGC,AAAI,AAAC,KACV,AAAI,EAAQ,KACV,AAAI,AAAE,EAAQ,QACZ,cACE,GACA,wCAGC,AAAI,AAAC,KACV,cACE,GACA,cAAS,uDAIH,AAAW,6BAAkB,8CACzC,AAAI,AAAC,EAAQ,KAAmC,KAAK,AAAC,EAAQ,KAAwB,SACpF,cACE,GACA,wBAGG,AACL,cACA,cACA,EACA,cACA,cACA,4BANF,oRhBk0CM,EAAmB,sEA9lDlB,EAAsB,cAAY,cAAc,4BAAvD,qCgBwjHA,AAAgB,4BAChB,AAAI,EAAa,SAAmB,EAAa,SAAoB,6BAAoB,EACzF,cACE,GACA,cAAS,wFAp3GQ,YACnB,KACoB,cAA8B,cAAI,EAAO,cAAY,UACvE,AAAI,AAAC,KAAoB,aAAP,IAClB,cAAmC,gCACnC,cAAkB,kBACX,cAAQ,mBAEP,AAA6B,cAAY,cAAc,cAAS,EAAU,wCACpF,AAAI,AAAC,cAAQ,gBAAoB,AAAC,SAAO,cAAc,kBAChD,aAAP,2GhB44BM,EAAmB,8DAl2ClB,EAAsB,cAAO,4BAApC,+BgBsgFA,AAA8C,IAC9C,AAAI,0BAAa,MAAoB,AAAC,wBACpC,cAAQ,SACK,AAAgC,6BAAqB,oDAE1D,AAA6B,cAAY,8CACnD,cAAQ,cACD,aAAP,gDA+/ByB,0LhB5pEnB,EAAa,sEAx2CZ,EAAgB,cAAM,cAAW,4BAAxC,+BgB8gFA,AAAe,sBACC,cAAoB,wBACpC,AAAI,AAAC,KAAkB,aAAP,IAEhB,AAAI,cAAQ,cAEV,AAAI,cAAQ,kBACM,cAAqB,6BACrC,AAAI,AAAC,KAAkB,aAAP,IAEhB,AAAI,cAAQ,kBACA,AAAuB,cAAW,cAAW,cAAS,EAAU,wCAC1E,cAAQ,cACD,aAAP,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,wBAGT,aAAP,2GhB1kCM,EAAqB,6EAp6CpB,EAAwB,4BAA/B,wCgBu/EW,cAAqB,6BAChC,AAAI,AAAC,KAAa,aAAP,OAED,AAA+B,sBACzC,cAAQ,cACD,aAAP,yKhBhiCM,EAAgB,sEA/4Cf,EAAmB,cAAU,cAAU,cAAM,4BAApD,kCgBgkFe,cAAqB,6BACpC,AAAI,AAAC,KAAiB,aAAP,IAEf,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,aAAP,OAGc,cAAoB,wBACpC,AAAI,AAAC,KAAkB,aAAP,IAET,AACL,cACA,cACA,cACA,cAAS,EAAU,8CAJrB,wMhB/sCM,EAAc,gEAx4Cb,EAAiB,cAAa,cAAW,cAAa,cAAM,4BAAnE,iCgBi8EA,AAAe,mBAEf,AAAI,cAAQ,eACV,AAAoC,IAEpC,AAAI,cAAQ,iBACI,cAAmB,cAAI,EAAmB,EAAM,iBAAa,WACtE,AAAI,cAAQ,iBACH,cAAmB,cAAI,EAAiB,EAAM,iBAAa,WACpE,AAAI,cAAQ,iBACH,cAAmB,cAAI,EAAkB,EAAM,iBAAa,WAErE,AAAI,AAAC,cAAQ,mBACJ,cAA8B,sBAC5C,AAAI,AAAC,KAAoB,cAAP,QAGpB,AAAI,IACF,AAAI,cAAQ,cAEV,AAAI,iBAAoB,KACtB,AAAI,AAAC,mEAAqD,KACxD,cACE,GACA,sCAEK,cAAP,IAEK,cAAyB,cAAI,EAAU,6BAA9C,IAEF,AAAI,iBAAoB,QACH,AAAC,yDACf,AAAQ,IAAO,qBAAqB,EAAI,QACzB,cAAa,aACb,sBAClB,AAAI,IACF,cACE,GACA,uCAN0C,AAAE,WAU3C,cAAyB,cAAI,EAAU,6BAA9C,IAEF,cACE,GACA,sCAEK,cAAP,IAGF,AAAI,iBAAoB,QACH,AAAC,yDACf,AAAQ,IAAO,qBAAqB,EAAI,QACzB,cAAa,UAC/B,AAAI,AAAC,oBACH,AAAI,iBAAoB,KACtB,cACE,GACA,sDAEG,AAAI,AAAC,oBACV,cACE,GACA,uEAXwC,AAAE,aAmBtD,AAAI,iBAAY,MACd,AAA4C,IAC5C,AAAI,AAAC,cAAQ,mBACC,cAA8B,sBAC1C,AAAI,AAAC,KAAkB,cAAP,KAGlB,AAAI,iBAAY,MACd,AAAqC,IACrC,AAAI,AAAC,cAAQ,mBACG,cAAqB,6BACnC,AAAI,AAAC,KAAoB,cAAP,IAElB,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,cAAP,QAIY,cAAoB,wBACpC,AAAI,AAAC,KAAkB,cAAP,IAET,AACL,cACA,IACI,kBACA,eACJ,cACA,cACA,cAAS,EAAU,+CAPrB,IAWA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,wBAGT,cAAP,yKhBhmCM,EAAa,sEAzhDZ,EAAgB,cAAW,cAAQ,cAAS,4BAAnD,+BgBgqFA,AAAe,mBACf,AAAI,cAAQ,kBACM,cAAqB,6BACrC,AAAI,AAAC,KAAkB,aAAP,IAChB,AAAI,cAAQ,kBACM,cAAoB,wBACpC,AAAI,AAAC,KAAkB,aAAP,IAChB,AAAsC,IACtC,AAAI,cAAQ,iBACM,cAAoB,wBACpC,AAAI,AAAC,KAAsB,aAAP,KAEf,AACL,cACA,cACA,cACA,cAAS,EAAU,8CAJrB,IAOA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,wBAGT,aAAP,2GhB/iCM,EAAiB,8DAxhDhB,EAAoB,cAAO,4BAAlC,+BgBybA,AAAe,mBACf,AAA8B,IAC9B,AAAgB,4BAChB,AACE,EAAa,MACb,EAAa,SACb,AAAC,wBAED,AAAI,GAAS,cAAqB,kCAAa,aAAP,QAGhC,AAA2B,cAAM,cAAS,EAAU,wCAC9D,AAAI,AAAC,cAAQ,gBAAkB,cAAc,kBACtC,aAAP,2EhB4uBM,EAAgB,8DA52Cf,EAAmB,4BAA1B,skBAguDM,GAAqB,sEAthDpB,EAAe,cAAO,cAAY,4BAAzC,+BgBwmFA,AAAe,mBAMf,AAAI,cAAQ,iBACE,cAAqB,6BACjC,AAAI,AAAC,KAAc,aAAP,IACZ,AAAI,cAAQ,kBACG,YACb,IACE,0BAAa,KACb,iBAAgB,SAChB,iBAAgB,YAEJ,cAAoB,wBAChC,AAAI,AAAC,KAAkB,aAAP,IAChB,cAAgB,uBAEX,AAAsB,cAAO,cAAY,cAAS,EAAU,8CAAnE,IAEA,cACE,GACA,sCAAY,yBAMX,AAAI,cAAQ,cACjB,AAAI,cAAQ,kBACG,YACb,IACE,0BAAa,KACb,iBAAgB,SAChB,iBAAgB,YAEJ,cAAoB,wBAChC,AAAI,AAAC,KAAkB,aAAP,IAChB,cAAgB,uBAEX,AAAsB,EAAM,cAAY,cAAS,EAAU,8CAAlE,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,iDAGG,aAAP,oRhBvnCM,EAAiB,sEAhjDhB,EAAoB,cAAW,cAAO,4BAA7C,+BgBwkFA,AAAe,mBACf,AAAI,cAAQ,kBACM,cAAqB,6BACrC,AAAI,AAAC,KAAkB,aAAP,IAChB,AAAI,cAAQ,eACV,AAAI,cAAQ,iBACQ,YAClB,IAAO,AAAC,cAAQ,kBACG,cAAqB,sBACtC,AAAI,AAAC,KAAmB,aAAP,IACjB,cAAiB,0BAET,AAA2B,cAAW,cAAa,cAAS,EAAU,wCAChF,cAAQ,cACD,aAAP,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,wBAGT,aAAP,2GhB7iCM,EAAgB,8DA7iDf,EAAmB,cAAO,4BAAjC,+BgBiqFA,AAAe,sBACE,cAAqB,6BACtC,AAAI,AAAC,KAAmB,aAAP,OACP,AAA0B,cAAY,cAAS,EAAU,wCACnE,AAAI,AAAC,cAAQ,gBAAkB,cAAc,kBACtC,aAAP,wMhBvmCM,EAAc,gEArjDb,EAAiB,cAAgB,cAAe,cAAiB,cAAmB,4BAA3F,+BgBwqFA,AAAe,mBAEf,AAAI,cAAQ,iBACW,YACrB,IAAO,AAAC,cAAQ,kBACP,cAAoB,wBAC3B,AAAI,AAAC,KAAa,aAAP,IACX,cAAoB,uBAEtB,AAAiD,IACjD,AAA0C,IAC1C,AAA4C,IAC5C,AAAI,cAAQ,cACV,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,aAAP,IAEF,AAAI,AAAC,2BACH,cACE,GACA,+CAEK,aAAP,OAEc,AAAgC,6BAAqB,gDACrE,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,aAAP,IAEF,AAAI,AAAC,cAAQ,eACX,cACE,GACA,sCAAY,uBAEP,aAAP,OAEgB,kBAClB,IAAO,AAAC,cAAQ,kBACP,cAAoB,wBAC3B,AAAI,AAAC,KAAa,aAAP,IACX,cAAqB,wBAGzB,AAAI,cAAQ,cACV,AAAI,AAAC,cAAQ,eACX,cACE,GACA,sCAAY,uBAEP,aAAP,OAEkB,kBACpB,IAAO,AAAC,cAAQ,kBACP,cAAoB,wBAC3B,AAAI,AAAC,KAAa,aAAP,IACX,cAAuB,wBAG3B,AAAI,AAAE,OAAmB,MACvB,cACE,GACA,sCAAY,uBAEP,aAAP,OAEQ,AACR,cACA,cACA,cACA,cACA,cAAS,EAAU,wCAErB,cAAQ,cACD,aAAP,IAEA,cACE,GACA,sCAAY,wBAGT,aAAP,2GhBznCM,EAAe,8DAxlDd,EAAkB,cAAY,4BAArC,+BgBgyFA,AAAe,sBACE,cAAqB,cAAI,UAC1C,AAAI,AAAC,KAAmB,aAAP,OACP,AAAyB,cAAY,cAAS,EAAU,wCAClE,cAAQ,cACD,aAAP,0IhB/rCM,EAAgB,sEA9lDf,EAAmB,cAAW,cAAW,4BAAhD,+BgBsyFA,AAAe,mBACf,AAAI,cAAQ,kBACO,cAAqB,6BACtC,AAAI,AAAC,KAAmB,aAAP,IACjB,AAAI,cAAQ,kBACM,cAAoB,cAvtBvB,UAwtBb,AAAI,AAAC,KAAkB,aAAP,OACN,AAA0B,cAAY,cAAW,cAAS,EAAU,wCAC9E,cAAQ,cACD,aAAP,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,wBAGT,aAAP,2dhBloFM,EAAwB,sEA/vBvB,EAAsB,cAAM,cAAa,cAAa,4BAA7D,+BgBy+BA,AAAI,wBAAa,SACE,AACf,6BACA,gDAEF,AAAwC,IACxC,AAAI,cAAQ,iBACC,cAAe,0BAC1B,AAAI,AAAC,KAAa,aAAP,IACX,AAAI,iBAAa,KACf,cACE,GACA,sCAEK,aAAP,OAEY,2CAEhB,AAAwC,IACxC,AAAI,cAAQ,kBACC,cAAe,0BAC1B,AAAI,AAAC,KAAa,aAAP,IACX,AAAI,iBAAa,KACf,cACE,GACA,sCAEK,aAAP,OAEY,2CAET,AACL,cACA,cACA,cACA,AAAW,6BAAkB,mEAJ/B,IAOA,cACE,GACA,gDAGG,aAAP,4KAtFqB,YACrB,AAAmB,IACnB,AAAY,mBACZ,IAAO,AAAC,cAAQ,mBACM,cAAwB,sBAC5C,AAAI,AAAC,KAAsB,aAAP,IACpB,AAAI,mBACF,AAAe,KACV,AAAI,IACT,cACE,GACA,sCAEF,cAA4B,OAE9B,cAAoB,kBACpB,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,eACV,GAEA,cACE,GACA,sCAAY,uBAEP,aAAP,WAIN,AAAI,AAAC,oBACH,cACE,GACA,cAAS,EAAO,0CAGb,aAAP,+BA4zGF,QAAQ,qBACD,OAYA,QAZoB,AACvB,AAAI,AAAC,8FAA6C,mBACzC,aAAP,OAEkB,AAAC,yDACrB,AAAI,IACG,AAAQ,IAAO,qBAAsB,EAAI,KAC5C,AAAI,AAAoB,cAAM,cAAc,sBAAY,aAAP,IADF,YAInD,GAE0B,GACP,0CACnB,AAAI,AAAoB,cAAM,kCAAiC,aAAP,OACvC,sBACZ,AAAQ,IAAO,qBAAmB,EAAI,KACzC,AAAI,AAAoB,cAAM,cAAW,qCAAiB,aAAP,IADP,WAG9C,GAEO,AAAO,qBAEX,aAAP,oIhB7sEQ,EAA0B,cAAM,cAAY,EAAO,gEA5kDlD,EAAoB,cAAM,cAAY,EAAO,cAAgB,cAAM,4BAA1E,+BgB+vFA,AAAI,6BACS,AAAgC,6BAAqB,gDAChE,AAAiD,IACjD,AAAI,cAAQ,kBACO,cAAyB,sBAC1C,AAAI,AAAC,KAAuB,aAAP,IACrB,EAAS,QAEX,AAAI,cAAQ,eACV,cAAQ,iBACG,cAAe,0BAC1B,AAAI,AAAC,KAAa,aAAP,IACX,AAAI,AAAoB,6BAAW,mBACjC,cACE,GACA,6BAAY,oCAEP,aAAP,OAEQ,AACR,cACA,cACA,EACA,cACA,cACA,cAAS,EAAU,wCAErB,cAAQ,cACR,cAA2B,gCACpB,aAAP,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,gDAGG,aAAP,oCvB7/DW,qCACX,AAAU,mBACV,AAAU,mBACV,AAAY,IACZ,AAAa,IACb,AAAY,IACZ,AAAgB,IAChB,AAAuB,IAEvB,IAAO,EAAM,KACX,AAAQ,cAAgB,OACxB,AAAI,EAAK,KAEP,AAAY,EAAQ,IAAO,eACtB,AAAI,EAAK,KAEd,AAAY,EACV,EAAQ,IAAO,cACf,IzB93CR,AAAO,EAAO,SyBg4CH,AAAI,EAAK,MACd,AAAI,EAAU,KACZ,cACE,EAAU,KACN,IACA,IACJ,cAAW,kCAGf,AAAS,EAAM,MAEf,KAEF,AAAI,EAAO,IAAO,cAEhB,AAAmB,KAErB,AAAQ,IACR,AAAE,YAEJ,AAAI,EAAO,KACT,cACE,GACA,cAAW,kCAER,AAAI,EAAU,KACnB,cACE,GACA,cAAW,EAAS,mCAEjB,AAAI,IACT,cACE,GACA,cAAW,EAAQ,GAAG,iBACtB,4CAA2B,EAAQ,GAAG,2BAG1C,cAAW,KACJ,aAAP,oCAtHW,qCACX,AAAU,mBACV,AAAU,mBACV,AAAY,IACZ,AAAa,IACb,AAAY,IACZ,AAAY,EAAQ,uBACpB,AAAgB,IAChB,AAAuB,IAEvB,IAAO,EAAM,KACX,AAAQ,cAAgB,OACxB,AAAI,AAAQ,OAEV,AAAY,EACV,EAAQ,IAAO,IzBnzCvB,AAAO,EAAQ,QyBozCP,EAAQ,EAAI,mCAET,AAAI,EAAK,MACd,AAAI,EAAU,KACZ,cACE,EAAU,KACN,IACA,IACJ,cAAW,kCAGf,AAAS,EAAM,MAEf,IAEF,AAAI,EAAS,IAAO,cAElB,AAAmB,KAErB,AAAQ,IACR,AAAE,YAEJ,AAAI,EAAO,KACT,cACE,GACA,cAAW,kCAER,AAAI,EAAU,KACnB,cACE,GACA,cAAW,EAAS,mCAEjB,AAAI,IACT,cACE,GACA,cAAW,EAAQ,GAAG,iBACtB,4CAA2B,EAAQ,GAAG,2BAG1C,cAAW,KACJ,aAAP,oCAzHW,qCACX,AAAU,mBACV,AAAU,mBACV,AAAY,IACZ,AAAa,IACb,AAAY,IACZ,AAAa,EAAQ,uBACrB,AAAgB,IAChB,AAAuB,IAEvB,IAAO,EAAM,KACX,AAAQ,cAAgB,OACxB,AAAI,AAAU,OAEZ,AAAY,EACV,EAAQ,IAAO,IzBpzCvB,AAAO,EAAO,QyBqzCN,EAAQ,EAAI,mCAET,AAAI,EAAK,MACd,AAAI,EAAU,KACZ,cACE,EAAU,KACN,IACA,IACJ,cAAW,kCAER,AAAI,EAAM,GAAK,KAAS,cAAgB,EAAM,MAAM,SACzD,cACE,GACA,cAAW,mCAGf,AAAS,EAAM,MAEf,IAEF,AAAI,EAAS,IAAO,IzBvtCxB,AAAO,EAAY,QyBytCb,AAAmB,KAErB,AAAQ,IACR,AAAE,YAEJ,AAAI,EAAO,KACT,cACE,GACA,cAAW,kCAER,AAAI,EAAU,KACnB,cACE,GACA,cAAW,EAAS,mCAEjB,AAAI,IACT,cACE,GACA,cAAW,EAAO,iBAClB,4CAA2B,EAAO,2BAGtC,cAAW,KACJ,aAAP,oCAhKW,qCACX,AAAU,mBACV,AAAI,EAAM,GAAI,oBAAY,cAAgB,KAAQ,SAChD,QAAQ,cAAgB,EAAM,MAAK,OAC5B,QAIA,QAIA,SARY,AACf,cAAW,EAAM,MACV,4BAAP,IAEe,AACf,cAAW,EAAM,MACV,4BAAP,IAEe,AACf,cAAW,EAAM,MACV,4BAAP,IAGJ,AAAI,AAAQ,cAAgB,EAAM,WAChC,AAAY,IACZ,cAAW,EAAM,MACjB,AAAY,mBACZ,cACE,GACA,cAAW,EAAO,yCAEb,aAAP,KAGG,4BAAP,qCAoYA,AAAU,mBACV,AAAI,EAAM,oBAAY,AAAkB,4CAA4B,cAClE,cACE,GACA,cAAW,gFA5FJ,qCACX,AAAU,mBACV,AAAY,IACZ,AAAU,mBACV,AAAa,IACb,AAAe,IAEf,IAAO,EAAM,KACX,AAAQ,cAAgB,OAExB,AAAI,EAAK,MACP,AAAI,EAAU,KACZ,cACE,EAAU,KACN,IACA,IACJ,cAAW,kCAER,AAAI,AAAC,KAAuB,EAAM,GAAK,SAAS,cAAgB,EAAM,MAAM,SACjF,cACE,GACA,cAAW,mCAGf,AAAS,EAAM,KACf,AAAE,QACG,AAAI,AAAC,AAAU,QACpB,IAEF,AAAE,YAGJ,AAAI,EAAO,KAAS,EAAU,SAC5B,cACE,GACA,cAAW,EAAS,mCAIxB,cAAW,KACJ,aAAP,+BjBjxCA,AAAqB,mBACrB,AAAuB,mBACvB,AAAI,EAAW,KACN,EAAU,KACb,GACA,AAAe,EAAa,EAAM,cAAU,8BAFhD,IAIF,AAAwB,mBACxB,AAAI,AAAC,KACH,AAAI,AAAC,KAAmB,aAAP,OAEP,AAAyB,AAAC,EAAU,AAAC,EAAU,GAAK,IAAe,GAAG,UAChF,AAAY,EAAwB,EAAgC,EAAc,OAClF,AAAa,IACR,AAAe,MAAG,EAAI,KACzB,AACE,EAA0B,WAAY,IACtC,AAAU,EAA2B,EAAK,UAE5C,AACE,EAA0B,EAAU,IACpC,EACA,EAAc,OAEhB,EAAU,KAVwB,AAAE,WAY/B,aAAP,IAEgB,IAAiB,IACnC,AAAI,EAAa,KAEf,AAAc,EAAW,QACf,AAAyB,EAAS,UAC5C,AAAY,EAAwB,EAAyB,MAC7D,IAAO,AAAE,AAAO,AAAO,cAAa,cAAQ,YAC1C,AAAY,EAA0B,EAAQ,IAAI,EAAgC,EAAc,OAChG,AAAO,EAAO,UAET,aAAP,IAEuB,IAAsB,IAAa,IAC5D,IAAO,AAAE,AAAO,AAAO,cAAa,cAAQ,YAC1C,AAAI,AAAC,sBAAW,AAAyB,EAAW,GAAG,WACvD,AAAY,EAAO,KACnB,AAAI,EAAS,GAAQ,GAAa,KAChC,EAAY,QACN,AAA2B,EAAwB,EAAW,YAEtE,AACE,EAA0B,EAAU,IACpC,EAA2B,EAAQ,IACnC,EAAS,OAEX,EAAU,KACV,AACE,EAA0B,EAAU,IACpC,EACA,EAAc,OAEhB,EAAU,KACV,AAAO,EAAO,UAEhB,AAAI,IACF,AAAW,EAAU,KACrB,AAAI,EAAS,GAAO,KAClB,EAAY,QACN,AAA2B,EAAwB,EAAW,YAEtE,AAAI,IACF,AACE,EAA0B,EAAU,IACpC,EAA2B,EAAQ,IACnC,EAAQ,QAGZ,EAAQ,KACR,AAAI,EAAU,QACN,AAA2B,EAAwB,EAAQ,YAE5D,aAAP,IAEK,aAAP,iCHwUF,AAAU,mBACV,AAAI,AAAC,KAAY,oBAAP,IAEV,AAAW,IACX,AAAW,AAAe,OAE1B,AAAW,WAEX,IAAO,IAAO,AAAQ,WACpB,AAAO,AAAe,EAAO,UAC7B,AAAE,YAEJ,AAAI,AAAC,KAAY,oBAAP,IAGV,AAAI,EAAQ,KACV,AAAI,AAAC,AAAE,UAAY,oBAAP,IACZ,AAAO,AAAe,EAAO,UAC7B,AAAO,YACF,AAAI,EAAQ,KACjB,AAAI,AAAC,AAAE,UAAY,oBAAP,IACZ,AAAO,AAAe,EAAO,YAI/B,AAAI,EAAO,KAAK,EAAQ,UACtB,AACE,AAAU,KAAW,YACrB,AAAU,KAAW,gBAEd,SAAW,cAAlB,IAEK,oBAAP,IAGF,AAAI,EAAQ,KAAgB,AAAM,EAAO,GAAgB,SAChD,oBAAP,IAEF,AAAe,IAEf,IAAO,EAAQ,KACb,AAAO,AAAe,EAAO,UAC7B,AAAE,YAEJ,AAAI,EAAO,KAAU,SAAM,cAAb,IAEd,AAAc,IACd,AAAe,IACf,AAAe,IACf,AAAa,IACb,AAAI,EAAQ,KACV,AAAe,AAAE,EAAW,MAC5B,EAAO,KAAG,AAAE,OACZ,AAAI,AAAC,KAAO,QAAiB,oBAAP,IACjB,AAAU,MAAM,AAAC,AAAO,AAAe,OAAS,KAAmC,AAAE,OAAxB,AAAE,OAAU,EAAO,SACrF,AAAI,EAAO,KAAU,SAAM,cAAb,IACd,AAAI,AAAC,KAAY,QAAY,EAAO,GAAe,SAAW,oBAAP,KAEpD,AAAY,EAAO,SAAa,EAAQ,QAAO,EAAQ,KAAgB,AAAC,UAC3E,AAAI,EAAQ,KACV,AAAI,EAAW,KAAW,EAAK,GAAI,KAAQ,EAAI,AAAK,AAAC,SACrD,AAAE,QAEF,AAAW,IACX,AAAU,KAEZ,AAAI,AAAC,AAAE,UAAK,GACZ,AAAO,AAAe,EAAO,UATwD,AAAQ,EAAO,UAYtG,AAAI,AAAC,KAAS,AAAW,KAClB,AAAc,EAAW,IAAG,EAAW,AAAI,IAAU,WAAY,EAAS,IAAK,IAwS3E,IAAe,IAC1B,AAAW,AAAe,OAE1B,AAAI,AAAC,EAAO,GAAO,MAAY,AAAO,KAEtC,AAAI,AAAC,AAAE,UAAK,AAAO,KACnB,AAAO,AAAe,EAAO,UAC7B,AAAI,EAAQ,KACV,AAAI,AAAC,AAAE,UAAK,AAAO,KACnB,AAAO,AAAe,EAAO,UAC7B,AAAO,KACF,AAAI,EAAQ,KACjB,AAAI,AAAC,AAAE,UAAK,AAAO,KACnB,AAAO,AAAe,EAAO,YAG/B,IAAO,EAAQ,KACb,AAAI,AAAC,AAAE,UAAK,AAAO,KACnB,AAAO,AAAe,EAAO,eAE1B,AAAiB,EAAO,OAAa,IAAO,EAAQ,SACvD,AAAI,EAAa,MAAM,AAAO,EAAO,OACrC,AAAY,EAAK,GAAY,KAC7B,AAAO,AAAe,EAAO,UAC7B,AAAE,OAJyD,AAAQ,EAAO,SAM5E,AAAO,EAAO,SArGd,AAAI,AAAC,WAAe,EAAM,OAAM,AAAO,YACvC,AAAI,EAAM,MAAK,AAAO,YAKtB,AAAmB,KACnB,AAAI,AAAC,KAAK,AAAO,KACjB,AAAI,EAAM,KAAM,EAAO,EAAK,UAC1B,EAAgB,EAAM,EAAM,wBAC5B,AAAM,KAER,AAAI,EAAe,YAAoB,AAAI,eAAQ,SACjD,AAAI,EAAM,KAAG,AAAO,EAAe,EAAM,wBACzC,AAAO,EAAe,EAAM,EAAC,KA+G/B,AAAO,AAAU,IAAY,EAAK,cA9G3B,AAAI,EAAM,KACf,AAAO,EAAU,IAAa,IAchC,AAAY,AAAI,KAChB,EAAgB,KAChB,AAAQ,GAAM,KAEd,EAAO,EAAO,KACZ,AAAQ,EAAc,SACtB,AAAQ,EAAc,SACtB,AAAQ,AAAI,KACZ,AAAc,AAAC,EAAK,GAAK,AAAa,SAAQ,AAAM,EAAM,EAAI,YAC9D,EAAS,KALQ,EAAO,SAO1B,AAAQ,AAAY,EAAG,EAAC,SACxB,AAAQ,EAAc,KACtB,AAAQ,EAAc,KACtB,AAAQ,AAAI,KACZ,AAAc,AAAC,EAAK,GAAK,AAAM,AAAiB,AAAiB,IAAW,EAAK,KAAO,SACxF,EAAS,KAET,AAAO,AAAkB,GAAkB,YA9BzC,AAAO,EAAQ,IAAa,IAuC9B,AAAY,AAAI,KAChB,EAAgB,KAChB,EAAS,MAET,AAAgB,KAChB,EAAO,EAAO,KACZ,AAAc,EAAO,IAAa,2GADlB,EAAO,SAGzB,AAAc,EAAO,IAAa,AAAY,EAAG,OA+CjD,AAAW,AAAC,EAAI,OAAc,MAC9B,AAAW,AAAC,EAAK,GAAM,IAAK,EAAO,MACnC,AAAe,AAAM,EAAQ,MAC7B,AAAY,AAAI,KAChB,AAAoB,EAAK,MACzB,GAAiB,MACjB,AAAO,AAAC,EAAQ,IAAQ,AAAC,EAAM,OAAe,IAAa,EAAO,IAAS,GAAK,SApDhF,AAAQ,KACR,AAAO,AAAkB,GAAkB,gBAhSkD,cAA7F,8BGtMO,AAAO,4BAAd,oCiBm7Ba,qCACX,AAAU,mBACV,AAAY,mBACZ,AAAe,cAA6B,OAC5C,AAAI,iBAAW,KAAO,cAAgB,oBAAa,SACjD,AAAE,qCACF,EAAY,uBAEd,AAAI,iBAAW,KACb,AAAQ,cAAgB,sBACxB,AAAI,AAAC,EAAI,GAAO,MACd,AACE,AAAE,wDAAW,KACb,AAAC,AAAI,cAAgB,sBAAc,YAAkB,EAAK,KAC1D,AAAU,cAAgB,iBAAW,gBAErC,AAAE,sCAEJ,EAAY,cAS0C,aAN7C,cAAe,EAAO,yBACnC,AAAI,OAAmB,cAAkB,gBAAK,wBACvC,AAAW,4BAAlB,8BA3BO,4BAAP,qCuBywFA,AAAY,IACZ,AAAY,IACZ,EACE,kBAAQ,4BACD,QAQA,OAIA,OAKA,QAIA,QAIA,QAQA,QAKA,SAtCiB,AACpB,cACE,GACA,sCAAY,uBAEd,AAAQ,IACR,GAEoB,AACpB,AAAE,OACF,GAEqB,AACrB,AAAE,OACF,AAAI,AAAC,KAAO,AAAQ,KACpB,GAEqB,AACrB,kBACA,GAEuB,AACvB,sBACA,GAE0B,AAC1B,sBACA,IAAM,mBACJ,cAAe,iBACf,cAAc,cAEhB,GAEyB,AACzB,kBACA,iBACA,GAEuB,AACvB,kBACA,iBACA,GAGG,wCA3FT,AAAI,mBAAoB,0BACxB,IACE,AAAgB,4BAChB,AACE,EAAa,SACb,EAAa,OAEb,yBACA,GAEF,AAAI,mBAAoB,GACxB,cAAQ,4BACD,QAIA,QACA,QAIA,QAKA,QAKA,QAnBkB,AACrB,kBACA,IAG0B,AAC1B,sBACA,GAEyB,AACzB,kBACA,iBACA,GAEuB,AACvB,kBACA,iBACA,GAEoB,AACpB,cAAe,iBACf,GAGG,MACT,cAA2B,6CAp/Cf,sBACZ,AAAY,0BACZ,AAAkC,IAClC,sCAAQ,MACD,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAUA,QAGA,OAIA,OAIA,OAIA,OAIA,OAIA,QArEa,GACJ,cAAgB,sBAC5B,GAEgB,GACJ,cAAmB,cAAI,EAAmB,EAAM,2BAC5D,GAEmB,GACP,cAAmB,sBAC/B,GAEa,GACD,cAAsB,sBAClC,GAEc,GACF,cAAuB,sBACnC,GAEa,GACD,cAAsB,sBAClC,GAEc,GACF,cAAmB,cAAI,EAAiB,EAAM,2BAC1D,GAEc,GACF,cAAmB,cAAI,EAAkB,EAAM,2BAC3D,GAEoB,GACR,cAAyB,cAAI,UACzC,GAEiB,AACjB,AAAI,IACF,cACE,GACA,mDAGQ,cAAiB,sBAC7B,GAGO,AAA0B,cAAS,qDADtB,IAGH,GACL,cAA0B,sBACtC,GAEgB,GACJ,cAAyB,sBACrC,GAEc,GACF,cAAuB,sBACnC,GAEe,GACH,cAAwB,sBACpC,GAEgB,GACJ,cAAyB,sBACrC,GAEe,AACX,cAAQ,YAA8B,SAC5B,cAA0B,cAAI,EAAkB,EAAM,yBAClE,IAIK,AACP,cAAS,oBACG,cAA8B,sBAC1C,GAGJ,AAAI,AAAC,KACH,cAAS,iBACT,cAAmB,kBAEnB,cAAW,kBAEN,aAAP,2GhBzqCM,EAAgB,8DAr0Cf,EAAmB,cAAY,4BAAtC,+BgBw/EA,AAAe,sBACE,YACjB,IAAO,AAAC,cAAQ,kBACF,yBACI,cAAoB,cAAI,UACxC,AAAI,AAAC,KACH,AAAI,iBAAY,MAAwB,aAAP,IACjC,cAAS,iBACT,cAAmB,kBAEnB,cAAW,iBACX,cAAgB,2BAGV,AAA0B,cAAY,cAAS,EAAU,wCACnE,AAAI,IAAU,cAAQ,eACf,aAAP,2GhBxpDM,EAAmB,6EAhgClB,EAAuB,4BAA9B,+BgB0xCA,AAAI,EAAW,KAAG,AAAW,mCAC7B,AAAI,EAAiB,KAAG,AAAiB,KAEzC,AAAkC,IAClC,AAAI,EAAa,KAAoB,cAAQ,sBAC9B,cAAe,0BAC5B,AAAI,AAAC,KAAmB,aAAP,QAEJ,AAAuB,cAAS,gDAG/C,AAAI,IACF,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,cAAS,uCAAS,uBAEb,aAAP,QAIY,AACd,cACA,cACA,cACA,EACA,cAAS,EAAgB,wCAG3B,AAA6B,IAC7B,AAAI,IACF,AAAI,cAAQ,iBACH,cAAyB,cAAI,cAEf,cAAqB,cAAI,EAAmB,WACjE,AAAI,OAAuB,AAA+B,yBAG5D,AAAI,AAAC,cAAQ,eACX,cACE,GACA,cAAS,uCAAS,uBAEb,aAAP,OAEK,cAAyB,cAAI,WAEtC,AAAI,AAAC,KAAa,aAAP,OAEO,AAChB,cACA,EACA,EACA,EACA,cACA,cACA,EACA,cAAS,EAAU,wCAEd,AAA8B,4BAArC,sDA9DgB,KACM,+aAxRtB,AAAa,IACb,AAAiB,IACjB,AAA+B,IAC/B,AAA+B,IAC/B,AAAI,IACF,AAAI,cAAQ,iBACG,+BACb,EAAe,OACV,AAAI,cAAQ,iBACJ,+BACb,EAAe,OACV,AAAI,cAAQ,iBACJ,+BACb,EAAe,SAEjB,AAAI,0BAAa,QACH,sBACZ,yBACA,AAAI,0BAAa,MACf,cAAW,iBACX,AAAI,AAAC,QAAyB,gCAC9B,EAAe,OAEf,cAAS,oBAIf,AAAI,cAAQ,eACV,AAAI,IACF,cACE,GACA,mDAGW,gCAEf,AAAS,KAEX,AAAI,0BACF,AAAI,AAAC,QAAqB,mCACT,AAAgC,6BAAqB,gDACtE,AAA4B,IAC5B,AAAI,AAAa,cAAQ,iBACvB,AAAI,IACF,cACE,GACA,wCAIN,AAAI,cAAQ,kBACH,cAAe,0BACtB,AAAI,AAAC,KAAa,aAAP,QAEJ,AAAuB,cAAS,gDAEzC,AAAqC,IACrC,AAAI,cAAQ,eACV,AAAI,IACF,cACE,GACA,uCAGJ,AAAI,IACF,cACE,GACA,uCAGF,AAAa,QAED,cAAqB,cAAI,EAAmB,WAC1D,AAAI,AAAC,KAAoB,aAAP,QAER,AACV,IACI,GACA,IACE,GACA,IACN,cACA,cACA,cACA,AAAW,GAAO,0CAAa,6DAEjC,+BAAe,MACR,aAAP,IAEA,cACE,GACA,gDAGG,aAAP,kCA1LiB,YACjB,AAAqC,IACrC,AAAmB,IACnB,AAAmB,IACnB,AAAgC,IAGhC,cAA2B,KAC3B,AAAI,cAAQ,cACV,AAAI,cAAQ,kBACC,cAAe,0BAC1B,AAAI,AAAC,KAAiB,aAAP,IACf,AAAI,iBAAiB,KACnB,cAA2B,qDAE3B,cACE,GACA,wCAIJ,cACE,GACA,sCAAY,uBAEP,aAAP,IAEF,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,eACH,aAAP,IAEA,cACE,GACA,sCAAY,uBAEP,aAAP,OAKN,IAAO,AAAC,cAAQ,mBACF,cAAoB,cAAI,UACpC,AAAI,AAAC,KAAc,aAAP,IACZ,AAAI,IAAY,AAAC,SACf,cACE,GACA,qDAEF,AAAe,KAEjB,QAAQ,qBAUD,OAIA,QAbI,AACP,AAAI,IACF,cACE,GACA,sDAGJ,GAE2B,AAC3B,AAAe,IACf,GAEuB,GACZ,OACX,GAGJ,cAAgB,kBAChB,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,eACV,GAEA,cACE,GACA,sCAAY,uBAEP,aAAP,WAIC,aAAP,+BAiPA,AAAe,mBAEf,AAAgB,IAOhB,AAAI,iBAAY,KACd,AAAI,6BACK,AAAgC,6BAAqB,oDAErD,AAAqC,cAAS,gDAEvD,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,cAAS,uCAAS,uBAEb,aAAP,KAQF,AAAY,IACZ,AAAO,iBAAY,yBACZ,AAAqC,cAAS,gDAKvD,AAAqB,sBACJ,cAAqB,wBACtC,AAAI,AAAC,KAAmB,aAAP,IAEV,cAAmC,cAAI,cAAM,cAAY,6BAA0B,EAAW,EAAU,gBAA/G,2GhBjKM,EAAwB,8DA1jCvB,EAA4B,cAAY,4BAA/C,+BgB65HA,AAAuC,IACvC,IACE,cAAQ,kBACR,OACiB,cAA0C,kCAEhD,cAAoB,sBAC/B,AAAI,AAAC,KAAM,MACJ,AACL,cACA,cACA,cACA,cAAS,gCAAkB,wCAE7B,AAAqB,SAEhB,aAAP,2EhB/3FM,EAAkB,8DArjCjB,EAAsB,4BAA7B,yOAizBM,EAAkB,6IAYlB,EAAmB,8DAl7BlB,EAA2B,cAAoB,4BAAtD,skBAgqCM,EAAoB,sEAjjCnB,EAA4B,cAAO,cAAQ,4BAAlD,6JA+1BM,EAAoB,sEAr8BnB,EAAwB,EAAe,cAAY,cAAQ,4BAAlE,wMAkwCM,EAAsB,gEA/lCrB,EAA8B,cAAK,cAAO,cAAU,cAAa,4BAAxE,+BgB+yHA,AAAe,IAAM,iCAAkB,uBAC3B,eACG,eACH,YACZ,cAAW,cAAc,EAAG,EAAO,sBACnC,cAAc,4CAAyB,iBAAoB,oCAC3D,IAAO,sBACM,cAAqB,6BAChC,AAAI,AAAC,KAAa,aAAP,IACX,cAAW,kBACX,AAAI,AAAC,cAAQ,eACX,cACE,GACA,sCAAY,uBAEP,aAAP,IAEF,cAAW,cAAc,GAAmB,EAAO,sBACnD,cAAc,4CAAyB,iBAAoB,yCAEtD,AAAqC,cAAK,cAAO,cAAU,cAAO,cAAS,EAAU,8CAA5F,4EhBvvFM,eAAS,EAAO,sBACtB,cAAY,6CAvlCL,EAAoB,4BAA3B,2GA4kCM,EAAoB,8DAllCnB,EAA4B,cAAO,4BAA1C,+FAu8BM,EAAqB,8DA3gCpB,EAA6B,EAAO,4BAA3C,+FAu+BM,EAAmB,8DA5/BlB,EAA2B,EAAO,4BAAzC,kCPo5BW,qCACX,AAAY,mBACZ,AAAU,mBACV,AAAc,IACd,IAAO,IACL,AAAI,iBAAY,KACd,cACE,GACA,cAAW,EAAO,0BAEpB,GAEF,AAAI,cAAgB,oBAAa,MAC/B,AAAE,qCACF,AAAU,IACV,GAEF,AAAQ,cAAgB,sBACxB,AAAI,AAAC,KAAW,EAAK,SAAgB,GACrC,AAAI,AAAY,OACd,cACE,GACA,cAAW,EAAO,yCAEpB,GAEF,AAAE,qCACF,AAAU,SAEL,cAAe,EAAO,+BAA7B,kCAIW,qCACX,AAAY,mBACZ,AAAU,mBACV,AAAY,IACZ,IAAO,iBAAW,KAChB,AAAa,cAAgB,sBAC7B,AAAI,AAAC,AAAiB,QAAI,GAC1B,AAAE,qCAGF,UAAQ,MACD,QAIA,QAIA,SARY,AACf,EAAS,EAAQ,KAAI,GAAK,MAC1B,GAEe,AACf,EAAS,EAAQ,KAAI,GAAK,MAC1B,GAEe,AACf,EAAS,EAAQ,KAAI,GAAK,MAC1B,GAEO,AACP,AAAQ,IACR,QAIN,AAAI,EAAS,KACX,cACE,GACA,cAAW,EAAO,0CAGf,cAAe,EAAO,+BAA7B,0IOuLM,EAAoB,sEAtkCnB,EAA4B,cAAS,cAAc,4BAA1D,ifA07C0C,sBAJpC,EAA2B,cAAM,cAAY,EAAO,iEAr1CnD,EAAqB,cAAM,cAAY,EAAO,cAAgB,cAAa,cAAiB,cAAS,4BAA5G,wlBA+wCM,GAAyB,sEA7lCxB,EAAuB,cAAS,cAAW,EAAO,4BAAzD,+BgB4vDA,AAAI,IAAc,iBAAoB,SACpC,cACE,GACA,AAAW,cAAW,gCAAU,cAAW,iBAAoB,0DAInE,AAAY,mBACZ,AAAI,6BACO,sBACT,AAAI,cAAM,qBACR,AAAI,cAAQ,kBACI,cAAe,0BAC7B,AAAI,AAAC,KAAgB,aAAP,IACd,AAAI,iBAAgB,KAClB,cACE,GACA,+CAEK,aAAP,IAEF,AAAI,cAAQ,eACV,AAAI,cAAQ,kBACM,cAAe,0BAC/B,AAAI,AAAC,KAAkB,aAAP,IAChB,AAAI,iBAAkB,KACpB,cACE,GACA,sCAEK,aAAP,IAEK,AAA0B,iDAAwB,cAAW,EAAO,cAAS,EAAO,8CAA3F,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,gDAGG,aAAP,4BhBv+CsC,AAAC,iBAAa,GAAS,cAA9B,yFAmgCzB,EAA2B,cAAM,cAAY,EAAO,cAAM,cAAa,gEAh4CtE,EAAqB,cAAM,cAAY,EAAO,cAAM,cAAa,EAAI,4BAA5E,gNA+jDM,cAAM,cAAY,EAAO,cAAgB,cAAW,cAAM,EAAgB,sBAChF,cAAY,gDA3gDL,EAAsB,cAAM,cAAY,EAAO,cAAgB,cAAW,cAAM,4BAAvF,iCgBssCA,AAAkB,iBAAe,KACjC,AAAe,IACf,AAAyC,IACzC,AAAI,cAAQ,eACV,AAAW,mBACX,OACkB,cAAoB,sBACpC,AAAI,AAAC,KAAW,GAChB,AAAI,AAAC,QAAyB,aAC9B,cAAgB,kBACT,cAAQ,iBACjB,AAAI,IAAe,QACjB,cACE,GACA,AAAW,cAAW,gCAAU,cAAW,iBAAoB,2DAMrE,AAAY,iBAAe,OAG3B,AAAI,IAAa,EAAS,UAE1B,AAAmB,IACnB,AAAiB,IACjB,AAAuB,cAAU,SACjC,AAAI,cAAQ,cACV,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,AAAI,IACF,cACE,GACA,gDAGF,EAAS,EAAsB,QAC/B,AAAe,mBACf,AAAa,qBAGjB,AAAI,AAAC,KAAU,AAAW,qBACrB,AAAI,IACT,EAAS,SAGX,AAAkB,IAClB,AAAgB,IAChB,AAAI,cAAQ,cACV,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,EAAS,MACT,AAAc,mBACd,AAAY,oBAEd,AAAI,AAAC,KAAU,AAAW,qBACrB,AAAI,cAAQ,cACjB,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,EAAS,MACT,AAAc,mBACd,AAAY,oBAEd,AAAI,AAAC,KAAU,AAAW,qBACrB,AAAI,cAAQ,cACjB,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,EAAS,MACT,AAAc,mBACd,AAAY,oBAEd,AAAI,AAAC,KAAU,AAAW,uBAG5B,AAAkB,IAClB,AAAgB,IAChB,AAAoB,IACpB,AAAkB,IAClB,AAAI,cAAQ,cACV,AAAI,IACF,cACE,GACA,sCAAY,wBAGd,EAAS,KACT,AAAc,mBACd,AAAY,oBAEd,AAAI,AAAC,KAAU,AAAW,qBAE1B,EAAS,OACT,AAAI,cAAQ,cACV,AAAI,OAAe,AAAC,cAAU,UAC5B,cACE,GACA,sCAAY,wBAGd,EAAS,MACT,AAAgB,mBAChB,AAAc,oBAEhB,AAAI,AAAC,KAAU,AAAW,qBAE5B,AAAI,iBAAe,OAAqB,EAAS,SAGnD,AAAoB,IACpB,AAAkB,IAClB,AAAI,cAAQ,cACV,AAAI,OAAe,iBAAsB,MACvC,cACE,GACA,sCAAY,wBAGd,EAAS,OACT,AAAgB,mBAChB,AAAc,oBAEhB,AAAI,AAAC,KAAU,AAAW,qBAG5B,AAAoB,IACpB,AAAkB,IAClB,AAAI,0BAAa,QACH,sBACZ,yBACA,AAAI,0BAAa,MACf,cAAW,iBACX,EAAS,MACT,AAAgB,mBAChB,AAAc,mBACd,AAAI,AAAC,KAAU,AAAW,MAE1B,cAAS,sBAKD,sBACZ,AAAoB,IACpB,AAAe,IACf,AAAe,IACf,AAAa,IACb,AAAe,IACf,AAAe,IACf,AAAa,IACb,AAAI,AAAC,KACH,AAAI,cAAQ,cACV,AAAI,cAAQ,YAA8B,MAAoB,AAAC,wBAC7D,EAAS,MACT,AAAW,IACX,AAAW,mBACX,AAAS,mBACT,AAAI,AAAC,KAAU,AAAW,KAC1B,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,yBAI1C,cAAS,mBAEN,AAAI,cAAQ,cACjB,AAAI,cAAQ,YAA8B,MAAoB,AAAC,wBAC7D,EAAS,MACT,AAAW,IACX,AAAW,mBACX,AAAS,mBACT,AAAI,AAAC,KAAU,AAAW,KAC1B,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,yBAI1C,cAAS,mBAEN,AAAI,cAAQ,cACjB,EAAS,OACT,AAAgB,IAChB,AAAI,AAAC,KAAU,AAAW,oBAC1B,AAAI,EAAQ,KACV,cACE,GACA,cAAS,EAAa,iBAAY,wBAGtC,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,wBAG1C,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,4BAM9C,AAAuB,OAAY,KAEnC,AAAI,OACK,AAAiC,+CAExC,AAAI,AAAC,KAAoB,cAAQ,mBAC/B,AAAI,AAAC,KAAU,AAAW,oBAE1B,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAa,iBAAY,wBAE/B,AAAI,EAAQ,MACjB,cACE,GACA,cAAS,EAAa,iBAAY,wBAE/B,AAAI,EAAQ,MACjB,cACE,GACA,cAAS,EAAa,iBAAY,0BAGtC,AAAI,EAAQ,KACV,cACE,GACA,cAAS,EAAa,iBAAY,wBAGtC,AAAI,EAAQ,OACV,cACE,GACA,cAAS,EAAe,iBAAc,wBAG1C,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,2BAG3B,cAAyB,cAAI,EAAO,sBACnD,AAAI,AAAC,KACH,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,wBAGnC,cAAP,IAEF,cAAQ,cACD,cAAP,IAEF,AAAI,AAAC,cAAkB,QACrB,cACE,GACA,+CAEK,cAAP,IAEF,AAAI,AAAC,KAAU,AAAW,uBACnB,AAAgC,6BAAqB,iDAE9D,AAAiD,IACjD,AAAI,cAAQ,eACV,AAA0B,sBACT,cAAyB,sBAC1C,AAAI,AAAC,KAAuB,cAAP,IACrB,AAAI,IACF,cACE,GACA,cAAS,EAAqB,0CAE3B,AAAI,IACT,cACE,GACA,cAAS,EAAqB,0CAGhC,EAAS,UAKb,AAAI,cAAQ,eACV,AAAI,EAAQ,KACV,cACE,GACA,cAAS,EAAc,iBAAa,wBAIxC,AAAqB,sBACJ,cAAqB,cAAI,UAC1C,AAAI,AAAC,KAAmB,cAAP,OACF,sBACf,AAAI,IACG,AAAQ,IAAO,qBAAmB,EAAI,QACzB,cAAW,UAC3B,AAAI,cACF,GACA,IACA,IACA,YAE+B,AAC7B,6BACA,EACA,iBAAkB,KAClB,6BACA,EACA,qCAEF,cAA0C,KAC1C,cAAqC,iBACrC,6BAAoB,mBAlBsB,AAAE,YAqB3C,AAAI,IACT,AAAI,mBACF,cACE,GACA,wCAGC,AAAI,IACT,AAAI,iBAAqB,KACvB,cACE,GACA,uCAGJ,AAAI,iBAAoB,KAAK,cAAW,0BACtC,cACE,GACA,wCAGC,AAAI,6BAAa,oBACtB,cACE,GACA,6BAAY,0BAIhB,AAAkC,IAClC,AAAI,cAAQ,eACV,AAAI,iBAAa,KACf,cACE,GACA,gDAEG,AAAI,IACT,cACE,GACA,oDAGS,cAAe,cAAI,OAAY,iBAAa,cACzD,AAAI,AAAC,KAAmB,cAAP,QAEJ,AAAuB,cAAS,+CAC7C,AAAI,AAAC,KAAY,iBAAa,SAC5B,cACE,GACA,2CAKU,AACd,cACA,cACA,cACA,EACA,cAAS,EAAgB,wCAG3B,AAA6B,IAC7B,AAAI,cAAQ,cACV,AAAI,EAAQ,OACV,cACE,GACA,gDAEG,AAAI,EAAQ,MACjB,cACE,GACA,sCAAY,qCAET,AAAI,IACT,cACE,GACA,sCAAY,6BAGT,cAAyB,cAAI,UACpC,AAAI,AAAC,KAAa,cAAP,KACN,AAAI,AAAC,KAAe,AAAE,EAAS,IAAsB,YAC1D,cACE,GACA,oDAIY,AACd,cACA,cACA,EACA,cACA,cACA,cACA,cAAS,EAAU,wCAErB,AAAI,AAAE,IAAe,cAAQ,oBAC3B,cAAQ,eAEH,cAAP,IAEK,AAAI,IACT,cACE,GACA,uCAGG,AAAI,IACT,cACE,GACA,uCAKF,AAAI,EAAQ,KACV,cACE,GACA,cAAS,EAAc,iBAAa,wBAIxC,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAe,iBAAc,wBAI1C,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAU,iBAAS,wBAIhC,AAAI,EAAQ,MACV,cACE,GACA,cAAS,EAAU,iBAAS,wBAIhC,AAA4B,IAC5B,AAAI,cAAQ,eACV,cACE,GACA,cAAS,EAAU,0CAGvB,AAAI,cAAQ,eACV,EAAS,QAEX,AAAI,cAAQ,kBACH,cAAe,0BACtB,AAAI,AAAC,KAAa,cAAP,KAEX,cACE,GACA,gDAGJ,AAAqC,IACrC,AAAI,cAAQ,eACV,AAAI,EAAQ,OACV,cACE,GACA,mDAGU,cAAqB,6BACnC,AAAI,AAAC,KAAoB,cAAP,IAClB,AAAI,EAAQ,OACV,cACE,GACA,2CAIM,cAAS,EAAU,yBAC/B,AAAI,AAAC,EAAQ,KAAmC,KAAM,OAAe,AAAC,EAAQ,KAAwB,UACpG,cACE,GACA,2BAGW,AACb,cACA,cACA,EACA,cACA,cACA,sBAEF,AAAI,AAAE,IAAe,cAAQ,oBAC3B,cAAQ,eAEH,cAAP,MAEK,cAAP,2GhBloCM,EAAgB,6EA7+Bf,EAAoB,4BAA3B,+BgB4gDA,AAAe,mBAGf,AAAI,6BACK,AAAgC,6BAAqB,oDAErD,AAAqC,cAAS,gDAGvD,AAAI,AAAC,cAAQ,eACX,cACE,GACA,cAAS,uCAAS,uBAEb,aAAP,OAGY,eACI,AAChB,cACA,EACA,EACA,EACA,EACA,EACA,cACA,cAAS,EAAU,wCAErB,AAAI,AAAC,cAAQ,eACX,KACe,cAAsB,cAAI,sBACvC,AAAI,IACF,AAAI,iBAAe,MACjB,cAA6B,qDAE7B,AAAO,GACP,cAAa,uDAGf,cAAmB,iBACnB,AAAI,cAAQ,eACV,cACE,GACA,sCAAY,uBAEP,aAAP,KAGG,AAAC,cAAQ,iBAEpB,6BAAwB,oBACjB,AAA2B,4BAAlC,qCAsvDA,AAAY,cAAQ,OACpB,AAAe,mBACf,gEAAQ,MAGD,QACA,OAGA,QACA,QACA,QACA,QACA,OACA,OACA,OAKA,QACA,QAkBA,OA8BA,OACA,OACA,OACA,OACA,OAGA,QAgGA,QA0BA,OAgDA,QAmBA,QA2BA,OAUA,QAGA,QAGA,QAKA,QAOA,QAeA,OAKA,gBArUc,GACH,cAAqB,cAAI,UACvC,AAAI,AAAC,KAAgB,cAAP,IACP,AAAiC,EAAO,cAAS,cAAS,EAAU,+CAA3E,KAGsB,GACR,cAAqB,cAAI,UACvC,AAAI,AAAC,KAAgB,cAAP,IACd,UAAQ,qBACD,OACA,OACA,UAAyB,GACrB,AACP,cACE,GACA,uCAIC,AAAiC,EAAO,cAAS,cAAS,EAAU,+CAA3E,IAIc,AACd,AAAI,AAAC,2BACH,cACE,GACA,+CAEK,cAAP,OAEa,cAAmB,sBAClC,AAAI,AAAC,KAAiB,cAAP,IACf,AAAuC,IACvC,AAAsC,IACtC,AACE,cAAQ,qBACS,cAA0C,8BAE9C,cAAoB,sBACjC,AAAI,AAAC,KAAmB,cAAP,QAEJ,mBAER,AACL,cACA,cACA,cACA,cAAS,EAAU,+CAJrB,IASsB,AAA0B,qDAAjC,IACO,AAA0B,qDAAjC,IACQ,AAA2B,qDAAlC,IACM,AAA0B,qDAAjC,IACc,AAAiC,qDAAxC,IAGF,AAGpB,AAAI,cAAQ,eACH,cACL,cACA,AAAqC,cAAS,uCAC9C,0BACA,EACA,0BALF,OAQU,sBACZ,AAAY,IACZ,EACE,QAAQ,cAAQ,SAGT,QAKA,SALmB,AACtB,cAAS,iBACF,cAA6B,6BAApC,IAGqB,AACrB,kBACA,YAAQ,4BAGD,QAgBA,QAKA,QAYA,SAjCkB,AAErB,AAAI,cAAQ,kBACC,cAAe,cAAI,EAAM,UACpC,AAAI,EAAQ,KACV,AAAQ,IACR,IAGJ,AAAI,AAAC,cAAQ,gBACX,AAAQ,IACR,IAKc,AAChB,cAAS,iBACF,cAA6B,6BAApC,IAGmB,AACnB,AACE,cAAQ,kBACR,cAAQ,mBACR,cAAQ,gBAER,cAAS,iBACF,cAA6B,6BAApC,IAEF,AAAQ,IACR,GAEgB,GAKT,AACP,AAAQ,IACR,GAGJ,GAGO,AACP,AAAQ,IACR,GAGG,KACT,cAAS,oBAGG,cAAqB,6BACjC,AAAI,AAAC,KAAc,cAAP,IACZ,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,cAAP,OAEM,AAAmC,cAAO,cAAS,EAAU,wCAC9D,cAA8B,cAAI,+BAAzC,IAGsB,GACG,YACzB,IAAO,AAAC,cAAQ,gBAEd,AAAI,0BAAa,SACR,AAA6B,cAAS,mDAEtC,cAAqB,cAAI,EAAmB,WACnD,AAAI,AAAC,KAAa,cAAP,KAEb,cAAwB,kBACxB,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,eACV,GAEA,cACE,GACA,sCAAY,uBAEP,cAAP,WAIC,AAAkC,cAAoB,cAAS,EAAU,+CAAhF,IAGoB,AACpB,AAAe,sBACH,eACC,YAEb,IAAO,AAAC,cAAQ,eACd,AAAI,AAAC,2BACH,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,+CAEK,cAAP,OAEK,AAAgC,iCAAiB,gDACxD,cAAgB,SAET,AAAgC,6BAAqB,iDAE9D,cAAW,kBACX,AAAI,cAAQ,kBACE,cAAqB,cAAI,EAAmB,WACxD,AAAI,AAAC,KAAc,cAAP,IACZ,cAAY,mBACP,AAAI,AAAC,oBACV,cAAY,mBAEZ,cACE,GACA,sCAAY,uBAEP,cAAP,KAEF,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,cACV,GAEA,cACE,GACA,sCAAY,uBAEP,cAAP,WAIC,AAAmC,cAAO,cAAQ,cAAS,EAAU,+CAA5E,IAGmB,GACN,cAAe,0BAC5B,AAAI,AAAC,KAAe,cAAP,IACb,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,cAAP,OAES,cAAqB,cAAI,UACpC,AAAI,AAAC,KAAa,cAAP,IACJ,AACL,EACA,cACA,cACA,cAAS,EAAU,+CAJrB,IAOqB,GACA,sBACrB,AAAI,cAAkB,oBAAe,AAA0B,qDAAjC,OACb,AAAgC,cAAgB,cAAS,EAAU,0CACpF,AAAI,cAAQ,eACH,cAA0B,cAAI,6BAArC,IAEF,AAAI,0BAAa,MAA4B,AAAC,wBACrC,cACL,cACA,AAAqC,cAAS,uCAC9C,qCACE,AACE,EACA,cACA,AAAuB,2DACvB,EACA,iDAGJ,EACA,EACA,wBAdF,IAiBK,cAA8B,cAAI,cAAY,iBAArD,IAEgB,AAChB,AAAI,0BAAa,MAAa,iBAAgB,UAC5C,cACE,GACA,mDAGO,AAA2B,cAAS,EAAU,wCAClD,cAA8B,cAAI,+BAAzC,IAGO,AAAmC,iCAAiB,cAAS,EAAU,+CADtD,IAIjB,cAA0B,cAiV8B,iBAlVrC,IAGD,AACzB,AAAY,mBACZ,iBACO,AAAoC,EAAO,cAAS,EAAU,+CAArE,IAEuB,AACvB,AAAY,mBACZ,iBACO,AAAkC,EAAO,cAAS,EAAU,+CAAnE,IAIgB,GACI,sBACpB,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,qBAEP,cAAP,IAEK,AACL,cACA,6BACA,cAAS,EAAU,+CAHrB,IAMmB,GACR,cAA6B,uBACxC,AAAI,AAAC,KAAa,cAAP,IACJ,cAA8B,cAAI,+BAAzC,IAGO,cAA0B,6BADjB,IAGT,AACP,AAAI,EAAS,MACX,cACE,GACA,cAAS,kCAGX,cACE,GACA,gDAGG,cAAP,0JhBlmFE,EAAqB,sEAtgCpB,EAAyB,cAAY,cAAQ,4BAApD,0IAk+BM,EAAwB,sEA7/BvB,EAA4B,cAAY,cAAmB,4BAAlE,2EAoxCM,EAAuB,EAAU,cAAS,8DA1oCzC,EAA2B,EAAU,cAAS,4BAArD,yKAkiCM,EAAkB,sEA7kCjB,EAAsB,cAAW,cAAQ,cAAQ,4BAAxD,2GAq4BM,EAAgB,8DAl/Bf,EAAoB,cAAa,4BAAxC,kCgBg9Ha,sBACb,QAAQ,qBACD,OAQA,QARqB,AACxB,cAAkB,AAChB,cACA,iDACA,cAAS,EAAU,kDAErB,GAEkB,GACN,cAAsB,cAAI,EAAU,cAAM,0DACtD,AAAI,AAAC,KAAc,aAAP,IACZ,cAAkB,iBAClB,cAAa,cAAS,EAAU,mCAChC,GAEO,AACP,cACE,GACA,sCAEK,aAAP,IAGG,aAAP,6JhBnjGM,EAAiB,sEA58BhB,EAAqB,EAAU,cAAM,cAAO,4BAAnD,iCgBgvHA,AAAO,EAAc,wBACV,cAA0B,sBACrC,AAAI,AAAC,KAAa,cAAP,IACX,AAAe,kCAKf,IACE,AAAC,AAAiB,AAAoB,+BAAe,KAErD,AAAY,0BACZ,8FAAQ,MAGD,OAoBA,QAWA,OAWA,QAmBA,QACA,QAmBA,QAwBA,QAWA,QA+BA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QAOA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QA5LU,AACb,AAAI,cAAQ,iBACH,AACL,EACA,cACA,EACA,cAAS,EAAU,4CAGR,cAAe,0BAC5B,AAAI,AAAC,KAAe,cAAP,OACN,AACL,EACA,cACA,cACA,cAAS,EAAU,yCAGvB,GAEsB,GACf,AACL,EACA,cACA,EACA,cAAS,EAAU,2CAEd,cAA8B,cAAI,wBACzC,GAGqB,GACR,cAAe,0BAC5B,AAAI,AAAC,KAAe,cAAP,OACN,AACL,cACA,cACA,cAAS,EAAU,wCAErB,GAGsB,GACX,cAAqB,6BAChC,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,cAAP,OAEK,AACL,cACA,cACA,cAAS,EAAU,2CAEd,cAA8B,cAAI,cA6MpB,UA5MrB,IAIsB,AACtB,AACE,iBAAa,KACb,iBAAa,SACb,iBAAa,SAEb,cACE,GACA,0CAGG,AACL,EACA,cACA,cAAS,EAAU,wCAErB,GAGmB,GACN,cAAqB,6BAClC,AAAI,AAAC,KAAe,cAAP,IACb,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,sCAAY,uBAEP,cAAP,OAEW,cAAqB,cAAI,EAAa,KAC/C,EAAmB,IACnB,WAEJ,AAAI,AAAC,KAAe,cAAP,OACN,AACL,cACA,cACA,cACA,cAAS,EAAU,wCAErB,GAGgB,GACe,oCAAE,YACjC,KACS,cAAqB,cAAI,EAAmB,WACnD,AAAI,AAAC,KAAa,cAAP,IACX,cAAgB,kBACT,cAAQ,mBACV,AAA2B,cAAY,cAAS,EAAU,wCACjE,GAGc,AACd,AAAI,cAAkB,UACT,AAAgC,6BAAqB,mDACzD,AACL,cACA,cACA,cAAS,EAAU,4CAGV,cAAqB,cAAI,EAAiB,WACrD,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,iBAAa,QACR,cAAsB,cAAI,EAAU,cAAM,0DACjD,AAAI,AAAC,KAAa,cAAP,KAEX,cACE,GACA,sCAEK,cAAP,KAGJ,AAAI,cAAQ,kBACH,cAA0B,cAAI,sBACrC,AAAI,AAAC,KAAa,cAAP,QAEJ,cAA8B,cAAI,cAAM,WAEjD,gBAgB4B,GACjB,cAAqB,cAAI,UACpC,AAAI,AAAC,KAAa,cAAP,OACJ,AAA4B,EAAO,cAAM,cAAM,cAAS,EAAU,wCACzE,wBAwBa,GACF,cAAqB,cAAI,EAAiB,WACrD,AAAI,AAAC,KAAa,cAAP,OACJ,AAA4B,EAAO,cAAM,cAAM,cAAS,EAAU,wCACzE,GAEO,AAAO,0BAGb,cAAP,kCA5OW,YACX,IAAO,AAAC,cAAQ,mBACH,cAAqB,cAAI,EAAmB,WACvD,AAAI,AAAC,KAAa,aAAP,IACX,cAAU,kBACV,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,eACV,GAEA,cACE,GACA,sCAAY,uBAEP,aAAP,WAIC,aAAP,4JhBv5FM,EAAoB,iEApF1B,AAAI,iBAAiB,QACL,AAAC,yDACf,AAAO,mCACP,kBAAQ,cAAmB,SACpB,QAIA,QAIA,QAIA,QAIA,QAIA,QAIA,QAIA,SA5BY,AACf,AAAI,cAAW,qBAAkB,cAAP,IAC1B,GAEe,AACf,AAAI,cAAW,qBAAmB,cAAP,IAC3B,GAEe,AACf,AAAI,cAAW,qBAAgB,cAAP,IACxB,GAEe,AACf,AAAI,cAAW,qBAAiB,cAAP,IACzB,GAEe,AACf,AAAI,cAAW,qBAAiB,cAAP,IACzB,GAEe,AACf,AAAI,cAAW,qBAAe,cAAP,IACvB,GAEe,AACf,AAAI,cAAW,qBAAmB,cAAP,IAC3B,GAEe,AACf,AAAI,cAAW,qBAAoB,cAAP,IAC5B,AAAI,cAAW,qBAAiB,cAAP,IACzB,IAGC,AAAI,iBAAiB,QACD,6CACR,sBACjB,AAAI,iBAAmB,QACP,AAAC,yDACf,AAAO,sCACO,qCACd,AAAO,mCACP,AAAI,cAAW,qBACb,MAAQ,cAAmB,SACpB,QAIA,SAJY,AACf,AAAI,cAAW,qBAAiB,cAAP,IACzB,GAEe,AACf,AAAI,cAAW,qBAAiB,cAAP,IACzB,AAAI,cAAW,qBAAkB,cAAP,IAC1B,IAGC,AAAI,cAAW,qBACpB,IAAQ,cAAmB,SACpB,SAAY,AACf,AAAI,cAAW,qBAAa,cAAP,IACrB,QAMH,cAAP,oCAn3BO,EAAkB,AAAuB,iBAAO,cAAM,cAAM,4BAAnE,+BgB+qBA,AAAe,mBACf,AAAI,6BACS,yBACkB,AAAgC,cAAM,cAAS,EAAU,0CACtF,IAAO,cAAQ,eACb,AAAI,cAAkB,UACb,yBACM,AACX,cACA,AAAgC,cAAM,uDACtC,cAAS,EAAU,yCAGrB,cACE,GACA,+CAEK,aAAP,SAIJ,AAAI,cAAQ,kBACH,cAAoB,sBAC3B,AAAI,IACK,AAAqB,cAAY,cAAM,cAAS,EAAU,8CAAjE,KAGK,AAAqB,cAAY,EAAM,cAAS,EAAU,8CAAjE,KAGF,cACE,GACA,gDAGG,aAAP,qhBhB69BM,EAA+B,cAAM,EAAM,EAAO,EAAM,cAAa,sEA33CpE,EAAyB,cAAM,EAAO,cAAa,4BAA1D,+BgBqkBA,AAAI,AAAC,2BACH,cACE,GACA,+CAEK,aAAP,OAEe,AAAgC,6BAAqB,gDACtE,AAA+B,IAC/B,AAAI,cAAQ,kBACF,cAAqB,cAAI,EAAmB,WACpD,AAAI,AAAC,KAAc,aAAP,KAEP,AACL,cACA,EACA,cACA,AAAW,6BAAkB,mEAJ/B,+OhByxBM,EAA0B,cAAM,cAAY,EAAO,sEAp3ClD,EAAoB,cAAM,cAAY,EAAO,cAAQ,4BAA5D,+BgB2hBA,AAAI,wBAAa,MACf,cACE,GACA,+CAEK,aAAP,OAEe,AAAgC,6BAAqB,gDACtE,AAAI,wBAAa,KACf,cACE,GACA,sCAAY,uBAEP,aAAP,OAEY,YACd,IAAO,AAAC,cAAQ,kBACD,cAAoB,cAAI,UACrC,AAAI,AAAC,KAAe,aAAP,IACb,cAAa,kBACb,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,cACV,GAEA,cACE,GACA,sCAAY,uBAEP,aAAP,cAII,AACR,cACA,cACA,EACA,cACA,cAAS,EAAU,wCAErB,cAA2B,gCAC3B,cAAQ,cACD,aAAP,iCAwWA,AAAI,AAAC,2BACH,cACE,GACA,cAAS,gDAEJ,cAAP,OAGS,AAAgC,6BAAqB,gDAChE,AAAqB,IAErB,AAAiD,IACjD,AAAI,cAAQ,eACV,AAAiB,sBACA,cAAyB,sBAC1C,AAAI,AAAC,KAAuB,cAAP,IACrB,EAAS,QAGX,AAAI,AAAC,cAAQ,gBACX,cACE,GACA,cAAS,uCAAS,uBAEb,cAAP,IAGF,AAAI,EAAiB,KACnB,AAAiB,uBAGF,cAAqB,cA/OhB,UAgPtB,AAAI,AAAC,KAAmB,cAAP,OACF,sBAEf,AAAe,AAAC,EAAQ,IAAoB,KAC5C,AAAI,IACF,AAAI,iBAAqB,KACvB,cACE,GACA,uCAGJ,AAAI,iBAAoB,KAAK,cAAW,0BACtC,cACE,GACA,wCAKN,AAAI,EAAQ,MACV,AAAI,mBACF,cACE,GACA,wCAKN,AAAkC,IAClC,AAAI,cAAQ,kBACG,cAAe,cAAI,EAAM,UACtC,AAAI,AAAC,KAAmB,cAAP,KAGnB,AAAI,AAAC,QACU,AACX,cAAS,+CAEX,AAAI,AAAC,KACH,cACE,GACA,2CAKU,AACd,cACA,cACA,cACA,EACA,cAAS,EAAgB,wCAG3B,AAA6B,IAC7B,AAAI,cAAQ,cACV,AAAI,EAAQ,OACV,cACE,GACA,mDAIG,cAAyB,cAAI,UACpC,AAAI,AAAC,KAAa,cAAP,KACN,AAAI,AAAE,EAAQ,QACnB,cACE,GACA,cAAS,qDAIH,AACR,cACA,cACA,EACA,cACA,cACA,cACA,EACA,cAAS,EAAU,wCAErB,cAA2B,gCAC3B,cAAQ,cACD,cAAP,gNhBknBM,cAAM,cAAY,EAAO,cAAgB,cAAa,cAAiB,cAAS,sBACtF,cAAY,gDApjDL,EAAyB,cAAM,cAAY,EAAO,cAAgB,cAAa,cAAiB,cAAS,4BAAhH,iCgBokCA,AAAkB,iBAAY,KAE9B,AAAI,AAAC,2BACH,cACE,GACA,+CAEK,cAAP,OAGe,AACf,6BACA,gDAGF,AAAiD,IACjD,AAAI,cAAQ,kBACO,cAAyB,sBAC1C,AAAI,AAAC,KAAuB,cAAP,IACrB,EAAS,QAGX,AAAwC,IACxC,AAAI,cAAQ,iBACC,cAAe,0BAC1B,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,iBAAa,KACf,cACE,GACA,sCAEK,cAAP,OAEY,2CAGhB,AAA8C,IAC9C,AAAI,cAAQ,cACV,AAAI,IACF,cACE,GACA,gDAGJ,KACa,cAAe,cAjtCF,EACL,UAitCnB,AAAI,AAAC,KAAa,cAAP,IACX,AAAI,iBAAa,KACf,cACE,GACA,sCAEK,cAAP,IAEF,AAAI,AAAC,KACH,AAAI,AAAC,QAAmC,oBACxC,cAAqB,sDAEhB,cAAQ,iBAGnB,AAAI,AAAC,cAAQ,eACX,cACE,GACA,sCAAY,uBAEP,cAAP,OAGY,YAEd,AAAI,IACF,AAAO,AAAC,wBACM,AACZ,cACA,cACA,EACA,cACA,cACA,EACA,cACA,cAAS,EAAU,4CAGP,AACZ,cACA,cACA,EACA,cACA,cACA,cACA,cACA,cAAS,EAAU,yCAGvB,AAAI,AAAC,cAAQ,eACX,KACe,cAAsB,cAAI,sBACvC,AAAI,IACF,AAAI,iBAAe,MACjB,cAA6B,qDAE7B,AAAO,0CACP,cAAa,uDAGf,cAAmB,iBACnB,AAAI,cAAQ,eACV,cACE,GACA,sCAAY,uBAEP,cAAP,KAGG,AAAC,cAAQ,iBAEpB,6BAAwB,oBACxB,cAAmC,gCAC5B,cAAP,qGhBkaM,EAA+B,cAAM,cAAY,EAAO,sEAnhDvD,EAAyB,cAAM,cAAY,EAAO,cAAS,4BAAlE,+BgBizDA,AAAI,6BACe,AAAgC,6BAAqB,gDACtE,AAAI,cAAQ,iBACI,eACI,AAChB,cACA,cACA,EACA,cACA,cAAS,EAAU,wCAErB,IAAO,AAAC,cAAQ,kBACD,cAA4B,cAAI,sBAC7C,AAAI,IACF,AAAI,iBAAe,KACjB,cACE,GACA,sCAEK,aAAP,IAEF,cAAa,mBAEb,cAAmB,iBACnB,AAAI,cAAQ,eACV,cACE,GACA,sCAAY,uBAEP,aAAP,UAIN,6BAAwB,oBACxB,cAAmC,gCACnC,cAAQ,cACD,aAAP,IAEA,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,gDAGG,aAAP,0IhBznBM,EAAuB,sEAj3CtB,EAA0B,cAAM,cAAc,4BAArD,+BgB0xEA,AAAI,6BACiB,AAAgC,6BAAqB,gDACxE,AAAI,cAAQ,eACV,AAAI,6BACe,AAAgC,6BAAqB,mDAC5D,AAAiC,cAAY,cAAc,cAAS,EAAU,wCACxF,cAAQ,cACD,aAAP,IAEA,cACE,GACA,iDAIJ,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,gDAGG,aAAP,uZhBrvBM,EAA4B,cAAM,EAAM,EAAkB,sEA/gDhE,AAAI,AAAC,QAAa,QACX,EAAsB,cAAM,cAAa,4BAAhD,+BgB+rEA,AAAI,cAAkB,UACH,AAAgC,6BAAqB,gDACtE,AAAgD,IAChD,AAAI,cAAQ,cACV,AAAI,6BACa,AAAgC,6BAAqB,iDAEpE,cACE,GACA,+CAEK,aAAP,KAGJ,AAAI,IACK,AACL,cACA,cACA,AAAW,6BAAkB,0DAH/B,IAMK,AACL,cACA,EACA,2CAHF,IAMA,cACE,GACA,gDAGG,aAAP,oU5B9qFF,AAAU,mBACV,AAAI,EAAO,KACT,AAAI,EAAO,KAAU,cAAP,IACd,AAAI,cAA0B,KAAM,MAC3B,aAAP,KAGJ,IAAO,AAAE,OAAM,KACb,AAAI,cAA0B,KAAQ,MAC7B,cAAyB,EAAG,gBAAnC,SAGG,cAAP,+BAtBA,AAAI,cAA0B,uBACrB,aAAP,IAEK,AACL,AAAQ,6BAAU,6BAAiB,2CADrC,sLYo/DQ,EAAiB,yBACF,AAAc,qCACnC,AAAI,6BAAsB,yBACP,AAAY,cAAgB,qDAE7C,AAAI,AAAC,cAA0B,yBAAkC,cAAiB,wBAEpF,cAAoB,AAAmB,gFA9iDhC,EAAoB,EAAM,cAAe,cAAM,4BAAtD,oCARO,EAAoB,cAAc,EAAM,cAAM,4BAArD,ymCgB2mEA,AAAe,mBACf,AAA0C,IAC1C,AAAiD,IACjD,AAAe,IACf,AAAI,cAAQ,iBACA,YACV,IAAO,AAAC,cAAQ,kBACD,cAA4B,sBACzC,AAAI,AAAC,KAAe,cAAP,IACb,cAAa,kBACb,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,cACV,GAEA,cACE,GACA,sCAAY,uBAEP,cAAP,YAID,AAAI,cAAQ,eACjB,AAAI,cAAQ,cACV,AAAI,6BACc,AAAgC,6BAAqB,iDAErE,cACE,GACA,+CAEK,cAAP,KAGF,cACE,GACA,sCAAY,uBAEP,cAAP,KAEG,AAAI,cAAQ,GAAkB,UACxB,yBACC,kCACF,qCACR,AACE,AAAgC,gBAAW,+BAC3C,AAAgC,cAAM,+BACtC,2BAGJ,AAAI,cAAQ,eAEV,cACE,GACA,sCACA,uBAEK,cAAP,KAGF,AAAW,OAGb,AAAI,OAAY,cAAQ,eACtB,AAAI,cAAQ,kBACC,AAAmC,iCAAiB,8CAE/D,AAAI,IACF,AAAO,AAAC,wBACF,AAAmC,cAAe,cAAM,cAAS,EAAU,4CAE3E,AAA2B,cAAS,cAAM,cAAS,EAAU,4CAElD,sBACnB,AAAI,AAAC,6BAAiB,oBACpB,6BAAmB,cAAc,EAAa,GAAO,yDAAqB,iCAC1E,6BAAkB,mBAEpB,cAAQ,cACD,cAAP,IAEA,cACE,GACA,iDAIJ,cACE,GACA,sCAAY,wBAGT,cAAP,8HhBpfM,EAAiB,8DAhjDhB,EAAsB,cAAM,EAAO,4BAA1C,+BgB2yFA,AAAe,mBACf,AAAO,wBAAa,yBACH,6BACP,AAA6B,cAAY,EAAO,cAAS,EAAU,wCAC7E,cAAyB,iBACzB,cAAQ,cACD,aAAP,0IhBrnDM,EAAuB,sEAv3C7B,AAAI,AAAC,QAA6B,QAC3B,EAAiB,cAAW,cAAc,4BAAjD,uUAs4CM,EAAiB,sBACvB,AAAI,OACmB,AAAc,qCACnC,AAAI,6BAAsB,yBACP,AAAY,cAAgB,qDAE7C,AAAI,AAAC,cAA0B,yBAAkC,cAAiB,wBAEpF,cAAoB,kBAEpB,cAAoB,sDAx6Cf,EAAoB,cAAS,cAAM,EAAW,4BAArD,kCgBqoEW,yBACC,kCACF,AAA2B,qCACnC,AACE,AAAgC,cAAM,+BACtC,AAAgC,gBAAW,cAAS,EAAc,kCAClE,kCAED,EAAM,EAAO,cAAS,EAAU,wCACnC,cAAQ,cACD,aAAP,iVAtDA,AAAI,cAAkB,UACH,AAAgC,6BAAqB,gDACtE,AAAgD,IAChD,AAAI,cAAQ,cACV,AAAI,cAAkB,UACL,AAAgC,6BAAqB,iDAEpE,cACE,GACA,+CAEK,aAAP,KAGJ,AAAI,IACK,AACL,cACA,cACA,AAAW,6BAAkB,0DAH/B,IAMK,AACL,cACA,EACA,2CAHF,IAMA,cACE,GACA,gDAGG,aAAP,ydArHA,AAA2C,OACvB,GAAO,kDAC3B,AAAI,cAAQ,iBACI,YACd,IAAO,AAAC,cAAQ,kBACD,cAAuB,sBACpC,AAAI,AAAC,KAAe,cAAP,IACb,cAAa,kBACb,AAAI,AAAC,cAAQ,gBACX,AAAI,cAAQ,cACV,GAEA,cACE,GACA,sCAAY,uBAEP,cAAP,WAIN,AAAI,cAAQ,cACV,AAAI,cAAQ,kBACH,AAAmC,iCAAiB,+CAE3D,cACE,GACA,+CAEK,cAAP,QAGM,AAA2B,cAAS,cAAM,EAAW,cAAS,EAAU,wCAClF,AAAI,OACiB,GAAO,kDAC1B,AAAI,AAAC,6BAAiB,oBACpB,6BAAmB,cAAc,EAAa,cAAe,iCAC7D,6BAAkB,kBAClB,6BAAiB,oBAGrB,cAAQ,cACD,cAAP,IACK,AAAI,cAAQ,eACjB,AAAI,cAAQ,cACV,AAAI,cAAQ,kBACH,AAAmC,cvB7+C1B,EAA4B,iBuB6+Ce,iDACjD,AAA2B,EAAM,cAAM,EAAW,cAAS,EAAU,2CAC5D,GAAO,qDACb,yBACK,sBAClB,AAAI,AAAC,KAAa,cAAqB,oCAAE,uBACpC,AAAI,AAAC,cAAqB,sBAAe,cAAiB,oBAC/D,AAAI,AAAC,6BAAiB,oBACpB,6BAAmB,cAAc,EAAa,cAAe,iCAC7D,6BAAkB,mBAEpB,cAAQ,cACD,cAAP,IAEA,cACE,GACA,iDAIJ,cACE,GACA,sCAAY,yBAIhB,cACE,GACA,sCAAY,yBAGT,cAAP,2GhBxpBM,EAAwB,8DAj7CvB,EAA2B,cAAa,4BAA/C,+BgBjUA,AAAY,IAAY,iBAAkB,MAAsB,KAChE,AAAe,IAGf,AAAyC,IACzC,IAAO,cAAQ,eACb,AAAI,EAAW,KAAG,AAAW,uBACb,cAAoB,sBACpC,AAAI,AAAC,KACH,cAAmB,iBACnB,GAEF,AAAI,AAAC,QAAyB,oCAAC,aAC1B,cAAgB,wBAIvB,AAAkB,IAClB,AAAgB,IAChB,AAAmB,IACnB,AAAiB,IACjB,AAAI,cAAQ,cACV,AAAI,EAAW,KAAG,AAAW,oBAC7B,EAAS,KACT,AAAc,mBACd,AAAY,mBACZ,AAAI,cAAQ,cACV,AAAe,mBACf,AAAa,qBAIjB,AAAmB,IACnB,AAAiB,IACjB,AAAuB,EAAa,OAAQ,cAAa,aACzD,AAAI,cAAQ,cACV,AAAI,IACF,cACE,GACA,gDAGF,AAAI,EAAW,KAAG,AAAW,oBAC7B,AAAe,IACf,AAAa,mBACb,EAAS,EAAsB,UAE5B,AAAI,IACT,EAAS,SAIX,AAAkC,IAGlC,AAAY,4BACZ,AAAI,EAAW,KAAG,AAAW,oBAC7B,4BAAQ,MACD,OAWA,OACA,OAMA,OAMA,OAMA,OA2BA,OACA,OAMA,OAaA,OAUA,OAaA,QApGa,AAChB,yBACA,EAAS,KACT,AAAI,cAAQ,iBACE,cAAe,cAAI,EAAO,cAAY,cAEtC,cAAmB,cAAI,EAAO,cAAY,aAExD,AAAa,IACb,GAEc,EAAS,MACT,AACd,4BACY,cAAmB,cAAI,EAAO,cAAY,EA+oB5C,UA9oBV,AAAa,IACb,GAEe,AACf,4BACY,cAAe,cAAI,EAAO,cAAY,UAClD,AAAa,IACb,GAEmB,AACnB,4BACY,cAAmB,cAAI,EAAO,cAAY,UACtD,AAAa,IACb,GAEmB,GACP,sBACZ,yBACA,AAAoB,mBACpB,AAAkB,mBAClB,AAAI,mBACF,cAAS,oBACG,cAAoB,cAAI,UACpC,GAEF,AAAW,4BACX,AAAI,EAAQ,KACV,AAAI,EAAQ,KACV,cACE,GACA,cAAS,EAAe,2BAG5B,cAAS,oBACG,cAAoB,cAAI,UACpC,GAEA,cAAW,kBAEb,EAAS,QAIW,AACpB,4BACY,cAA2B,cAAI,EAAO,cAAY,UAC9D,AAAa,IACb,GAEoB,GACR,sBACZ,yBACA,AAAI,cAAQ,YAA8B,MACxC,cAAW,oBACC,cAAoB,cAAI,EAAO,cAAY,UACvD,AAAa,KAEb,cAAS,oBACG,cAAoB,cAAI,WAEtC,GAEiB,AACjB,yBACA,EAAS,KACT,AAAI,EAAQ,QACE,cAAuB,cAAI,cAE3B,cAAiB,uBAE/B,GAEe,GACH,sBACZ,yBACA,AAAI,cAAQ,YAA8B,MACxC,cAAW,oBACC,cAA0B,cAAI,EAAO,cAAY,UAC7D,AAAa,KAEb,cAAS,oBACG,cAAoB,cAAI,WAEtC,GAEiB,GACL,sBACZ,yBACA,AAAI,0BAAa,MAAuB,AAAC,wBACvC,cAAW,oBACC,cAA4B,cAAI,WAE5C,cAAS,oBACG,cAAoB,cAAI,WAEtC,GAEO,AAGP,AAAI,EAAQ,KACV,AAAI,IAAc,cAAkB,WAClC,AAAI,IACF,cACE,GACA,cAAS,EAAc,8BAGf,cAA6B,cAAI,EAAU,EAAc,UACrE,AAAe,AAAa,UAEhB,cAAiB,cAAI,EAAU,AAAC,EAAQ,GAAwB,aAK9E,AAAI,IACF,cACE,GACA,cAAS,EAAa,iBAAY,wBAGtC,AAAI,IACF,cACE,GACA,cAAS,EAAc,iBAAa,wBAGxC,AAAI,AAAC,QACS,cAAoB,cAAI,YAGxC,GAKJ,AAAI,IACG,AAAQ,IAAO,qBAAmB,EAAI,KACzC,cACE,GACA,cAAW,yCAH+B,AAAE,YASlD,AAAI,IAAc,EAAa,qBACrB,qBACD,OACA,OACA,OACA,OACA,YACI,AAAkC,kDAAiC,cAAS,EAAU,8CAD3D,IAG3B,AACP,cACE,GACA,cAAS,EAAc,iBAAa,wBAKrC,aAAP,kCAxSqB,AAAc,yBAChB,AAAmB,sBAGtC,AAAI,6BAAiB,4BAAe,EACpC,6BAAiB,kBACjB,6BAAiB,kBAGjB,AAAI,cAAQ,UACM,sBAChB,AAAgC,IAChC,AAAI,cAAc,sBAA0B,GAAO,cAAc,mDACjE,cACE,GACA,IACI,iCACA,eACJ,8BAEF,KAIW,EACX,IACI,GACA,cAAgB,qBACd,cAAa,cAAgB,oBAAyB,KACpD,GACA,IACF,IACN,cACA,sBAGF,6BAAkB,kBAClB,cAAqB,iBACrB,cAAyB,QAGhB,EAAc,cAAQ,qCAC/B,cAAe,mCACE,sBACjB,IAAO,AAAC,cAAQ,mBACE,cAA4B,cAAI,UAChD,AAAI,IACF,cAAgB,mBAEhB,cAAmB,iEDiJzB,6BAAyB,cAAM,cAAM,mEAFrB,uFZJd,AAAU,mBACV,AAAI,EAAM,KAAwB,iBAClC,AAAW,sBACG,AAAQ,UACtB,AAAgB,EAAM,KACtB,AACE,EACA,EAAO,GACP,EAAoB,OAElB,GAAkB,AACP,EAAQ,EAAoB,IAAe,KAK1D,cAAe,KACR,aAAP,wCagGc,sBACP,mBAAiB,GAAO,8CAAmB,cAAlD,4BDvGK,2CAAP,kCC4GkB,sBAChB,AAAI,cAAc,sBACD,GAAO,cAAc,kDAC7B,2CAAP,IAEK,aAAP,oCD5GK,6BAA2B,4BAAlC,qEpBw9FI,EACA,cACA,AAAmB,cAAM,cAAQ,mBACjC,6BACA,cACA,sBAEF,cAAsB,mDA/8EV,0BACK,AAAgC,cAAM,wBAChD,AACL,cACA,EAAM,EAAO,EACb,AAAuB,6BACvB,4BAJF,kCAo6BqB,sBACrB,AAAI,cAAmB,sBACN,GAAO,cAAmB,kDAMzC,AAAI,EAAY,QACD,AAAS,cAAU,sBAChC,AAAI,AAAC,KACH,AAAI,AAAkB,sBACpB,cACE,GACA,4CACA,AAAC,8FACD,sBAGF,cACE,GACA,4CAA8B,sBAG3B,aAAP,OAEQ,SAGd,cAAmB,cAAM,kBAClB,aAAP,yOAy5Cc,cAAgB,sBAC9B,AAAI,IAAgB,aAAP,OACK,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,KAC1C,GAAc,cAAY,iBAAa,0BAAc,aAAP,IADD,AAAE,YAI5C,aAAP,yOAYc,sBACd,AAAI,AAAC,KAAS,iBAAyB,4BACvC,cAAY,cAAM,kBAClB,AAAI,gCAA0B,KAAyB,6BAA0B,cAAM,mBAGnF,AAAQ,MAAG,EAAI,sCACR,6BAAqB,UAC9B,cAAO,cAAM,oBAFiC,gDA1ChD,AAAI,cAAqB,WACb,6BAA0B,cAAM,uBAE5C,AAAI,AAAC,cAAU,cAAM,cAAS,oBAAiC,aAAP,OAC9C,GAAO,cAAe,kDAChC,AAAI,cAAW,OAAuB,AAAC,SACrC,cACE,6BACA,kBAGG,aAAP,kCAn+Cc,EACZ,cACA,6BACA,cAA+B,cAAM,iBACrC,WAEF,cAAgB,iBAChB,6BAAoB,cAAM,iGA2xDxB,EACA,cACA,cACA,sBAEF,cAAsB,gDAhxDtB,AAAO,sCACM,EACX,cACA,6BACA,GACA,cAAmC,cAAM,EAAoB,0BAE/D,cAA+B,EAAO,iBACtC,6BAAoB,cAAM,cAw7CuE,2yCA2DnF,sBACd,AAAI,IAAW,cAAY,uBAAc,GAAO,cAAY,wDAA1B,OAChB,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,QAC5B,cAAY,iBAAgB,sBAC1C,AAAI,IAAgB,aAAP,IAFgC,AAAE,YAK5C,aAAP,04FA35BgB,wCACE,wCAGJ,cAAuB,sBACrC,AAAI,IACF,cACE,GACA,4CAA2B,+BAE7B,EAGF,AAAI,cAAe,OAGjB,GAAc,cAAoB,0BAChC,cAAuB,cAAa,kBAKpC,AAAI,cAAkB,sBAAqB,GAAO,cAAkB,mDAC/D,cAAkB,iBAAoB,6BAC3C,cAAW,cAAa,EACtB,6BACA,6BACA,EAAM,uBAOV,AAAI,cAAkB,sBAAqB,GAAO,cAAkB,mDAC/D,cAAkB,iBAAoB,6BAC3C,cAAW,cAAa,EACtB,6BACA,6BACA,cACA,cAAqB,0BACjB,cAAsB,EAAG,iBAAqB,sBAC9C,cAAc,wsDAzER,sBACd,AAAI,IACG,AAAQ,IAAO,qBAAgB,EAAI,KACtC,cAAsB,cAAQ,iBAAI,cAAQ,6BAAwB,iBADzB,AAAE,YAK7C,AAAI,cAAsB,sBAAkB,GAAO,cAAsB,mDACpE,cAAsB,iBAAiB,yCAC1B,sDAClB,cAAY,EACV,cACA,cAAqB,0BACjB,cAAsB,EAAG,iBAAqB,sBAC9C,cAAc,8BAClB,GAAO,yJAwiCT,EACA,cACA,AAAmB,cAAM,cAAQ,mBACjC,6BACA,cACA,sBAEF,cAAsB,KACtB,cAAa,6DAvgDb,AAAY,KACZ,AAAI,IACG,AAAQ,IAAO,qBAAmB,EAAI,QACzB,cAAW,UAC3B,AAAW,AAAuB,kCAClC,AAAW,AAAwB,OACnC,AAAI,IACF,AAAI,AAAE,EAAgB,MACpB,cACE,GACA,6BAAiB,mEAEd,AAAI,EAAQ,KACjB,cACE,GACA,uCAGF,EAAS,QAhB+B,AAAE,YAqB3C,aAAP,2QA2lDkB,sBAVhB,EACA,cACA,cACA,sBAEF,cAAsB,KACtB,cAAa,gEA7rCF,wCACG,EACZ,cACA,cACA,cACA,cAAqB,6BACnB,cAGJ,AAAI,AAAC,cAAW,cAAM,+BAAU,0CAnCrB,wCACG,EACZ,cACA,cACA,cACA,cAAqB,6BACnB,GACA,IACA,eAGJ,AAAI,AAAC,cAAW,cAAM,sBAAiB,aAAP,OACnB,sBACR,AAAQ,IAAO,qBAAe,EAAI,KACrC,cAAyB,cAAO,iBAAI,iBADI,AAAE,WAGrC,aAAP,kCAuPW,qCACX,AAAsB,KACtB,AAAI,cAAe,SACjB,EAAmB,GAA0B,QAE7C,EAAmB,MACnB,AAAI,oDAAsC,cAAe,QACvD,EAAmB,QAGvB,AAAI,AAAC,cAAe,UAClB,AAAI,iBAAe,KACjB,EAAmB,QAGvB,AAAI,iDACF,EAAmB,UAEP,EACZ,cACA,cACA,cACA,cAAqB,6BAAwB,aAE/C,AAAI,cAAqB,QAA2B,AAAC,eAAqB,uCACxE,cACE,GACA,6BAAmB,GAAY,+GAGnC,AAAI,AAAC,cAAW,cAAM,sBAAiB,aAAP,IACzB,aAAP,4SAijDoD,mBAEf,mBAEY,mBAEF,mBAEkB,kCAE7B,mBAEL,kCAED,sBAc5B,IAAe,GAAiC,GAChD,cACA,AAAmB,cAAM,cAAQ,cAAe,wBAChD,6BACA,cACA,sBAEF,cAAsB,uPAhQJ,0BACH,sBACf,AAAI,AAAC,QAAqB,AAAuB,uEACzB,EACtB,6BACA,6BACA,iBAAyB,KAAuB,IAChD,EACA,EAAqB,0BAAI,cAAU,EAAM,EAAO,6BAChD,EACA,yBAEsB,EACtB,6BACA,6BACA,iBAAyB,KAAuB,IAChD,EACA,EACE,qCACE,EACE,EACA,6BACA,cAAU,EAAM,kCAGpB,EACE,EACE,EAAyB,eAAI,EAAO,6BACpC,EAAM,6BAER,EAAM,EAAO,6BAEf,EAAM,EAAO,6BAEf,EAAM,yBAEQ,EAAsB,cAAM,cAAQ,sBACpD,cAA6B,iBAC7B,cAA2B,KAC3B,cAA4B,EAAsB,cAAgB,6BAAM,cAAQ,cAAmB,oBACnG,cAA4B,EAAsB,cAAgB,6BAAM,cAAQ,cAAmB,oBAC5F,cAAP,kCA6P0B,yBACJ,sBACtB,AAAI,AAAC,KAAiB,iBAAyC,4BAC1D,AAAI,cAAoB,sBACZ,GAAO,cAAoB,qDAC7B,AAAS,cAAU,sBAChC,AAAI,AAAC,KACH,AAAI,AAAkB,sBACpB,6BACE,GACA,4CACA,AAAC,2DACD,oDAGF,6BACE,GACA,4CAA8B,oDAG3B,aAAP,OAEQ,SAEZ,cAAoB,cAAM,kBAC1B,AAAI,cAAW,OAAuB,cAAQ,cAC5C,cAAY,SAEd,4CAAuC,cAAqB,kBACrD,aAAP,kCAzpEW,wCACM,sBAEjB,AAAoC,KACpC,AAAI,cAAU,SACZ,EAAiB,OAEnB,AAAI,cAAe,OACjB,AAAO,iBAAe,qBACtB,EAAiB,MACjB,AAAI,cAAe,QACjB,EAAiB,UAET,EACR,cACA,cACA,cAAqB,cAAY,KACjC,sBAEF,AAAI,AAAC,cAAW,cAAM,+BAAU,GAEhC,AAAO,AAAC,cAAkB,GAAuB,IAAkB,6BACzD,AACR,cACA,cACA,cACA,cAAqB,cAAY,aAEnC,AAAI,AAAC,cAAmB,cAAM,6BAAU,6CAiH/B,qCACX,AAAI,cAAe,UACG,sBACpB,AAAI,IAAiB,cAAkB,0BACvB,GAAO,cAAkB,kDACvC,AAAI,iBAAgB,KAAsC,kDAAP,QAErC,EAAsB,cAAM,cAAQ,sBAClD,AAAI,AAAC,cAAW,cAAM,sBAAiB,cAAP,IACzB,cAAP,QAGkB,sBACpB,AAAI,IAAiB,cAAkB,0BACvB,GAAO,cAAkB,kDACvC,AAAI,iBAAgB,KAAsC,kDAAP,QAErC,EAAsB,cAAM,cAAQ,sBAClD,AAAI,AAAC,cAAmB,cAAM,oBAAiB,cAAP,IACjC,cAAP,KAGJ,cACE,GACA,4CAAwB,qBAEnB,cAAP,kCAUe,cAAoB,cAAa,sBAChD,AAAI,AAAC,cAAU,KACJ,qCACX,AAAe,cAAe,QAC9B,AAAI,IACF,AAAI,mBACF,cACE,GACA,4CAAwB,8BAE1B,GAGF,AAAI,mBACF,cACE,GACA,4CAAwB,8BAE1B,MAGU,EACZ,AAAC,IAAW,GAAgB,eAAiB,6BAC7C,6BACA,cACA,cAAqB,6BACnB,GAAwB,eAG5B,AAAI,IACF,cAA2B,kBAE3B,cAA2B,qDAtgE7B,AAAO,mCACP,UAAQ,MACD,QACA,QAqEA,QAuBA,UA5F8B,AACjC,8BAAQ,cAAe,SAChB,QAKA,QAKA,OAIA,OAIA,OAKA,OAIA,OAIA,OAIA,QAIA,QAIA,OAIA,OAIA,OAOA,QA1DsB,AACzB,AAAI,cAAO,qBAAa,cAAP,IACjB,AAAI,cAAO,qBAAc,cAAP,IAClB,GAEuB,AACvB,AAAI,cAAO,qBAAa,cAAP,IACjB,AAAI,cAAO,qBAAc,cAAP,IAClB,GAEkB,AAClB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEmB,AACnB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEsB,AACtB,AAAI,cAAO,qBAAY,cAAP,IAChB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAEmB,AACnB,AAAI,cAAO,mBAAY,cAAP,IAChB,GAEqB,AACrB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEuB,AACvB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEiB,AACjB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEmB,AACnB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEoB,AACpB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAEyB,AACzB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAEyB,AACzB,AAAI,cAAO,qBAAY,cAAP,IAChB,AAAI,cAAO,qBAAa,cAAP,IACjB,AAAI,cAAO,qBAAa,cAAP,IACjB,AAAI,cAAO,qBAAc,cAAP,IAClB,GAEsB,AACtB,AAAI,cAAO,qBAAY,cAAP,IAChB,AAAI,cAAO,qBAAa,cAAP,IACjB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAGJ,GAEiC,AACjC,UAAQ,cAAe,SAChB,OAKA,OAKA,OAIA,SAde,AAClB,AAAI,cAAO,qBAAY,cAAP,IAChB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAEmB,AACnB,AAAI,cAAO,qBAAY,cAAP,IAChB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAEyB,AACzB,AAAI,cAAO,qBAAY,cAAP,IAChB,GAEmB,AACnB,AAAI,cAAO,oBAAY,cAAP,IAChB,GAGJ,GAEkC,AAClC,MAAQ,cAAe,SAChB,OAIA,QAJe,AAClB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAEmB,AACnB,AAAI,cAAO,qBAAa,cAAP,IACjB,GAGJ,GAGG,cAAP,g+BA4xDA,AAAI,IACG,AAAQ,IAAO,qBAAmB,EAAI,QACV,cAAW,UAC1C,UAAQ,qBACD,QACA,QACA,QACA,YAA+B,GACvB,sBACX,AAAc,IAAO,kBAAc,KACnC,AAAI,EAAW,QACE,AAAC,GAAc,0DAAgB,UAC9C,AAAI,cAAuB,UACd,AAAC,yDACZ,AAAW,AAA2B,iBAAyB,mBAC/D,AAAI,EAAQ,MACV,cACE,GACA,6BAAgB,yBAGF,sBAChB,AAAI,cAAc,OAChB,cACE,GACA,uCAGF,cAAyB,KACzB,cAAc,EAAM,qBAIxB,cACE,GACA,wCAIJ,cACE,GACA,6BAAiB,gBAAK,0BAxCc,AAAE,oDA9CvC,qCACX,AAAe,cAAe,OAC9B,AAAoB,GAAwB,MAC5C,AAAI,AAAC,cAAe,UAClB,EAAiB,GACA,IACA,QAEnB,AAAI,cAAU,SACZ,EAAiB,OAEnB,AAAI,iDACF,EAAiB,UAEL,EACZ,cACA,cACA,cACA,cAAqB,6BAAwB,aAE/C,AAAI,cAAqB,QAA2B,AAAC,eAAqB,uCACxE,cACE,GACA,6BAAmB,GAAY,+GAGnC,AAAI,IACF,AAAO,gCAAyB,qBAChC,AAAI,AAAC,cAAW,cAAM,sBAAiB,aAAP,KAEhC,AAAI,AAAC,cAAmB,cAAM,oBAAiB,aAAP,KAE1C,cAA4B,6BAAwB,cAAS,iBACtD,aAAP,kCAtJW,wCACG,EACZ,cACA,cACA,cACA,cAAqB,6BACnB,GACA,IACA,OAkpEiB,UA/oErB,AAAI,AAAC,cAAW,cAAM,sBAAiB,aAAP,OAGV,sBACtB,AAAI,IACF,AAAyB,mBACzB,AAAI,IAEF,AAAI,cAAqB,QACvB,cACE,GACA,AACE,4CACA,cAAgB,EAAqB,0DAIzC,cAAsB,qBAM5B,AAAI,mBACF,cAAmB,mBACd,AACL,AAAC,cAAqB,SACtB,6BAAwB,wBAExB,cAAkC,UAIX,sBACpB,AAAQ,IAAO,qBAA2B,EAAI,QACzB,cAAmB,UAC3C,UAAQ,qBACD,OAIA,OAYA,SAhB2B,AAC9B,cAAqB,iDAAqC,iBAC1D,GAE+B,GACP,0CACxB,AAAI,cAAwB,GAAkB,SAC5C,cAAwB,cAAmB,qBAE9B,cAAsB,cAAmB,sBACtD,AAAI,IAAU,gCAA+B,SAC3C,cAA+B,mBAGnC,GAE4B,GACrB,AAAO,qBApBkC,AAAE,WAuBjD,aAAP,uEAmvFE,cACA,cACA,cACA,EACA,0DAnrEa,sBACf,AAAI,AAAC,QAAqB,AAAuB,oEACjD,cACE,AACE,6BACA,6BACA,iBAAoB,IACpB,EACA,AACE,0BACA,cACA,EACA,EACA,4CAEF,EACA,4CAEF,iBAEF,AAAI,AAAC,cAAe,SAClB,cACE,AACE,6BACA,6BACA,iBAAoB,IACpB,EACA,AACE,qCACE,AACE,EACA,6BACA,cACA,EACA,gEAGJ,AAAuB,0EACvB,EACA,EACA,4CAEF,EACA,4CAEF,2DAzFO,wCACG,EACZ,cACA,cACA,cACA,cAAqB,6BACnB,cAGJ,AAAI,AAAC,cAAW,cAAM,sBAAiB,aAAP,IAGhC,AAAI,mBAAyB,cAAmB,sBAEvB,sBACpB,AAAQ,IAAO,qBAA2B,EAAI,QACzB,cAAmB,UAC3C,QAAQ,qBACD,OAIA,QAJ2B,AAC9B,cAA+B,iDAAqC,iBACpE,GAE+B,GACP,0CACxB,AAAI,cAAwB,GAAkB,SAC5C,cAAwB,cAAmB,kBAE3C,cAAsB,cAAmB,mBAE3C,GAEO,AAAO,qBAhBkC,AAAE,WAmBjD,aAAP,sEAmvBE,EACA,cACA,AAAmB,cAAM,cAAQ,EA+lDpB,iBA9lDb,6BACA,cACA,sBAEF,cAAsB,mDA5nBX,wCACG,EACZ,cACA,cACA,cACA,cAAqB,6BAAwB,cAE/C,cAAW,cAAM,4DAUE,sBACd,AAAQ,IAAO,qBAAqB,EAAI,UACzB,cAAa,aACpB,qCACX,AAAoB,GAAwB,MAC5C,AAAI,cAAe,SACjB,EAAiB,OAEnB,AAAI,cAAe,OACjB,EAAiB,OAEnB,AAAI,iDACF,EAAiB,UAEL,EACZ,cACA,cACA,cAAqB,6BAAwB,KAC7C,sBAEF,AAAI,cAAqB,QAA2B,AAAC,eAA8B,uCACjF,cACE,GACA,6BAAmB,GAAY,+GAGnC,AAAI,AAAC,cAAW,cAAM,sBAAU,IAzBc,AAAE,qDAzEvC,wCACI,EACb,cACA,cACA,cACA,cAAqB,6BAAwB,cAE/C,AAAI,AAAC,cAAW,cAAM,sBAAkB,cAAP,OACnB,GAAO,cAAiB,qDACxB,sBACT,AAAQ,IAAO,qBAAgB,EAAI,QACzB,cAAQ,UACrB,kBAAQ,qBACD,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,QAxB2B,AAC9B,cAAqB,iDAA0B,cAAU,cAAe,kBACxE,GAE6B,AAC7B,cAAoB,iDAAyB,kBAC7C,GAEiC,AACjC,cAAwB,iDAA6B,kBACrD,GAEkC,AAClC,cAAyB,iDAA8B,cAAU,kBACjE,GAEkC,AAClC,cAAyB,iDAA8B,cAAU,cAAe,kBAChF,GAE6B,AAC7B,cAA8B,iDAAyB,iBACvD,GAEsB,AACtB,cAAyB,iDAA2B,iBACpD,GAEO,AAAO,qBA/BuB,AAAE,WAkC7C,AAAI,EAAY,KAAS,AAAY,cAAU,kBACxC,cAAP,oCA/TkB,sBAClB,AAAsC,IACtC,cAAQ,qBACD,OAIA,OAIA,OAIA,OAIA,QAhB0B,GACnB,cAAoB,iDAA8B,sBAC5D,GAEiC,GACvB,cAAwB,kDAAkC,sBACpE,GAE8B,GACpB,cAAqB,iDAA+B,cAAQ,cAAe,sBACrF,GAEkC,GACxB,cAAyB,kDAAmC,cAAQ,sBAC9E,GAEkC,GACxB,cAAyB,kDAAmC,cAAQ,cAAe,sBAC7F,GAEO,AAAO,qBAElB,AAAI,OACY,sBACd,AAAI,AAAC,KAAS,iBAA2B,4BAEvC,AAAI,cAAY,wBACC,GAAO,cAAY,oDAClC,cACE,GACA,4CACA,2DACA,iCAEF,GAGJ,cAAY,gBAAW,mQAxoBP,sBACX,cAAgB,mBACnB,GAAO,cAAgB,8CACvB,cAAgB,mBACd,GAAO,cAAgB,8CACvB,eAJN,+PAgBA,SAEgB,cAAyB,sBACvC,AAAI,IAAgB,cAAP,IAGb,AAAI,cAAkB,sBACI,GAAO,cAAkB,kDACjD,AAAI,cAAsB,sBACL,GAAO,cAAsB,qDAClB,sBAG9B,AAAI,OACc,cAAuB,cAAyB,GAAO,kEACvE,AAAI,AAAC,KAAkB,cAAP,OACF,wCACA,OACd,MAIQ,cAAsB,oDAChC,AAAI,IAAgB,cAAP,MAGjB,GACO,SAGS,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,QAC5B,cAAmB,cAAa,cAAY,iBAAI,sBAC9D,AAAI,IAAgB,cAAP,IAFgC,AAAE,YAK5C,cAAP,8YAyoBqB,cAAqB,0BACtC,cAAsB,EAAG,iBAAqB,sBAC9C,cAAc,0BAGA,cAAuB,cAAa,sBACtD,AAAI,OACY,cAAmB,4CAA8B,cAAa,sBAC5E,AAAI,IACF,cAAW,4CAAuB,cAAS,0CAC3C,GAKJ,cAAmB,EACjB,cACA,6BACA,6BACA,cACA,yEA5DiB,sBACnB,AAAI,IACG,AAAQ,IAAO,qBAAqB,EAAI,KAC3C,cACE,cAAa,iBACb,cACA,6BACA,cACA,iBAN4C,AAAE,eAU9B,sBACpB,AAAI,IACF,cAAmB,EACjB,cACA,cACA,EACA,6BACA,6BAAyB,koCQ7zE3B,GAaK,cAAa,cAAO,KAAc,cADpC,kLRwjGW,sBAClB,AAAI,AAAC,KAAa,iBAAiC,qCAC9C,AAAI,cAAqB,cQvkGI,gBRukGG,GACrC,cAAiB,4PQ91FjB,AAAU,mBACV,AAAc,EAAQ,KAAI,AAAS,EAAM,KAAO,WAAK,AAAS,IAAO,aACrE,AAAc,AAAS,AAAS,IAAa,EAAM,aAAQ,eAC7C,AAAgC,EAAa,EAAc,GzB7WI,UyB8W7E,AAAkB,mBAClB,AAAgB,mBAChB,AAAgB,EAAa,EAAgB,MAC7C,AACE,EACA,EACA,EAAsB,OAExB,AAAa,EAAQ,KACrB,AAAI,EAAO,KACT,AACE,EACA,EAAa,EAAiB,IAC9B,AAAQ,EAAM,GAAW,QAG7B,cAAe,EAAM,MACd,aAAP,wCRmfY,uBACL,AACL,AAAgC,cAAM,cKlsBvB,iBLmsBf,EAAM,EAAO,yBAAI,4BAFnB,gDAHqB,yGA+7EY,+GAlEnB,sBACd,AAAI,IAEG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,QAC9C,AAAU,cAAM,aACpB,GAAO,cAAY,kDAChC,cAAO,cAAY,cAzU0E,MAsU3B,AAAE,eAMtD,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,KAC1C,cAAY,iBAA0B,iBADO,AAAE,8LAzBjC,6BAA4C,6BAC9D,cAAmB,oBACV,EAAc,cAAM,cAAQ,6BACrC,cAAO,QACP,cAA4B,iBAI5B,6BAA0B,kBACnB,aAAP,m+CAjiDqB,sBACrB,AAAO,AAAC,oBAA4B,AAAC,cAAmB,2CAC1C,GAAO,cAAY,kDACjC,AAAO,iBAAgB,wBACJ,GAAO,6BAA2B,kDAAyB,+CAC9E,cAA2B,iBAC3B,cAAmB,cAAM,i6BC5pDzB,AAAY,AACV,AAAkB,iBAAgB,AAAQ,EAAW,kBAAoB,SAE3E,IAAO,IACL,AAAiB,OACjB,AAAI,AAAE,EAAa,MAAU,KAAa,SAAY,aAAP,IAC/C,AAAQ,AAAwB,EAAa,AAAC,aAEzC,aAAP,+BAwDA,AAAyB,AAAM,EAAiB,QAC/B,EAAgB,EAAqB,WACtD,AAAyB,EAAqB,GAAgB,QAC7C,EAAgB,EAAqB,gBAGtD,AAAa,AAAkB,mBAC/B,AAAa,EAAS,AAAO,iBAAqB,WAClD,AAAa,IACb,IAAO,EAAU,KACf,AAAe,IACf,AAAI,AAAE,KAAsB,MAC1B,AAAe,OACG,UAClB,EAAe,iBACf,AAAqB,AAAQ,iBAAe,KAC5C,AAAuB,EAAgC,EAAwB,MAC/E,EAAsB,AAAY,QAClC,AAAa,EAAkB,KAC/B,EAAU,WAEZ,EAAU,eAGZ,cAAe,iBACf,cAAmB,KACnB,cAAe,iBACf,cAAuB,KACvB,cAAqB,uDA3ErB,AAAe,AAAQ,mBACvB,AAAY,cAAU,cAAK,OAC3B,AAAI,AAAC,KAEH,AAAI,iBAAsB,oBACxB,cACE,iBAAoB,iBAAuB,GAAgB,MACtD,kBACD,AAAC,iBAAoB,GAAK,QAIlC,AAAQ,AAAwB,AAAkB,iBAAgB,AAAQ,yCAAwB,WAClG,EAAY,iBACR,GAAgB,AACX,EAAyB,EAAwB,KAE1D,AAAE,qCAEF,AAAoB,AAAkB,iBAAgB,AAAQ,EAAW,kBAAoB,MAC7F,EAAmB,AAAY,QAC/B,AAAa,EAAe,MAEvB,aAAP,65BD+4CA,AAAI,cAAiB,IAA0B,mBAAsB,EACrE,AACE,iBAAmB,KACnB,iBAAmB,YAEF,6CACA,0CACjB,AAAI,AAAC,cAA4B,oBAC/B,cACE,GACA,4CAAiC,sDAGrC,cAAe,YACC,sBAChB,AAAI,AAAC,KAAW,iBAA0C,4BAC1D,cAAc,wDACY,sBAC1B,AAAI,IACG,GAAc,KAAW,gCAA0B,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACjC,cAAuB,SAF6D,AAAE,aAKrF,AACL,iBAAmB,KACnB,iBAAmB,YAEA,6CACA,0CACnB,AAAI,AAAC,cAA8B,oBACjC,cACE,GACA,4CAAmC,4CS1lCnB,EACA,EACA,MT2lCpB,AAAI,gCAA4B,KAG9B,AAAkB,mBAClB,AAAI,EAAe,oBACjB,AAAI,IACF,cACE,GACA,4CAAmC,4CACnC,6BAAmB,6BAAwB,iCAG7C,cACE,GACA,4CAAmC,4CACnC,6BAAmB,6BAAwB,2CAG/C,EACK,AAAI,cAET,IAGJ,cAAiB,YACA,sBACjB,AAAI,IACF,cAAe,YACE,sBACjB,AAAI,OACc,sBAChB,AAAI,AAAC,KAAW,iBAA0C,4BAC1D,cAAc,sBAEU,sBAC1B,AAAI,IACG,GAAc,KAAW,gCAA0B,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACjC,cAAuB,SAF6D,AAAE,gBAM3E,sBACjB,AAAI,IAAc,uBAChB,cAAe,YACE,sBACjB,AAAI,OACc,sBAChB,AAAI,AAAC,KAAW,iBAA0C,4BAC1D,cAAc,sBAEU,uBAC1B,AAAI,IACG,GAAc,KAAW,kCAA0B,IAAO,qBAAgB,EAAI,QACxD,cAAQ,WACjC,cAAuB,SAF6D,AAAE,cAO5F,cACE,GACA,4CAAiC,4CACjC,6BAAiB,6BAAwB,6EAjJnB,sBAC1B,AAAI,OACgB,KAAW,gCAC7B,AAAuC,IACvC,OAC4B,sBAC1B,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,QACzB,cAAY,UAC7B,AAAI,cAAwB,qCACT,GAAO,cAAwB,iEAChD,cAAuB,cAAe,cAAY,cAAe,kBAJtB,AAAE,eAUrB,sBAC9B,AAAI,IACG,AAAQ,IAAO,qBAAgC,EAAI,QACzB,cAAwB,UACrD,AAAI,EAA0B,KAC5B,cAAsB,cAAe,kBAHkB,AAAE,eAO3C,sBACpB,AAAI,AAAC,KAAe,GAEpB,AAAI,AAAC,QAAa,WAClB,cAAS,kBACT,AAAI,cAAS,mBAAgB,MAEb,OACT,+eR12CX,AAAY,cAAU,cAAK,AAAQ,sBACnC,AAAI,AAAC,KAAc,aAAP,IACZ,OAAoB,MACpB,AAAE,qCAEF,AAAsB,iBAAoB,KAC1C,AACE,EAAkB,GAAK,AAAS,IAAkB,4BAClD,iBAAoB,iBAAuB,GAAgB,UAC3D,cAAY,MACP,aAAP,+Bd2fF,AAAU,mBACV,AAAI,AAAC,KACC,GAEK,oBAFS,IASpB,AAAU,IACV,AAAW,AAAe,OAG1B,IAAO,AAAQ,OACb,AAAO,AAAe,EAAO,UAC7B,AAAE,YAIJ,AAAc,WACd,AAAI,EAAQ,QAAkB,EAAQ,MACpC,AAAI,AAAC,AAAE,UACD,GAEK,oBAFS,IAQpB,AAAI,EAAQ,KAEV,AAAO,YAET,AAAO,AAAe,EAAO,WAI/B,AAAI,IACF,AAAI,EAAQ,QAAK,EAAQ,MACnB,GAEK,oBAFS,IASpB,AAAI,EAAS,KACX,AACE,EAAM,KACN,EAAQ,SACR,AAAC,AAAe,KAAU,GAAO,UAEjC,EAAO,KAAG,EAAO,QAKrB,AAAI,EAAQ,KAAe,EAAM,SAC/B,QAAQ,AAAe,KAAU,OAC1B,QAKA,QAKA,SAVY,AACf,EAAO,KAAG,EAAO,KACjB,AAAQ,IACR,GAEe,AACf,EAAO,KAAG,EAAO,KACjB,AAAQ,IACR,GAEe,AACf,EAAO,KAAG,EAAO,KACjB,AAAQ,IACR,IAIN,AAAI,AAAC,KAAO,AAAQ,MAKtB,AAAa,WACb,AAAc,EAAM,KACpB,IAAO,aACL,AAAO,AAAe,OACtB,AAAI,EAAO,GAAc,KACvB,EAAQ,MACH,AAAI,EAAO,IAAc,AAAM,GAAa,OACjD,EAAQ,GAAa,OAChB,AAAI,EAAO,IAAc,AAAM,GAAa,OACjD,EAAQ,GAAa,SAEvB,AAAI,EAAQ,KACV,AAAI,EAAW,KACT,GAEK,oBAFS,IAQpB,GAGF,AAAM,EAAM,IAAQ,MACpB,EAAO,UAGF,EAAO,cAAd,8BG/HO,AAAY,cAAK,gBAAxB,6PmB8hCE,cAAY,QACZ,YAAQ,qBACD,OAWA,OAQA,OACA,OACA,QArB4B,GACT,AAAC,yDACvB,AAAI,IAEG,GAAc,KAAW,gCAAsB,IAAO,qBAAgB,EAAI,QAChE,AAAU,cAAQ,UAC/B,cAAsB,iBAF0D,AAAE,YAKtF,GAEkC,GACV,6CACF,sBACtB,AAAI,IAAiB,cAAsB,qBACrB,sBACtB,AAAI,IAAiB,cAAsB,kBAC3C,KAIsB,AAAO,wBAEb,sBACpB,AAAI,IAEG,GAAc,KAAW,gCAAoB,IAAO,qBAAgB,EAAI,QAC9D,AAAU,cAAQ,UAC/B,cAAsB,iBAFwD,AAAE,oDA9CtE,sBACd,AAAI,IAEG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,QACvD,AAAU,cAAQ,UAChC,cAAsB,iBAFkD,AAAE,eAK5D,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,KAC1C,cAAuB,cAAY,oBADU,AAAE,oDAnuBnD,AAAI,gCAAkB,EACtB,iBAAmB,QAEL,yBAGd,iBAAwB,iBAAgB,qBACxC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAmB,sCAC3C,iBAAwB,iBAAgB,qBACxC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAmB,sCAC3C,iBAAwB,iBAAkB,qBAC1C,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAiB,qBACzC,iBAAwB,iBAAmB,qBAC3C,iBAAwB,iBAAoB,qBAC5C,iBAAwB,iBAAqB,qBAC7C,mCAAoB,iBAAoB,EACtC,iBACA,mCACA,iBAA+B,iBAAoB,EAAqB,uBACxE,2BAEF,mCAAoB,iBAAqB,EACvC,iBACA,mCACA,iBAA+B,iBAAqB,EAAqB,uBACzE,2BAEF,mCAAoB,iBAAqB,EACvC,iBACA,mCACA,iBAA+B,iBAAqB,EAAqB,uBACzE,2BAEF,mCAAoB,iBAAsB,EACxC,iBACA,mCACA,iBAA+B,iBAAsB,EAAqB,uBAC1E,2BAEF,mCAAoB,iBAAqB,EACvC,iBACA,mCACA,iBAA+B,iBAAqB,EAAqB,uBACzE,2BAMF,iBAAwB,iBAAkB,qBAC1C,iBAAwB,iBAAqB,qBAC7C,iBAAwB,iBAAuB,qBAC/C,iBAAwB,iBAAoB,qBAC5C,iBAAwB,iBAAmB,qBAC3C,iBAAwB,iBAAuB,qBAC/C,iBAAwB,iBAAsB,qBAC9C,iBAAwB,iBAAoB,qBAC5C,iBAAwB,iBAAuB,qBAC/C,iBAAwB,iBAA6B,qBACrD,iBAAwB,iBAA8B,qBACtD,iBAAwB,iBAA6B,qBAGrD,iBAA6B,iBAAwB,kBACnD,EAAQ,sBAAmB,IAAgB,0BAC7C,iBAA6B,iBAAyB,kBACpD,EAAQ,0CACV,iBAA6B,iBAA2B,kBACtD,EAAQ,sBAAmB,GAAI,KAAG,oBACpC,iBAA6B,iBAA6B,kBACxD,EAAQ,sBAAoB,oBAC9B,iBAA6B,iBAA4B,kBACvD,EAAQ,sBAAmB,oBAC7B,iBAA6B,iBAAgC,kBAC3D,EAAQ,sBAA2B,oBACrC,iBAA6B,iBAA8B,kBACzD,EAAQ,sBAAyB,oBACnC,iBAA6B,iBAAkC,kBAC7D,EAAQ,sBAAwB,oBAClC,iBAA6B,iBAAgC,kBAC3D,EAAQ,sBAAwB,GAAI,KAAG,oBACzC,iBAA6B,iBAA+B,kBAC1D,EAAQ,0CACV,iBAA6B,iBAA+B,kBAC1D,EAAQ,0CACV,iBAA6B,iBAA+B,kBAC1D,EAAQ,0CAGV,iBAA6B,iBAAwC,kBACnE,EAAQ,iBAAmB,OAAyB,GAAI,KAAG,oBAC7D,iBAA6B,iBAAyC,kBACpE,EAAQ,iBAAmB,OAA0B,GAAI,KAAG,oBAC9D,iBAA6B,iBAAyC,kBACpE,EAAQ,iBAAmB,OAA0B,GAAI,KAAG,oBAC9D,iBAA6B,iBAAqC,kBAChE,EAAQ,iBAAmB,OAAsB,GAAI,KAAG,oBAC1D,iBAA6B,iBAA8B,kBACzD,EAAQ,iBAAmB,OAAgB,GAAI,KAAG,oBACpD,iBAA6B,iBAAiC,kBAC5D,EAAQ,iBAAmB,OAAmB,GAAI,KAAG,oBACvD,iBAA6B,iBAA4C,kBACvE,EAAQ,iBAAmB,QAA6B,GAAI,KAAG,oBACjE,iBAA6B,iBAAoC,kBAC/D,EAAQ,iBAAmB,QAAqB,GAAI,KAAG,oBACzD,iBAA6B,iBAAyC,kBACpE,EAAQ,iBAAmB,QAA0B,GAAI,KAAG,oBAC9D,iBAA6B,iBAAqC,kBAChE,EAAQ,iBAAmB,QAAsB,GAAI,KAAG,oBAC1D,iBAA6B,iBAA4B,kBACvD,EAAQ,iBAAmB,QAAc,GAAI,KAAG,oBAClD,iBAA6B,iBAAkC,kBAC7D,EAAQ,iBAAmB,QAAoB,GAAI,KAAG,oBACxD,iBAA6B,iBAAsC,kBACjE,EAAQ,iBAAmB,QAAuB,GAAI,KAAG,oBAC3D,iBAA6B,iBAAwC,kBACnE,EAAQ,iBAAmB,SAAyB,GAAI,KAAG,oBAC7D,iBAA6B,iBAAmC,kBAC9D,EAAQ,iBAAmB,SAAqB,GAAI,KAAG,uBAGrC,eACA,aACI,aACJ,eACG,YAGlB,AAAQ,IAAO,0CAAqB,EAAI,QAC9B,mCAAa,aACf,EAAS,iBAAM,yBAC1B,mCAAqB,mCAAmB,wBACvB,yBACZ,AAAQ,IAAO,wBAAmB,EAAI,QACzB,iBAAW,UAC3B,sBAAQ,wBACD,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,OAIA,QApCiB,AACpB,iBAAuB,oDAA4B,iBAAM,iBAAe,oBACxE,GAE2B,AAC3B,iBAA6B,qDAAmC,iBAAM,iBAAe,oBACrF,GAEoB,AACpB,iBAAuB,oDAA4B,iBAAM,iBAAe,oBACxE,GAEsB,AACtB,iBAAyB,oDAA8B,oBACvD,GAE8B,AAC9B,iBAAqB,oDAA6B,iBAAM,iBAAe,qBACvE,GAE6B,AAC7B,iBAAoB,oDAA4B,qBAChD,GAEiC,AACjC,iBAAwB,oDAAgC,qBACxD,GAEkC,AAClC,iBAAyB,oDAAiC,iBAAM,qBAChE,GAEkC,AAClC,iBAAyB,oDAAiC,iBAAM,iBAAe,qBAC/E,GAE6B,AAC7B,iBAA8B,oDAA4B,oBAC1D,GAzCwC,AAAE,WALF,AAAE,WAsD7C,GAAY,KAAS,mCAAwB,IAAO,wBAAc,EAAI,QAC9D,iBAAM,aACC,GAAO,iBAAsB,sDAC1C,AAAQ,IAAO,wBAAoB,EAAI,UACzB,AAAU,iBAAY,cACrB,iBAAuB,mCAAwB,4CACjE,AAAI,AAAC,KACH,iBACE,GACA,qDAA8B,4DAEhC,GAEF,iBAAsB,qBAVuB,AAAE,WAH2B,AAAE,WAmBhF,IACU,IAAkB,IAC1B,IAAO,EAAI,0BACU,iBAAc,cACX,6BACE,6BAEN,GAAO,iBAAuB,mCAA0B,yEAC1E,AAAI,OACY,iBACZ,mCACA,iBACA,0BAEF,AAAI,IACF,mCACE,mCACA,iBACA,qBAEF,iBAAqB,EAAG,MACxB,AAAe,KAEf,AAAE,YAGY,6BACA,0BAChB,iBACE,iBACA,iBACE,iBACA,iBACA,mCAEF,qBAEF,iBAAqB,EAAG,MACxB,AAAe,UAGnB,AAAI,AAAC,KAEE,AAAQ,IAAO,wBAAsB,EAAI,QACzB,iBAAc,cACT,0BACxB,AAAI,IACF,iBACE,GACA,mCAAyB,mCAA0B,yCANR,AAAE,WAUnD,GAEK,MAIJ,GAAY,KAAS,qCAAoB,IAAO,wBAAc,EAAI,QAC1D,AAAU,iBAAM,cACb,GAAO,iBAAkB,uDAElC,GAAkB,KAAS,qCAAc,IAAO,wBAAoB,EAAI,QAC1D,AAAU,iBAAY,cACpB,GAAO,iBAAY,0DACtB,+CACE,0BAClB,AAAI,OAEgB,GAAO,iBAAuB,iBAAa,GAAO,0GACtD,iBAAmB,iBAAW,iBAAa,0BACzD,AAAI,IACF,iBAAkB,iBAAY,qBAE9B,iBACE,GACA,qDACA,iBAAa,2BAIH,iBAAe,0BAC7B,AAAI,IACF,iBAAkB,iBAAY,wBAEV,iBAAY,0BAChC,AAAI,IAAiB,AAAkB,6BACrC,iBAAkB,iBAAY,yDAE9B,iBACE,GACA,qDACA,mCAAmB,6DA9BmD,AAAE,WAJV,AAAE,WA2C5E,AAAO,sCAA0B,qBACjC,AAAO,sCAA+B,qBACtC,AAAO,sCAA0B,qBACjC,AAAO,sCAAmC,qBAG1C,iBAA0B,kBAAS,oBACnC,iBAA0B,kBAAU,oBACpC,iBAA0B,kBAAU,oBACpC,iBAA0B,kBAAU,oBACpC,iBAA0B,mCAAmB,oBAC7C,iBAA0B,kBAAS,oBACnC,iBAA0B,kBAAU,oBACpC,iBAA0B,kBAAU,oBACpC,iBAA0B,kBAAU,oBACpC,iBAA0B,mCAAmB,oBAC7C,iBAA0B,kBAAW,oBACrC,iBAA0B,kBAAU,oBACpC,iBAA0B,kBAAU,oBACpC,AAAI,iBAAmB,OAAe,iBAA0B,kBAAW,qBAC3E,AAAI,iBAAmB,QACrB,iBAA0B,kBAAc,oBACxC,iBAA0B,kBAAgB,oBAC1C,AAAI,iBAAmB,QACrB,iBAA0B,kBAAa,oBACvC,iBAA0B,kBAAY,oBACtC,iBAA0B,kBAAgB,qBAC1C,iBAA0B,kBAAe,qBACzC,iBAA0B,kBAAa,0BAK5B,2BACV,AAAQ,KAAO,yBAAsB,GAAI,WACxB,iBAAc,gBAChB,GAAO,+DACP,kBAAyB,oCAAkB,qDAC7D,AAAI,AAAC,MAAa,GAClB,AAAI,qBAAsB,KACxB,AAAI,qBAAoB,QACF,iDACpB,AAAI,kBAA2B,QAC7B,iBACE,GACA,oCAAmB,8DAGvB,AACE,kBAA2B,MAC3B,kBAA2B,SAE3B,iBACE,GACA,AAAW,sDAAoC,gEAGnD,AAAI,AAAC,kBAAsB,wBACzB,kBAA8B,sBAE9B,iBACE,GACA,sDACA,+DAIJ,iBACE,GACA,+CAGC,AAAI,qBAAsB,KAC/B,AAAI,qBAAoB,QACA,iDACtB,AAAI,AAAC,kBAAsB,wBACzB,kBAA8B,sBAE9B,iBACE,GACA,sDACA,+DAIJ,iBACE,GACA,iDArDyC,AAAE,aA4D9C,AAAQ,KAAO,yBAAsB,GAAI,SAC5B,iBAAc,gBACR,4BACtB,AAAI,QACY,KAAW,yCACpB,AAAQ,KAAO,4BAAgB,GAAI,SACzB,kBAAQ,gBACH,4BAClB,AAAI,kBAAe,YACG,4BACpB,AAAkB,KAClB,IAAO,QACiB,4BACtB,AAAI,KACF,AAAI,kBAAoB,yCACtB,AAAc,KACd,OAGY,iCAElB,AAAI,AAAC,SACiB,GAAO,4DAC3B,iBACE,GACA,sDACA,6CArBmC,eALE,aAmC5C,AAAQ,KAAO,yBAAyB,GAAI,SAC3B,iBAAiB,gBACf,GAAO,4DACxB,AAAQ,KAAO,0BAAwB,GAAI,WACzB,kBAAgB,gBACd,kBAAyB,oCAAqB,qDACrE,AAAI,AAAC,MAAkB,GACvB,AAAI,qBAAyB,QACF,oDACC,4BAC1B,AAAI,AAAC,MAAqB,qBAA0D,oCACpF,kBAAyB,uBAEzB,iBACE,GACA,+CAZ6C,AAAE,aAHH,AAAE,aAsBjD,AAAQ,KAAO,yBAAsB,GAAI,SACxB,iBAAc,gBACd,4BACpB,AAAI,KACF,iBAAsB,kBAAe,sBAJQ,AAAE,aAO9C,AAAQ,KAAO,yBAAyB,GAAI,SAC3B,iBAAiB,gBACjB,+BACM,4BAC1B,AAAI,KACF,iBAAsB,kBAAe,sBAEvC,AAAI,KACG,AAAQ,KAAO,0BAA4B,GAAI,MAClD,iBAAsB,kBAAe,kBAAoB,wBADJ,AAAE,cART,AAAE,gBAgBhC,2BACpB,AAAI,AAAC,SAA+B,aACpC,AAAI,AAAC,kBAAkB,wBACrB,kBAAkB,kBAAmB,uBAEvC,AAAI,AAAC,kBAAkB,wBACrB,kBAAkB,kBAAmB,uBAEvC,AAAI,AAAC,kBAAkB,wBACrB,kBAAkB,kBAAkB,uBAEtC,AAAI,AAAC,kBAAkB,wBACrB,kBAAkB,kBAAkB,uBAEtC,AAAI,AAAC,kBAAkB,wBACrB,kBAAkB,kBAAmB,uBAGlC,GAAY,KAAS,yCAAoB,KAAO,0BAAc,GAAI,WACzD,AAAU,kBAAM,gBACjB,AAAmB,kBAAkB,4BAChD,AAAO,kBAAQ,uBACf,AAAI,AAAC,wBACH,mCAA2B,sBAC3B,GAEF,AAAgB,kBAAgB,QAChC,AAAI,GAAa,KAAe,GAAa,SAC3C,iBAA6B,kBAAO,kBAAU,EAAQ,AAAc,kBAAM,qCAErD,2BACrB,AAAI,kBAAmB,uBACrB,kBAAmB,kBAAO,GAAO,kBAAmB,yEAEpD,iBAAW,GAAoC,EAAM,4BAhBe,AAAE,aAwBzE,GAAc,KAAW,0DAAuB,KAAO,0BAAgB,GAAI,SACnE,AAAU,kBAAQ,aAC7B,AAAI,uCAA0B,KAC5B,iBAAuB,sBAHwD,AAAE,gDoB9mCvF,yP5BlRE,cAAe,EAAgB,EAAmB,qBAClD,cAAmB,EAAmB,MACtC,cAAe,EAAgB,EAAmB,0BAClD,cAAuB,KACvB,cAAqB,KACrB,cAAoB,wC6BuXpB,AAAI,kCAAqC,iBACzC,cAAe,4BACf,gCACA,gCACA,kEjB0lEA,AAAoC,iBAAU,6GkBpwEf,oCAQG,yHA++BI,mBAQJ,8yBCxmCE,kCAEA,kCAEP,qDA8HO,mBA8DR,mBAEC,uCAzLvB,qCACN,cAAgB,iyBtB5Ia,EAAgB,EAAmB,mCACvC,EAAmB,oBAGf,EAAgB,EAAmB,wCACnC,mBACF,mBACD,2HbgWI,mBAEZ,sEAMc,2CAEU,kCAEhB,2CAEQ,mBAED,mBAET,2CAEK,kCAEmB,kCAEnB,kCAEC,kCAEE,qDAID,mBAEJ,mBAkuGa,mBACA,mBACA,mBACA,mBACA,mBACA,mBAyyEe,sBAvgLjD,qCACN,cAAe,oBACF,yBACC,sBACd,AAAI,mBACF,cAAoB,EAAQ,uCAC5B,cAA0B,MAE1B,AAAI,AAAC,oBAA0B,iBAA6B,SAC1D,cAAoB,EAAQ,yBAC5B,cAA0B,MAE1B,cAAoB,EAAQ,wBAC5B,cAA0B,OAG9B,AAAiC,IACjC,AAAI,cAAmB,OAAwB,EAAgB,MAC/D,AAAI,cAAmB,OAAyB,EAAgB,MAChE,AAAI,cAAmB,OAAyB,EAAgB,MAChE,AAAI,cAAmB,OAAqB,EAAgB,MAC5D,AAAI,cAAmB,OAAe,EAAgB,MACtD,AAAI,cAAmB,OAAkB,EAAgB,MACzD,AAAI,cAAmB,QAA4B,EAAgB,OACnE,AAAI,cAAmB,QAAoB,EAAgB,OAC3D,AAAI,cAAmB,QAAyB,EAAgB,OAChE,AAAI,cAAmB,QAAqB,EAAgB,OAC5D,AAAI,cAAmB,QAAa,EAAgB,OACpD,AAAI,cAAmB,QAAmB,EAAgB,OAC1D,AAAI,cAAmB,QAAsB,EAAgB,QAC7D,AAAI,cAAmB,SAAwB,EAAgB,QAC/D,AAAI,cAAmB,SAAoB,EAAgB,QAC3D,cAAmB,QAGS,cAA2B,eAAoB,AAAiB,cAAS,yBAAI,ee2bjF,SAIR,oCf9bhB,cAAqC,kBACrC,cAAmB,gCACnB,cAAmB,sBACnB,cAAmB,EAAoB,wEgB6xDvC,AAAW,cAAuB,mBAC3B,AAA4B,iBAAU,KAAS,cAAtD,6BAhDA,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBAC5B,AAAoC,iBAAU,EAAO,gBAA5D,wCD5pCe,sBACf,AAAI,IAAY,uBACP,aAAP,OAEmB,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAU,cAAe,sBAAsB,aAAP,IADI,AAAE,WAG7C,aAAP,kCAKc,YACd,AAAY,OACG,sBACf,AAAI,IACF,AAAI,mBAAoB,cAAa,OACrC,AAAE,WAEiB,sBAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAU,cAAe,sBAC3B,cAAa,OAEf,AAAE,OAJ8C,AAAE,WAM7C,aAAP,gqCoBp3BA,AAAI,AAAC,6BAA8B,EACnC,6BAAmB,cAAM,qDnB6gEzB,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBAC5B,AAAkC,iBAAU,EAAO,gBAA1D,oChBt3Ca,sBACb,YAAQ,qBACD,OAYA,OA0CA,OAsCA,OAeA,QA3G+B,GAEV,0CACxB,AAAI,AAAC,cAAqB,aACD,6BAA8B,cAAmB,mBACxE,AAAI,IACF,cAAyB,cAAM,cAAkB,4BAEnD,EAEF,GAEyB,GACF,0CACvB,AAAI,AAAC,cAA8B,YACjB,sBAChB,AAAI,iBAA+B,sCAEd,cAAuB,sBAC1C,+BAAwB,QAE1B,cAAqB,oBACrB,AAAI,cAAoB,aACL,cAAS,sBAC1B,AAAI,AAAC,cAAiB,oBACpB,cAAyB,6BAA+B,kBACxD,cAAgC,KAChC,AAAyB,mBACzB,AAAI,IACF,6BAA4B,cAAY,iCAE1C,AAAI,AAAC,uBACY,sBACf,AACE,IAAY,AAA2B,0BACvC,AAA0B,mCAE1B,cAA4B,SAEP,sBAChB,AAAQ,IAAO,uBAAuB,EAAI,KAC7C,AAAI,AAA2B,cAAe,sBAC5C,cAA4B,KAC5B,GAH8C,AAAE,yBAS1D,GAGJ,GAEuB,GACV,0CACb,AAAc,cAAU,YAAsB,cAAU,EAAqB,UAC7E,AAAI,AAAC,KAAW,AAAC,6BAAwB,YACvC,cACE,GACA,4CAA6B,iCAE/B,EAEF,cAAmB,kBACnB,AAAI,cAAU,aACK,cAAS,sBAC1B,AAAI,AAAC,cAAiB,oBACpB,cAAuB,6BAAsB,kBAC7C,AAAI,AAAC,uBACQ,sBACX,AACE,AAA0B,sBAC1B,AAAC,cAAU,QAAsB,AAA2B,wBAE5D,cAA4B,QAIlC,AAAI,iBAAe,MACjB,cACE,GACA,mBACI,GAAO,6DACP,6CACJ,iCAGJ,EAEF,GAEqB,AACrB,cAAiB,wDACH,sBACd,AAAI,OACc,cAAS,6BAAO,sBAC3B,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,QAC9C,AAAU,cAAM,aACpB,GAAO,cAAY,kDAChC,AAAI,AAAC,cAAU,SACb,cAAyB,cAAY,cAAQ,kBAJmB,AAAE,sBAQxE,EAE0B,GACV,0CAChB,AAAI,AAAC,oBAAyB,AAAC,6BAAwB,YACrD,cACE,GACA,4CAAgC,iCAElC,EAEF,AAAI,cAAa,aACE,cAAS,sBAC1B,AAAI,AAAC,cAAiB,oBACpB,cAAuB,6BAAsB,6BAE/C,EAEF,GAGJ,cACE,GACA,4CqB1lBoB,EACA,EACA,8CrBmcR,sBACd,AAAI,IAEG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,QAC7C,AAAU,cAAM,aACpB,GAAO,cAAY,kDACjC,cAAyB,cAAa,cAYyC,kBAfb,AAAE,eAMtD,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,KAC1C,cAA0B,cAAY,oBADO,AAAE,sDYqwB5C,GAAQ,cAAa,cAAM,gDAAlC,4TCzjDA,cAAe,EAAgB,EAAmB,qBAClD,cAAmB,EAAmB,MACtC,cAAe,EAAgB,EAAmB,0BAClD,cAAuB,KACvB,cAAqB,KACrB,cAAoB,uCATb,4BAAP,0PG2mEA,AAAW,cAAuB,mBAClC,AAAiC,iBAAU,+ChBgxK7B,yBACD,sBACb,AAAe,qCACH,YAQZ,cACE,cAAiB,EACf,cAAY,EAAG,EACb,cACE,EAAY,MACR,GACA,GACJ,cAAiB,EAAG,KACpB,cACE,iBAAwB,6BAAgC,0BAG5D,iBACC,SAIP,AAAI,sBACa,0BAEA,UACf,cAAiB,qBACD,sBAChB,AAAI,IACG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACvB,cAAiB,kBAFyD,AAAE,aAMlF,AAAI,IACG,GAAc,KAAW,gCAAmB,IAAO,qBAAgB,EAAI,QAC3D,cAAQ,UACvB,cACE,cAAU,gBACR,cAAc,EACZ,cAAiB,EAAG,MACpB,cAAW,gCAN4D,AAAE,YAYnF,cACE,cACE,cAAW,YAGf,cAAM,EAAK,cAAa,gBAAe,cAAO,SAC9C,cAAe,KACf,cACE,cAAW,SAEb,cAAsB,iBACtB,cAAmB,cAAM,EAAU,GAAa,0BAAiB,cAAa,EAAM,cAAO,mRAyE9E,sBACb,AAAe,qCACH,eACI,sBAQhB,AAAI,OACY,sBACd,cACE,cAAiB,EACf,cAAY,EAAG,EACb,cACE,EAAY,MACR,GACA,GACJ,cAAiB,EAAG,KACpB,cACE,iBAAwB,6BAAgC,0BAG5D,iBACC,YAGY,UACd,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACvB,AAAI,sBACiB,sBACnB,AAAI,IACG,GAAc,KAAW,gCAAmB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UAC1B,cAAiB,kBAF4D,AAAE,aAMnF,cAAiB,qBACD,sBAChB,AAAI,IACG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACvB,cAAiB,kBAFyD,AAAE,aAdR,AAAE,WAqBzE,GAAc,KAAW,gCAAmB,IAAO,qBAAgB,EAAI,QAC3D,cAAQ,UACvB,cACE,cAAU,gBACR,cAAc,EACZ,cAAiB,EAAG,MACpB,cAAW,gCAN4D,AAAE,YAYnF,cACE,cACE,cAAW,YAGf,cAAM,EAAK,cAAa,gBAAe,cAAO,SAC9C,cAAe,KACf,cACE,cAAW,SAEb,cAAsB,iBACtB,cAAmB,cAAM,EAAU,GAAa,0BAAiB,cAAa,EAAM,cAAO,qkBal+O3F,AAAY,AAAkB,mBAC9B,AAAW,sBACE,EAAa,UAC1B,AAAa,IACR,AAAQ,MAAG,EAAI,KAClB,AAAY,AAAwB,EAAQ,EAAW,WACvD,AAAI,AAAE,KAAmB,MACvB,AAAU,cAAO,WAAY,qBAHP,AAAE,WAM5B,cAAgB,KACT,aAAP,2OYyyFyB,qCACzB,AAAI,AAAC,KAA2B,cAAP,OAEC,GAAO,qDACjB,UAKX,GAAc,KAAW,gCAAyB,IAAO,qBAAgB,EAAI,UACjD,cAAQ,UACvC,AAAO,AAAC,uCACoB,sBAE5B,AAAO,iBAA8B,wBACpB,AAAC,yDAClB,AAAI,AAAC,KAAgB,GAChB,GAAc,KAAW,gCAAqB,IAAO,qBAAgB,EAAI,UACxD,cAAQ,UAE5B,AAAI,AAAC,cAA6B,oBAAsB,GACxD,AAAwC,IACxC,AAAI,cAAe,GAAkB,YAChB,uDACU,GAAO,cAAwB,kDAC5D,AAAO,iBAA+B,wBACV,cAAqB,iEACjD,AAAI,AAAC,KAAuB,GAC5B,AAAI,cAAY,WACK,uBAEnB,AAAO,cAAY,2BACA,2BAGA,cAAwB,qCAC7C,AAAI,IACF,AAAO,iBAAuB,wBACX,cAAqB,kDAAmC,gDAG/E,AAAI,IAAkB,cAAc,oBAxB2C,AAAE,YARA,AAAE,WAmChF,KAAW,uCAAlB,iaTuTsB,oCACC,oCACU,oCACP,KAI1B,cAAc,iBACd,cAAiB,8CI9pGjB,AAAU,mBACV,AAAI,EAAO,QAAK,EAAa,MAAY,aAAP,IAClC,AAAI,EAAY,KAAG,AAAY,AAAI,EAAM,KAAW,aACpD,AAAU,mBACV,IAAO,EAAY,KACjB,AAAI,AAAQ,EAAO,EAAoB,OAAkB,KAAc,aAAP,IAChE,AAAE,YAEG,aAAP,qFAiBA,AAAa,mBACb,AAAU,EAAS,KACnB,AAAe,EAAyB,EAAK,OACzC,GAAgB,AAClB,AAAa,iBAAkB,EAAiB,IAAe,KAC/D,AAAO,EAAyB,EAA0B,KAI5D,cAAe,KACR,aAAP,wCJgoGY,sBACZ,AAAY,cAAc,cIrqGO,OJsqGjC,AAAI,EAAQ,KACV,AAAQ,mBACR,cAAW,mBAEb,6BAAiB,MACjB,6BAAkB,yCI9uGlB,AAAI,EAAc,AAAK,oBAAmC,mBAC9C,AAAQ,iBAAkB,EAAgB,YAClD,GAAkB,AAChB,AAAC,IAAiB,AAChB,AAAC,KAA0C,iBAG5C,aAAP,oCJovGa,yBACD,sBACZ,AAAe,mBACf,AAAI,AAAC,KACI,cAAY,gCAAnB,OAEW,sBACb,AAAgB,sBACF,yBACF,EAAyB,EAAI,GAAY,cACxC,EAAkB,UAC1B,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAO,EAAK,GAAO,eAAI,8HADL,AAAE,WAGhC,cAAM,EAAK,cAAiB,EAAY,iBAAgB,QACnD,AAAQ,MAAG,EAAI,KAClB,AAAY,AAAU,cAAQ,OAC9B,AAAU,cAAM,EAAI,GAAK,cAAU,cAAO,iBACxC,cAAc,EACZ,cAAiB,EAAY,MAC7B,cAAW,cAAO,mBALO,AAAE,WASjC,AAAmB,sBACA,gBAAU,sBAC7B,cAAM,EAAI,GAAa,cACrB,AAAC,OACG,cAAO,MACP,eA1pDqB,EACJ,QA2pDvB,AAAc,cAAa,cAAO,iBAAI,0BACjC,AAAQ,MAAG,EAAI,QACN,cAAM,EAAI,WACtB,cAAc,MACd,AAAU,cAAa,AAAU,cAAO,iBAAK,0BAHjB,AAAE,cAKjB,cAAM,EAAW,WAChC,cAAiB,MACV,cACL,AAAC,OACG,GACA,eACJ,oCAJF,oChBigGW,cAAwB,sBACnC,AAAI,cAAQ,oBAAuB,EAEnC,AAAO,gCAAwB,QAAqB,gCAAwB,yBAC/D,yBACG,qCAChB,AAAkB,sBACG,wCACJ,qCACjB,AAAoB,mBACpB,AAAgB,EAAI,uBAGN,EAAkB,6BAC9B,cAAY,EAAG,EACb,cACE,EAAe,MACX,GACA,GACJ,cAAiB,EAAG,KACpB,EAAe,MACX,cAAW,QACX,cAAW,SAEjB,GgBn2JY,yBhBs2JQ,6BAA+B,sBACvD,AAAI,IACG,AAAQ,IAAO,qBAA0B,EAAI,UACzB,cAAkB,UACzC,AAAI,AAAC,cAAoB,WAAuB,MAC7B,yBACA,sBACnB,AAAI,AAAC,cAA4B,ce9/LmB,Qf+/LlD,cACE,GACA,4CAAuC,+BAAyB,oCAElE,MAGsB,yBACK,sBAC7B,AAA4B,sBACX,EAAyB,EAAI,WAC9C,cAAW,EAAK,cAAiB,EAAG,QAC/B,AAAQ,MAAG,EAAK,KACnB,cAAW,EAAK,cAAiB,EAAG,cAAe,EAAI,2BADrB,AAAE,WAGtC,AAAuB,IAClB,AAAQ,MAAe,EAAI,KAE9B,cAAW,EAAI,GAAK,cAAc,cAAuB,uBACzD,AAAmB,IAHkC,AAAE,cAKxC,IACb,cAAuB,iCACvB,uBACJ,AAAoB,qCACR,YACZ,AAAI,IAEF,cAAW,cAAkB,6BAA8B,cAAW,aAExE,AAAI,EAAc,MAChB,cACE,cAAY,cAAY,cAAY,WAEtC,cACE,wBAGF,cACE,cACE,cAAY,cAAY,cAAY,kBAItB,GAAO,kDAC3B,cAAgB,iBAAkB,oBAElB,sBAChB,AAAI,IACG,GAAc,KAAW,OwBl9MtC,AAAO,yBxBk9M+C,IAAO,qBAAgB,EAAI,UACxD,cAAQ,aACD,qCACtB,AAAI,IAAmB,cAAoB,oEACzC,GAEF,cAAgB,iBAAa,kBAN6C,AAAE,aAvD7B,AAAE,eAwErC,sBACpB,AAAI,AAAC,cAAY,SAAyB,AAAE,IAAiB,iBAAsB,iBAChE,EAAyB,UAC1C,cAAW,EAAK,cAAiB,EAAG,QAC/B,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,cAAW,EAAI,GAAK,cAAiB,EAAI,GAAG,cAAe,0BADX,AAAE,WAGpD,AAAO,cAAY,6BAAuB,cAAY,yBAItD,AAAO,oBAIT,AAAU,mBACV,AAAI,IAAK,cAAsB,iCAC/B,cAAW,cACT,6BACA,gCACA,gCACA,0BACA,cAAa,EAAM,sCACjB,cAAe,EgBrqG0B,0BhBsqGzC,mBACC,0BAEL,cAAS,4CgBt6IT,AAAW,cAAuB,mBAClC,AAAI,AAAC,AAA4B,iBAAU,OAAc,aAAP,IAClD,AAA+B,iBAAU,KAClC,aAAP,0FJ5mDa,sBACb,AAAI,AAAC,KAAQ,iBAA8B,GAAgB,cAAa,eAAiB,6DAClF,aAAP,kCAMa,sBACb,AAAI,AAAC,KAAQ,iBAA8B,GAAgB,cAAa,eAAiB,6DAClF,aAAP,wUA0qIc,yBAEQ,sBACtB,AAAI,IAGG,GAAc,KAAW,gCAAsB,IAAO,qBAAgB,EAAI,UAChE,AAAU,cAAQ,UAC/B,AAAI,iBAAe,QACD,6CACD,sBACf,AAAI,AAAC,KAAU,GACf,AAAI,mBAAoB,sCAAgC,aAAP,MAN6B,AAAE,WAWpF,AAAI,cAAoB,uBACN,sBAChB,AACE,EAAa,uBACb,EAAa,wBACb,EAAa,wBACb,EAAa,wBAIO,GAAO,cAAwB,kDAC9C,AAAQ,IAAO,qBAAsB,EAAI,KAC5C,AAAI,cAAc,sBAAqB,aAAP,IADe,AAAE,WAG5C,aAAP,IAEK,aAAP,KAGG,aAAP,6BO4lLF,AAAY,GAA+B,EAAK,qBAChD,AAAI,cAAQ,OAAqB,EAAS,OAC1C,AAAI,cAAQ,OAAqB,EAAS,OAC1C,AAAI,cAAQ,QAAqB,EAAS,QAC1C,AAAI,mBAA6B,EAAS,QACnC,EAAQ,eAAf,sCAKc,yBACD,yBACQ,sBACrB,AAAY,mBACZ,AAAW,EAAI,EAAI,SACR,EAAe,UAC1B,AAAS,EAAO,cAAM,KACtB,AAAU,OACQ,yBACC,yBACE,yBACF,yBACA,yBACQ,sBAC3B,AAAa,IAER,GAAY,KAAS,gCAAqB,IAAO,qBAAc,EAAI,KACtE,AAAiB,AAAU,cAAM,UAClB,GAAO,cAAmB,uCACzC,AAAO,EAAc,+BACrB,AAA2B,IAC3B,AAAI,mBAAwB,EAAS,MACrC,AAAI,EAAY,KAAe,cAA0B,0BACvC,sBAChB,EAAS,KACT,EAAS,GAA8B,AAAmB,sBACrD,AAAI,cAA0B,sBACnB,sBAChB,EAAS,KACT,EAAS,GAA8B,AAAmB,sBACrD,AAAI,cAA0B,sBACf,GAAO,cAA4B,mDACvD,AAAO,iBAAwB,sBAC/B,EAAS,KACT,EAAS,GAA8B,AAAmB,cAAc,yBACnE,AAAI,cAA0B,sBACf,GAAO,cAA4B,mDACvD,AAAO,iBAAwB,sBAC/B,EAAS,KACT,EAAS,IAA8B,AAAmB,cAAc,wBACxE,EAAS,GAA8B,AAAmB,cAAc,yBACnE,AAAI,cAA0B,sBACnB,sBAChB,EAAS,KACT,EAAS,GAA8B,AAAmB,0BAE5D,AAAS,EAAO,cAAM,KAAM,EAAO,KACnC,cAAqB,KA/BoD,AAAE,WAiC7E,AAAO,EAAO,yBACE,wCACF,cAAiC,cnBxjRc,UmByjR7D,AAAI,iBAAkB,KACpB,AAAa,mBACb,cAAiB,eAAwB,GAAa,EAAO,cAAW,EAAQ,UAAS,EAAS,qBAElG,cAAiB,eAAwB,GAAa,EAAO,cAAW,EAAQ,0EP7pTnE,sBACb,AAAI,AAAC,KAAQ,iBAA+B,cAAqB,eAg7BN,4BA/6BpD,aAAP,uIQ3pBA,AAAI,EAAc,MAAuB,MAAmC,iBAE5E,AAAiB,AAAI,IAAe,UAAa,QACpC,AAA8B,EAAY,UACvD,AAAI,EAAe,IAGnB,cAAc,iBACd,cAAiB,KACjB,cAAkB,KAClB,cAAe,+JAuDK,AACX,EAAyB,EAA0B,uCAhD5D,AAAe,EAAyB,EAAW,EAAc,KACjE,cAAe,gDhB4Hf,AAAY,AAAkB,mBAC9B,AAAW,sBACE,EAAa,UAC1B,AAAa,IACR,AAAQ,MAAG,EAAI,KAClB,AAAY,AAA0B,EAAQ,EAAW,WACzD,AAAI,AAAE,KAAmB,MACvB,AAAU,cAAO,WAAY,qBAHP,AAAE,WAM5B,cAAgB,KACT,aAAP,+Jem2TW,yBACD,YACZ,AAAkB,qCACE,GAAO,kEAG3B,cAAyB,cAAe,MAGnC,GAAc,KAAW,8DAAsC,IAAO,qBAAgB,EAAI,UAC/E,AAAU,cAAQ,UAChC,AAAI,iBAAgB,KAAoB,MAC3B,8CACI,yBACI,sBACrB,AACE,IACA,AAAC,cAA4B,aAC7B,cAAU,cAEV,AAAI,cAAU,UACZ,AAAY,mBACZ,AAAI,EAAQ,eAAU,EAAS,gBAC7B,cACE,cAAY,6BAA4B,qCACtC,kCACI,cAAW,EAAQ,UAAQ,EAAS,iBACpC,cAAW,EAAQ,qBACvB,cAAiB,EAAG,uBACnB,cAIP,cACE,cACE,cAAiB,EACf,cAAkB,6BAAqB,KACvC,YAEF,cAAY,6BAA4B,qCACtC,cAAiB,EAAG,YACpB,cAAiB,EAAG,uBACnB,oBAjCqF,AAAE,WAuCpG,cAAmB,eACjB,GACA,GACA,qCAAE,mBACF,mBACI,cAAa,EAAM,yBACnB,iEP9iOG,yEAAP,iCOojOF,AAAO,mDACP,AAAI,6BAAmB,KAET,yBACD,yBACG,qCAChB,AAAkB,mBAClB,AAAmB,sBACC,GAAO,sDAChB,eAGA,sBACX,AAAI,IACF,cACE,cAAY,AAAG,4DAA2B,qCACxC,cAAiB,EAAG,YACpB,cAAiB,EAAG,uBACnB,aAMP,AAAmB,IACnB,AAAI,sBACmB,cAAmB,uBACxC,AAAI,IACF,AAAO,iBAAuB,yBACV,6BAAiC,mDAAmC,mBACxF,AAAI,AAAC,QAAiB,AAAC,cAAyB,cnB9sRtB,SmB+sRxB,cACE,yBAGmB,yBACD,GAAO,mDAC3B,AACE,gCAAwC,KACxC,6BAA8B,KAAM,UACpC,iBAA6B,UAC7B,6BAAqC,cJxrTqB,4BI0rT5D,cACE,cAAY,6BAA4B,qCACtC,cAAiB,EAAG,YACpB,cAAiB,EAAG,uBACnB,aAGP,AAAe,MAMnB,AAAqB,IACrB,AAAI,AAAC,QACW,sBACd,AAAI,IAEG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,UACxD,AAAU,cAAQ,UAC/B,AAAI,iBAAe,KAA+B,MAEnC,AAAC,0DAChB,AAAI,AAAC,KAAU,MACC,sBAChB,AAAI,AAAC,uBAAoB,iBAAuC,SAAY,AAAC,qBAAqB,GAClG,AAAkB,mBAClB,AAAO,EAAe,sBACtB,AAAiB,IACjB,cAEE,cACE,cAAiB,EACf,cAAY,EAAc,EACxB,cAAiB,EAAG,KACpB,EAAa,cAEf,YAEF,cAAY,6BAA4B,sCACtC,cAAiB,EAAG,YACpB,cAAiB,EAAG,uBACnB,kBAxBiE,AAAE,aAgChF,cAAoB,cAAmB,AAAG,4DACxC,AAAW,uCAAC,+BACZ,GACA,2CAAmB,QAAgB,eACnC,cAAe,cAAM,YAIvB,AAAI,IAAQ,sCAEV,AAAqB,cAAU,6DAMnB,yBACD,yBACG,qCAChB,AAAkB,sBACG,yBACD,GAAO,mDAC3B,cAAyB,cAAe,SAI5B,eACA,YACZ,AAAa,IACR,GAAY,KAAS,gCAAqB,IAAO,qBAAc,EAAI,KACtE,AAAiB,cAAM,OACvB,AAAO,EAAc,kCACN,GAAO,cAAmB,uCACzC,cAAM,EAAK,gCACX,AAAI,mBACF,cAAM,EAAK,uBAEX,cAAM,EAAK,cAAa,EAAM,qCAC5B,cAAY,AAAG,4DAA+B,qCAC5C,cAAiB,EAAG,YACpB,cAAiB,EAAG,uBACnB,eACH,oCACC,SACH,AAAqB,cAAU,kBAfwC,AAAE,WAoB7E,AAAc,cAAa,cAAM,iBAAI,qCACnC,cAAc,cAAO,gBAEnB,cAAY,EAAG,EACb,EAAe,MACX,cAAc,EACZ,cAAiB,EAAG,KACpB,cAAW,WAEb,cAAc,EACZ,cAAiB,EAAG,KACpB,cAAW,SAEjB,GAAa,cH79QM,sBGg+QtB,QAGE,AAAQ,IAAO,iBAAe,OAAG,EAAI,KACxC,AAAU,cAAa,cAAM,EAAI,kBAAI,qCACnC,SACA,cAAM,sBACL,QAJwC,AAAE,WAQ/C,AAAU,cAAa,gBAAW,qCAChC,SACA,cAAM,iBAAe,uBACpB,QAGH,cAAmB,eACjB,AAAW,sCAAE,+BACb,GACA,EACA,cAAe,uCACb,SACA,mFChuUK,4BAAP,6FboGA,AAAU,iBAAiB,GAAc,wCavDzC,AAAI,EAAc,AAAK,oBACrB,AAAI,EAAQ,KAAwB,gBACpC,AAAe,EAAyB,EAAQ,GAAG,EApH6B,KAqHhF,cAAe,EAAQ,OAEzB,AAAS,iBAAkB,EAAgB,IAAe,KAC1D,AAAI,0CJ4tEJ,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAQ,sBACG,EAAiB,aACjB,EAAe,aACf,EAAyB,aACzB,EAAiB,UACvB,AAAQ,MAAG,EAAI,QACJ,AAAU,cAAS,aACpB,sBACb,AAAa,mBACb,AAAU,cAAK,EAAK,AAAa,oBACjC,AAAU,cAAK,EAAK,KACpB,AAAU,cAAK,EAAK,EAAU,MAC1B,cAAS,EAAQ,UAAS,EAAS,I/B7yE3C,AAAO,AAAM,EAAU,W+B8yEf,cAAS,EAAQ,iBAErB,AAAU,cAAK,EAAK,oBAVC,AAAE,WAYzB,AAAY,AAAc,mBAC1B,AAAY,AAAa,mBACzB,AAAY,AAAc,mBAC1B,AAAY,AAAc,mBAC1B,AACE,iBAAU,EAAS,EAAS,EAAO,EAAO,EAAO,EAAO,EAAO,EAAG,EAAQ,EAAO,KAEnF,AAAe,IACf,AAAe,IACf,AAAe,IACf,AAAe,IACV,AAAQ,EAAI,OAAG,EAAK,KACvB,AAAe,AAAU,cAAK,OADJ,AAAE,8CA9E9B,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAkC,iBAAU,EAAO,EAAO,EAAO,4ChB1lDjE,cAAoB,QAEN,yBACD,yBACQ,sBAErB,AAAwB,IACxB,AAAmB,KACnB,AAAqB,IAErB,AAAI,sBAAyC,oBAC3C,AAAe,EAAY,EAAU,EAAU,IAAc,MfjgBjE,AAAgB,EAAY,KAC5B,AAAO,OAAa,AAAC,EAAY,GAAS,yBAC1C,AAAO,AAAC,EAAQ,GAAQ,AAAC,We+fkD,EAAQ,uBfnkBnF,AAAO,EAAS,iBeskBd,AAAI,mBACF,AAAI,iBAAwB,KAC1B,cACE,GACA,EACA,2BAGF,AAAe,qBAInB,AAAI,mBACF,AAAI,iBAAwB,KAC1B,cACE,GACA,EACA,2BAGF,AAAe,qBAInB,AAAI,mBACF,AAAiB,IACjB,AAAI,AAAC,oBACH,cACE,GACA,WAEF,AAAiB,KAEnB,AAAI,AAAC,cAAmB,QACtB,cACE,GACA,EqBxUgB,SrB0UlB,AAAiB,MAKrB,AAAuB,mBACvB,AAAI,IACF,AAAqB,EAAQ,EAAmB,AAAC,QfxvBnB,IAClC,AAAO,AAAU,GAAM,GAAW,SewvB9B,AAAI,EAAO,IAAc,IftlB7B,AAAO,EAAO,QeulBR,cACE,GACA,EAAM,EAAc,2CAAe,EAAc,IfteP,IAClD,AAAO,IAAW,EqCtGe,MrCsGS,EqCnNT,4BtB8rB/B,cACE,EACA,EACA,cACA,iBACA,mBAAuB,IAAqB,eAC5C,eACA,KAIF,AAAI,mBACF,cACE,eACA,eACA,eACA,yCgBs/CJ,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAiC,iBAAU,EAAO,EAAO,wCAjEzD,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBAC5B,AAAiC,iBAAU,EAAO,gBAAzD,4BA6QA,AAAY,cAAuB,mBACnC,AAAY,cAAuB,mBACnC,AAAkC,EAAO,0CAxGzC,AAAW,cAAuB,mBAClC,AAAe,sBACH,EAAqB,UAC5B,AAAQ,MAAG,EAAI,KAClB,AAAU,cAAM,EAAK,cAAuB,cAAM,uBADtB,AAAE,WAGhC,AAAW,AAAc,mBACzB,AAAe,AAA2B,iBAAU,OACpD,AAAI,AAAC,KACH,AAAW,AAA2B,iBAAU,EAAM,EAAS,EAAS,SAExE,AAAkC,EAAU,KAC5C,AAA8B,EAAU,MAE1C,AAA0C,iBAAU,EAAM,EAAM,EAAM,EAAU,MAChF,AAAe,4ChB1mDD,yBACD,sBAGb,AAAI,mBACF,cACE,eACA,eACA,kBAEF,AAAI,mBAAoB,uBACtB,cACE,GACA,aAIN,AAAI,mBACF,cAAsB,eAA0B,mBAChD,AAAI,mBAAoB,uBACtB,cACE,GACA,EqB5cgB,EACA,EACA,OrBgdtB,AAAgB,mBAChB,AAAI,AAAC,KAAW,AAAY,QACR,yBACK,EAAkB,yBACtC,AAAQ,IAAO,qBAAsB,EAAI,KAC5C,cAAmB,EAAK,cAAc,mCADS,AAAE,WAInD,AAAuB,EAAmB,oBAC1C,AAAuB,KAEvB,AAAI,AAAE,sBAAuB,qBAE3B,AAAmB,IACnB,AAAI,mBAGF,cAAuB,gBAAwC,oBAGnE,cACE,eACA,EACA,EACA,cACA,cAAW,0CgB22Cb,AAA2B,iBAAU,wCf97DvC,AAAU,mBACV,AAAI,AAAC,KAAY,aAAP,IACV,AAAS,AAAK,cAAgB,OAC9B,AAAI,AAAC,AAAkB,QAAY,aAAP,IAC5B,AAAQ,AAAa,OACrB,IAAO,EAAI,KACT,AAAK,AAAK,cAAgB,OAC1B,AAAI,AAAC,AAAiB,QAAY,aAAP,IAC3B,EAAK,AAAa,aAEb,aAAP,6BmBrBE,AAAU,mBACV,AAAI,EAAM,KAAwB,iBAClC,AAAU,AAAQ,iBAAkB,AAAU,OAAQ,SACtD,cAAe,KACR,aAAP,6Bc2XA,AAAyB,mBACzB,cAA0B,AAAO,4BACjC,gKAAQ,AAAyB,QAC1B,OAWA,OAUA,OASA,OAWA,OAeA,OAYA,OAWA,OAOA,OAQA,OAOA,OAQA,OAOA,OAQA,OAIA,OAOA,OAQA,OASA,OAOA,OAUA,OAIA,OAOA,OAIA,OAIA,OAQA,OASA,OASA,OAQA,OAIA,OAOA,OAQA,OAQA,OASA,OAQA,OAOA,OAQA,OASA,OAIA,OASA,OASA,OAIA,OAIA,OAOA,OAOA,OAQA,OAWA,OAWA,OAIA,OAYA,OAOA,OAOA,OAOA,OAaA,OAOA,OAOA,OAQA,OAYA,OAQA,OASA,OASA,QAYA,QAQA,QASA,QAOA,QAWA,QAOA,QAaA,QAMA,QAOA,QAUA,QAQA,QAQA,QAOA,QASA,QAQA,QAOA,QAQA,QASA,SApnBoB,AACvB,6BAAgB,MAChB,AAAW,AAAsB,MACjC,AAAI,IAAM,cAAgB,MACrB,AAAe,IAAO,AAA6B,QAAO,EAAI,KACjE,cAAW,AAAyB,EAAM,OAD0B,AAAE,WAGxE,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAEoB,AACpB,6BAAgB,MAChB,cAAW,AAAwB,OACnC,cAAW,AAAqB,OAChC,AAAc,AAAsB,MACpC,AAAI,IAAS,cAAW,MACxB,AAAO,gCAAoB,qBAC3B,cAAa,KACb,GAEsB,AACtB,6BAAgB,MAChB,AAAW,AAAqB,OAChC,AAAI,IAAM,cAAgB,MAC1B,cAAW,AAAqB,QAChC,AAAO,gCAAoB,qBAC3B,cAAe,KACf,GAEuB,AACvB,6BAAgB,MAChB,cAAgB,AAAsB,QACtC,AAAgB,AAA2B,OAC3C,AAAI,IAAW,cAAW,MAC1B,AAAY,AAAuB,OACnC,AAAI,IAAO,cAAW,MACtB,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAEwB,AACxB,6BAAgB,MAChB,AAAkB,AAA8B,OAChD,AAAI,IAAa,cAAgB,MACjC,AAAe,AAA2B,OACrC,AAAe,MAAG,EAAI,KACzB,cAAgB,AAAyB,EAAM,QADZ,AAAE,WAGvC,cAAW,AAA4B,QACvC,AAAY,AAAwB,OACpC,AAAI,IAAO,cAAW,MACtB,AAAO,gCAAoB,qBAC3B,cAAiB,KACjB,GAEsB,AACtB,cAAkB,KAClB,6BAAgB,MAChB,cAAe,AAAuB,OACtC,AAAkB,AAA4B,MACzC,AAAe,MAAG,EAAI,KACzB,cAAW,AAA0B,EAAM,OADL,AAAE,WAG1C,AAAO,gCAAoB,qBAC3B,cAAe,KACf,GAE8B,AAC9B,cAA0B,KAC1B,6BAAgB,MAChB,cAAW,AAA+B,QACrC,AAAe,IAAO,AAAoC,SAAO,EAAI,KACxE,cAAW,AAAkC,EAAM,QADwB,AAAE,WAG/E,AAAO,gCAAoB,qBAC3B,cAAuB,KACvB,GAE0B,AAC1B,6BAAgB,MAChB,cAAgB,AAA0B,OAC1C,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE0B,AAC1B,6BAAgB,MAChB,cAAgB,AAA0B,OAC1C,cAAW,AAA0B,OACrC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE2B,AAC3B,6BAAgB,MAChB,cAAe,AAA0B,OACzC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAE2B,AAC3B,6BAAgB,MAChB,cAAe,AAA0B,QACzC,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAEsB,AACtB,6BAAgB,MAChB,cAAW,AAAoB,QAC/B,AAAO,gCAAoB,qBAC3B,cAAe,KACf,GAEuB,AACvB,6BAAgB,MAChB,cAAW,AAAqB,QAChC,cAAW,AAAuB,QAClC,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAEuB,AACvB,cAAgB,KAChB,GAEuB,AACvB,6BAAgB,MAChB,cAAW,AAAuB,OAClC,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAEwB,AACxB,6BAAgB,MAChB,cAAW,AAAuB,OAClC,cAAW,AAAwB,OACnC,AAAO,gCAAoB,qBAC3B,cAAiB,KACjB,GAEwB,AACxB,6BAAgB,MAChB,cAAW,AAAyB,OACpC,cAAW,AAA0B,OACrC,cAAW,AAA4B,QACvC,AAAO,gCAAoB,qBAC3B,cAAiB,KACjB,GAEsB,AACtB,6BAAgB,MAChB,cAAW,AAAsB,QACjC,AAAO,gCAAoB,qBAC3B,cAAe,KACf,GAEwB,AACxB,AAAY,AAAwB,OACpC,AAAI,IACF,6BAAgB,MAChB,cAAW,KACX,AAAO,gCAAoB,sBAE7B,cAAiB,KACjB,GAE4B,AAC5B,cAAqB,KACrB,GAE4B,AAC5B,6BAAgB,MAChB,cAAW,AAA4B,QACvC,AAAO,gCAAoB,qBAC3B,cAAqB,KACrB,GAEqB,AACrB,cAAc,KACd,GAE6B,AAC7B,cAAsB,KACtB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAE+B,AAC/B,6BAAgB,MAChB,cAAW,AAA6B,QACxC,cAAW,AAAkC,QAC7C,cAAW,AAAqC,QAChD,AAAO,gCAAoB,qBAC3B,cAAwB,KACxB,GAE4B,AAC5B,6BAAgB,MAChB,cAAW,AAA0B,QACrC,cAAW,AAA+B,QAC1C,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAqB,KACrB,GAE8B,AAC9B,6BAAgB,MAChB,cAAW,AAA4B,QACvC,cAAW,AAAoC,QAC/C,AAAO,gCAAoB,qBAC3B,cAAuB,KACvB,GAE6B,AAC7B,cAAsB,KACtB,GAE6B,AAC7B,6BAAgB,MAChB,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAsB,KACtB,GAE6B,AAC7B,6BAAgB,MAChB,cAAW,AAA2B,QACtC,cAAW,AAA6B,QACxC,AAAO,gCAAoB,qBAC3B,cAAsB,KACtB,GAE6B,AAC7B,6BAAgB,MAChB,cAAW,AAA4B,QACvC,cAAW,AAA6B,QACxC,AAAO,gCAAoB,qBAC3B,cAAsB,KACtB,GAE6B,AAC7B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,cAAW,AAAyB,QACpC,cAAW,AAAyB,QACpC,AAAO,gCAAoB,qBAC3B,cAAsB,KACtB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAwB,QACnC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAEmC,AACnC,6BAAgB,MAChB,cAAW,AAAiC,QAC5C,cAAW,AAAiC,QAC5C,AAAO,gCAAoB,qBAC3B,cAA4B,KAC5B,GAE4B,AAC5B,6BAAgB,MAChB,cAAW,AAA2B,QACtC,cAAW,AAA6B,QACxC,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAqB,KACrB,GAE0B,AAC1B,cAAmB,KACnB,GAE4B,AAC5B,6BAAgB,MAChB,cAAW,AAA2B,QACtC,cAAW,AAA6B,QACxC,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAqB,KACrB,GAE4B,AAC5B,6BAAgB,MAChB,cAAW,AAA2B,QACtC,cAAW,AAA4B,QACvC,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAqB,KACrB,GAEqB,AACrB,cAAc,KACd,GAEyB,AACzB,cAAkB,KAClB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAEyB,AACzB,6BAAgB,MAChB,cAAe,AAAwB,QACvC,AAAO,gCAAoB,qBAC3B,cAAkB,KAClB,GAEuB,AACvB,6BAAgB,MAChB,cAAW,AAAsB,QACjC,cAAW,AAAuB,QAClC,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAEqB,AACrB,6BAAgB,MAChB,cAAW,AAAoB,QAC/B,AAAqB,AAA8B,OAC9C,AAAe,MAAG,EAAI,KACzB,cAAW,AAA2B,EAAM,QADH,AAAE,WAG7C,AAAO,gCAAoB,qBAC3B,cAAc,KACd,GAEuB,AACvB,6BAAgB,MAChB,cAAc,AAAqB,QACnC,AAAkB,AAA6B,OAC1C,AAAe,MAAG,EAAI,KACzB,cAAW,AAA2B,EAAM,QADN,AAAE,WAG1C,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAEyB,AACzB,cAAkB,KAClB,GAE2B,AAC3B,AAAkB,AAAiC,OACnD,AAAI,IACF,6BAAgB,MACX,AAAe,MAAG,EAAI,KACzB,cAAW,AAA+B,EAAM,QADV,AAAE,WAG1C,AAAO,gCAAoB,sBAE7B,cAAoB,KACpB,GAE8B,AAC9B,6BAAgB,MAChB,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAuB,KACvB,GAEwB,AACxB,6BAAgB,MAChB,cAAW,AAAwB,QACnC,AAAO,gCAAoB,qBAC3B,cAAiB,KACjB,GAEwB,AACxB,6BAAgB,MAChB,cAAW,AAAsB,QACjC,AAAO,gCAAoB,qBAC3B,cAAiB,KACjB,GAEyB,AACzB,6BAAgB,MAChB,AAAkB,AAA+B,OACjD,AAAI,IACG,AAAe,MAAG,EAAI,KACzB,cAAW,AAA6B,EAAM,QADR,AAAE,YAI5C,cAAW,AAA0B,QACrC,AAAO,gCAAoB,qBAC3B,cAAkB,KAClB,GAEyB,AACzB,6BAAgB,MAChB,cAAW,AAAuB,QAClC,AAAO,gCAAoB,qBAC3B,cAAkB,KAClB,GAEyB,AACzB,6BAAgB,MAChB,cAAW,AAAuB,QAClC,AAAO,gCAAoB,qBAC3B,cAAkB,KAClB,GAEsB,AACtB,6BAAgB,MAChB,cAAgB,AAAqB,QACrC,cAAW,AAAoB,QAC/B,AAAO,gCAAoB,qBAC3B,cAAe,KACf,GAE2B,AAC3B,AAAkB,AAAiC,OACnD,AAAI,IACF,6BAAgB,MACX,AAAe,MAAG,EAAI,KACzB,cAAW,AAA+B,EAAM,QADV,AAAE,WAG1C,AAAO,gCAAoB,sBAE7B,cAAoB,KACpB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,cAAgB,AAA2B,QAC3C,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,cAAgB,AAA2B,QAC3C,cAAW,AAA2B,QACtC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,AAAW,AAAyB,OACpC,AAAI,IAAM,cAAW,MACrB,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE2B,AAC3B,AAAgB,AAA+B,OAC/C,AAAI,IACF,6BAAgB,MACX,AAAe,MAAG,EAAI,KACzB,cAAW,AAA6B,EAAM,QADV,AAAE,WAGxC,AAAO,gCAAoB,sBAE7B,cAAoB,KACpB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAwB,QACnC,cAAW,AAA0B,QACrC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAwB,QACnC,cAAW,AAA0B,QACrC,cAAW,AAA0B,QACrC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAwB,QACnC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAA6B,QACxC,cAAW,AAA+B,QAC1C,cAAW,AAA4B,QACvC,cAAW,AAA8B,QACzC,cAAW,AAA4B,QACvC,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAEuB,AACvB,6BAAgB,MAChB,cAAW,AAAuB,QAClC,AAAO,gCAAoB,qBAC3B,cAAgB,KAChB,GAE2B,AAC3B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,AAAa,AAA4B,OACzC,AAAI,IAAQ,cAAW,MACvB,AAAY,AAA2B,OACvC,AAAI,IAAO,cAAW,MACtB,AAAU,AAAyB,OACnC,AAAI,IAAK,cAAW,MACpB,AAAO,gCAAoB,qBAC3B,cAAoB,KACpB,GAE6B,AAC7B,6BAAgB,MAChB,AAAO,gCAAoB,qBAC3B,cAAsB,KACtB,GAE+B,AAC/B,6BAAgB,MAChB,cAAW,AAA6B,QACxC,AAAO,gCAAoB,qBAC3B,cAAwB,KACxB,GAE8B,AAC9B,6BAAgB,MAChB,cAAW,AAA4B,QACvC,cAAW,AAA4B,QACvC,AAAY,AAA8B,OAC1C,AAAI,IAAO,cAAW,MACtB,AAAO,gCAAoB,qBAC3B,cAAuB,KACvB,GAE8B,AAC9B,6BAAgB,MAChB,cAAW,AAA6B,QACxC,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAuB,KACvB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAyB,QACpC,cAAW,AAA0B,QACrC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAE0B,AAC1B,6BAAgB,MAChB,cAAW,AAAwB,QACnC,AAAO,gCAAoB,qBAC3B,cAAmB,KACnB,GAEmC,AACnC,6BAAgB,MAChB,cAAW,AAAiC,QAC5C,cAAW,AAAiC,QAC5C,cAAW,AAAmC,QAC9C,AAAO,gCAAoB,qBAC3B,cAA4B,KAC5B,GAEgC,AAChC,6BAAgB,MAChB,cAAW,AAA8B,QACzC,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAyB,KACzB,GAEgC,AAChC,6BAAgB,MAChB,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAyB,KACzB,GAEgC,AAChC,6BAAgB,MAChB,cAAW,AAA8B,QACzC,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAyB,KACzB,GAEgC,AAChC,6BAAgB,MAChB,cAAW,AAA8B,QACzC,cAAW,AAAgC,QAC3C,cAAW,AAA8B,QACzC,AAAO,gCAAoB,qBAC3B,cAAyB,KACzB,GAEiC,AACjC,6BAAgB,MAChB,cAAW,AAA+B,QAC1C,cAAW,AAA+B,QAC1C,AAAO,gCAAoB,qBAC3B,cAA0B,KAC1B,GAEO,AAAgB,iBAE3B,cAA0B,uCA8C1B,AAAW,AAAyB,OACpC,AAAI,IACF,cAAwB,KACxB,cAAW,KACX,cAAwB,wCAZ1B,AAAgB,kCACX,AAAe,IAAO,AAAyB,SAAY,EAAI,KAClE,cAAkB,AAA4B,EAAW,QADY,AAAE,6CAyBzE,cAAsB,KACtB,AAAW,AAA2B,OACtC,AAAI,IAAM,cAAW,MACrB,cAAsB,uCAXtB,AAAgB,kCACX,AAAe,IAAO,AAAuB,SAAY,EAAI,KAChE,cAAgB,AAA0B,EAAW,QADc,AAAE,6CAzBvE,iBACA,mHCjqBe,sBAGT,qCACN,cAAkB,ojBAzcY,2CAAP,4BAEO,2CAAP,4BAEG,iBAAgB,MAAc,GAAI,cAAzC,4BAEiB,iBAAgB,MAAc,GAAkB,cAAvD,4BAEO,iBAAgB,MAAc,GAAkB,cAAvD,6BAItB,iBAAgB,MACnB,6BAAgB,QAChB,6BAAgB,iBAFpB,kCA4Ga,sBACb,AAAI,AAAC,oBACH,cAA6B,KAC7B,cAAmB,gBAAgB,GAAc,GAAc,EAC7D,cACE,cAAc,EACZ,cAAkB,eAA4B,oBAC9C,cAAkB,eAAuB,uBAE3C,6BACE,6BAAiC,mBACjC,kBnBq9CiB,UmBh9ClB,cAAY,gBAAgB,EAAM,mBAAzC,+BA5EA,AAAO,EAAU,wBACJ,sBACb,AAAW,cAAkB,eAC3B,cAAc,EAAU,KAAI,kBAAoB,kBAC9C,cAAkB,eAA4B,oBAC9C,cAAc,AAAI,0BAGtB,AAAI,EAAS,KAAU,aAAP,IACT,cAAa,EAAM,qCACxB,SACA,kCACC,iBAHH,+BAQA,AAAO,EAAY,wBACN,sBACb,AAAI,6BAAwB,OAAuB,EAAY,SAC7D,cACE,cACE,cAAkB,eAA4B,oBAC9C,cAAW,KACX,cAAc,oBAIlB,AAAa,IACb,IAAO,EAAU,KAEf,cACE,cAAa,EACX,cAAkB,eAA4B,oBAC9C,cAAW,EnBolCe,KmBnlC1B,GACA,EAAY,mBAGhB,EAAU,UAEZ,AAAI,IACF,AAAO,EAAU,qBAEjB,cACE,cAAa,EACX,cAAkB,eAA4B,oBAC9C,cAAW,KACX,GACA,EAAY,+pFAlEpB,AAAI,6BAAkB,UACV,AAAoB,6BAAkB,UAChD,AAAI,cAAY,OACP,AAAkB,cAAY,gBAArC,QAGQ,UACV,6BAAkB,EAAM,mBAE1B,AAAgB,AAA8B,OAC9C,AAAiB,EAAY,oBAC7B,cAAY,EAAM,MACX,aAAP,sbvBuiB6B,AAAgB,UAC7C,AAAI,OACsB,sBACxB,AAAI,cAAoB,sBACN,GAAO,cAAoB,kDAC3C,AAAI,iBAAgB,KACX,gDAAP,MAIC,aAAP,+BuBhWA,AAAW,AAAyB,OACpC,AAAa,AAA2B,OACxC,AAAc,AAA4B,OAC1C,AAAW,AAAO,AAAyB,8BAC3C,AAAc,AAA4B,UAC/B,YACN,AAAe,MAAG,EAAI,KACzB,cAAK,EAAK,AAAwB,EAAS,QADT,AAAE,cAGvB,sBACf,AAAI,cAAa,UACD,AAAoB,cAAa,UAC1C,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,KAC/D,cAAU,cAAM,SADkD,AAAE,YAIxE,AAAgB,kCAChB,AAAwB,EAAW,KACnC,AAAW,AAAc,mBACzB,AAAiB,AAAqB,EAAW,EAAM,EAAQ,EAAS,EAAM,iBAAa,MAC3F,AAAI,qCAA0B,sCACjB,4CAA0C,UACrD,AAAI,IAAM,cAAkB,6BAAa,OAE3C,AAAM,mkDnBo2EN,AAAI,EAAO,KAAU,aAAP,OACD,sBACb,AAAI,cAAW,OAAa,AAAmB,cAAW,gBAArC,OACX,AAAW,UACrB,cAAW,EAAK,kBACT,aAAP,6BA2HF,AAAY,AAA4B,OACxC,AAAW,AAAiB,EAAgB,OAC5C,AAA6B,EAAM,QACvB,EAAmB,UAC1B,AAAa,MAAG,EAAI,KACvB,AAAU,cAAM,EAAK,AAAoB,EAAQ,EAAY,SAD/B,AAAE,WAGlC,AAAe,IACR,aAAP,kCmBv+Ee,sBACb,AAAgB,mBAChB,AAAO,AAAuB,KAAc,qBAE5C,AAAsB,AAAwB,UAC3B,iBAAwB,uCAC3C,AAAsB,AAAuB,OAC7C,AAAc,AAAqB,EAAW,MAC9C,AAAa,AAA2B,UACvB,AAAW,UAC5B,AAAgB,mBAChB,AAAc,AAA4B,OAC1C,AAAgB,OACL,YACX,AAAe,AAAO,yCACtB,AAAgB,EAAW,uBACT,gBAAY,sBAC9B,AAAqB,cAAyB,mBAE9C,AAAI,AAAqB,EAAW,IAAmB,QACzC,YAEZ,cACE,cAAqB,EAAC,UAEnB,AAAgB,MAAG,EAAY,KAElC,cACE,cAAa,iBACX,cAAkB,eAA4B,oBAC9C,cAAiB,cAAsB,KAAY,oBACnD,iBAAc,EAAY,kCANc,AAAE,cAUxB,EAAyB,UAC5C,AAAQ,MAAG,EAAI,KAClB,cAAkB,EAAK,cAAiB,EAAG,cAAW,WADzB,AAAE,WAGjC,AAAI,EAAW,MACb,AAAgB,aAChB,cAAU,MAEV,cACE,cAAiB,EACf,cAAY,cAAc,cAAmB,OAC7C,SAIJ,cACE,cAAqB,SAGvB,cACE,cAAiB,EAAW,UAI9B,cACE,cAAY,cAAc,cAAmB,WAG/C,cACE,cAAqB,UAGzB,AAAW,AAAc,mBACzB,AAAqB,EAAW,EAAgB,EAAQ,EAAS,EAAM,iBACrE,cAAa,EAAM,cAAO,QAE5B,AAAM,KAER,AAAsB,EAAW,KACjC,AAA2B,EAAW,EAAgB,6CAMtD,oBAGa,yBACW,EAAsB,sBACzC,GAAY,KAAS,+CAAoB,IAAO,qBAAc,EAAI,KACrE,AAAW,cAAM,UACH,AAAoB,6BAAkB,UACpD,AAAgB,iBAAe,oBAG/B,cAA8B,KAC9B,cAA+B,QAGnB,YAEZ,cACE,cAAqB,EAAC,UAGxB,cAAmB,EAAW,iBAG9B,AAAW,AAAyB,OACpC,AAAe,AAA2B,MAC1C,AAAI,EAAY,MAEd,cACE,OAEG,AAAI,EAAY,MAErB,cACE,MAGF,cACE,cAAqB,UAGvB,AAAW,cAAmB,EAAM,OAEpC,cACE,cAAiB,EAAM,EAAM,SAG/B,cACE,cAAqB,SAGvB,cACE,cAAiB,EAAM,WAG3B,AAAyB,EAAM,cAAe,cAAO,QAlDmB,AAAE,WAuDvE,GAAY,KAAS,+CAAoB,IAAO,qBAAc,EAAI,KACrE,cAAoB,cAAM,QAD8C,AAAE,cAK5D,sBACX,GAAY,KAAS,gCAAgB,IAAO,qBAAc,EAAI,QAChD,cAAM,UACvB,AAAgB,AAAmB,iBAAY,cAAyB,yBAC5C,AAAkB,cAAc,sBAC5D,cAAkB,EAAW,iBAJuC,AAAE,2FC5lBvD,yCAKX,qCACN,cAAe,8EA8Bf,iBACA,AAAI,mBACF,6BAA8B,gBAAY,gBAAU,gBAClD,AAAW,qCAAE,gEACb,iEpC2aU,yBACD,yBACC,yBACC,sBACf,AAAqB,iBAAoB,KAGzC,mCAG4B,qCAC5B,AAAO,6BAAsC,uCACrB,sBACxB,AAAO,iBAA4B,wBAGvB,sBAEP,GAAc,KAAW,gCAAY,IAAO,qBAAgB,EAAI,QACxD,AAAU,cAAQ,UAC7B,AAAI,gCAA0B,KAC5B,cAAiB,iBACjB,cAA0B,kBAJ0C,AAAE,WAS1E,AAAI,qCAA+B,kCAA6B,wBACzD,AAAQ,IAAO,sBAAyB,EAAI,QACpC,eAAiB,aACb,cAAwB,wBACvC,AAAI,cAAqB,qBAAa,AAAC,cAAiB,wBACtD,cAAyB,6BAAuB,mBAJA,AAAE,WAOjD,AAAQ,IAAO,sBAAuB,EAAI,QAClC,eAAe,aACX,cAAsB,sBACrC,AAAI,cAAmB,mBAAa,AAAC,cAAiB,wBACpD,cAAuB,6BAAuB,mBAJA,AAAE,eAUlC,sBACpB,KAC2B,YAEpB,GAAc,KAAW,gCAAoB,IAAO,qBAAgB,EAAI,QAC5D,AAAU,cAAQ,UACjC,cAAwB,kBAFsD,AAAE,WAIlF,iBACK,AAAQ,IAAO,qBAA2B,EAAI,KACjD,cAAqB,AAAU,cAAmB,iBAAK,MADH,AAAE,WAGjD,oBAGJ,GAAY,KAAS,+CAA6B,IAAO,qBAAc,EAAI,QACnE,cAAM,aACN,GAAO,6BAA2B,kDAC7C,YAAQ,qBACD,OACA,OAIA,OACA,SALuB,AAC1B,cAAwB,iDAAa,iBACrC,IAGmC,AACnC,cAA2B,iDAAsB,iBACjD,GAEO,AAAO,qBAd+D,AAAE,cAmBjE,yBACA,sBACf,AAAQ,IAAO,qBAAsB,EAAI,QAC7B,cAAc,WAC7B,AAAI,cAAY,WACd,AAAO,cAAY,yBACnB,cAAc,EAAK,cAAwB,iCACtC,AAAI,gCAAwC,kDACjD,cAAc,EAAK,cAAuB,kCANG,AAAE,cAS3B,WACxB,EAGE,cAA8B,KACzB,GAAc,KAAW,kCAAoB,IAAO,qBAAgB,EAAI,QAC5D,AAAU,cAAQ,cACT,cAA0B,uBAClD,AAAI,IACG,AAAQ,IAAO,qBAA0B,EAAI,KAChD,cAAqB,cAAkB,uBADY,AAAE,YAIzD,cAAsB,kBARwD,AAAE,WAU3E,iBAAqB,uBAA0B,qBACxD,iBACK,GAAc,KAAW,kCAAoB,IAAO,qBAAgB,EAAI,KAC3E,cAA0B,cAAQ,oBAD4C,AAAE,WAKlF,cAAoB,mBACpB,AAAI,iBAAuB,KAAsB,AAAY,kBAC7D,AAAI,iBAAuB,KAA8B,AAAoB,kBAC7E,AAAI,iBAAuB,KAA8B,AAAoB,kBAE7E,AAAmB,EAAU,mBAAmB,+FAGhD,cAAoB,mBACpB,AAAI,AAAC,iBAAuB,GAAyB,QAAK,KACxD,AAAI,mBACF,cAAiB,eAAuB,GAAa,EACnD,cAAW,EAAQ,UAAe,EAAS,qBAG7C,cAAiB,eAAuB,GAAa,EACnD,cAAW,EAAQ,mBAMzB,cAAoB,mBACpB,AAAI,AAAC,iBAAuB,GAA0B,QAAK,KACzD,AAAe,EACb,EAAQ,IAAc,EAAQ,sCftjBpC,AAAO,EAAO,QeujBR,+FAEF,AAAI,mBACF,cAAiB,eAA4B,GAAa,EACxD,cAAW,EAAQ,UAAe,EAAS,qBAG7C,cAAiB,eAA4B,GAAa,EACxD,cAAW,EAAQ,mBAMzB,cAAoB,mBACpB,AAAI,AAAC,iBAAuB,GAAyB,QAAK,KACxD,AAAI,mBACF,cAAiB,eAAwB,GAAa,EACpD,cAAW,EAAQ,UAAe,EAAS,qBAG7C,cAAiB,eAAwB,GAAa,EACpD,cAAW,EAAQ,mBAMzB,cAAuB,KACvB,iBAGA,AAAI,iBAAuB,MACzB,cAAmB,eAAiC,GAAa,GAAc,EAC7E,cAAkB,8BAA8B,eAAiB,EAAG,aAEtE,cAAyB,eAAiC,oBAM5D,AAAmB,AAAC,uBACF,uBAClB,AAAI,AAAC,QAAgB,cAAe,WAClB,uBAChB,AAAI,AAAC,KAAgB,cAAe,WAClC,cAAiB,eAAsB,GAAa,EAAM,cAAW,SACrE,cACE,cAAkB,eAAsB,cAAW,YAErD,cACE,cACE,cAAkB,eAAsB,MACxC,cgBonCoB,ehBhnC1B,AAAc,cACZ,6BACA,iBACA,iBACA,AAAY,8CACZ,cAAe,8BAEjB,cAA+B,cAAQ,KACvC,AAAI,cAAe,OAAM,cAAgB,MAEvC,AAAI,AAAC,AAAa,uBAAgB,cAAiB,oBACjD,cACE,GACA,8BAAqB,cqBjQP,EACA,MrBmQhB,cAAyB,6BAAoC,qBAMnE,AAAI,IACF,iCAEF,AAAI,cAAe,mBAAiB,KAClC,EAAiB,iCAGZ,cAAP,oCgCnXF,gCACO,EAAa,2CAApB,wVKpU4B,oBAI1B,cAAe,iBACf,cAAsB,sVCMD,0CACI,mBACkB,kCACT,uCAI5B,cAAS,UACf,cAAW,ia7CqRX,AAAa,mBAGb,AAAI,EAAQ,QAAK,GAAc,IAAS,EAAK,OACtB,iBAGvB,AAAI,EAAS,QAAK,AAAC,MAAe,cAAP,IAC3B,AAAI,EAAS,KAAU,aAAP,OACN,AAAyB,AAAC,EAAS,GAAU,GAAG,UAC1D,AAAc,EAAwB,EAAyB,EAAiB,GAAG,KAC5E,aAAP,85BQwVF,AAAI,EAAS,KACX,UAAQ,MACD,OACA,OACA,OACA,QAHG,cAAQ,mBAAW,GACnB,cAAQ,mBAAW,GACnB,cAAQ,mBAAW,GACnB,cAAQ,mBAAW,IAM7B,AAAI,kBAAoB,MACtB,AAAI,eAAgB,UACR,GAAO,eAAgB,uCAEjC,eAAgB,KAAkB,eAAgB,iCAG1C,eAAgB,WAE5B,cAAQ,03CoC9jBQ,sBAChB,AAAI,IAEG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,AAAU,cAAQ,UACjC,AAAI,cAAY,UAAuB,cAAmB,cAAM,kBAFU,AAAE,8CjBTzE,AAAQ,iBAAkB,EAAgB,kBAAjD,kCiBiBgB,sBAChB,AAAI,IAEG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,AAAU,cAAQ,UACjC,AAAO,iBAAiB,qBACxB,AAAI,cAAY,UAAuB,cAAgB,cAAM,kBAHa,AAAE,oDAShE,sBAChB,AAAI,IAEG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,GAAqB,cAAQ,0CAC5C,AAAO,iBAAiB,qBACxB,AAAI,cAAY,UAAuB,cAAoB,cAAM,kBAHS,AAAE,oDAqBpE,sBACd,AAAI,IAEG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,QACxD,AAAU,cAAQ,UAC/B,QAAQ,qBACD,OAWA,QAX+B,GAClB,AAAC,yDACjB,AAAI,IAEG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,AAAU,cAAQ,UACjC,AAAI,cAAY,UAA8B,aAAP,IAFmC,AAAE,YAKhF,GAE+B,GACf,AAAC,yDACjB,AAAI,IAEG,GAAc,KAAW,gCAAgB,IAAO,qBAAgB,EAAI,QACxD,AAAU,cAAQ,UACjC,AAAI,cAAY,UAA8B,aAAP,IAFmC,AAAE,YAKhF,GAEO,AACP,AAAI,cAAU,aAAyB,AAAkB,oBAAgB,aAAP,IAClE,GA3BoE,AAAE,YAgCvE,aAAP,iCA5IE,AAAI,cAAW,QAAwB,AAAC,kCAAqB,KAClD,sBACX,AAAI,AAAC,cAAW,UAAyB,cAAS,uBAChD,cAAgB,cAAM,cAAS,GAAO,cAAS,sEAC/C,EAEF,cAAS,cAAS,kBAClB,0BAAQ,qBACD,OAIA,OAIA,OACA,OAIA,OAIA,OAIA,OAMA,OAQA,OAIA,OACA,QAxCoB,AACvB,AAAI,cAAW,UAAuB,cAAiB,cAAM,sDAC7D,GAEqB,AACrB,AAAI,cAAW,UAAuB,cAAe,cAAM,sDAC3D,GAE0B,GACQ,AAClC,cAA4B,cAAM,oDAClC,GAE+B,AAC/B,cAAyB,cAAM,oDAC/B,GAEmC,AACnC,cAA6B,cAAM,qDACnC,GAEkC,GACX,AAAC,yDACxB,AAAI,AAAC,KAAkB,MACb,QAGe,GACF,6CACF,sBACrB,AAAI,IAAgB,cAAmB,cAAM,qBACxB,sBACrB,AAAI,IAAgB,cAAmB,cAAM,kBAC7C,GAE0B,AAC1B,AAAI,AAAkB,mBAAU,cAAoB,cAAM,kBAC1D,IAG+B,GACxB,AAGA,8DAxEG,sBACd,AAAI,IAEG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,QAC9C,AAAU,cAAM,aACpB,GAAO,cAAY,iDAChC,cAAkB,cAAY,iBAHoC,AAAE,eAMtD,sBAClB,AAAI,IACG,AAAQ,IAAO,qBAAoB,EAAI,QACzB,AAAU,cAAY,UACvC,cAAe,iBAF8B,AAAE,iDAnB9C,GAAc,KAAW,8DAA+B,IAAO,qBAAgB,EAAI,QAC3E,AAAU,cAAQ,UAC7B,AAAI,gCAA0B,KAAsB,cAAe,kBAFsB,AAAE,uRpC0pBtF,YACT,AAAU,IACV,AAAQ,IACH,AAAQ,qBAAY,EAAI,KAC3B,0BAAQ,cAAe,SAChB,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAMA,OAUA,OAUA,QAMA,SApEe,AAClB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,AAAM,EAAI,yBAClD,cAAQ,oBACR,AAAM,AAAE,SACR,GAEuB,AACvB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,AAAM,AAAE,SACR,cAAQ,oBACR,GAEiB,AACjB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,AAAM,AAAE,SACR,cAAQ,oBACR,GAEsB,AACtB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,AAAM,AAAE,SACR,cAAQ,oBACR,GAEyB,AACzB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,AAAM,AAAE,SACR,cAAQ,oBACR,GAEsB,AACtB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,AAAM,AAAE,SACR,cAAQ,oBACR,GAE4B,AAC5B,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,cAAQ,oBACR,AAAM,AAAE,SACR,GAEyB,AACzB,AAAI,EAAS,KACX,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,cAAQ,oBACR,AAAM,AAAE,UAER,AAAE,QAEJ,GAEyB,AACzB,AAAI,EAAS,KACX,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,cAAQ,oBACR,AAAM,AAAE,UAER,AAAE,QAEJ,GAEuB,AACvB,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,cAAQ,oBACR,AAAM,AAAE,SACR,GAEsB,AACtB,AAAI,EAAS,MACX,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACxC,cAAQ,oBACR,AAAM,AAAE,UAER,AAAE,QAEJ,GAEO,AACP,AAAE,OACF,OAIN,AAAI,EAAI,KAAK,cAAQ,cAAc,EAAK,sBACjC,cAAQ,6BAAf,kCqCzmBW,sBACT,AAAI,AAAC,oBACH,cAAQ,oBACR,AAAE,sCAEJ,AAAI,iDACF,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,GAAU,mBAAW,KAAa,+FAE5C,AAAI,iDACF,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,GAAU,mBAAW,KAAa,+FAE5C,iBACA,AAAI,AAAC,oBACH,AAAE,qCACF,cAAQ,wBAEU,sBACf,AAAQ,IAAO,qBAAsB,EAAI,KAC5C,cAAQ,cAAc,qBADyB,AAAE,WAGnD,AAAI,AAAC,oBACH,cAAQ,oBACR,cAAQ,uBACY,qCACf,GAAY,KAAS,gCAAoB,IAAO,qBAAc,EAAI,QACpD,cAAM,UACvB,cAAQ,oBACR,AAAI,AAAa,mBACf,cAAQ,mBAER,cAAQ,oBACR,cAAQ,AAAa,cAAY,qBACjC,cAAQ,qBAEV,cAAQ,oBAVgE,AAAE,WAY5E,cAAQ,qBAEH,cAAQ,6BAAf,4BA3LO,EAAe,cAAS,EAU+B,+BAV9D,4BNkUK,AAAiB,cAAS,gBAAjC,sUFvPuB,0CACI,mBAEK,mBACC,mBACD,mBACC,mBACF,mBACC,mBACI,mBACC,mBACA,mBACC,mBACH,mBACC,mBACR,mBACC,mBACA,mBACF,mBACC,mBACA,mBACA,mBACA,mBACA,mBACD,mBACA,mBACC,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBAEU,kCACC,kCACN,oCAEL,oCACc,qCAIlC,cAAS,UACf,cAAW,kc1BvFJ,4BAAP,m7B0By6BA,AAAI,cAAc,qBAAc,aAAP,OACT,sBAChB,AAAe,cAAc,mBACzB,AAAI,cAAc,kBAClB,oBACJ,cAAc,cAAY,MACnB,aAAP,4BAj5BK,cAAc,8BAArB,gQAqYkB,AAAc,GAA0B,qCACxD,AAAI,OACS,sBACX,AAAI,IAAQ,iBAAe,YACX,cAAK,UACnB,AAAI,iBAAgB,QACJ,0CACd,AAAI,iBAAuB,KAClB,AAAC,+DAAR,IAEF,AAAI,iBAAuB,QACb,AAAC,yDACb,AAAI,iBAAgB,KACX,cAAM,gBAAb,QAMH,aAAP,6BAu6BF,AAAI,EAAQ,MAEV,AAAI,EAAQ,MAAkB,aAAP,IAEvB,AAAI,mBAAuB,iBAAa,UAAW,aAAP,KAG5C,AAAI,EAAQ,MAAkB,aAAP,IAGvB,AAAI,mBAA+B,iBAAa,SAAW,aAAP,KAE/C,AAAC,6BAAR,wCAIqB,sBACrB,AAAkB,EAAQ,MAAc,IAAc,MACtD,AAAI,AAAC,AAAa,6BAAsB,QAAc,aAAP,IAC1C,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,AAAC,AAAa,cAAe,iBAAI,QAAqB,aAAP,IADH,AAAE,WAG7C,aAAP,qCAtQE,AAAI,mBACF,AAAI,iDACF,cAAmB,KACZ,eAAP,IAEA,cAAmB,KACZ,eAAP,MAGJ,AAAI,EAAa,MACf,cAAkB,KACX,eAAP,IAEF,AAAI,EAAa,SAAW,EAAa,OACvC,cAAkB,KACX,eAAP,IAEF,AAAI,EAAa,MACf,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,MACf,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,OACxC,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,OACxC,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,OACxC,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,OACxC,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,MACf,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,MACf,cAAmB,KACZ,eAAP,IAEK,eAAP,kCAKS,cAA4B,sBACrC,AAEE,sBACA,EAAa,UACZ,mBAAoC,iBAAkB,UAEvD,cAAQ,oBACR,cAAuB,AAAG,6CAAe,cAAW,kBAEpD,cAAQ,2DAMD,cAA4B,sBACrC,AAAI,mBACF,cAAuB,GAAG,UAAM,2HAAgB,cAAW,kBAE3D,cAAQ,kBACR,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,AAAI,EAAa,MACf,cAAQ,6DAqEZ,AAAO,AAAc,sCACZ,YACT,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,kDACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,4CACX,cAAQ,uBACM,sBACd,AAAI,IACG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,UAC9C,cAAM,aACV,GAAO,cAAY,kDAChC,AAAI,iBAAe,KAA+B,MACnC,AAAC,yDAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,GACpC,AAAO,iBAAyB,qBAChC,AAAO,cAAI,oBACX,cAAQ,iCACR,cAAQ,oBACR,cAA4B,6BAAe,cAAI,gBAAa,oDAC5D,cAAQ,qBAX0D,AAAE,YAcxE,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACD,cAAQ,8BAAf,+BAjXA,AAAI,sBAEY,GAAO,cAAuB,iEAC5C,AAAI,cAAuB,gEACzB,cAAQ,oBACR,cAAuB,MAClB,AAAI,cAAuB,gEAChC,cAAQ,oBACR,cAAuB,MAClB,AAAI,cAAuB,oDAChB,sBAChB,cAAQ,oBACR,cAA4B,cAAW,iBACvC,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAAsB,MACjB,AAAI,cAAuB,oDAChB,sBAChB,cAAQ,oBACR,cAA4B,cAAW,iBACvC,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAA4B,MACvB,AAAI,cAAuB,gEAChC,cAAQ,oBACR,AAAI,6BAAc,oBAChB,cAAQ,qBACH,AAAI,6BAAc,oBACvB,cAAQ,qBAER,cAAQ,mCAEV,cAAQ,oBACR,cAA2B,MACtB,AAAI,AAAc,mBACvB,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,AAAI,AAAC,6BAAuB,oBAC1B,6BAAuB,kBACvB,AAAsB,mBACtB,cAAmB,KACnB,6BAAuB,cAAoB,iCAC3C,cAAmB,OAGrB,cAAQ,oBACR,cAA0B,WAE5B,cAAQ,kBACR,AAAI,AAAC,cAAqB,wBAExB,cAAQ,qBAEV,cAAQ,qBAGR,AAAI,EAAQ,MACV,cAAQ,AAAG,kDACN,AAAI,mBAA+B,iBAAa,SACrD,AAAI,iBAAa,MACf,cAAQ,GAAsB,6FAE9B,cAAQ,AAAG,mDAGb,cAAQ,gEAgZd,AAAgB,IAChB,AAAa,mBACb,AAAU,IACV,IAAO,EAAM,KACX,AAAI,cAAgB,KAAQ,KAC1B,AAAI,IAAU,AAAW,KACpB,AAAO,cAAI,MAChB,cAAQ,cAAe,EAAW,AAAY,EAAM,yBAEtD,AAAE,YAEJ,AAAI,EAAY,KACd,AAAI,AAAC,KAAU,AAAO,cAAI,MAC1B,cAAQ,cAAe,wEAlNvB,AAAI,mBACF,AAAI,iDACF,cAAmB,KACZ,eAAP,IAEA,cAAmB,KACZ,eAAP,MAGJ,AAAI,EAAa,SAAW,EAAa,UAAW,EAAa,OAC/D,cAAkB,KACX,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,OACxC,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,UAAY,EAAa,UAAgB,EAAa,OAC9F,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,SAAY,EAAa,UAAY,EAAa,UAAgB,EAAa,OAC9F,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,MACf,cAAmB,KACZ,eAAP,IAEF,AAAI,EAAa,MACf,cAAmB,KACZ,eAAP,IAEK,eAAP,kCAKS,cAA2B,sBACpC,AAAI,mBACF,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,cAAsB,gBAAS,cAAW,iBAC1C,cAAQ,qBAER,cAAQ,2DAMD,cAA2B,sBACpC,cAAQ,kBACR,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,cAAsB,cAAW,cAAW,iBAC5C,cAAQ,2DA4CR,AAAO,AAAc,sCACZ,YACT,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,kDACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAAQ,sCACR,cAAQ,uBACM,sBACd,AAAI,IACG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,UAC9C,cAAM,aACV,GAAO,cAAY,kDAChC,AAAI,iBAAe,KAA+B,MACnC,AAAC,yDAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,GACpC,AAAO,iBAAyB,qBAChC,AAAO,cAAI,oBACX,cAA2B,6BAAe,cAAI,gBAAa,iDAAyB,gBAAS,gCAC7F,cAAQ,qBAT0D,AAAE,YAYxE,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACD,cAAQ,8BAAf,+BAlVA,AAAI,sBAEY,GAAO,cAAuB,iEAC5C,AAAI,cAAuB,gEACzB,cAAQ,oBACR,cAAwB,MACnB,AAAI,cAAuB,gEAChC,cAAQ,oBACR,cAAwB,MACnB,AAAI,cAAuB,oDAChB,sBAChB,cAAQ,oBACR,cAA2B,cAAW,iBACtC,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAAQ,qDACR,cAAQ,oBACR,cAAuB,MAClB,AAAI,cAAuB,oDAChB,sBAChB,cAAQ,oBACR,cAA2B,cAAW,iBACtC,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAA6B,MACxB,AAAI,cAAuB,mEAChB,sBAChB,cAAQ,oBACR,AAAI,EAAa,MACf,cAAQ,qBACH,AAAI,EAAa,MACtB,cAAQ,qBAER,cAAQ,mCAEV,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,cAAQ,qDACR,cAAQ,oBACR,cAA4B,MACvB,AAAI,AAAc,mBACvB,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,AAAI,AAAC,6BAAwB,oBAC3B,6BAAwB,kBACxB,AAAsB,mBACtB,cAAmB,KACnB,6BAAuB,cAAqB,iCAC5C,cAAmB,OAGrB,cAAQ,oBACR,cAA2B,WAE7B,cAAQ,kBACR,AAAI,cAAuB,oDAET,sBAChB,AAAI,mBACF,cAAQ,oBACR,AAAI,EAAa,SAAW,EAAa,OACvC,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,SAAY,EAAa,OAC/C,cAAQ,oBACH,AAAI,EAAa,SAAY,EAAa,OAC/C,cAAQ,oBACH,AAAI,EAAa,SAAY,EAAa,OAC/C,cAAQ,qBACH,AAAI,EAAa,SAAY,EAAa,OAC/C,cAAQ,qBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBAGR,AAAO,gCAIb,cAAQ,oBACR,AAAI,AAAC,cAAQ,SACX,cAAoB,KACpB,cAAQ,sBAIV,cAAQ,kBACR,AAAI,mBAAuB,iBAAa,UACtC,cAAQ,qBACH,AAAI,EAAQ,MAEjB,cAAQ,+DA54BH,yBACO,sBAChB,AAAO,cAAI,oBACX,AAAI,AAAa,mBACf,cAAQ,mBAER,cAAQ,oBACR,cAAQ,AAAa,cAAM,qBAC3B,cAAQ,qBAEV,AAAI,AAAgB,cAAW,QAAgB,AAAC,uBAC9C,cAAQ,oBACR,AAAO,cAAI,iBAAmB,MAC9B,cAAQ,oBACR,cAAQ,iCACR,cAAQ,kDACR,cAAQ,oBACR,AAAO,cAAI,iBAAmB,MAC9B,AAAI,cAAc,qBAChB,cAAQ,kBACR,cAAQ,oBAEV,cAAQ,kBACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,qBAER,cAAQ,uBACa,yBACA,YAChB,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,cAAoB,cAAyB,qBADG,AAAE,WAGpD,cAAQ,cAAoB,mCAC5B,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,iCACR,cAAQ,kDACR,cAAQ,oBACH,AAAQ,IAAO,qBAAuB,EAAI,QAClC,cAAe,UAC1B,AAAI,AAAC,AAAa,cAAM,YACX,cAAyB,UACpC,AAAO,cAAI,oBACX,cAAQ,kBACR,cAAQ,oBACR,cAAuB,cAAM,cAAM,iBACnC,cAAQ,qBARsC,AAAE,cAWzC,YACX,AAAe,cAAoB,mBACnC,AAAI,IACF,cAAU,oBACV,AAAO,cAAM,KACb,cAAU,oBACV,AAAW,cAAM,EAAG,cAmnCuD,KAlnC3E,cAAU,qBAEV,AAAI,cAAc,qBAChB,cAAU,oBACV,cAAU,uBACV,cAAU,oBAEZ,cAAU,kBACV,cAAU,oBACV,cAAU,cAAoB,mCAC9B,cAAU,wBAEL,cAAU,uBACjB,cAAc,KACd,AAAW,cAAM,iBAAkB,cAAM,QAClC,cAAU,uBACjB,AAAO,cAAI,oBACX,AAAI,iBAAwB,MAC1B,cAAQ,oBACR,cAAsB,cAAM,6BAAsB,iBAClD,cAAQ,qBAER,cAAQ,kBACR,cAAQ,qBAEV,AAAO,cAAI,AAAE,2DACb,cAAQ,qBAEV,cAAQ,4DApIC,yBACE,sBACX,AAAO,cAAI,oBACX,AAAI,AAAa,mBACf,cAAQ,mBAER,cAAQ,oBACR,cAAQ,AAAa,cAAM,qBAC3B,cAAQ,qBAEV,AAAe,cAAoB,mBACnC,AAAI,AAAa,cAAM,QACrB,cAAQ,oBACR,AAAO,cAAI,iBAAmB,MAC9B,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,cAAQ,kDACR,cAAQ,oBACR,AAAO,cAAI,iBAAmB,MAC9B,AAAI,cAAc,qBAChB,cAAQ,oBACR,cAAQ,uBACR,cAAQ,oBAEV,cAAQ,kBACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,qBAER,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,cAAQ,kDACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,qBAEV,cAAQ,+D1B5FR,AAAY,AAAkB,mBAC9B,AAAW,sBACA,EAAa,UACxB,AAAa,IACR,AAAQ,MAAG,EAAI,KAClB,AAAY,AAA0B,EAAQ,EAAW,WACzD,AAAI,AAAE,KAAmB,MACvB,AAAU,cAAK,WAAY,qBAHL,AAAE,WAM5B,cAAc,KACP,aAAP,+B0B80CK,GAAmB,UAET,UAGA,6JALjB,+BAaO,GAAmB,UAEF,UAGA,6JALxB,4BAz8CA,AAAI,cAAc,qBAAiB,eAAP,IACrB,aAAP,oCAiagB,yBACM,wCACN,yBACA,yBACL,sBAET,cAAQ,mBACR,AAAO,cAAI,4CACX,AAAI,AAAC,oBAAU,cAAQ,qBACvB,cAAQ,oBACR,AAAkB,cAAQ,kBAAM,KAIhC,AAAO,cAAI,4CACX,cAAQ,oBACR,AAAqB,mBAChB,GAAY,KAAS,gCAAoB,IAAO,qBAAc,EAAI,UACpD,cAAM,UACvB,AAAe,cAAoB,sBACtB,AAAqB,cAAkB,sBACpD,AAAO,cAAI,oBACX,AAAI,AAAa,mBACf,cAAQ,mBAER,cAAQ,oBACR,cAAQ,AAAa,cAAY,qBACjC,cAAQ,qBAEV,AAAI,AAAC,AAAiB,oBACpB,cAAQ,oBACR,cAAQ,uBACR,cAAQ,oBACR,GAEF,AAAe,mBACf,cAAQ,oBACR,AAAI,cAAc,qBAChB,cAAQ,qBAER,cAAQ,oBACR,cAAQ,wBAEV,cAAQ,oBACR,AAAI,cAAc,qBAChB,cAAQ,qBAEV,cAAQ,oBACR,AAAE,qCACF,AAAsB,IACjB,GAAa,KAAS,gCAAa,IAAO,qBAAe,EAAI,QACrD,cAAO,aACP,GAAO,cAAW,kDAC7B,AAAI,iBAAa,QACJ,6CACA,cAAqB,sBAChC,AAAI,AAAC,AAAgB,6BAAgB,YAAgB,AAAC,AAAa,wBAAS,KAC1E,cAAwB,cAAY,cAAM,kDAAgB,iBAC1D,AAAE,SAEC,AAAI,iBAAa,QACT,0CACb,AAAI,AAAC,AAAa,6BAAa,YAAgB,AAAC,AAAa,qBAC3D,cAAsB,cAAY,cAAM,iBACxC,AAAE,UAd6D,AAAE,WAkBvE,AAAE,qCACF,AAAI,AAAC,KACH,cAAY,KACZ,AAAI,cAAc,qBAChB,cAAQ,qBAER,cAAQ,oBACR,cAAQ,wBAEV,cAAQ,qBAER,AAAO,cAAI,oBACX,cAAQ,sBA/D8D,AAAE,WAkE5E,AAAE,qCACF,AAAwB,iBAAY,KACpC,AAAI,IACF,AAAO,cAAI,oBACX,cAAQ,qBAER,cAAY,EAAiB,UAGhB,yBACL,YACL,GAAY,KAAS,gCAAe,IAAO,qBAAc,EAAI,QAC/C,cAAM,UACvB,AAAI,cAAc,qBAChB,cAAS,qBAET,AAAe,AAAK,cAAa,mBACjC,AAAI,cAAc,qBAGhB,cAAS,oBACT,cAAS,oBACT,cAAS,oBACT,cAAS,qBAEX,cAAS,oBACT,cAAS,uBACT,cAAS,oBACT,AAAI,AAAa,mBACf,cAAS,mBACT,cAAS,mBAET,cAAS,oBACT,cAAS,AAAa,cAAY,qBAClC,cAAS,qBAEX,cAAS,qBAzBwD,AAAE,WA4BvE,cAAG,EAAa,cAAS,iCAEzB,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAI,IACF,cAAQ,qBAER,cAAQ,qBAEV,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,4CACX,cAAQ,oBACR,AAAiB,mBAIjB,iBACA,AAAE,qCACF,AAAwB,iBAAY,KACpC,AAAI,IACF,AAAO,cAAI,oBACX,cAAQ,qBAER,AACE,sBAAwB,uBACxB,uBAAwB,uBACxB,uBAAuB,uBACvB,uBAA4B,uBAC5B,oBAEA,cAAY,EAAiB,OAE7B,cAAY,EAAiB,WAKd,sBACnB,AAAI,mBACG,AAAQ,IAAO,qBAAqB,EAAI,KAC3C,cAAQ,cAAa,qBADyB,AAAE,YAMpD,AAAI,sBACmB,sBACrB,AAAmB,cAAwB,mBAAY,oBACvD,cAAQ,GAE+E,EAAC,oGAI1F,AAAI,mBACF,AAAoB,kCACpB,cAAQ,GAEwC,mGAMlD,AAAI,sBACmB,uBACrB,AAAmB,cAAwB,mBAAY,oBACvD,AAAgB,KAChB,cAAQ,GAGmD,EAAC,iBAKvC,gBAAkF,yKAKzG,AAAI,mBACF,AAAe,kCACf,cAAQ,GAI+B,mGAOzC,AAAI,mBACF,AAAsB,6BAAyC,qBAC/D,AAAmB,kCACnB,cAAmB,KACnB,cAAQ,GAGyB,gBACS,sIAO5C,AAAI,mBACF,AAAoB,qCACU,uBAC9B,AAAgB,iBAA2C,KAC3D,AAAmB,cAAiC,qBACpD,AAAsB,cAAiC,qBACvD,AAAuB,cAAiC,qBACxD,AAAmB,EAAmB,KACtC,cAAmB,KACnB,cAAQ,GAIgD,gBACjB,gBACrB,gBACY,gBACA,gBACA,kRAQhC,AAAI,sBAC4B,uBAC9B,AAAsB,cAAiC,qBACvD,AAAuB,cAAiC,qBACxD,cAAmB,KACnB,cAAQ,GAIa,gBACY,sIAKnC,AAAI,mBACF,AAAoB,qCACU,uBAC9B,AAAW,mBACX,AAAmB,cAAiC,qBACpD,AAAsB,cAAiC,qBACvD,AAAuB,cAAiC,qBACxD,cAAmB,KACnB,cAAQ,GAIgD,gBAC/B,gBACP,gBACY,gBACA,+OAOhC,AAAI,sBACmB,uBACrB,AAAmB,cAAwB,mBAAY,oBACvD,cAAmB,KACnB,cAAQ,GAGsB,EAAC,oGAOjC,AAAI,mBACF,cAAQ,qBAeV,AAAI,sBAA2B,oBAC7B,cAAQ,qBAEV,AAAI,mBACF,cAAmB,KACnB,cAAoB,KACpB,cAAQ,qBASV,AAAI,mBACF,cAAQ,qBAOV,AAAI,sBAAoB,oBACtB,cAAQ,qBAGV,AAAI,mBACF,cAAQ,qBAUV,AAAI,mBACF,cAAQ,qBAUV,AAAI,mBACF,cAAQ,qBAKV,AACE,sBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,oBAEA,cAAQ,qBAEV,AAAI,mBAAiB,cAAQ,AAAkB,eAAM,oCACrD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAiB,cAAQ,AAAkB,eAAM,oCACrD,AAAI,mBAAiB,cAAQ,AAAkB,eAAM,oCACrD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,oCACvD,AAAI,mBAAkB,cAAQ,AAAkB,eAAO,uCAErC,uBAClB,AAAI,IACF,cAAQ,GAAa,8FAGvB,AAAI,IACF,cAAQ,qBAER,cAAQ,qBAEV,AAAE,qCACF,AAAO,iBAAoB,qBAE3B,AAAI,mBACF,cAAQ,oBACR,AAAI,iDACF,cAAQ,qBAEV,AAAI,iDACF,cAAQ,qBAEL,AAAQ,IAAO,qBAAgB,EAAI,KACtC,AAAI,EAAI,KAAG,cAAQ,qBACnB,cAAQ,cAAQ,qBAFyB,AAAE,WAI7C,cAAQ,oBAOR,AAAwB,OACP,aACZ,GAAY,KAAS,kCAAe,IAAO,qBAAc,EAAI,QAC/C,cAAM,WACvB,AAAI,cAAc,qBAChB,AAAO,cAAI,KACX,cAAQ,qBAER,AAAe,cAAoB,mBACnC,AAAO,cAAI,KACX,AAAI,AAAa,mBACf,cAAQ,mBAER,cAAQ,oBACR,cAAQ,AAAa,cAAY,qBACjC,cAAQ,qBAEV,cAAQ,oBACR,cAAQ,uBACR,cAAQ,oBACR,cAAgB,oBAChB,cAAgB,uBAChB,cAAgB,oBAChB,cAAgB,AAAa,AAAe,6BAAa,qBACzD,cAAgB,oBAChB,AAAoB,KAvB6C,AAAE,WA0BvE,cAAG,EAAK,cAAgB,iCACxB,cAAQ,GACA,AAAa,6BAAsB,gGAE3C,AAAI,IACF,cAAQ,sBAQL,cAAQ,8BAAf,4BA/3BO,EAAc,cAAS,EA+CgC,+BA/C9D,4BEgQK,AAAgB,cAAS,gBAAhC,4BAKO,4BAAP,4BhB45ES,AAAiC,oBAAa,cAArD,4BgBv5EK,4BAAP,qChBkrEE,AAAe,sBACH,EAAqB,UAC5B,AAAQ,MAAG,EAAI,KAClB,cAAM,EAAK,AAAY,cAAO,uBADF,AAAE,WAGhC,AAAW,AAAc,mBACzB,AAAI,IACF,AAAoC,EAAM,iBAAU,EAAM,MAE1D,AAAkC,iBAAU,EAAM,MAEpD,AAAe,IACV,AAAQ,EAAW,OAAG,EAAK,KAAQ,AAAe,cAAM,OAA1B,AAAE,sDAUrC,AAAI,EAAiB,QAAK,EAAe,MAAG,AAAgB,KAE5D,cAAsB,KACtB,cAAoB,KACpB,cAAkB,KAClB,cAAyB,KACzB,cAAiB,KACjB,iBAGA,AAAI,EAAiB,KAAK,EAAe,SACvC,cAA4B,KAC5B,cAA8B,MAC9B,cAA+B,MAC/B,cAAwC,EAAiB,OAEzD,cACE,EAAiB,QAAK,EAAe,MACjC,GACA,MAEN,cAA8B,MAC9B,cAA+B,MAC/B,cAAwC,MAK1C,AAAI,EAAgB,QAAK,EAAc,SACxB,YAIb,cAAY,oBACZ,cAAY,oBAGZ,AAAI,EAAiB,KACnB,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAEd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAEd,AAAI,EAAiB,KACnB,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAEd,cAAY,oBACZ,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBACZ,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAEZ,cAAY,qBAEd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBACZ,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,qBAEd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,qBAEd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,AAAI,EAAiB,KACnB,cAAY,qBAKd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,qBAEd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,qBAEd,AAAI,mBACF,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,qBAEZ,cAAY,sBAGhB,cAAY,oBACZ,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,qBAEZ,cAAY,oBACZ,cAAY,qBAEd,AAAI,EAAiB,KAAK,AAAC,iBAAqB,IAAoB,SAClE,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAGd,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAEZ,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,AAAI,EAAiB,QAAK,EAAe,MACvC,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBAEZ,cAAY,oBACZ,AAAI,EAAiB,KAEnB,cAAY,oBACZ,cAAY,oBAEZ,cAAY,oBAGZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBAEZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBAEZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBAEZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,oBACZ,cAAY,qBAGd,cAAY,oBACZ,AAAI,EAAe,KACjB,cAAY,qBAEd,cAAY,oBACZ,cAAY,oBAEZ,cAAe,cAjO6B,wCgBtqEhD,cAAgB,EAAe,EAAa,EAAW,8DAHrC,KACO,sEXzHZ,yBACF,sBACX,AAAU,mBACV,AAAY,mBACZ,AAAU,OACO,cAAc,eAC/B,AAAuB,IACnB,AAAI,wBAA2B,0BAC/B,uBACY,gBAAW,UAE3B,IAAO,EAAQ,KAAK,AAAC,AAAY,cAAgB,EAAQ,gBAAK,YAE9D,IAAO,EAAQ,KAAO,AAAa,cAAgB,cAAS,YAE5D,IAAO,EAAM,KAAO,AAAC,AAAY,cAAgB,eAAO,eACrC,oCACjB,oBAEA,gBAAW,EAAmB,4BAC9B,oBAEA,cAAe,EAAO,iBAAgB,gBAAM,qCAE5C,uBAGF,IAAO,EAAQ,oBACb,AAAI,cAAgB,KAAU,KAC5B,cAAQ,oBACR,EAAS,MAET,cAAQ,oBACR,aAGJ,AAAI,KAAmB,cAAQ,oBAC/B,AAAI,iBAAe,oBACjB,cAAQ,qBAER,IAAO,WAAU,oBACf,AAAS,cAAgB,OACzB,AAAI,EAAM,KACR,cAAQ,qBACH,AAAI,AAAY,OACrB,cAAQ,EAAS,iBAAc,MAAI,KAAM,oBACzC,GAEA,cAAQ,2BAId,AAAI,KAAmB,cAAQ,oBAC/B,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,cAAQ,iCACD,cAAQ,6BAAf,+BApHA,AAAuB,AAAiB,UAGrB,kBACnB,AAAI,KAAmB,cAAQ,AAA0B,qCACzD,cAAQ,AAA2B,oCACnC,AAAI,KAAmB,cAAQ,oBAC/B,cAAQ,iBAAe,MAAO,KAAQ,qBACtC,cAAQ,sCACR,cAAQ,oBACR,cAAQ,oCAGI,sBACZ,AAAI,OACW,yBACM,sBACnB,AAAc,IACd,AAAI,IAEF,AAAU,AAAI,cAAc,sBAAc,6BAA2B,+BAIvE,AAAI,IACF,cAAQ,oBACR,cAAQ,AAAwB,cAAO,sBAEvC,cAAQ,oBACR,cAAQ,kCAEV,cAAQ,oBACR,cAAQ,cAAc,yCACtB,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBAER,AAAI,OACkB,sBACpB,AAAI,IACF,cAAQ,oBACR,cAAQ,AAAwB,cAAc,sBAE9C,cAAQ,oBACR,cAAQ,kCAEV,cAAQ,oBACR,cAAQ,cAAqB,yCAC7B,cAAQ,oBACR,cAAQ,sCACR,cAAQ,sBAGZ,AAAiB,MACV,cAAQ,6BAAf,mDAzDkB,KACE,4ETsgGJ,cAAe,sBAC7B,AAAI,IAAgB,aAAP,IACN,6BAAoB,4BAA3B,wCA4Ia,cAAe,sBAC5B,AAAI,IAAe,aAAP,IACL,cAAa,cAAM,gBAA1B,wCAgCa,cAAe,sBAC5B,AAAI,IAAe,aAAP,IACL,cAAa,cAAM,gBAA1B,qCuBnuGF,AACE,AAAyB,IAAS,KAClC,cAAwB,AAAuB,mBAAU,wBAEzD,AAAO,AAA4B,IAAS,qBACrC,AAA0B,EAAM,eAAvC,IAEK,aAAP,4BD8mCE,AAAsB,mBACtB,AAAI,AAAC,KAAiC,iBAC/B,aAAP,sc9B7tC6B,EAAgB,EAAmB,mCACvC,EAAmB,oBAGf,EAAgB,EAAmB,wCACnC,mBACF,mBACD,8vD+B0J1B,AAAI,6BAAkB,UACV,AAAoB,6BAAkB,UAChD,AAAI,cAAY,OACP,AAAgB,cAAY,gBAAnC,QAGQ,UACV,6BAAkB,EAAM,mBAE1B,AAAgB,mBAChB,cAAY,EAAY,MACjB,aAAP,kCA6Ga,sBACb,AAAe,IACV,AAAQ,IAAO,qBAAiB,EAAI,OACvC,AAAc,cAAS,OACvB,AAAY,AAAa,cAAQ,OACjC,AAAI,AAAC,KAAO,GACZ,AAAI,AAAC,AAAU,cAAQ,QACrB,cAAS,EAAK,KACd,GAEF,AAAsB,mBACtB,AAAgB,AAA8B,OAC9C,AAAgB,cAAc,EAAiB,EAAY,kBAAsB,QACjF,AAAW,cAAmB,EAAiB,yBACnC,YAEZ,cACE,cAAiB,EAAM,EAAO,SAGhC,cACE,cAAa,iBACX,cAAkB,eAA4B,oBAC9C,cAAiB,EAAM,oBACvB,iBAAc,EAAY,kCAI9B,cACE,cAAiB,EAAM,wBAEzB,cAAS,EAAK,cAAa,EAAM,cAAO,uBACxC,AAAE,QA9BwC,AAAE,WAgCvC,aAAP,qCAUA,AAAkB,AAA4B,SAC/B,EAAyB,UACnC,AAAe,MAAG,EAAI,KACzB,cAAS,EAAK,AAA0B,EAAM,OADR,AAAE,WAG1C,AAAe,cAAwB,mBAClC,AAAQ,IAAO,qBAAiB,EAAI,KACvC,AAA0B,EAAM,EAAG,cAAS,QADF,AAAE,WAG9C,AAAI,IAEF,+BAAuB,OAEzB,6BAAwB,wCAKxB,AAAe,kCACf,AAAI,IAAU,+BAAuB,kDAKrC,AAAkB,AAAoC,UACvC,EAAyB,UACnC,AAAe,MAAG,EAAI,KACzB,cAAS,EAAK,AAAkC,EAAc,QADxB,AAAE,WAG1C,AAAe,cAAwB,mBAClC,AAAQ,IAAO,qBAAiB,EAAI,KACvC,AAAkC,EAAc,EAAG,cAAS,QADlB,AAAE,WAG9C,AAAI,IAEF,+BAAuB,OAEzB,6BAAwB,wCAKxB,AAAe,kCACf,AAAI,IAAU,+BAAuB,yCDpIrC,AAAwB,mBACxB,AAAI,AAAC,KAAmC,iBACjC,aAAP,+BAMY,sBACZ,AAAa,mBACN,IAAS,cAAM,EAAS,OAAK,cAApC,6BAsiCA,AAAa,mBACb,AAAW,mBACX,AAAW,AAAyB,OACpC,AAAI,EAAQ,KACV,AAAyB,EAAM,MAE/B,AAAa,AAAO,0CACpB,AAAe,AAAa,EAAQ,EAAQ,OAC5C,AAAI,AAAC,oBACL,AAA4B,8CCh7BjB,sBACb,AAAY,AAA0B,MACtC,AAAY,AAAa,cAAQ,OACjC,AAAI,AAAC,cAAO,EACZ,AAAI,AAAC,AAAU,cAAQ,QACrB,AAA0B,EAAU,cACpC,EAEF,AAAY,AAA0B,MACtC,AAAgB,cAAc,iBAAsB,UACxC,YAEZ,cACE,cAAa,iBACX,cAAkB,eAA4B,oBAC9C,cAAiB,EAAO,EAAO,YAC/B,iBAAc,EAAY,kCAG9B,AAAI,AAAuB,MAEzB,cACE,cAAiB,EAAO,wBAE1B,cAAoB,cAAe,cAAO,wBAE1C,cAAoB,cAAe,cAAO,wDC7ZzB,gCAA6B,AAAyB,wDAClE,cAAwB,gB3CyJO,gB2CzJtC,kCAKa,sBACb,AAAU,AAAqB,OAC/B,AAAa,AAAwB,OACrC,AAAY,AAAuB,OAEnC,AAAqB,EACnB,cAAY,gBAAY,qCACtB,SACA,cAAW,YACX,cAAW,YACX,cAAW,AAAI,qCACd,iBpBgxDY,QoB9wDjB,cAAkB,0CDslBlB,AAAO,sCACM,sBACb,AAAY,AAAwB,UACxB,YACZ,AAAI,IACF,AAAiB,AAA2B,MAC5C,AAAI,EAAc,eAAqB,EACvC,AAAW,6BAA8B,iBAAsB,OAE/D,cACE,cAAiB,EAAM,EAAO,SAGhC,cACE,6BAAgC,AAAC,wBAGnC,AAAwB,EAAK,cAAiB,EAAM,SAGpD,cACE,6BAAgC,AAAC,yBAIrC,cACE,MAEF,cAAoB,cAAe,cAAO,iDL9gBjC,yBACE,sBACX,6BAAkB,kBAClB,AAAI,AAAC,AAAa,cAAM,SACtB,AAAO,cAAI,oBACX,cAAQ,kBACR,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,cAAQ,mCACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAuB,gBAAa,6BAAO,+BAAU,cAAM,iBAC3D,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,AAAI,AAAC,cAAW,QACd,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,cAAsB,gBAAS,cAAM,iBACrC,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,qBAEV,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,qBAEV,cAAoB,cAAM,oD1BtH1B,AAAY,AACV,AAAkB,iBAAgB,AAAQ,EAAW,kBAAoB,SAE3E,IAAO,IACL,AAAiB,OACjB,AAAI,AAAE,EAAa,MAAU,KAAa,SAAY,aAAP,IAC/C,AAAQ,AAA0B,EAAa,AAAC,aAE3C,aAAP,oCAIO,cAAU,cAAK,AAAQ,oBAAS,cAAvC,oCAKA,AAAY,cAAU,cAAK,AAAQ,sBACnC,AAAI,AAAC,KAAuB,iBACrB,gBAAP,+BkC+HA,AAAI,mBAAc,AAAC,uCAAgD,aAAP,OAC9C,sBACd,AAAI,IACG,GAAc,KAAW,gCAAc,IAAO,qBAAgB,EAAI,QACxD,cAAQ,UACrB,AAAI,cAAa,GAAsB,SAA+B,aAAP,IAC/D,AAAI,cAAU,SAEZ,AAAI,gCAA4B,qBAA4B,aAAP,KALiB,AAAE,YASvE,aAAP,+BlClFA,AAAyB,AAAM,EAAiB,QAC/B,EAAgB,EAAqB,WACtD,AAAyB,EAAqB,GAAgB,QAC7C,EAAgB,EAAqB,gBAGtD,AAAa,AAAkB,mBAC/B,AAAa,EAAS,AAAO,iBAAqB,WAClD,AAAa,IACb,IAAO,EAAU,KACf,AAAe,IACf,AAAI,AAAE,KAAsB,MAC1B,AAAe,OACG,UAClB,EAAe,iBACf,EAAiB,oBACjB,AAAqB,AAAQ,iBAAe,KAC5C,AAAuB,EAAgC,EAAwB,MAC/E,EAAsB,AAAY,QAClC,AAAa,EAAkB,KAC/B,EAAU,WAEZ,EAAU,eAGZ,cAAe,iBACf,cAAmB,KACnB,cAAe,iBACf,cAAuB,KACvB,cAAqB,+DAjFrB,AAAe,AAAQ,mBACvB,AAAY,cAAU,cAAK,OAC3B,AAAI,IACF,EAAc,iBACV,GAAgB,AACX,EAAyB,EAA0B,MAI5D,AAAI,iBAAsB,oBACxB,cACE,iBAAoB,iBAAuB,GAAgB,MACtD,kBACD,AAAC,iBAAoB,GAAK,WAIpB,sBACd,AAAQ,AAA0B,EAA6B,AAAQ,yCAAwB,WAE/F,EAAY,iBACR,GAAgB,AACX,EAAyB,EAAwB,KAE1D,EAAc,iBACV,GAAgB,AACX,EAAyB,EAA0B,KAE5D,AAAE,qCAEF,AAAoB,AAAkB,iBAAgB,AAAQ,EAAW,kBAAoB,MAC7F,EAAmB,AAAY,QAC/B,AAAa,EAAe,MAEvB,aAAP,4BkCiOA,AAAI,mBACK,cAAQ,iBAAf,IAEK,aAAP,kCAlCS,eACK,sBACd,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,cAAQ,sCACR,cAAQ,oBACR,AAAI,IACG,GAAY,KAAS,gCAAc,IAAO,qBAAc,EAAI,UAC9C,cAAM,aACV,GAAO,cAAY,kDAChC,AAAI,iBAAe,KAA+B,MACnC,AAAC,yDAChB,AAAI,AAAC,QAAY,AAAC,qBAAkB,GACpC,cAAQ,oBACR,cAAQ,kDACR,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,cAAQ,cAAsB,6BAAe,qBAC7C,AAAI,cAA2B,kCAC7B,cAAQ,qBAEV,cAAQ,qBAf0D,AAAE,YAkBxE,cAAQ,oBACD,cAAQ,6BAAf,kCAWS,YACT,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,cAAQ,oBACR,cAAQ,sCACR,cAAQ,uBACiB,OACzB,EACE,cAAQ,oBACR,cAAQ,iBhBxMqB,qBgByM7B,cAAQ,uBACD,sBACA,KACT,cAAQ,oBACD,cAAQ,6BAAf,+BA/IA,AAAI,sBACS,eACG,GAAO,cAAuB,iEAC5C,AAAI,cAAuB,gEACzB,cAAQ,oBACH,AAAI,cAAuB,gEAChC,cAAQ,oBACH,AAAI,cAAuB,oDACd,sBAClB,cAAQ,oBACR,cAAQ,cAAsB,cAAW,qBACzC,cAAQ,qBACH,AAAI,cAAuB,oDACd,sBAClB,cAAQ,oBACR,cAAQ,cAAsB,cAAW,qBACzC,cAAQ,qBACH,AAAI,cAAuB,mEACd,sBAClB,AAAI,EAAa,MACf,cAAQ,oBACH,AAAI,EAAa,MACtB,AAAI,cAAuB,iDACzB,cAAQ,oBAER,cAAQ,qBAEL,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,qBACH,AAAI,EAAa,MACtB,cAAQ,qBACH,AAAI,EAAa,MACtB,cAAQ,oBACH,AAAI,EAAa,MACtB,cAAQ,oBAER,cAAQ,kCAGY,sBAEtB,AAAI,cAAoB,sBACX,GAAO,cAAoB,kDACtC,cAAQ,kBACR,AAAI,cAAmB,mBACrB,cAAQ,EAAQ,MAAc,KAAY,uBAG5C,AAAc,cAAmB,sBACtB,AAAG,IAAU,KAAa,iBAAgB,0CACrD,cAAQ,kBACR,cAAoB,cAAO,kBAC3B,AAAI,IACF,cAAQ,EAAQ,MAAc,KAAY,qBAC1C,6BAA0B,cAAoB,cAAO,sBAErD,6BAA0B,cAAuB,wCAIvD,AAAI,cAAQ,QACV,cAAQ,qBAEH,cAAQ,6BAAf,IAEA,AAAI,EAAQ,MACH,cAAP,IAEF,AAAI,EAAQ,MACH,cAAP,IAEF,AAAI,mBACF,AAAI,mBACK,eAAP,IAEK,cAAP,KAGG,eAAP,kCAtRS,yBACE,yBACE,cAAsB,cAAM,WACzC,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAI,mBAAU,cAAQ,qBACtB,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,mCACR,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,kBACR,AAAI,AAAC,cAAW,QACd,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,kBACR,cAAQ,qBAER,cAAQ,qBAEV,AAAO,cAAI,AAAE,2DACb,cAAQ,8DR0HC,sBACT,6BAAkB,kBAClB,AAAO,cAAI,oBACX,cAAQ,kBACR,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,iCACR,cAAQ,uBACM,sBACd,AAAI,IACG,GAAc,KAAW,ON3MlC,AAAO,yBM2MyC,IAAO,qBAAgB,EAAI,UACzD,cAAQ,UACpB,AAAI,iBAAc,KAAuB,GACzC,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,iCACR,AAAI,cAAS,UACX,cAAQ,oBACR,cAAQ,EAAQ,AAAC,sD7C9LzB,AAAO,MqCwC0B,sBQwJzB,cAAQ,oBACR,cAAQ,AAAa,cAAO,8BAAM,4CAAY,qBAC9C,cAAQ,qBAEV,cAAQ,oBACR,cAAQ,AAAa,6BAAY,qBACjC,cAAQ,qBAhBgE,AAAE,YAmB9E,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAoB,cAAM,yDQxJjB,sBACT,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,iCACR,cAAQ,oBACR,AAAO,cAAI,4CACX,cAAQ,oBACR,AAAI,mBAAU,cAAQ,qBACtB,cAAQ,oBACR,cAAQ,kBACR,cAAQ,uBACM,sBACd,AAAI,IAEG,GAAY,KAAS,Od9F9B,AAAO,yBc8FqC,IAAO,qBAAc,EAAI,UAC9C,AAAU,cAAM,aACpB,GAAO,cAAY,kDAChC,AAAI,iBAAe,KAAuB,GAC1C,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,kBACR,cAAQ,qBAR0D,AAAE,YAWxE,AAAO,cAAI,AAAE,2DACb,cAAQ,yDR0QR,AAAI,cAAW,iBAAsB,KAC5B,yBACO,sBAChB,6BAAkB,kBAClB,AAAI,AAAC,AAAgB,cAAW,SAC9B,AAAO,cAAI,oBACX,cAAQ,kBACR,cAAQ,uBACa,sBACrB,AAAoB,IACf,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,cAAe,sBAAwB,QAC3C,AAAI,EAAI,KAAG,cAAQ,qBACnB,cAAQ,cAAyB,qBAHe,AAAE,WAKpD,cAAQ,oBACR,AAAO,cAAI,AAAE,2DACb,cAAQ,oBACR,cAAQ,iCACR,cAAQ,cfmvBc,qBelvBtB,cAAQ,uBACO,YACV,AAAQ,IAAO,qBAAuB,EAAI,QAClC,cAAe,UAC1B,AAAI,AAAC,AAAa,cAAM,YACX,cAAyB,UACpC,AAAO,cAAI,oBACX,cAAQ,kBACR,cAAQ,oBACR,AAAyB,qBAA4B,AAAE,OAAgB,SACvE,AAAI,IACF,cAAmB,KACnB,cAAoB,KACpB,cAAQ,oBACR,cAAc,mBAEhB,cAAsB,cAAM,cAAM,iBAClC,AAAI,IACF,cAAQ,qBAEV,cAAQ,qBAlBsC,AAAE,WAqBpD,AAAI,mBACF,AAAO,cAAI,4CACX,cAAQ,qBAEV,AAAI,iBAA+B,oBACjC,AAAO,cAAI,oBACX,cAAQ,wBAEG,EV7WS,UU8WtB,cAAU,oBACV,cAAU,kBACV,cAAU,oBACL,AAAQ,IAAO,qBAAuB,EAAI,KAC7C,AAAI,EAAI,KAAG,cAAU,qBACrB,cAAU,cAAyB,qBAFa,AAAE,WAIpD,cAAU,oBACV,AAAI,iBAAwB,MAC1B,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAuB,cAAU,8BAAK,6BAAsB,kBAE5D,AAAO,cAAI,oBACX,cAAQ,cAAU,mCAEpB,cAAQ,oBACR,AAAI,mBACF,AAAO,cAAI,iBAAmB,MAC9B,cAAQ,oBACH,AAAQ,IAAO,qBAAiB,EAAI,KACvC,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,cAAS,qBACjB,cAAQ,oBAJkC,AAAE,WAM9C,AAAO,cAAI,AAAE,2DACb,cAAQ,qBAEV,AAAO,cAAI,AAAE,2DACb,cAAQ,qBAEV,cAAoB,cAAM,yDQ1VjB,yBACO,sBAChB,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,iCACR,cAAQ,uBACa,sBACrB,AAAoB,mBACf,AAAQ,MAAG,EAAI,KAClB,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,cAAyB,qBACjC,cAAQ,oBACR,cAAQ,cAAe,sCACvB,cAAQ,oBANyB,AAAE,cAQpB,sBACjB,AAAI,EAAc,MAChB,AAAO,cAAI,oBACX,cAAQ,oBACR,cAAQ,cvB4bc,qBuB3btB,cAAQ,qBAEV,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAO,cAAI,oBACX,cAAQ,oBACR,AAAI,mBAAU,cAAQ,qBACtB,cAAQ,oBACR,cAAQ,kBACR,cAAQ,oBACR,AAAyB,mBACpB,AAAQ,MAAG,EAAI,KAClB,AAAI,IAAG,cAAQ,qBACf,cAAQ,cAAyB,qBACjC,AAAI,EAAK,KAAoB,cAAQ,qBACrC,cAAQ,oBACR,cAAQ,cAAsB,cAAe,iBAAI,sBALhB,AAAE,WAOrC,cAAQ,oBACR,cAAQ,cAAsB,cAAY,sBAC1C,cAAQ,8DRuTR,cAAgB,cAAM,u4D1BjOO,AACf,IAAK,AAAQ,EAAK,8mQAfV,4mFSlCtB,AAAQ,AAAkB,iBAAe,KACzC,AAAc,AAAkB,mBAC5B,GAAgB,AAClB,AAAU,IACV,AAAU,EAAM,AAAO,iBAAqB,WAC5C,IAAO,EAAM,KACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACvB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,MAEtB,EAAO,EApKb,AAAO,aAuKL,AAAQ,EAAS,uJ2BtLjB,AAAQ,iBAAW,s2CpB+df,GAAgB,AAClB,AAAU,mBACV,AAAU,EAAO,AAAO,iBAAgB,MACxC,IAAO,EAAM,KACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,UAGX,AAAQ,AAAkB,iBAAc,mXhBpRd,AAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,iEAlB5B,AAAQ,AAAkB,iBAAe,KACzC,AAAc,AAAkB,mBAC5B,GAAkC,AACpC,AAAU,IACV,AAAU,EAAM,AAAO,iBAAqB,WAC5C,IAAO,EAAM,KACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACnB,GAAgB,AAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,KAEtB,AAAI,IAON,EAAO,EAzMb,AAAO,aA4ML,AAAQ,EAAS,uCF9MjB,AAAI,EAAc,SAAyC,mBAC9C,AAA8B,EAAe,UAC1D,AAAI,EAAe,IAGZ,aAAP,uGd2TF,AAAI,EAAQ,QAAK,EAAQ,MACF,iBAEvB,AAAI,AAAC,KAAc,cAAP,IAEZ,AAAW,AAAC,EAAU,GAAO,KAC7B,AAAI,IAAM,AAAQ,EAAC,MAGnB,AAAI,EAAS,KACX,AAAe,AAAe,UACxB,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,EAAgB,EAAyB,KAAM,IAAO,qBACjD,AAAI,EAAS,KAClB,AAAe,AAAC,EAAK,AAAI,IAAU,GAAK,QAClC,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,EAAgB,EAAyB,KAAM,IAAO,sBAEtD,AAAY,IACZ,AAAe,AAAU,GAAO,UAC1B,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,AAAgB,EAAyB,GAAM,GAAO,EAAU,OAElE,AAAI,IAAM,AAAW,EAAwB,MACtC,aAAP,4BOxWA,AAAiB,EAAiB,QAErB,AAAoC,EAAY,EAAqB,UAElF,AAAY,AAAM,EAAmB,OACrC,AAAa,EAAO,KACpB,AAAO,EAAO,EAA2B,KACzC,AAAa,EAAO,KACpB,AAAW,EAAO,KAClB,AAAW,EAAO,KACX,aAAP,0iBFbE,AAAa,EAAY,UACf,AAAyB,EAAK,GAAa,UACrD,AAAI,AAAC,KACH,AAAW,EAAwB,MAGnC,AAAO,EAAa,uBACpB,EAAQ,OACR,AAAS,AAAC,EAAO,IAAU,OAC3B,AAAS,EAAS,GAAK,OACvB,AAAW,EAAwB,EAAK,EAAM,QAEzC,aAAP,qKLgTF,AAAI,EAAQ,QAAK,EAAQ,MACF,iBAEvB,AAAI,AAAC,KAAc,cAAP,IAGZ,AAAI,EAAS,KACX,AAAe,AAAe,UACxB,AAAyB,EAAY,GAAG,UAC9C,EAAgB,IAAwB,IAAO,qBAC1C,AAAI,EAAS,KAClB,AAAe,AAAC,EAAK,AAAI,IAAU,GAAK,QAClC,AAAyB,EAAY,GAAG,UAC9C,EAAgB,IAAwB,IAAO,IA9D7C,EAAoB,IAEjB,AACQ,EAAQ,GAAK,OA6D1B,AAAe,AAAU,GAAO,UAC1B,AAAyB,EAAY,GAAG,UAC9C,AAAgB,EAAwB,GAAO,EAAU,OAEpD,aAAP,+BAgCA,AAAI,EAAQ,QAAK,EAAQ,MACF,iBAEvB,AAAI,AAAC,QAAc,cAAP,IAGZ,AAAI,EAAS,KACX,AAAI,EAAS,OACX,AAAe,KACf,AAAe,AAAe,UACxB,AAAyB,EAAY,GAAG,UAC9C,EAAgB,IAAwB,IAAO,qBAE/C,AAAe,AAAmB,UAC5B,AAAyB,EAAY,GAAG,UAC9C,EAAgB,IAAwB,IAAO,sBAE5C,AAAI,EAAS,KAClB,AAAe,AAAC,EAAK,AAAQ,KAAW,GAAK,QACvC,AAAyB,EAAY,GAAG,UAC9C,EAAgB,IAAwB,IAAO,qBAE/C,AAAe,AAAU,EAAO,UAC1B,AAAyB,EAAY,GAAG,UAC9C,AAAgB,EAAwB,EAAO,EAAU,OAEpD,aAAP,+BAIA,AAAI,EAAQ,QAAK,EAAQ,MACF,iBAEvB,AAAI,AAAC,QAAc,cAAP,IAEZ,AAAW,AAAI,EAAU,IAAO,KAChC,AAAI,IAAM,AAAQ,EAAC,MAGnB,AAAI,EAAS,KACX,AAAI,EAAc,OAChB,AAAe,KACf,AAAe,AAAe,UACxB,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,EAAgB,EAAyB,KAAM,IAAO,IA1JtD,EAAoB,IAEjB,AACU,EAAQ,EAAK,OAyJ1B,AAAe,AAAmB,UAC5B,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,EAAgB,EAAyB,KAAM,IAAO,IA1ItD,EAAoB,IAEjB,AACU,EAAQ,EAAK,QAyIvB,AAAI,EAAS,KAClB,AAAe,AAAC,EAAK,AAAQ,KAAW,GAAK,QACvC,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,EAAgB,EAAyB,KAAM,IAAO,IArIpD,EAAoB,IAEjB,AACQ,EAAQ,EAAK,OAoI1B,AAAe,AAAU,EAAO,UAC1B,AAAyB,AAAC,EAAY,GAAK,GAAM,UACvD,AAAgB,EAAyB,GAAM,EAAO,EAAU,OAElE,AAAI,IAAM,AAAW,EAAwB,MACtC,aAAP","sourceRoot":"./assemblyscript.debug","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","/**\n * @fileoverview 64-bit integer glue code for WebAssembly.\n * @license Apache-2.0\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@global const i64_zero: i64 = 0;\n\n// @ts-ignore: decorator\n@global const i64_one: i64 = 1;\n\n// @ts-ignore: decorator\n@global const i64_neg_one: i64 = -1;\n\n// @ts-ignore: decorator\n@global const i64_minimum: i64 = i64.MIN_VALUE;\n\n// @ts-ignore: decorator\n@global const i64_maximum: i64 = i64.MAX_VALUE;\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is<T>(value: T): bool {\n  return isInteger<T>() && sizeof<T>() == 8;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_new(lo: i32, hi: i32 = 0): i64 {\n  return <i64><u32>lo | (<i64>hi << 32);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_low(value: i64): i32 {\n  return <i32>value;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_not(value: i64): i64 {\n  return ~value;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_neg(value: i64): i64 {\n  return -value;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_clz(value: i64): i32 {\n  return <i32>clz(value);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_ctz(value: i64): i32 {\n  return <i32>ctz(value);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_high(value: i64): i32 {\n  return <i32>(value >>> 32);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_add(left: i64, right: i64): i64 {\n  return left + right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_sub(left: i64, right: i64): i64 {\n  return left - right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_mul(left: i64, right: i64): i64 {\n  return left * right;\n}\n\n// @ts-ignore: decorator\n@global\nfunction i64_pow(left: i64, right: i64): i64 {\n  if (right <= 0) {\n    if (left == -1) return select<i64>(-1, 1, right & 1);\n    return i64(right == 0) | i64(left == 1);\n  }\n  if (right == 1) return left;\n  if (right == 2) return left * left;\n  let result: i64 = 1;\n  while (right) {\n    if (right & 1) result *= left;\n    right >>>= 1;\n    left *= left;\n  }\n  return result;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_div(left: i64, right: i64): i64 {\n  return left / right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_div_u(left: i64, right: i64): i64 {\n  return <u64>left / <u64>right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_rem(left: i64, right: i64): i64 {\n  return left % right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_rem_u(left: i64, right: i64): i64 {\n  return <u64>left % <u64>right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_and(left: i64, right: i64): i64 {\n  return left & right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_or(left: i64, right: i64): i64 {\n  return left | right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_xor(left: i64, right: i64): i64 {\n  return left ^ right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_shl(left: i64, right: i64): i64 {\n  return left << right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_shr(left: i64, right: i64): i64 {\n  return left >> right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_shr_u(left: i64, right: i64): i64 {\n  return left >>> right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_eq(left: i64, right: i64): bool {\n  return left == right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_ne(left: i64, right: i64): bool {\n  return left != right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_ge(left: i64, right: i64): bool {\n  return left >= right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_ge_u(left: i64, right: i64): bool {\n  return <u64>left >= <u64>right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_gt(left: i64, right: i64): bool {\n  return left > right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_gt_u(left: i64, right: i64): bool {\n  return <u64>left > <u64>right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_le(left: i64, right: i64): bool {\n  return left <= right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_le_u(left: i64, right: i64): bool {\n  return <u64>left <= <u64>right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_lt(left: i64, right: i64): bool {\n  return left < right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_lt_u(left: i64, right: i64): bool {\n  return <u64>left < <u64>right;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_align(value: i64, alignment: i64): i64 {\n  let mask: i64 = alignment - 1;\n  assert(alignment && (alignment & mask) == 0);\n  return (value + mask) & ~mask;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_signbit(value: i64): bool {\n  return <bool>(value >>> 63);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_i8(value: i64): bool {\n  return value >= i8.MIN_VALUE && value <= i8.MAX_VALUE;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_i16(value: i64): bool {\n  return value >= i16.MIN_VALUE && value <= i16.MAX_VALUE;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_i32(value: i64): bool {\n  return value >= i32.MIN_VALUE && value <= i32.MAX_VALUE;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_u8(value: i64): bool {\n  return <u64>value <= <u64>u8.MAX_VALUE;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_u16(value: i64): bool {\n  return <u64>value <= <u64>u16.MAX_VALUE;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_u32(value: i64): bool {\n  return <u64>value <= <u64>u32.MAX_VALUE;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_bool(value: i64): bool {\n  return (value & ~1) == 0;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_f32(value: i64): bool {\n  return value >= <i64>f32.MIN_SAFE_INTEGER && value <= <i64>f32.MAX_SAFE_INTEGER;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_is_f64(value: i64): bool {\n  return value >= <i64>f64.MIN_SAFE_INTEGER && value <= <i64>f64.MAX_SAFE_INTEGER;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_to_f32(value: i64): f32 {\n  return <f32>value;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_to_f64(value: i64): f64 {\n  return <f64>value;\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_to_string(value: i64, unsigned: bool = false): string {\n  return unsigned ? u64(value).toString() : value.toString();\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_clone(value: i64): i64 {\n  return value;\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore\n@builtin\nexport declare function bswap<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport const enum CommonFlags {\n  /** No flags set. */\n  None = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  Import = 1 << 0,\n  /** Has an `export` modifier. */\n  Export = 1 << 1,\n  /** Has a `declare` modifier. */\n  Declare = 1 << 2,\n  /** Has a `const` modifier. */\n  Const = 1 << 3,\n  /** Has a `let` modifier. */\n  Let = 1 << 4,\n  /** Has a `static` modifier. */\n  Static = 1 << 5,\n  /** Has a `readonly` modifier. */\n  Readonly = 1 << 6,\n  /** Has an `abstract` modifier. */\n  Abstract = 1 << 7,\n  /** Has a `public` modifier. */\n  Public = 1 << 8,\n  /** Has a `private` modifier. */\n  Private = 1 << 9,\n  /** Has a `protected` modifier. */\n  Protected = 1 << 10,\n  /** Has a `get` modifier. */\n  Get = 1 << 11,\n  /** Has a `set` modifier. */\n  Set = 1 << 12,\n  /** Has a `override` modifier.  */\n  Override = 1 << 13,\n\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DefinitelyAssigned = 1 << 14,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  Ambient = 1 << 15,\n  /** Is generic. */\n  Generic = 1 << 16,\n  /** Is part of a generic context. */\n  GenericContext = 1 << 17,\n  /** Is an instance member. */\n  Instance = 1 << 18,\n  /** Is a constructor. */\n  Constructor = 1 << 19,\n  /** Is a module export. */\n  ModuleExport = 1 << 20,\n  /** Is a module import. */\n  ModuleImport = 1 << 21,\n\n  // Compilation states\n\n  /** Is resolved. */\n  Resolved = 1 << 22,\n  /** Is compiled. */\n  Compiled = 1 << 23,\n  /** Did error. */\n  Errored = 1 << 24,\n  /** Has a constant value and is therefore inlined. */\n  Inlined = 1 << 25,\n  /** Is scoped. */\n  Scoped = 1 << 26,\n  /** Is a stub. */\n  Stub = 1 << 27,\n  /** Is an overridden method. */\n  Overridden = 1 << 28,\n  /** Is (part of) a closure. */\n  Closure = 1 << 29,\n\n  // Other\n\n  /** Is quoted. */\n  Quoted = 1 << 30\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const Empty = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const anyref = \"anyref\";\n  export const eqref = \"eqref\";\n  export const structref = \"structref\";\n  export const arrayref = \"arrayref\";\n  export const i31ref = \"i31ref\";\n  export const stringref = \"stringref\";\n  export const stringview_wtf8 = \"stringview_wtf8\";\n  export const stringview_wtf16 = \"stringview_wtf16\";\n  export const stringview_iter = \"stringview_iter\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  export const nonnull = \"nonnull\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_RUNTIME = \"ASC_RUNTIME\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  export const ASC_FEATURE_RELAXED_SIMD = \"ASC_FEATURE_RELAXED_SIMD\";\n  export const ASC_FEATURE_EXTENDED_CONST = \"ASC_FEATURE_EXTENDED_CONST\";\n  export const ASC_FEATURE_STRINGREF = \"ASC_FEATURE_STRINGREF\";\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Anyref = \"Anyref\";\n  export const Eqref = \"Eqref\";\n  export const Structref = \"Structref\";\n  export const Arrayref = \"Arrayref\";\n  export const I31ref = \"I31ref\";\n  export const String = \"String\";\n  export const RegExp = \"RegExp\";\n  export const Object = \"Object\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const TemplateStringsArray = \"TemplateStringsArray\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const link = \"__link\";\n  export const collect = \"__collect\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n  // memory & table\n  export const DefaultMemory = \"0\";\n  export const DefaultTable = \"0\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Runtime } from \"../std/assembly/shared/runtime\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  None = 0,\n  /** Sign extension operations. */\n  SignExtension = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MutableGlobals = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NontrappingF2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BulkMemory = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  Simd = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  Threads = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  ExceptionHandling = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TailCalls = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  ReferenceTypes = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MultiValue = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  Memory64 = 1 << 11, // see: https://github.com/WebAssembly/memory64\n  /** Relaxed SIMD. */\n  RelaxedSimd = 1 << 12, // see: https://github.com/WebAssembly/relaxed-simd\n  /** Extended const expressions. */\n  ExtendedConst = 1 << 13, // see: https://github.com/WebAssembly/extended-const\n  /** Reference typed strings. */\n  Stringref = 1 << 14, // see: https://github.com/WebAssembly/stringref\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SignExtension: return \"sign-extension\";\n    case Feature.MutableGlobals: return \"mutable-globals\";\n    case Feature.NontrappingF2I: return \"nontrapping-f2i\";\n    case Feature.BulkMemory: return \"bulk-memory\";\n    case Feature.Simd: return \"simd\";\n    case Feature.Threads: return \"threads\";\n    case Feature.ExceptionHandling: return \"exception-handling\";\n    case Feature.TailCalls: return \"tail-calls\";\n    case Feature.ReferenceTypes: return \"reference-types\";\n    case Feature.MultiValue: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.Memory64: return \"memory64\";\n    case Feature.RelaxedSimd: return \"relaxed-simd\";\n    case Feature.ExtendedConst: return \"extended-const\";\n    case Feature.Stringref: return \"stringref\";\n  }\n  assert(false);\n  return \"\";\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  Js = 0,\n  /** WebAssembly with 32-bit pointers. */\n  Wasm32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  Wasm64 = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\n// helper globals used by mangleImportName\nlet mangleImportName_moduleName: string = \"\";\nlet mangleImportName_elementName: string = \"\";\n\nimport {\n  BuiltinNames,\n  BuiltinFunctionContext,\n  BuiltinVariableContext,\n  builtinFunctions,\n  builtinVariables_onAccess,\n  builtinVariables_onCompile,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI\n} from \"./builtins\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  TypeRef,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getConstValueV128,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags,\n  isConstZero,\n  isConstNegZero,\n  isConstExpressionNaN,\n  ensureType,\n  createType\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  STATIC_DELIMITER,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  Runtime\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  DeclaredElement,\n  Enum,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n  DecoratorNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n  CompiledExpression,\n\n  TypeNode,\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted,\n  Source\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToRefs\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  writeV128,\n  cloneMap,\n  isPowerOf2,\n  readI32,\n  isIdentifier,\n  accuratePow64,\n  v128_zero,\n  v128_ones,\n} from \"./util\";\n\nimport {\n  RtraceMemory\n} from \"./passes/rtrace\";\n\nimport {\n  ShadowStackPass\n} from \"./passes/shadowstack\";\n\nimport {\n  liftRequiresExportRuntime,\n  lowerRequiresExportRuntime\n} from \"./bindings/js\";\n\n/** Compiler options. */\nexport class Options {\n  constructor() { /* as internref */ }\n\n  /** WebAssembly target. Defaults to {@link Target.Wasm32}. */\n  target: Target = Target.Wasm32;\n  /** Runtime type. Defaults to Incremental GC. */\n  runtime: Runtime = Runtime.Incremental;\n  /** If true, indicates that debug information will be emitted by Binaryen. */\n  debugInfo: bool = false;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imported memory is zero filled. */\n  zeroFilledMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** Unchecked behavior. Defaults to only using unchecked operations inside unchecked(). */\n  uncheckedBehavior: UncheckedBehavior = UncheckedBehavior.Default;\n  /** If given, exports the start function instead of calling it implicitly. */\n  exportStart: string | null = null;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MutableGlobals\n                    | Feature.SignExtension\n                    | Feature.NontrappingF2I\n                    | Feature.BulkMemory;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n  /** If true, exports the runtime helpers. */\n  exportRuntime: bool = false;\n  /** Stack size in bytes, if using a stack. */\n  stackSize: i32 = 0;\n  /** Semantic major bundle version from root package.json */\n  bundleMajorVersion: i32 = 0;\n  /** Semantic minor bundle version from root package.json */\n  bundleMinorVersion: i32 = 0;\n  /** Semantic patch bundle version from root package.json */\n  bundlePatchVersion: i32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n  /** Hinted basename. */\n  basenameHint: string = \"output\";\n  /** Hinted bindings generation. */\n  bindingsHint: bool = false;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.Wasm64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.Wasm64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the size type reference matching the target. */\n  get sizeTypeRef(): TypeRef {\n    return this.target == Target.Wasm64 ? TypeRef.I64 : TypeRef.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Behaviors regarding unchecked operations. */\nexport const enum UncheckedBehavior {\n  /** Only use unchecked operations inside unchecked(). */\n  Default = 0,\n  /** Never use unchecked operations. */\n  Never = 1,\n  /** Always use unchecked operations if possible. */\n  Always = 2\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  None = 0,\n\n  /** Must implicitly convert to the target type. */\n  ConvImplicit = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  ConvExplicit = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MustWrap = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WillDrop = 1 << 3,\n  /** Indicates that static data is preferred. */\n  PreferStatic = 1 << 4,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IsThis = 1 << 5\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  None = 0,\n  /** Requires data setup. */\n  Data = 1 << 0,\n  /** Requires a stack. */\n  Stack = 1 << 1,\n  /** Requires heap setup. */\n  Heap = 1 << 2,\n  /** Requires runtime type information setup. */\n  Rtti = 1 << 3,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 4,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 5,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 6\n}\n\n/** Imported default names of compiler-generated elements. */\nexport namespace ImportNames {\n  /** Name of the default namespace */\n  export const DefaultNamespace = \"env\";\n  /** Name of the memory instance, if imported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if imported. */\n  export const Table = \"table\";\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the memory instance, if exported. */\n  export const Memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const Table = \"table\";\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n}\n\n/** Functions to export if `--exportRuntime` is set. */\nconst runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\n/** Globals to export if `--exportRuntime` is set. */\nconst runtimeGlobals = [ \"__rtti_base\" ];\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Module instance being compiled. */\n  get module(): Module { return this.program.module; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.None;\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending instanceof helpers and their names. */\n  pendingInstanceOf: Map<DeclaredElement, string> = new Map();\n  /** Stubs to defer calls to overridden methods. */\n  overrideStubs: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n  /** Shadow stack reference. */\n  shadowStack!: ShadowStackPass;\n  /** Whether the module has custom function exports. */\n  hasCustomFunctionExports: bool = false;\n  /** Whether the module would use the exported runtime to lift/lower. */\n  desiresExportRuntime: bool = false;\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    let module = program.module;\n    let options = program.options;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    let featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SignExtension)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MutableGlobals)) featureFlags |= FeatureFlags.MutableGlobals;\n    if (options.hasFeature(Feature.NontrappingF2I)) featureFlags |= FeatureFlags.TruncSat;\n    if (options.hasFeature(Feature.BulkMemory)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.Simd)) featureFlags |= FeatureFlags.SIMD;\n    if (options.hasFeature(Feature.Threads)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.ExceptionHandling)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TailCalls)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.ReferenceTypes)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MultiValue)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.Memory64)) featureFlags |= FeatureFlags.Memory64;\n    if (options.hasFeature(Feature.RelaxedSimd)) featureFlags |= FeatureFlags.RelaxedSIMD;\n    if (options.hasFeature(Feature.ExtendedConst)) featureFlags |= FeatureFlags.ExtendedConst;\n    if (options.hasFeature(Feature.Stringref)) featureFlags |= FeatureFlags.Stringref;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    let startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, Signature.create(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n    this.shadowStack = new ShadowStackPass(this);\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    let options = this.options;\n    let module = this.module;\n    let program = this.program;\n    let resolver = this.resolver;\n    let hasShadowStack = options.stackSize > 0; // implies runtime=incremental\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    let startFunctionInstance = this.currentFlow.targetFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    let startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // compile entry file(s) while traversing reachable elements\n    let files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.compileFile(file);\n        this.compileModuleExports(file);\n      }\n    }\n\n    // compile and export runtime if requested or necessary\n    if (this.options.exportRuntime || (this.options.bindingsHint && this.desiresExportRuntime)) {\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n        let name = runtimeFunctions[i];\n        let instance = program.requireFunction(name);\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\n          module.addFunctionExport(instance.internalName, name);\n        }\n      }\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n        let name = runtimeGlobals[i];\n        let instance = program.requireGlobal(name);\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\n          module.addGlobalExport(instance.internalName, name);\n        }\n      }\n    }\n\n    // compile lazy functions\n    let lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending instanceof helpers\n    for (let _keys = Map_keys(this.pendingInstanceOf), i = 0, k = _keys.length; i < k; ++i) {\n      let elem = _keys[i];\n      let name = assert(this.pendingInstanceOf.get(elem));\n      switch (elem.kind) {\n        case ElementKind.Class:\n        case ElementKind.Interface: {\n          this.finalizeInstanceOf(<Class>elem, name);\n          break;\n        }\n        case ElementKind.ClassPrototype:\n        case ElementKind.InterfacePrototype: {\n          this.finalizeAnyInstanceOf(<ClassPrototype>elem, name);\n          break;\n        }\n        default: assert(false);\n      }\n    }\n\n    // set up override stubs\n    let functionTable = this.functionTable;\n    let overrideStubs = this.overrideStubs;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.Overridden)) {\n        assert(instance.is(CommonFlags.Instance));\n        functionTable[i] = this.ensureOverrideStub(instance); // includes varargs stub\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    let overrideStubsSeen = new Set<Function>();\n    do {\n      // override stubs and overrides have cross-dependencies on each other, in that compiling\n      // either may discover the respective other. do this in a loop until no more are found.\n      resolver.discoveredOverride = false;\n      for (let _values = Set_values(overrideStubs), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        let overrideInstances = resolver.resolveOverrides(instance);\n        if (overrideInstances) {\n          for (let i = 0, k = overrideInstances.length; i < k; ++i) {\n            this.compileFunction(overrideInstances[i]);\n          }\n        }\n        overrideStubsSeen.add(instance);\n      }\n    } while (overrideStubs.size > overrideStubsSeen.size || resolver.discoveredOverride);\n    overrideStubsSeen.clear();\n    for (let _values = Set_values(overrideStubs), i = 0, k = _values.length; i < k; ++i) {\n      this.finalizeOverrideStub(_values[i]);\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.Rtti) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    let memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\n\n    // finalize data\n    module.removeGlobal(BuiltinNames.data_end);\n    if ((this.runtimeFeatures & RuntimeFeatures.Data) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize stack (grows down from __heap_base to __data_end)\n    module.removeGlobal(BuiltinNames.stack_pointer);\n    if ((this.runtimeFeatures & RuntimeFeatures.Stack) != 0 || hasShadowStack) {\n      memoryOffset = i64_align(\n        i64_add(memoryOffset, i64_new(options.stackSize)),\n        options.usizeType.byteSize\n      );\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize heap\n    module.removeGlobal(BuiltinNames.heap_base);\n    if ((this.runtimeFeatures & RuntimeFeatures.Heap) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // setup default memory & table\n    this.initDefaultMemory(memoryOffset);\n    this.initDefaultTable();\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n\n    // NOTE: no more element compiles from here. may go to the start function!\n\n    // compile the start function if not empty or if explicitly requested\n    let startIsEmpty = !startFunctionBody.length;\n    let exportStart = options.exportStart;\n    if (!startIsEmpty || exportStart != null) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && exportStart != null) {\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.global_set(BuiltinNames.started, module.i32(1))\n        );\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, TypeRef.I32),\n            module.return()\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(startFunctionInstance.getNonParameterLocalTypes()),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (exportStart == null) module.setStart(funcRef);\n      else {\n        if (!isIdentifier(exportStart) || module.hasExport(exportStart)) {\n          this.error(\n            DiagnosticCode.Start_function_name_0_is_invalid_or_conflicts_with_another_export,\n            Source.native.range, exportStart\n          );\n        } else {\n          module.addFunctionExport(startFunctionInstance.internalName, exportStart);\n        }\n      }\n    }\n\n    // Run custom passes\n    if (hasShadowStack) {\n      this.shadowStack.walkModule();\n    }\n    if (program.lookup(\"ASC_RTRACE\") != null) {\n      new RtraceMemory(this).walkModule();\n    }\n\n    return module;\n  }\n\n  private initDefaultMemory(memoryOffset: i64): void {\n    this.memoryOffset = memoryOffset;\n\n    let options = this.options;\n    let module = this.module;\n    let memorySegments = this.memorySegments;\n\n    let initialPages: u32 = 0;\n    let maximumPages = Module.UNLIMITED_MEMORY;\n    let isSharedMemory = false;\n\n    if (options.memoryBase /* is specified */ || memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.Threads)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n\n    // check that we didn't exceed lowMemoryLimit already\n    let lowMemoryLimit32 = options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n\n    // Setup internal memory with default name \"0\"\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.Memory : null,\n      CommonNames.DefaultMemory,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) {\n      module.addMemoryImport(\n        CommonNames.DefaultMemory,\n        ImportNames.DefaultNamespace,\n        ImportNames.Memory,\n        isSharedMemory\n      );\n    }\n  }\n\n  private initDefaultTable(): void {\n    let options = this.options;\n    let module = this.module;\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\n        CommonNames.DefaultTable,\n        ImportNames.DefaultNamespace,\n        ImportNames.Table\n      );\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(CommonNames.DefaultTable, ExportNames.Table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up function table (first elem is blank)\n    let tableBase = options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    let functionTable = this.functionTable;\n    let functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n\n    let initialTableSize = <Index>tableBase + functionTable.length;\n    let maximumTableSize = Module.UNLIMITED_TABLE;\n\n    if (!(options.importTable || options.exportTable)) {\n      // use fixed size for non-imported and non-exported tables\n      maximumTableSize = initialTableSize;\n      if (options.willOptimize) {\n        // Hint for directize pass which indicate table's content will not change\n        // and can be better optimized\n        module.setPassArgument(\"directize-initial-contents-immutable\", \"true\");\n      }\n    }\n    module.addFunctionTable(\n      CommonNames.DefaultTable,\n      initialTableSize,\n      maximumTableSize,\n      functionTableNames,\n      module.i32(tableBase)\n    );\n  }\n\n  // === Exports ==================================================================================\n\n  /** Compiles the respective module exports for the specified entry file. */\n  private compileModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.compileModuleExport(elementName, element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.compileModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Compiles the respective module export(s) for the specified element. */\n  private compileModuleExport(name: string, element: DeclaredElement, prefix: string = \"\"): void {\n    let module = this.module;\n    switch (element.kind) {\n      case ElementKind.FunctionPrototype: {\n        // obtain the default instance\n        let functionPrototype = <FunctionPrototype>element;\n        if (!functionPrototype.is(CommonFlags.Generic)) {\n          let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n          if (functionInstance) {\n            this.compileModuleExport(name, functionInstance, prefix);\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          this.compileFunction(functionInstance);\n          if (functionInstance.is(CommonFlags.Compiled)) {\n            let exportName = prefix + name;\n            if (!module.hasExport(exportName)) {\n              module.addFunctionExport(functionInstance.internalName, exportName);\n              this.hasCustomFunctionExports = true;\n              let hasManagedOperands = signature.hasManagedOperands;\n              if (hasManagedOperands) {\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\n              }\n              if (!this.desiresExportRuntime) {\n                let thisType = signature.thisType;\n                if (\n                  thisType && lowerRequiresExportRuntime(thisType) ||\n                  liftRequiresExportRuntime(signature.returnType)\n                ) {\n                  this.desiresExportRuntime = true;\n                } else {\n                  let parameterTypes = signature.parameterTypes;\n                  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n                    if (lowerRequiresExportRuntime(parameterTypes[i])) {\n                      this.desiresExportRuntime = true;\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n        }\n        break;\n      }\n      case ElementKind.Global: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n        if (!isConst && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.warning(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            global.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        this.compileGlobal(global);\n        if (global.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n            if (!this.desiresExportRuntime) {\n              let type = global.type;\n              if (\n                liftRequiresExportRuntime(type) ||\n                !global.is(CommonFlags.Const) && lowerRequiresExportRuntime(type)\n              ) {\n                this.desiresExportRuntime = true;\n              }\n            }\n          }\n          if (global.type == Type.v128) {\n            this.warning(\n              DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n              global.typeNode\n                ? assert(global.typeNode).range\n                : global.identifierNode.range,\n              \"v128\"\n            );\n          }\n          return;\n        }\n        break;\n      }\n      case ElementKind.Enum: {\n        this.compileEnum(<Enum>element);\n        let members = element.members;\n        if (members) {\n          let subPrefix = prefix + name + STATIC_DELIMITER;\n          for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(members.get(memberName));\n            if (!member.is(CommonFlags.Private)) {\n              this.compileModuleExport(memberName, member, subPrefix);\n            }\n          }\n        }\n        return;\n      }\n      case ElementKind.EnumValue: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MutableGlobals)) {\n          this.error(\n            DiagnosticCode.Feature_0_is_not_enabled,\n            enumValue.identifierNode.range, \"mutable-globals\"\n          );\n          return;\n        }\n        if (enumValue.is(CommonFlags.Compiled)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n          return;\n        }\n        break;\n      }\n    }\n    this.warning(\n      DiagnosticCode.Only_variables_functions_and_enums_become_WebAssembly_module_exports,\n      element.identifierNode.range\n    );\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    let file: File;\n    let filesByName = this.program.filesByName;\n    let pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.Compiled)) return;\n    file.set(CommonFlags.Compiled);\n\n    // compile top-level statements within the file's start function\n    let startFunction = file.startFunction;\n    let startSignature = startFunction.signature;\n    let previousBody = this.currentBody;\n    let startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    let previousFlow = this.currentFlow;\n    let flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<TypeRef>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\n      const funcRef = module.addFunction(\n        startFunction.internalName,\n        startSignature.paramRefs,\n        startSignature.resultRefs,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      startFunction.finalize(module, funcRef);\n      previousBody.push(\n        module.call(startFunction.internalName, null, TypeRef.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Tries to compile a global variable lazily. */\n  compileGlobalLazy(global: Global, reportNode: Node): bool {\n    if (global.is(CommonFlags.Compiled)) return !global.is(CommonFlags.Errored);\n    if (global.hasAnyDecorator(DecoratorFlags.Lazy | DecoratorFlags.Builtin) || global.is(CommonFlags.Ambient)) {\n      return this.compileGlobal(global); // compile now\n    }\n    // Otherwise the global is used before its initializer executes\n    this.errorRelated(\n      DiagnosticCode.Variable_0_used_before_its_declaration,\n      reportNode.range, global.identifierNode.range, global.internalName\n    );\n    return false;\n  }\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.Compiled)) return !global.is(CommonFlags.Errored);\n    global.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    let module = this.module;\n    let initExpr: ExpressionRef = 0;\n    let typeNode = global.typeNode;\n    let initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.Resolved)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.program.checkTypeSupported(resolvedType, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.Errored);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.Errored);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.hasDecorator(DecoratorFlags.Builtin)) {\n      let internalName = global.internalName;\n      if (builtinVariables_onCompile.has(internalName)) { // optional\n        let fn = assert(builtinVariables_onCompile.get(internalName));\n        fn(new BuiltinVariableContext(this, global));\n      }\n      pendingElements.delete(global);\n      return true;\n    }\n\n    let type = global.type;\n\n    // Enforce either an initializer, a definitive assignment or a nullable type\n    // to guarantee soundness when globals are accessed. In the absence of an\n    // initializer, a definitive assignment guarantees a runtime check, whereas\n    // a nullable type guarantees that obtaining default `null` is OK. Avoids:\n    //\n    //   let foo: string;\n    //   function bar() {\n    //     foo.length; // no error in TS even though undefined\n    //   }\n    //   bar();\n    if (\n      !initializerNode && !global.is(CommonFlags.DefinitelyAssigned) &&\n      type.isReference && !type.isNullableReference\n    ) {\n      this.error(\n        DiagnosticCode.Initializer_definitive_assignment_or_nullable_type_expected,\n        global.identifierNode.range\n      );\n    }\n\n    let typeRef = type.toRef();\n    let isDeclaredConstant = global.is(CommonFlags.Const) || global.is(CommonFlags.Static | CommonFlags.Readonly);\n    let isDeclaredInline = global.hasDecorator(DecoratorFlags.Inline);\n\n    // Handle imports\n    if (global.is(CommonFlags.Ambient)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MutableGlobals)) {\n        mangleImportName(global, global.declaration);\n        this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, global);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          typeRef,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        if (!this.desiresExportRuntime && lowerRequiresExportRuntime(type)) {\n          this.desiresExportRuntime = true;\n        }\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.Errored);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    let initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.ConvImplicit | Constraints.MustWrap | Constraints.PreferStatic\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant expression, attempt to precompute\n      if (!module.isConstExpression(initExpr)) {\n        if (isDeclaredConstant) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp;\n          } else {\n            initializeInStart = true;\n          }\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.Ambient)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>TypeRef.I32: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>TypeRef.I64: {\n              global.constantValueKind = ConstantValueKind.Integer;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>TypeRef.F32: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>TypeRef.F64: {\n              global.constantValueKind = ConstantValueKind.Float;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.Errored);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.Inlined); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.Inlined)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PreferStatic);\n      } else {\n        initExpr = this.makeZero(type);\n      }\n    }\n\n    let internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.Inline, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, typeRef, true, this.makeZero(type));\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.Compiled)) return !element.is(CommonFlags.Errored);\n    element.set(CommonFlags.Compiled);\n\n    let pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    let module = this.module;\n    let previousParent = this.currentParent;\n    this.currentParent = element;\n    let previousValue: EnumValue | null = null;\n    let previousValueIsMut = false;\n    let isInline = element.is(CommonFlags.Const) || element.hasDecorator(DecoratorFlags.Inline);\n\n    let members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.EnumValue) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.Compiled);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.Lazy)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.ConvImplicit\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, TypeRef.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.Const)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.ModuleExport)) {\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.Compiled)) return !instance.is(CommonFlags.Errored);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.Builtin)) return true;\n      if (instance.hasDecorator(DecoratorFlags.Lazy)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    // ensure the function has no duplicate parameters\n    let parameters = instance.prototype.functionTypeNode.parameters;\n    let numParameters = parameters.length;\n    if (numParameters >= 2) {\n      let visited = new Set<string>();\n      visited.add(parameters[0].name.text);\n      for (let i = 1; i < numParameters; i++) {\n        let paramIdentifier = parameters[i].name;\n        let paramName = paramIdentifier.text;\n        if (!visited.has(paramName)) {\n          visited.add(paramName);\n        } else {\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            paramIdentifier.range, paramName\n          );\n        }\n      }\n    }\n\n    instance.set(CommonFlags.Compiled);\n    let pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    let previousType = this.currentType;\n    let module = this.module;\n    let signature = instance.signature;\n    let bodyNode = instance.prototype.bodyNode;\n    let declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FunctionDeclaration || declarationNode.kind == NodeKind.MethodDeclaration);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    let funcRef: FunctionRef = 0;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.Ambient)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name or code\n      if (instance.hasAnyDecorator(DecoratorFlags.External | DecoratorFlags.ExternalJs)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator: DecoratorNode | null;\n        if (decorator = findDecorator(DecoratorKind.External, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external\"\n          );\n        }\n        if (decorator = findDecorator(DecoratorKind.ExternalJs, decoratorNodes)) {\n          this.error(\n            DiagnosticCode.Decorator_0_is_not_valid_here,\n            decorator.range, \"external.js\"\n          );\n        }\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      if (!this.compileFunctionBody(instance, stmts)) {\n        stmts.push(module.unreachable());\n      }\n\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(instance.getNonParameterLocalTypes()),\n        module.flatten(stmts, instance.signature.returnType.toRef())\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.Ambient)) {\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      this.program.markModuleImport(mangleImportName_moduleName, mangleImportName_elementName, instance);\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.paramRefs,\n        signature.resultRefs\n      );\n      funcRef = module.getFunction(instance.internalName);\n      if (!this.desiresExportRuntime) {\n        let thisType = signature.thisType;\n        if (\n          thisType && liftRequiresExportRuntime(thisType) ||\n          lowerRequiresExportRuntime(signature.returnType)\n        ) {\n          this.desiresExportRuntime = true;\n        } else {\n          let parameterTypes = signature.parameterTypes;\n          for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n            if (liftRequiresExportRuntime(parameterTypes[i])) {\n              this.desiresExportRuntime = true;\n              break;\n            }\n          }\n        }\n      }\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.Abstract) || instance.parent.kind == ElementKind.Interface) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        null,\n        module.unreachable()\n      );\n\n    } else {\n      // built-in field accessor?\n      if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n        let propertyName = instance.declaration.name.text;\n        let propertyParent = assert(instance.parent.getMember(propertyName));\n        assert(propertyParent.kind == ElementKind.PropertyPrototype);\n        let propertyInstance = (<PropertyPrototype>propertyParent).instance;\n        if (propertyInstance && propertyInstance.isField) {\n          funcRef = instance.is(CommonFlags.Get)\n            ? this.makeBuiltinFieldGetter(propertyInstance)\n            : this.makeBuiltinFieldSetter(propertyInstance);\n          assert(instance.is(CommonFlags.Compiled));\n        }\n      }\n      if (!funcRef) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          instance.identifierNode.range\n        );\n        instance.set(CommonFlags.Errored);\n      }\n    }\n\n    if (instance.is(CommonFlags.Ambient) || instance.is(CommonFlags.Export)) {\n      // Verify and print warn if signature has v128 type for imported or exported functions\n      let hasVectorValueOperands = signature.hasVectorValueOperands;\n      if (hasVectorValueOperands) {\n        let range: Range;\n        let fnTypeNode = instance.prototype.functionTypeNode;\n        if (signature.returnType == Type.v128) {\n          range = fnTypeNode.returnType.range;\n        } else {\n          let firstIndex = signature.getVectorValueOperandIndices()[0];\n          range = fnTypeNode.parameters[firstIndex].range;\n        }\n        this.warning(\n          DiagnosticCode.Exchange_of_0_values_is_not_supported_by_all_embeddings,\n          range, \"v128\"\n        );\n      }\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    let module = this.module;\n    let bodyNode = assert(instance.prototype.bodyNode);\n    let returnType = instance.signature.returnType;\n    let flow = this.currentFlow;\n    let thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n    let bodyStartIndex = stmts.length;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.Block) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.Expression);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.Constructor | CommonFlags.Get | CommonFlags.Set));\n\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.ConvImplicit);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.Terminates)) {\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n        flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.Constructor)) {\n      assert(instance.is(CommonFlags.Instance));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.AccessesThis | FlowFlags.ConditionallyAccessesThis) || !flow.is(FlowFlags.Terminates)) {\n\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n\n        // Insert right before the body\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\n          stmts[i + 1] = stmts[i];\n        }\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MayReturnNonThis)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MayReturnNonThis) && !classInstance.hasDecorator(DecoratorFlags.Final)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.Terminates)) {\n        stmts.push(\n          module.local_get(thisLocal.index, this.options.sizeTypeRef)\n        );\n        flow.set(FlowFlags.Returns | FlowFlags.ReturnsNonNull | FlowFlags.Terminates);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base && !classInstance.prototype.implicitlyExtendsObject && !flow.is(FlowFlags.CallsSuper)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.Terminates)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  /** Makes a built-in getter of a property that is a field. */\n  private makeBuiltinFieldGetter(property: Property): FunctionRef {\n    let getterInstance = assert(property.getterInstance);\n    let module = this.module;\n    let valueType = property.type;\n    let valueTypeRef = valueType.toRef();\n    let thisTypeRef = this.options.sizeTypeRef;\n    getterInstance.set(CommonFlags.Compiled);\n    let body = module.load(valueType.byteSize, valueType.isSignedIntegerValue,\n      module.local_get(0, thisTypeRef),\n      valueTypeRef, property.memoryOffset\n    );\n    let flowBefore = this.currentFlow;\n    let flow = getterInstance.flow;\n    this.currentFlow = flow;\n    if (property.is(CommonFlags.DefinitelyAssigned) && valueType.isReference && !valueType.isNullableReference) {\n      body = this.makeRuntimeNonNullCheck(body, valueType, getterInstance.identifierNode);\n    }\n    this.currentFlow = flowBefore;\n    return module.addFunction(\n      getterInstance.internalName,\n      thisTypeRef,\n      valueTypeRef,\n      typesToRefs(getterInstance.getNonParameterLocalTypes()),\n      body\n    );\n  }\n\n  /** Makes a built-in setter of a property that is a field. */\n  private makeBuiltinFieldSetter(property: Property): FunctionRef {\n    let setterInstance = assert(property.setterInstance);\n    let module = this.module;\n    let valueType = property.type;\n    let thisTypeRef = this.options.sizeTypeRef;\n    let valueTypeRef = valueType.toRef();\n    // void(this.field = value)\n    let bodyExpr = module.store(valueType.byteSize,\n      module.local_get(0, thisTypeRef),\n      module.local_get(1, valueTypeRef),\n      valueTypeRef, property.memoryOffset\n    );\n    if (valueType.isManaged) {\n      let parent = setterInstance.parent;\n      assert(parent.kind == ElementKind.Class);\n      if ((<Class>parent).type.isManaged) {\n        let linkInstance = this.program.linkInstance;\n        this.compileFunction(linkInstance);\n        bodyExpr = module.block(null, [\n          bodyExpr,\n          module.call(linkInstance.internalName, [\n            module.local_get(0, thisTypeRef),\n            module.local_get(1, valueTypeRef),\n            module.i32(0)\n          ], TypeRef.None)\n        ], TypeRef.None);\n      }\n    }\n    setterInstance.set(CommonFlags.Compiled);\n    return module.addFunction(\n      setterInstance.internalName,\n      createType([ thisTypeRef, valueTypeRef ]),\n      TypeRef.None,\n      null,\n      bodyExpr\n    );\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    let memoryOffset = i64_align(this.memoryOffset, alignment);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    let memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\n    let segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    let ptr = this.ensureStaticStringPtr(stringValue);\n    this.currentType = this.program.stringInstance.type;\n    return this.module.usize(ptr);\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticStringPtr(stringValue: string): i64 {\n    let program = this.program;\n    let totalOverhead = program.totalOverhead;\n    let stringInstance = assert(program.stringInstance);\n    let stringSegment: MemorySegment;\n    let segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    return i64_add(stringSegment.offset, i64_new(totalOverhead));\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    let length = values.length;\n    let byteSize = elementType.byteSize;\n    let elementTypeRef = elementType.toRef();\n    switch (<u32>elementTypeRef) {\n      case <u32>TypeRef.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.V128: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeV128(getConstValueV128(value), buf, pos);\n          pos += 16;\n        }\n        break;\n      }\n      case <u32>TypeRef.None: {\n        // nothing to write\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    let program = this.program;\n    let arrayBufferInstance = program.arrayBufferInstance;\n    let buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(\n    elementType: Type,\n    bufferSegment: MemorySegment,\n    /** Optional array instance override. */\n    arrayInstance: Class | null = null\n  ): MemorySegment {\n    let program = this.program;\n    if (!arrayInstance) {\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\n    }\n    let bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\n    let arrayLength = i32(bufferLength / elementType.byteSize);\n    let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n    let buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.Compiled) && !instance.is(CommonFlags.Stub));\n    let program = this.program;\n    let memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.ClassDeclaration: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.EnumDeclaration: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.Enum);\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potential merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.Variable: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.Global);\n            if (\n              !element.is(CommonFlags.Ambient) && // delay imports\n              !element.hasDecorator(DecoratorFlags.Lazy)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FieldDeclaration: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element && element.kind == ElementKind.Global) { // static\n          if (!element.hasDecorator(DecoratorFlags.Lazy)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.Export: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath != null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.ExportDefault: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.Import: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FunctionDeclaration:\n      case NodeKind.MethodDeclaration:\n      case NodeKind.InterfaceDeclaration:\n      case NodeKind.IndexSignature:\n      case NodeKind.TypeDeclaration: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement\n  ): ExpressionRef {\n    let module = this.module;\n    let stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.Block: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.Break: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.Continue: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.Do: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.Empty: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.Expression: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.For: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.ForOf: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.If: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.Return: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement);\n        break;\n      }\n      case NodeKind.Switch: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.Throw: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.Try: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.Variable: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.Void: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.While: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TypeDeclaration: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      case NodeKind.Module: {\n        stmt = module.nop();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Statements to append to. Also returned, created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    let numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    let flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i]);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) break;\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    let statements = statement.statements;\n    let outerFlow = this.currentFlow;\n    let innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    let stmts = this.compileStatements(statements);\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    let flow = this.currentFlow;\n    let breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Breaks);\n    return module.br(breakLabel);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    let flow = this.currentFlow;\n    let continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.Continues | FlowFlags.Terminates);\n    return module.br(continueLabel);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break\n    //  (loop $loop\n    //   (?block $continue\n    //    (body)\n    //   )\n    //   (br_if $loop (condition))\n    //  )\n    // )\n\n    // Cases of interest:\n    // * If the body never falls through or continues, the condition never executes\n    // * If the condition is always true and body never breaks, overall flow terminates\n    // * If the body terminates with a continue, condition is still reached\n\n    // Compile the body (always executes)\n    let flow = outerFlow.fork(/* resetBreakContext */ true);\n    let label = flow.pushControlFlowLabel();\n    let breakLabel = `do-break|${label}`;\n    flow.breakLabel = breakLabel;\n    let continueLabel = `do-continue|${label}`;\n    flow.continueLabel = continueLabel;\n    let loopLabel = `do-loop|${label}`;\n    this.currentFlow = flow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    flow.popControlFlowLabel(label);\n\n    let possiblyContinues = flow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = flow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    let possiblyFallsThrough = !flow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n\n    // Shortcut if the condition is never reached\n    if (!possiblyFallsThrough && !possiblyContinues) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      outerFlow.inherit(flow);\n\n      // If the body also never breaks, the overall flow terminates\n      if (!possiblyBreaks) {\n        outerFlow.set(FlowFlags.Terminates);\n      }\n\n    // Otherwise compile and evaluate the condition (from here on always executes)\n    } else {\n      let condExpr = this.compileExpression(statement.condition, Type.bool);\n      let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, statement.condition);\n      let condKind = this.evaluateCondition(condExprTrueish);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      let possiblyLoops = condKind != ConditionKind.False && (possiblyContinues || possiblyFallsThrough);\n      if (possiblyLoops && outerFlow.resetIfNeedsRecompile(flow.forkThen(condExpr), numLocalsBefore)) {\n        this.currentFlow = outerFlow;\n        return this.doCompileDoStatement(statement);\n      }\n\n      if (possiblyContinues) {\n        bodyStmts[0] = module.block(continueLabel, bodyStmts);\n        bodyStmts.length = 1;\n        flow.unset(FlowFlags.Terminates); // Continue breaks to condition\n      }\n      bodyStmts.push(\n        module.br(loopLabel,\n          condExprTrueish\n        )\n      );\n      outerFlow.inherit(flow);\n\n      // Terminate if the condition is always true and body never breaks\n      if (condKind == ConditionKind.True && !possiblyBreaks) {\n        outerFlow.set(FlowFlags.Terminates);\n      }\n    }\n\n    // Finalize and leave everything else to the optimizer\n    this.currentFlow = outerFlow;\n    let expr = module.loop(loopLabel,\n      module.flatten(bodyStmts)\n    );\n    if (possiblyBreaks) {\n      expr = module.block(breakLabel, [\n        expr\n      ]);\n    }\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.ConvImplicit);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (initializer)          └►┐ flow\n    // (?block $break           │ (initializer)\n    //  (?loop $loop          ┌◄┤ (condition) shortcut if false ◄┐\n    //   (if (condition)        ├►┐ bodyFlow                     │\n    //    (then                 │ │ (body)                       │\n    //     (?block $continue    │ │ if loops: (incrementor) ─────┘\n    //      (body)              │ │           recompile body?\n    //     )                    ├◄┘    \n    //     (incrementor)      ┌◄┘\n    //     (br $loop)\n    //    )\n    //   )\n    //  )\n    // )\n\n    // Compile initializer if present. The initializer might introduce scoped\n    // locals bound to the for statement, so create a new flow early.\n    let flow = outerFlow.fork();\n    this.currentFlow = flow;\n    let stmts = new Array<ExpressionRef>();\n    let initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.Expression ||\n        initializer.kind == NodeKind.Variable\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    // Precompute the condition if present, or default to `true`\n    let condExpr: ExpressionRef;\n    let condExprTrueish: ExpressionRef;\n    let condKind: ConditionKind;\n    let condition = statement.condition;\n    if (condition) {\n      condExpr = this.compileExpression(condition, Type.bool);\n      condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, condition);\n      condKind = this.evaluateCondition(condExprTrueish);\n\n      // Shortcut if condition is always false (body never executes)\n      if (condKind == ConditionKind.False) {\n        stmts.push(\n          module.drop(condExprTrueish)\n        );\n        outerFlow.inherit(flow);\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condExprTrueish = condExpr;\n      condKind = ConditionKind.True;\n    }\n    // From here on condition is either true or unknown\n\n    // Compile the body assuming the condition turned out true\n    let bodyFlow = flow.forkThen(condExpr, /* newBreakContext */ true);\n    let label = bodyFlow.pushControlFlowLabel();\n    let breakLabel = `for-break${label}`;\n    bodyFlow.breakLabel = breakLabel;\n    let continueLabel = `for-continue|${label}`;\n    bodyFlow.continueLabel = continueLabel;\n    let loopLabel = `for-loop|${label}`;\n    this.currentFlow = bodyFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    bodyFlow.popControlFlowLabel(label);\n    bodyFlow.breakLabel = null;\n    bodyFlow.continueLabel = null;\n\n    let possiblyFallsThrough = !bodyFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n    let possiblyContinues = bodyFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = bodyFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n\n    if (possiblyContinues) {\n      bodyStmts[0] = module.block(continueLabel, bodyStmts);\n      bodyStmts.length = 1;\n    }\n\n    // Compile the incrementor if it possibly executes\n    let possiblyLoops = possiblyContinues || possiblyFallsThrough;\n    if (possiblyLoops) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        bodyStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.ConvImplicit | Constraints.WillDrop)\n        );\n      }\n      bodyStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (outerFlow.resetIfNeedsRecompile(bodyFlow.forkThen(condExpr), numLocalsBefore)) {\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement);\n      }\n    }\n\n    // Body executes at least once\n    if (condKind == ConditionKind.True) {\n      flow.inherit(bodyFlow);\n\n    // Otherwise executes conditionally\n    } else {\n      flow.mergeBranch(bodyFlow);\n    }\n\n    // Finalize\n    outerFlow.inherit(flow);\n    this.currentFlow = outerFlow;\n    let expr = module.if(condExprTrueish,\n      module.flatten(bodyStmts)\n    );\n    if (possiblyLoops) {\n      expr = module.loop(loopLabel, expr);\n    }\n    if (possiblyBreaks) {\n      expr = module.block(breakLabel, [ expr ]);\n    }\n    stmts.push(expr);\n    if (outerFlow.is(FlowFlags.Terminates)) {\n      stmts.push(module.unreachable());\n    }\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let ifTrue = statement.ifTrue;\n    let ifFalse = statement.ifFalse;\n\n    // (if (condition)\n    //  (then (ifTrue))\n    //  (?else (ifFalse))\n    // )\n\n    // Cases of interest:\n    // * If the condition is always true or false, the other branch is eliminated\n    // * If both then and else terminate, the overall flow does as well\n    // * Without an else, when then terminates, follow-up flow acts like an else\n\n    // Precompute the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(\n      condExpr,\n      this.currentType,\n      statement.condition\n    );\n    let condKind = this.evaluateCondition(condExprTrueish);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.True: {\n        return module.block(null, [\n          module.drop(condExprTrueish),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.False: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExprTrueish),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExprTrueish);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    let flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    let thenStmts = new Array<ExpressionRef>();\n    let thenFlow = flow.forkThen(condExpr);\n    this.currentFlow = thenFlow;\n    if (ifTrue.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    let elseFlow = flow.forkElse(condExpr);\n    if (ifFalse) {\n      this.currentFlow = elseFlow;\n      let elseStmts = new Array<ExpressionRef>();\n      if (ifFalse.kind == NodeKind.Block) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      flow.inheritAlternatives(thenFlow, elseFlow); // terminates if both do\n      this.currentFlow = flow;\n      return module.if(condExprTrueish,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      if (thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n        // Only getting past if condition was false (acts like else)\n        flow.inherit(elseFlow);\n        flow.mergeSideEffects(thenFlow);\n      } else {\n        // Otherwise getting past conditionally\n        flow.inheritAlternatives(thenFlow, elseFlow);\n      }\n      this.currentFlow = flow;\n      return module.if(condExprTrueish,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let expr: ExpressionRef = 0;\n    let flow = this.currentFlow;\n    let returnType = flow.returnType;\n\n    let valueExpression = statement.value;\n    if (valueExpression) {\n      let constraints = Constraints.ConvImplicit;\n      if (flow.sourceFunction.is(CommonFlags.ModuleExport)) constraints |= Constraints.MustWrap;\n\n      expr = this.compileExpression(valueExpression, returnType, constraints);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.ReturnsWrapped);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.ReturnsNonNull);\n      if (flow.sourceFunction.is(CommonFlags.Constructor) && valueExpression.kind != NodeKind.This) {\n        flow.set(FlowFlags.MayReturnNonThis);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      this.currentType = returnType;\n      return module.unreachable();\n    }\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.Returns | FlowFlags.Terminates);\n\n    // Handle inline return\n    if (flow.isInline) {\n      let inlineReturnLabel = assert(flow.inlineReturnLabel);\n      return expr\n        ? this.currentType == Type.void\n          ? module.block(null, [ expr, module.br(inlineReturnLabel) ])\n          : module.br(inlineReturnLabel, 0, expr)\n        : module.br(inlineReturnLabel);\n    }\n\n    // Otherwise emit a normal return\n    return expr\n      ? this.currentType == Type.void\n        ? module.block(null, [ expr, module.return() ])\n        : module.return(expr)\n      : module.return();\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let cases = statement.cases;\n    let numCases = cases.length;\n\n    // Compile the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.u32,\n      Constraints.ConvImplicit\n    );\n\n    // Shortcut if there are no cases\n    if (!numCases) return module.drop(condExpr);\n    \n    // Assign the condition to a temporary local as we compare it multiple times\n    let outerFlow = this.currentFlow;\n    let tempLocal = outerFlow.getTempLocal(Type.u32);\n    let tempLocalIndex = tempLocal.index;\n    let breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set(tempLocalIndex, condExpr, false); // u32\n    \n    // Make one br_if per labeled case and leave it to Binaryen to optimize the\n    // sequence of br_ifs to a br_table according to optimization levels\n    let breakIndex = 1;\n    let defaultIndex = -1;\n    let label = outerFlow.pushControlFlowLabel();\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      if (case_.isDefault) {\n        defaultIndex = i;\n        continue;\n      }\n      breaks[breakIndex++] = module.br(`case${i}|${label}`,\n        module.binary(BinaryOp.EqI32,\n          module.local_get(tempLocalIndex, TypeRef.I32),\n          this.compileExpression(assert(case_.label), Type.u32,\n            Constraints.ConvImplicit\n          )\n        )\n      );\n    }\n\n    // If there is a default case, break to it, otherwise break out of the switch\n    breaks[breakIndex] = module.br(defaultIndex >= 0\n      ? `case${defaultIndex}|${label}`\n      : `break|${label}`\n    );\n\n    // Nest the case blocks in order, to be targeted by the br_if sequence\n    let currentBlock = module.block(`case0|${label}`, breaks, TypeRef.None);\n    let fallThroughFlow: Flow | null = null;\n    let breakingFlowAlternatives: Flow | null = null;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Can get here by matching the case or possibly by fall-through\n      let innerFlow = outerFlow.fork(/* newBreakContext */ true, /* newContinueContext */ false);\n      if (fallThroughFlow) innerFlow.mergeBranch(fallThroughFlow);\n      this.currentFlow = innerFlow;\n      let breakLabel = `break|${label}`;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : `case${i + 1}|${label}`;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let possiblyFallsThrough = true;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks)) {\n          possiblyFallsThrough = false;\n          break;\n        }\n      }\n      stmts.length = count;\n      fallThroughFlow = possiblyFallsThrough ? innerFlow : null;\n      let possiblyBreaks = innerFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n      innerFlow.unset(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks); // clear\n\n      // Combine all alternatives that merge again with outer flow\n      if (possiblyBreaks || (isLast && possiblyFallsThrough)) {\n        if (breakingFlowAlternatives) breakingFlowAlternatives.inheritAlternatives(breakingFlowAlternatives, innerFlow);\n        else breakingFlowAlternatives = innerFlow;\n\n      // Otherwise just merge the effects of a non-merging branch\n      } else if (!possiblyFallsThrough) {\n        outerFlow.mergeSideEffects(innerFlow);\n      }\n\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\n    }\n    outerFlow.popControlFlowLabel(label);\n\n    // If the switch has a default, we only get past through any breaking flow\n    if (defaultIndex >= 0) {\n      if (breakingFlowAlternatives) outerFlow.inherit(breakingFlowAlternatives);\n      else outerFlow.set(FlowFlags.Terminates);\n\n    // Otherwise either none or any breaking flow can get past conditionally\n    } else if (breakingFlowAlternatives) {\n      outerFlow.mergeBranch(breakingFlowAlternatives);\n    }\n\n    this.currentFlow = outerFlow;\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    let flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.Throws | FlowFlags.Terminates);\n\n    let stmts = new Array<ExpressionRef>();\n    let value = statement.value;\n    let message: Expression | null = null;\n    if (value.kind == NodeKind.New) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let declarations = statement.declarations;\n    let numDeclarations = declarations.length;\n    let flow = this.currentFlow;\n    let initializers = new Array<ExpressionRef>();\n    let resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n      let initType: Type | null = null;\n\n      if (declaration.is(CommonFlags.DefinitelyAssigned)) {\n        this.warning(\n          DiagnosticCode.Definitive_assignment_has_no_effect_on_local_variables,\n          declaration.name.range\n        );\n      }\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.program.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.ConvImplicit\n          );\n          initType = this.currentType;\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\n        initType = this.currentType;\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = initType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.Const);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>TypeRef.I32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.I64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.F32: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>TypeRef.F64: {\n                local = new Local(name, -1, type, flow.targetFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a dummy local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.Let | CommonFlags.Const) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.targetFunction.addLocal(type, name, declaration);\n          flow.unsetLocalFlag(local.index, ~0);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.Constant);\n        }\n        if (initExpr) {\n          initializers.push(\n            this.makeLocalAssignment(local, initExpr, initType ? initType : type, false)\n          );\n        } else {\n          // no need to assign zero\n          if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.Wrapped);\n          }\n        }\n      }\n    }\n    this.currentType = Type.void;\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.ConvExplicit | Constraints.WillDrop\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    let module = this.module;\n    let outerFlow = this.currentFlow;\n    let numLocalsBefore = outerFlow.targetFunction.localsByIndex.length;\n\n    // (block $break\n    //  (loop $continue\n    //   (if (condition)\n    //    (then\n    //     (body)\n    //     (br $continue)\n    //    )\n    //   )\n    //  )\n\n    // Cases of interest:\n    // * If the condition is always false, eliminate the body as it never runs\n    // * If the condition is always true and the body never breaks, terminate\n    // * If the body runs but always terminates, continue as if condition was false\n\n    // Compile and evaluate the condition (always executes)\n    let condExpr = this.compileExpression(statement.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, statement.condition);\n    let condKind = this.evaluateCondition(condExprTrueish);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.False) {\n      return module.drop(condExprTrueish);\n    }\n\n    // Compile the body assuming the condition turned out true\n    let thenFlow = outerFlow.forkThen(condExpr, /* newBreakContext */ true);\n    let label = thenFlow.pushControlFlowLabel();\n    let breakLabel = `while-break|${label}`;\n    thenFlow.breakLabel = breakLabel;\n    let continueLabel = `while-continue|${label}`;\n    thenFlow.continueLabel = continueLabel;\n    this.currentFlow = thenFlow;\n    let bodyStmts = new Array<ExpressionRef>();\n    let body = statement.body;\n    if (body.kind == NodeKind.Block) {\n      this.compileStatements((<BlockStatement>body).statements, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n    bodyStmts.push(\n      module.br(continueLabel)\n    );\n    thenFlow.popControlFlowLabel(label);\n\n    let possiblyContinues = thenFlow.isAny(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    let possiblyBreaks = thenFlow.isAny(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    let possiblyFallsThrough = !thenFlow.isAny(FlowFlags.Terminates | FlowFlags.Breaks);\n\n    // Detect if local flags are incompatible before and after looping, and\n    // if so recompile by unifying local flags between iterations. Note that\n    // this may be necessary multiple times where locals depend on each other.\n    let possiblyLoops = possiblyContinues || possiblyFallsThrough;\n    if (possiblyLoops && outerFlow.resetIfNeedsRecompile(thenFlow, numLocalsBefore)) {\n      this.currentFlow = outerFlow;\n      return this.doCompileWhileStatement(statement);\n    }\n\n    // If the condition is always true, the body's effects always happen\n    let alwaysTerminates = false;\n    if (condKind == ConditionKind.True) {\n      outerFlow.inherit(thenFlow);\n\n      // If the body also never breaks, the overall flow terminates\n      if (!possiblyBreaks) {\n        alwaysTerminates = true;\n        outerFlow.set(FlowFlags.Terminates);\n      }\n\n    // Otherwise loop conditionally\n    } else {\n      let elseFlow = outerFlow.forkElse(condExpr);\n      if (!possiblyFallsThrough && !possiblyBreaks) {\n        // Only getting past if condition was false\n        outerFlow.inherit(elseFlow);\n        outerFlow.mergeSideEffects(thenFlow);\n      } else {\n        // Otherwise getting past conditionally\n        outerFlow.inheritAlternatives(thenFlow, elseFlow);\n      }\n    }\n\n    // Finalize and leave everything else to the optimizer\n    this.currentFlow = outerFlow;\n    let stmts: ExpressionRef[] = [\n      module.loop(continueLabel,\n        module.if(condExprTrueish,\n          module.flatten(bodyStmts)\n        )\n      )\n    ];\n    if (alwaysTerminates) stmts.push(module.unreachable());\n    return module.block(breakLabel, stmts);\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.Inlined | CommonFlags.Resolved));\n    let type = element.type;\n    this.currentType = type;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            // @ts-ignore\n            ? <i32>i64_ne(element.constantIntegerValue, i64_zero)\n            : 0\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.Integer\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.Integer\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.Integer\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.Builtin) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.Parenthesized) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.Assertion: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Binary: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Call: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Comma: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ElementAccess: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Function: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.This:\n      case NodeKind.Super:\n      case NodeKind.True: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.InstanceOf: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Literal: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.New: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PropertyAccess: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Ternary: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPostfix: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UnaryPrefix: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.Compiled: {\n        let compiled = <CompiledExpression>expression;\n        expr = compiled.expr;\n        this.currentType = compiled.type;\n        break;\n      }\n      case NodeKind.Class: {\n        // TODO: compile as class expression\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Block-scoped class declarations or expressions\"\n        );\n        expr = this.module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    let currentType = this.currentType;\n    let wrap = (constraints & Constraints.MustWrap) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.ConvExplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = currentType = contextualType;\n      } else if (constraints & Constraints.ConvImplicit) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n\n    if (fromType.kind == TypeKind.Void) {\n      if (toType.kind == TypeKind.Void) {\n        // void to void: Can happen as a result of a foregoing error. Since we\n        // have an `expr` here that is already supposed to be void, return it.\n        return expr;\n      }\n      // void to any\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.Void) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // upcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // downcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeDowncastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    // Early return if we have same types\n    if (toType.kind == fromType.kind) {\n      this.currentType = toType;\n      return expr;\n    }\n\n    // v128 to any / any to v128\n    // except v128 to bool\n    //\n    // NOTE:In case we would have more conversions to and from v128 type it's better\n    // to make these checks more individual and integrate in below flow.\n    if (\n      !toType.isBooleanValue &&\n      (toType.isVectorValue || fromType.isVectorValue)\n    ) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NontrappingF2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.None, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // v128 to bool\n    } else if (fromType == Type.v128 && toType.isBooleanValue) {\n      expr = this.makeIsTrueish(expr, Type.v128, reportNode);\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let inheritedConstraints = constraints & ~(Constraints.ConvImplicit | Constraints.ConvExplicit);\n    switch (expression.assertionKind) {\n      case AssertionKind.Prefix:\n      case AssertionKind.As: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.sourceFunction,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.ConvExplicit);\n      }\n      case AssertionKind.NonNull: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.Literal && (<LiteralExpression>operand).literalKind == LiteralKind.Array) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.Class) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let left = expression.left;\n    let right = expression.right;\n\n    let leftExpr: ExpressionRef;\n    let leftType: Type;\n    let rightExpr: ExpressionRef;\n    let rightType: Type;\n    let commonType: Type | null;\n\n    let expr: ExpressionRef;\n    let compound = false;\n\n    let operator = expression.operator;\n    switch (operator) {\n      case Token.LessThan: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Lt);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonType(leftType, rightType, contextualType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Gt);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonType(leftType, rightType, contextualType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LessThan_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Le);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonType(leftType, rightType, contextualType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GreaterThan_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Ge);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonType(leftType, rightType, contextualType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.Equals_Equals_Equals:\n      case Token.Equals_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Eq);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonType(leftType, rightType, contextualType);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n        if (commonType.isFloatValue) {\n          if (\n            isConstExpressionNaN(module, rightExpr) ||\n            isConstExpressionNaN(module, leftExpr)\n          ) {\n            this.warning(\n              DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n              expression.range\n            );\n          }\n          if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n            this.warning(\n              DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n              expression.range\n            );\n          }\n        }\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Exclamation_Equals_Equals:\n      case Token.Exclamation_Equals: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClass();\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Ne);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonType(leftType, rightType, contextualType);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n        if (commonType.isFloatValue) {\n          if (\n            isConstExpressionNaN(module, rightExpr) ||\n            isConstExpressionNaN(module, leftExpr)\n          ) {\n            this.warning(\n              DiagnosticCode._NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead,\n              expression.range\n            );\n          }\n          if (isConstNegZero(rightExpr) || isConstNegZero(leftExpr)) {\n            this.warning(\n              DiagnosticCode.Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters,\n              expression.range\n            );\n          }\n        }\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Equals: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.Plus_Equals: compound = true;\n      case Token.Plus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Add);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Minus_Equals: compound = true;\n      case Token.Minus: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Sub);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Equals: compound = true;\n      case Token.Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Mul);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Asterisk_Asterisk_Equals: compound = true;\n      case Token.Asterisk_Asterisk: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Pow);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.Slash_Equals: compound = true;\n      case Token.Slash: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Div);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Percent_Equals: compound = true;\n      case Token.Percent: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Rem);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LessThan_LessThan_Equals: compound = true;\n      case Token.LessThan_LessThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShl);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: compound = true;\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseShrU);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.Ampersand_Equals: compound = true;\n      case Token.Ampersand: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseAnd);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Bar_Equals: compound = true;\n      case Token.Bar: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseOr);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.Caret_Equals: compound = true;\n      case Token.Caret: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseXor);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.ConvImplicit);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.Ampersand_Ampersand: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.forkThen(leftExpr);\n        this.currentFlow = rightFlow;\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always false\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.False) {\n            expr = leftExpr;\n            // RHS is not compiled\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always true\n            if (condKind == ConditionKind.True) {\n              expr = rightExpr;\n              flow.inherit(rightFlow); // true && RHS -> RHS always executes\n            } else {\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\n              flow.mergeBranch(rightFlow); // LHS && RHS -> RHS conditionally executes\n              flow.noteThen(expr, rightFlow); // LHS && RHS == true -> RHS always executes\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, this.currentType, left),\n              rightExpr,\n              expr\n            );\n\n          // if not possible, tee left to a temp\n          } else {\n            let tempLocal = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\n              rightExpr,\n              module.local_get(tempLocal.index, leftType.toRef())\n            );\n          }\n          flow.mergeBranch(rightFlow); // LHS && RHS -> RHS conditionally executes\n          flow.noteThen(expr, rightFlow); // LHS && RHS == true -> RHS always executes\n          this.currentFlow = flow;\n          this.currentType = commonType;\n        }\n        break;\n      }\n      case Token.Bar_Bar: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MustWrap;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.forkElse(leftExpr);\n        this.currentFlow = rightFlow;\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always true\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.True) {\n            expr = leftExpr;\n            // RHS is not compiled\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always false\n            if (condKind == ConditionKind.False) {\n              expr = rightExpr;\n              flow.inherit(rightFlow); // false || RHS -> RHS always executes\n            } else {\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\n              flow.mergeBranch(rightFlow); // LHS || RHS -> RHS conditionally executes\n              flow.noteElse(expr, rightFlow); // LHS || RHS == false -> RHS always executes\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          commonType = Type.commonType(leftType, rightType, contextualType);\n          if (!commonType) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"||\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          let possiblyNull = leftType.is(TypeFlags.Nullable) && rightType.is(TypeFlags.Nullable);\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              expr,\n              rightExpr\n            );\n\n          // if not possible, tee left to a temp. local\n          } else {\n            let temp = flow.getTempLocal(leftType);\n            let tempIndex = temp.index;\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempIndex, leftExpr, leftType.isManaged), leftType, left),\n              module.local_get(tempIndex, leftType.toRef()),\n              rightExpr\n            );\n          }\n          flow.mergeBranch(rightFlow); // LHS || RHS -> RHS conditionally executes\n          flow.noteElse(expr, rightFlow); // LHS || RHS == false -> RHS always executes\n          this.currentFlow = flow;\n          this.currentType = possiblyNull\n            ? commonType\n            : commonType.nonNullableType;\n        }\n        break;\n      }\n      case Token.In: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"'in' operator\"\n        );\n        this.currentType = Type.bool;\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    let targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GtISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GtUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.LeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.LeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.GeISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.GeUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.EqSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref: return module.ref_eq(leftExpr, rightExpr);\n      case TypeKind.Stringref: return module.string_eq(leftExpr, rightExpr);\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.NeSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref: {\n        return module.unary(UnaryOp.EqzI32,\n          module.ref_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.Stringref: {\n        return module.unary(UnaryOp.EqzI32,\n          module.string_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter:\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AddSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.SubSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.MulSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr,\n          TypeRef.I32\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueI32(leftExpr);\n            let rightValue = getConstValueI32(rightExpr);\n            this.currentType = type;\n            return module.i32(i64_low(i64_pow(\n              i64_new(leftValue),\n              i64_new(rightValue)\n            )));\n          }\n        }\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n            let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n            let result = i64_pow(leftValue, rightValue);\n            this.currentType = type;\n            return module.i64(i64_low(result), i64_high(result));\n          }\n        }\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = this.options.isWasm64;\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr) == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            if (isWasm64) {\n              let leftValue  = i64_new(getConstValueI64Low(leftExpr), getConstValueI64High(leftExpr));\n              let rightValue = i64_new(getConstValueI64Low(rightExpr), getConstValueI64High(rightExpr));\n              let result = i64_pow(leftValue, rightValue);\n              this.currentType = type;\n              return module.i64(i64_low(result), i64_high(result));\n            } else {\n              let leftValue  = getConstValueI32(leftExpr);\n              let rightValue = getConstValueI32(rightExpr);\n              this.currentType = type;\n              return module.i32(i64_low(i64_pow(\n                i64_new(leftValue),\n                i64_new(rightValue)\n              )));\n            }\n          }\n        }\n        let instance = isWasm64\n          ? this.i64PowInstance\n          : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(isWasm64\n            ? CommonNames.ipow64\n            : CommonNames.ipow32\n          );\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF32(leftExpr);\n            let rightValue = getConstValueF32(rightExpr);\n            this.currentType = type;\n            return module.f32(f32(accuratePow64(leftValue, rightValue)));\n          }\n        }\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.pow);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        if (this.options.willOptimize) {\n          // Precompute power if LHS and RHS constants\n          // TODO: move this optimization to AIR\n          if (\n            getExpressionId(leftExpr)  == ExpressionId.Const &&\n            getExpressionId(rightExpr) == ExpressionId.Const\n          ) {\n            let leftValue  = getConstValueF64(leftExpr);\n            let rightValue = getConstValueF64(rightExpr);\n            this.currentType = type;\n            return module.f64(accuratePow64(leftValue, rightValue));\n          }\n        }\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.pow);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.DivISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.DivUSize, leftExpr, rightExpr);\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.RemISize, leftExpr, rightExpr);\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        leftExpr  = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.RemUSize, leftExpr, rightExpr);\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.mod);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let prototype = namespace.getMember(CommonNames.mod);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FunctionPrototype);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShlSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      case TypeKind.I64: return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      case TypeKind.Isize: return module.binary(BinaryOp.ShrISize, leftExpr, rightExpr);\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(\n            BinaryOp.AndI32,\n            rightExpr,\n            module.i32(type.size - 1)\n          )\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.ShrUSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.AndSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.OrSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.XorSize, leftExpr, rightExpr);\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    let rightType: Type;\n    let signature = operatorInstance.signature;\n    let parameterTypes = signature.parameterTypes;\n    if (operatorInstance.is(CommonFlags.Instance)) {\n      leftExpr = this.convertExpression(leftExpr, leftType, assert(signature.thisType), false, left);\n      rightType = parameterTypes[0];\n    } else {\n      leftExpr = this.convertExpression(leftExpr, leftType, parameterTypes[0], false, left);\n      rightType = parameterTypes[1];\n    }\n    let rightExpr = this.compileExpression(right, rightType, Constraints.ConvImplicit);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    let program = this.program;\n    let resolver = program.resolver;\n    let flow = this.currentFlow;\n    let target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    let elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    let targetType: Type;\n    switch (target.kind) {\n      case ElementKind.Global: {\n        if (!this.compileGlobalLazy(<Global>target, expression)) {\n          return this.module.unreachable();\n        }\n        // fall-through\n      }\n      case ElementKind.Local: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          if (this.pendingElements.has(target)) {\n            this.error(\n              DiagnosticCode.Variable_0_used_before_its_declaration,\n              expression.range,\n              target.internalName\n            );\n            return this.module.unreachable();\n          }\n        }\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.IndexSignature: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        let parameterTypes = indexedSet.signature.parameterTypes;\n\n        assert(parameterTypes.length == 2); // parser must guarantee this\n        targetType = parameterTypes[1];     // 2nd parameter is the element\n\n        if (indexedSet.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          expression.range, target.internalName\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    let valueExpr = this.compileExpression(valueExpression, targetType);\n    let valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.Constant, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobalLazy(global, valueExpression)) {\n          return module.unreachable();\n        }\n        if (target.isAny(CommonFlags.Const | CommonFlags.Readonly)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          // Cannot assign to readonly fields except in constructors if there's no initializer\n          let isConstructor = flow.sourceFunction.is(CommonFlags.Constructor);\n          if (propertyInstance.is(CommonFlags.Readonly)) {\n            let initializerNode = propertyInstance.initializerNode;\n            if (!isConstructor || initializerNode) {\n              this.error(\n                DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n                valueExpression.range, propertyInstance.internalName\n              );\n              return module.unreachable();\n            }\n          }\n          // Mark initialized fields in constructors\n          thisExpression = assert(thisExpression);\n          if (isConstructor && thisExpression.kind == NodeKind.This) {\n            flow.setThisFieldFlag(propertyInstance, FieldFlags.Initialized);\n          }\n        }\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        if (propertyInstance.is(CommonFlags.Instance)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let returnTypeRef = returnType.toRef();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, returnTypeRef)\n            ], valueExpression)\n          ], returnTypeRef);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toRef());\n        }\n      }\n      case ElementKind.IndexSignature: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.Class);\n        let isUnchecked = flow.is(FlowFlags.UncheckedContext);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let thisType = classInstance.type;\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          thisType,\n          Constraints.ConvImplicit | Constraints.IsThis\n        );\n        let setterIndexType = setterInstance.signature.parameterTypes[0];\n        let getterIndexType = getterInstance.signature.parameterTypes[0];\n        if (!setterIndexType.equals(getterIndexType)) {\n          this.errorRelated(\n            DiagnosticCode.Index_signature_accessors_in_type_0_differ_in_types,\n            getterInstance.identifierAndSignatureRange,\n            setterInstance.identifierAndSignatureRange,\n            classInstance.internalName,\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        let elementExpr = this.compileExpression(assert(indexExpression), setterIndexType, Constraints.ConvImplicit);\n        let elementType = this.currentType;\n        if (tee) {\n          let tempTarget = flow.getTempLocal(thisType);\n          let tempElement = flow.getTempLocal(elementType);\n          let returnType = getterInstance.signature.returnType;\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\n              module.local_get(tempElement.index, tempElement.type.toRef())\n            ], valueExpression)\n          ], returnType.toRef());\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n      default: {\n        this.error(\n          DiagnosticCode.The_target_of_an_assignment_must_be_a_variable_or_a_property_access,\n          valueExpression.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let type = local.type;\n    assert(type != Type.void);\n    let localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NonNull);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NonNull);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.Initialized);\n    if (type.isShortIntegerValue) {\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.Wrapped);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.Wrapped);\n    }\n    if (tee) { // local = value\n      this.currentType = type;\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\n    } else { // void(local = value)\n      this.currentType = Type.void;\n      return module.local_set(localIndex, valueExpr, type.isManaged);\n    }\n  }\n\n  /** Makes an assignment to a global. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    let module = this.module;\n    let type = global.type;\n    assert(type != Type.void);\n    let typeRef = type.toRef();\n\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n    if (tee) { // (global = value), global\n      this.currentType = type;\n      return module.block(null, [\n        module.global_set(global.internalName, valueExpr),\n        module.global_get(global.internalName, typeRef) // known to be assigned now\n      ], typeRef);\n    } else { // global = value\n      this.currentType = Type.void;\n      return module.global_set(global.internalName,\n        valueExpr\n      );\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.Super) {\n      let flow = this.currentFlow;\n      let sourceFunction = flow.sourceFunction;\n      if (!sourceFunction.is(CommonFlags.Constructor)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(sourceFunction.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let baseClassInstance = classInstance.base;\n      if (!baseClassInstance || classInstance.prototype.implicitlyExtendsObject) {\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.expression.range\n        );\n        return module.unreachable();\n      }\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let sizeTypeRef = this.options.sizeTypeRef;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, sizeTypeRef)\n      );\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.AccessesThis |\n        FlowFlags.ConditionallyAccessesThis\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.AccessesThis | FlowFlags.CallsSuper);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\n    }\n\n    // otherwise resolve normally\n    let target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = this.resolver.currentThisExpression;\n\n    // handle direct call\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.Builtin)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n    }\n\n    // handle indirect call\n    let functionArg = this.compileExpression(expression.expression, Type.auto);\n    let signature = this.currentType.getSignature();\n    if (signature) {\n      return this.compileCallIndirect(\n        signature,\n        functionArg,\n        expression.args,\n        expression,\n        0,\n        contextualType == Type.void\n      );\n    }\n    this.error(\n      DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n      expression.range, this.currentType.toString()\n    );\n    if (target.kind == ElementKind.PropertyPrototype) {\n      let getterPrototype = (<PropertyPrototype>target).getterPrototype;\n      if (getterPrototype) {\n        this.infoRelated(\n          DiagnosticCode.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without,\n          expression.range, getterPrototype.identifierNode.range\n        );\n      }\n    }\n    return module.unreachable();\n  }\n\n  /** Compiles the given arguments like a call expression according to the specified context. */\n  private compileCallExpressionLike(\n    /** Called expression. */\n    expression: Expression,\n    /** Call type arguments. */\n    typeArguments: TypeNode[] | null,\n    /** Call arguments. */\n    args: Expression[],\n    /** Diagnostic range. */\n    range: Range,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\n    let call = this._reusableCallExpression;\n    if (call) {\n      call.expression = expression;\n      call.typeArguments = typeArguments;\n      call.args = args;\n      call.range = range;\n    } else {\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\n    }\n    return this.compileCallExpression(call, contextualType, constraints);\n  }\n  private _reusableCallExpression: CallExpression | null = null;\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    let typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.sourceFunction.parent,\n        cloneMap(this.currentFlow.contextualTypeArguments), // don't update\n        expression\n      );\n    }\n    let callee = expression.expression;\n    let ctx = new BuiltinFunctionContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PropertyAccess\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    let internalName: string;\n    if (prototype.is(CommonFlags.Instance)) {\n      // omit generic name components, e.g. in `Function<...>#call`\n      let parent = assert(prototype.getBoundClassOrInterface());\n      internalName = `${parent.prototype.internalName}#${prototype.name}`;\n    } else {\n      internalName = prototype.internalName;\n    }\n    assert(builtinFunctions.has(internalName)); // checked earlier\n    let fn = assert(builtinFunctions.get(internalName));\n    return fn(ctx);\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    let thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    let hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range, \"Rest parameters\"\n      );\n      return false;\n    }\n\n    let minimum = signature.requiredParameters;\n    let maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.None\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n    let signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let sourceFunction = this.currentFlow.sourceFunction;\n    if (sourceFunction.is(CommonFlags.Constructor) && reportNode.isAccessOnThis) {\n      let parent = sourceFunction.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.Inline) && (!instance.is(CommonFlags.Overridden) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions *before* pushing to the inline stack\n        // otherwise, the arguments may not be inlined, e.g. `abc(abc(123))`\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.ConvImplicit);\n        }\n        // make the inlined call\n        inlineStack.push(instance);\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WillDrop) != 0);\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      let paramType = parameterTypes[i];\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.ConvImplicit);\n      operands[index] = paramExpr;\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WillDrop) != 0);\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    let numArguments = operands ? operands.length : 0;\n    let signature = instance.signature;\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    let previousFlow = this.currentFlow;\n    let flow = Flow.createInline(previousFlow.targetFunction, instance);\n    let body = [];\n\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.Class);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType);\n      body.push(\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\n      );\n      flow.setLocalFlag(thisLocal.index, LocalFlags.Initialized);\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n    for (let i = 0; i < numArguments; ++i) {\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.Wrapped);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NonNull);\n      body.push(\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\n      );\n      flow.setLocalFlag(argumentLocal.index, LocalFlags.Initialized);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    let isConstructor = instance.is(CommonFlags.Constructor);\n    if (isConstructor) flow.set(FlowFlags.CtorParamContext);\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.ConvImplicit\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      body.push(\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\n      );\n    }\n    flow.unset(FlowFlags.CtorParamContext);\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (isConstructor) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.Class);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    let returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    this.currentType = returnType;\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): string {\n    let name = BuiltinNames.argumentsLength;\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\n    }\n    return name;\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    let stub = original.varargsStub;\n    if (stub) return stub;\n\n    let originalSignature = original.signature;\n    let originalParameterTypes = originalSignature.parameterTypes;\n    let originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    let returnType = originalSignature.returnType;\n    let isInstance = original.is(CommonFlags.Instance);\n\n    // arguments excl. `this`, operands incl. `this`\n    let minArguments = originalSignature.requiredParameters;\n    let minOperands = minArguments;\n    let maxArguments = originalParameterTypes.length;\n    let maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    let numOptional = assert(maxOperands - minOperands);\n\n    let forwardedOperands = new Array<ExpressionRef>(minOperands);\n    let operandIndex = 0;\n    let stmts = new Array<ExpressionRef>();\n\n    // forward `this` if applicable\n    let module = this.module;\n    let thisType = originalSignature.thisType;\n    if (thisType) {\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      let paramType = originalParameterTypes[i];\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\", maxArguments);\n\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    let previousFlow = this.currentFlow;\n    let flow = stub.flow;\n    if (original.is(CommonFlags.Constructor)) flow.set(FlowFlags.CtorParamContext);\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    let numNames = numOptional + 1; // incl. outer block\n    let names = new Array<string>(numNames);\n    let ofN = `of${numOptional}`;\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = `${i}${ofN}`;\n    }\n    let argumentsLength = this.ensureArgumentsLength();\n    let table = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(argumentsLength, TypeRef.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(argumentsLength, TypeRef.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = this.compileExpression(\n          initializer,\n          type,\n          Constraints.ConvImplicit\n        );\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      table = module.block(names[i + 1], [\n        table,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\n    }\n    assert(operandIndex == maxOperands);\n\n    stmts.push(\n      table\n    );\n    stmts.push(\n      // assume this will always succeed (can just use name as the reportNode)\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\n    );\n    this.currentFlow = previousFlow;\n\n    let funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      typesToRefs(stub.getNonParameterLocalTypes()),\n      module.flatten(stmts, returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the override stub for the specified function. */\n  ensureOverrideStub(original: Function): Function {\n    // An override stub is a function redirecting virtual calls to the actual\n    // override targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    let stub = original.overrideStub;\n    if (stub) return stub;\n    stub = original.newStub(\"override\");\n    original.overrideStub = stub;\n    let module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      null,\n      module.unreachable()\n    );\n    this.overrideStubs.add(original);\n    return stub;\n  }\n\n  /** Finalizes the override stub of the specified function. */\n  private finalizeOverrideStub(instance: Function): void {\n    let stub = this.ensureOverrideStub(instance);\n    if (stub.is(CommonFlags.Compiled)) return;\n\n    assert(instance.parent.kind == ElementKind.Class || instance.parent.kind == ElementKind.Interface);\n    let module = this.module;\n    let usizeType = this.options.usizeType;\n    let sizeTypeRef = usizeType.toRef();\n    let parameterTypes = instance.signature.parameterTypes;\n    let returnType = instance.signature.returnType;\n    let numParameters = parameterTypes.length;\n    let tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    let builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, sizeTypeRef),\n          sizeTypeRef == TypeRef.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        TypeRef.I32\n      )\n    );\n    let overrideInstances = this.resolver.resolveOverrides(instance);\n    if (overrideInstances) {\n      for (let i = 0, k = overrideInstances.length; i < k; ++i) {\n        let overrideInstance = overrideInstances[i];\n        if (!overrideInstance.is(CommonFlags.Compiled)) continue; // errored\n        let overrideType = overrideInstance.type;\n        let originalType = instance.type;\n        if (!overrideType.isAssignableTo(originalType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            overrideInstance.identifierNode.range, overrideType.toString(), originalType.toString()\n          );\n          continue;\n        }\n        // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n        let overrideSignature = overrideInstance.signature;\n        let overrideParameterTypes = overrideSignature.parameterTypes;\n        let overrideNumParameters = overrideParameterTypes.length;\n        let paramExprs = new Array<ExpressionRef>(1 + overrideNumParameters);\n        paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n        for (let n = 1; n <= numParameters; ++n) {\n          paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\n        }\n        let needsVarargsStub = false;\n        for (let n = numParameters; n < overrideNumParameters; ++n) {\n          // TODO: inline constant initializers and skip varargs stub\n          paramExprs[1 + n] = this.makeZero(overrideParameterTypes[n]);\n          needsVarargsStub = true;\n        }\n        let calledName = needsVarargsStub\n          ? this.ensureVarargsStub(overrideInstance).internalName\n          : overrideInstance.internalName;\n        let returnTypeRef = overrideSignature.returnType.toRef();\n        let stmts = new Array<ExpressionRef>();\n        if (needsVarargsStub) {\n          // Safe to prepend since paramExprs are local.get's\n          stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\n        }\n        if (returnType == Type.void) {\n          stmts.push(\n            module.call(calledName, paramExprs, returnTypeRef)\n          );\n          stmts.push(\n            module.return()\n          );\n        } else {\n          stmts.push(\n            module.return(\n              module.call(calledName, paramExprs, returnTypeRef)\n            )\n          );\n        }\n        let classInstance = assert(overrideInstance.getBoundClassOrInterface());\n        builder.addCase(classInstance.id, stmts);\n        // Also alias each extender inheriting this exact overload\n        let extenders = classInstance.extenders;\n        if (extenders) {\n          for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n            let extender = _values[i];\n            let instanceMembers = extender.prototype.instanceMembers;\n            if (instanceMembers && instanceMembers.has(instance.declaration.name.text)) {\n              continue; // skip those not inheriting\n            }\n            builder.addCase(extender.id, stmts);\n          }\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extenders inheriting the original function.\n    let body: ExpressionRef;\n    let instanceClass = instance.getBoundClassOrInterface();\n    if (!instance.is(CommonFlags.Abstract) && !(instanceClass && instanceClass.kind == ElementKind.Interface)) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the stub function\n    let ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      [ TypeRef.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toRef())\n    );\n    stub.set(CommonFlags.Compiled);\n  }\n\n  /** Marks managed call operands for the shadow stack. */\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\n    if (!this.options.stackSize) return;\n    let module = this.module;\n    let operandIndex = 0;\n    let thisType = signature.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        let operand = operands[0];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n    }\n    let parameterIndex = 0;\n    let parameterTypes = signature.parameterTypes;\n    assert(parameterTypes.length >= operands.length - operandIndex);\n    while (operandIndex < operands.length) {\n      let paramType = parameterTypes[parameterIndex];\n      if (paramType.isManaged) {\n        let operand = operands[operandIndex];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n      ++parameterIndex;\n    }\n  }\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.Inline)) {\n      if (!instance.is(CommonFlags.Overridden)) {\n        assert(!instance.is(CommonFlags.Stub)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.Instance)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = instance.signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = instance.signature.parameterTypes;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (instance.is(CommonFlags.Instance)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    let returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.ConvImplicit\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.Swallow);\n          if (resolved && resolved.kind == ElementKind.Global) {\n            let global = <Global>resolved;\n            if (this.compileGlobalLazy(global, initializer) && global.is(CommonFlags.Inlined)) {\n              operands.push(\n                this.compileInlineConstant(global, parameterTypes[i], Constraints.ConvImplicit)\n              );\n              continue;\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i]));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.ModuleImport)) {\n        let original = instance;\n        instance = this.ensureVarargsStub(instance);\n        if (!this.compileFunction(instance)) return module.unreachable();\n        instance.flow.flags = original.flow.flags;\n        let returnTypeRef = returnType.toRef();\n        // We know the last operand is optional and omitted, so inject setting\n        // ~argumentsLength into that operand, which is always safe.\n        let lastOperand = operands[maxOperands - 1];\n        assert(!(getSideEffects(lastOperand, module.ref) & SideEffects.WritesGlobal));\n        let lastOperandType = parameterTypes[maxArguments - 1];\n        operands[maxOperands - 1] = module.block(null, [\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\n          lastOperand\n        ], lastOperandType.toRef());\n        this.operandsTostack(instance.signature, operands);\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\n        if (returnType != Type.void && immediatelyDropped) {\n          expr = module.drop(expr);\n          this.currentType = Type.void;\n        } else {\n          this.currentType = returnType;\n        }\n        return expr;\n      }\n    }\n\n    // Call the override stub if the function has overloads\n    if (instance.is(CommonFlags.Overridden) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureOverrideStub(instance);\n    }\n\n    if (operands) this.operandsTostack(instance.signature, operands);\n    let expr = module.call(instance.internalName, operands, returnType.toRef());\n    this.currentType = returnType;\n    return expr;\n  }\n\n  /** Compiles an indirect call to a first-class function. */\n  compileCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    let numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    let numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    let operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    let index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    let parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.ConvImplicit\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to a first-class function. */\n  makeCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    let module = this.module;\n    let numOperands = operands ? operands.length : 0;\n    let numArguments = numOperands;\n    let minArguments = signature.requiredParameters;\n    let minOperands = minArguments;\n    let parameterTypes = signature.parameterTypes;\n    let returnType = signature.returnType;\n    let maxArguments = parameterTypes.length;\n    let maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i]));\n      }\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    let argumentsLength = this.ensureArgumentsLength();\n    let sizeTypeRef = this.options.sizeTypeRef;\n    if (getSideEffects(functionArg, module.ref) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType);\n      let tempIndex = temp.index;\n      functionArg = module.block(null, [\n        module.local_set(tempIndex, functionArg, true), // Function\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        module.local_get(tempIndex, sizeTypeRef)\n      ], sizeTypeRef);\n    } else { // simplify\n      functionArg = module.block(null, [\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        functionArg\n      ], sizeTypeRef);\n    }\n    if (operands) this.operandsTostack(signature, operands);\n    let expr = module.call_indirect(\n      null, // TODO: handle multiple tables\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\n      operands,\n      signature.paramRefs,\n      signature.resultRefs\n    );\n    this.currentType = returnType;\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    let exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.ConvImplicit | Constraints.WillDrop\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toRef());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let targetExpression = expression.expression;\n    let targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UncheckedContext);\n        let indexedGet = classReference.lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.ConvImplicit\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n    let isNamed = declaration.name.text.length > 0;\n    let isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\n    let prototype = new FunctionPrototype(\n      isSemanticallyAnonymous\n        ? `${isNamed ? declaration.name.text : \"anonymous\"}|${sourceFunction.nextAnonymousId++}`\n        : declaration.name.text,\n      sourceFunction,\n      declaration,\n      DecoratorFlags.None\n    );\n    let instance: Function | null;\n    let contextualTypeArguments = cloneMap(flow.contextualTypeArguments);\n    let module = this.module;\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    let contextualSignature = contextualType.signatureReference;\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            sourceFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          sourceFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      let signature = Signature.create(this.program, parameterTypes, returnType, thisType, numParameters);\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = contextualSignature.type;\n      if (!worked) return module.unreachable();\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n      if (!worked) return module.unreachable();\n    }\n\n    let offset = this.ensureRuntimeFunction(instance); // reports\n    let expr = this.options.isWasm64\n      ? module.i64(i64_low(offset), i64_high(offset))\n      : module.i32(i64_low(offset));\n\n    // add a constant local referring to the function if applicable\n    if (!isSemanticallyAnonymous) {\n      let fname = instance.name;\n      let existingLocal = flow.getScopedLocal(fname);\n      if (existingLocal) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existingLocal.declaration.name.range,\n            fname\n          );\n        } else { // scoped locals are shared temps that don't track declarations\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range, fname\n          );\n        }\n      } else {\n        let ftype = instance.type;\n        let local = flow.addScopedLocal(instance.name, ftype);\n        flow.setLocalFlag(local.index, LocalFlags.Constant | LocalFlags.Initialized);\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\n      }\n    }\n\n    return expr;\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    let internalPath = expression.range.source.internalPath;\n    let filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    let enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.Compiled)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let sourceFunction = flow.sourceFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.Null: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.True: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.False: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.This: {\n        let thisType = sourceFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          }\n          if (!(constraints & Constraints.IsThis)) {\n            let parent = sourceFunction.parent;\n            assert(parent.kind == ElementKind.Class);\n            this.checkFieldInitialization(<Class>parent, expression);\n          }\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.AccessesThis);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toRef());\n      }\n      case NodeKind.Super: {\n        if (sourceFunction.is(CommonFlags.Constructor)) {\n          if (flow.is(FlowFlags.CtorParamContext)) {\n            this.error(\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          } else if (!flow.is(FlowFlags.CallsSuper)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toRef());\n            }\n          }\n        }\n        if (sourceFunction.is(CommonFlags.Instance)) {\n          let parent = assert(sourceFunction.parent);\n          assert(parent.kind == ElementKind.Class);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toRef());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    let currentParent = this.currentParent;\n    if (!currentParent) currentParent = sourceFunction;\n    let target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.Local: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        if (!flow.isLocalFlag(localIndex, LocalFlags.Initialized)) {\n          this.error(\n            DiagnosticCode.Variable_0_is_used_before_being_assigned,\n            expression.range, local.name\n          );\n        }\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NonNull, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.targetFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toRef());\n      }\n      case ElementKind.Global: {\n        let global = <Global>target;\n        if (!this.compileGlobalLazy(global, expression)) {\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.hasDecorator(DecoratorFlags.Builtin)) {\n          return this.compileIdentifierExpressionBuiltin(global, expression, contextualType);\n        }\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        let expr = module.global_get(global.internalName, globalType.toRef());\n        if (global.is(CommonFlags.DefinitelyAssigned) && globalType.isReference && !globalType.isNullableReference) {\n          expr = this.makeRuntimeNonNullCheck(expr, globalType, expression);\n        }\n        this.currentType = globalType;\n        return expr;\n      }\n      case ElementKind.EnumValue: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.Compiled)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            expression.range\n          );\n          break; // also diagnose 'not a value at runtime'\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          cloneMap(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (functionInstance.hasDecorator(DecoratorFlags.Builtin)) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range, \"First-class built-ins\"\n          );\n          this.currentType = functionInstance.type;\n          return module.unreachable();\n        }\n        if (contextualType.isExternalReference) {\n          // TODO: Concrete function types currently map to first class functions implemented in\n          // linear memory (on top of `usize`), leaving only generic `funcref` for use here. In the\n          // future, once functions become Wasm GC objects, the actual signature type can be used.\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName, ensureType(functionInstance.type));\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return module.unreachable();\n  }\n\n  private compileIdentifierExpressionBuiltin(\n    element: VariableLikeElement,\n    expression: IdentifierExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (element.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression, element.identifierNode);\n    let internalName = element.internalName;\n    assert(builtinVariables_onAccess.has(internalName)); // checked earlier\n    let fn = assert(builtinVariables_onAccess.get(internalName));\n    return fn(new BuiltinVariableContext(\n      this,\n      element,\n      contextualType,\n      expression\n    ));\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let flow = this.currentFlow;\n    let isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NamedType) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.sourceFunction, ReportMode.Swallow);\n        if (element && element.kind == ElementKind.ClassPrototype) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.Generic)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    let expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.sourceFunction,\n      cloneMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let expr = this.compileExpression(expression.expression, expectedType);\n    let actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    let sizeTypeRef = actualType.toRef();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // same or upcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType)\n        );\n      }\n\n      // potential downcast - check dynamically\n      if (actualType.nonNullableType.hasSubtypeAssignableTo(expectedType)) {\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          return module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            module.call(this.prepareInstanceOf(expectedType.classReference!), [\n              module.local_get(tempIndex, sizeTypeRef)\n            ], TypeRef.I32)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // same or upcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n      }\n\n      // potential downcast - check dynamically\n      if (actualType.hasSubtypeAssignableTo(expectedType)) {\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let tempIndex = temp.index;\n          return module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(tempIndex, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            module.call(this.prepareInstanceOf(expectedType.classReference!), [\n              module.local_get(tempIndex, sizeTypeRef)\n            ], TypeRef.I32)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  /** Prepares the instanceof helper for the given class or interface instance. */\n  private prepareInstanceOf(instance: Class): string {\n    let name = `~instanceof|${instance.internalName}`;\n    let pending = this.pendingInstanceOf;\n    if (pending.has(instance)) return assert(pending.get(instance));\n    pending.set(instance, name);\n    let module = this.module;\n    module.addFunction(name, this.options.sizeTypeRef, TypeRef.I32, null,\n      module.unreachable()\n    );\n    return name;\n  }\n\n  /** Finalizes the instanceof helper of the given class or interface instance. */\n  private finalizeInstanceOf(\n    /** Class to finalize the helper for. */\n    instance: Class,\n    /** Name of the helper function. */\n    name: string\n  ): void {\n    let program = this.program;\n    let module = this.module;\n    let sizeType = this.options.sizeTypeRef;\n    let stmts = new Array<ExpressionRef>();\n    // (block $is_instance\n    //  (local.set $1 (i32.load (...))) ;; class id\n    //  (br_if $is_instance (i32.eq (local.get $1) (ID)))\n    //  ...\n    //  (return (i32.const 0))\n    // )\n    // (i32.const 1)\n    stmts.push(\n      module.local_set(1,\n        module.load(4, false,\n          module.binary(\n            sizeType == TypeRef.I64\n              ? BinaryOp.SubI64\n              : BinaryOp.SubI32,\n            module.local_get(0, sizeType),\n            module.i32(\n              program.totalOverhead - program.OBJECTInstance.offsetof(\"rtId\")\n            )\n          ),\n          TypeRef.I32\n        ), false // managedness is irrelevant here, isn't interrupted\n      )\n    );\n    let allInstances: Set<Class> | null;\n    if (instance.isInterface) {\n      allInstances = instance.implementers;\n    } else {\n      allInstances = new Set();\n      allInstances.add(instance);\n      let extenders = instance.extenders;\n      if (extenders) {\n        for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n          let extender = _values[i];\n          allInstances.add(extender);\n        }\n      }\n    }\n    if (allInstances) {\n      for (let _values = Set_values(allInstances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        stmts.push(\n          module.br(\"is_instance\",\n            module.binary(BinaryOp.EqI32,\n              module.local_get(1, TypeRef.I32),\n              module.i32(instance.id)\n            )\n          )\n        );\n      }\n    }\n    stmts.push(\n      module.return(\n        module.i32(0)\n      )\n    );\n    stmts[0] = module.block(\"is_instance\", stmts, TypeRef.None);\n    stmts.length = 1;\n    stmts.push(\n      module.i32(1)\n    ); \n    module.removeFunction(name);\n    module.addFunction(name, sizeType, TypeRef.I32, [ TypeRef.I32 ], module.block(null, stmts, TypeRef.I32));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    let module = this.module;\n    let expr = this.compileExpression(expression.expression, Type.auto);\n    let actualType = this.currentType;\n    let sizeTypeRef = actualType.toRef();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    let classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extendsPrototype(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            sizeTypeRef == TypeRef.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        let flow = this.currentFlow;\n        let temp = flow.getTempLocal(actualType);\n        let tempIndex = temp.index;\n        // !(t = expr) ? 0 : anyinstanceof(t)\n        return module.if(\n          module.unary(\n            sizeTypeRef == TypeRef.I64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(tempIndex, expr, actualType.isManaged),\n          ),\n          module.i32(0),\n          module.call(this.prepareAnyInstanceOf(prototype), [\n            module.local_get(tempIndex, sizeTypeRef)\n          ], TypeRef.I32)\n        );\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  /** Prepares the instanceof helper for the given class or interface prototype. */\n  private prepareAnyInstanceOf(prototype: ClassPrototype): string {\n    let name = `~anyinstanceof|${prototype.internalName}`;\n    let pending = this.pendingInstanceOf;\n    if (pending.has(prototype)) return assert(pending.get(prototype));\n    pending.set(prototype, name);\n    let module = this.module;\n    module.addFunction(name, this.options.sizeTypeRef, TypeRef.I32, null,\n      module.unreachable()\n    );\n    return name;\n  }\n\n  /** Finalizes the instanceof helper of the given class prototype. */\n  private finalizeAnyInstanceOf(prototype: ClassPrototype, name: string): void {\n    let module = this.module;\n    let sizeType = this.options.sizeTypeRef;\n    let stmts = new Array<ExpressionRef>();\n    let instances = prototype.instances;\n    // (block $is_instance\n    //  (local.set $1 (i32.load(...)))\n    //  (br_if $is_instance (i32.eq (local.get $1) (ID))\n    //  ...\n    //  (return (i32.const 0))\n    // )\n    // (i32.const 1)\n    if (instances) {\n      let program = this.program;\n      stmts.push(\n        module.local_set(1,\n          module.load(4, false,\n            module.binary(\n              sizeType == TypeRef.I64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              module.local_get(0, sizeType),\n              module.i32(\n                program.totalOverhead - program.OBJECTInstance.offsetof(\"rtId\")\n              )\n            ),\n            TypeRef.I32\n          ), false // managedness is irrelevant here, isn't interrupted\n        )\n      );\n      let allInstances = new Set<Class>();\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        if (instance.isInterface) {\n          let implementers = instance.implementers;\n          if (implementers) {\n            for (let _values = Set_values(implementers), i = 0, k = _values.length; i < k; ++i) {\n              let implementer = _values[i];\n              allInstances.add(implementer);\n            }\n          }\n        } else {\n          allInstances.add(instance);\n          let extenders = instance.extenders;\n          if (extenders) {\n            for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n              let extender = _values[i];\n              allInstances.add(extender);\n            }\n          }\n        }\n      }\n      for (let _values = Set_values(allInstances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = _values[i];\n        stmts.push(\n          module.br(\"is_instance\",\n            module.binary(BinaryOp.EqI32,\n              module.local_get(1, TypeRef.I32),\n              module.i32(instance.id)\n            )\n          )\n        );\n      }\n    }\n    stmts.push(\n      module.return(\n        module.i32(0)\n      )\n    );\n    stmts[0] = module.block(\"is_instance\", stmts, TypeRef.None);\n    stmts.length = 1;\n    stmts.push(\n      module.i32(1)\n    );\n    module.removeFunction(name);\n    module.addFunction(name, sizeType, TypeRef.I32, [ TypeRef.I32 ], module.block(null, stmts, TypeRef.I32));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    let module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.Array: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.Float: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.Integer: {\n        let expr = <IntegerLiteralExpression>expression;\n        let type = this.resolver.determineIntegerLiteralType(expr, implicitlyNegate, contextualType);\n        this.currentType = type;\n        let intValue = expr.value;\n        let sign = 1.0; // should multiply for float literals\n        if (implicitlyNegate) {\n          if (type.isFloatValue) {\n            sign = -1.0;\n          } else {\n            intValue = i64_neg(intValue);\n          }\n        }\n        switch (type.kind) {\n          case TypeKind.Isize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.Usize: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(<f32>sign * i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(sign * i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.String: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Template: {\n        assert(!implicitlyNegate);\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.Object: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.RegExp: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    return this.ensureStaticString(expression.value);\n  }\n\n  private compileTemplateLiteral(\n    expression: TemplateLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    let tag = expression.tag;\n    let parts = expression.parts;\n    let numParts = parts.length;\n    let expressions = expression.expressions;\n    let numExpressions = expressions.length;\n    assert(numExpressions == numParts - 1);\n\n    let module = this.module;\n    let stringInstance = this.program.stringInstance;\n    let stringType = stringInstance.type;\n\n    if (!tag) {\n      // Shortcut if just a (multi-line) string\n      if (numParts == 1) {\n        return this.ensureStaticString(parts[0]);\n      }\n\n      // Shortcut for `${expr}`, `<prefix>${expr}`, `${expr}<suffix>`\n      if (numParts == 2) {\n        let expression = expressions[0];\n        let lhsLen = parts[0].length;\n        let rhsLen = parts[1].length;\n        // Shortcut for `${expr}`  ->   expr.toString()\n        if (!lhsLen && !rhsLen) {\n          return this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n        }\n        // Shortcuts for\n        // `<prefix>${expr}`  ->  \"<prefix>\" + expr.toString()\n        // `${expr}<suffix>`  ->  expr.toString() + \"<suffix>\"\n        let hasPrefix = lhsLen != 0;\n        // @ts-ignore: cast\n        if (hasPrefix ^ (rhsLen != 0)) {\n          let lhs: ExpressionRef;\n          let rhs: ExpressionRef;\n          let expr = this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n          if (hasPrefix) {\n            lhs = this.ensureStaticString(parts[0]);\n            rhs = expr;\n          } else {\n            // suffix\n            lhs = expr;\n            rhs = this.ensureStaticString(parts[1]);\n          }\n          let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n          return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n        }\n      }\n\n      // Shortcut for `${exprA}${exprB}`  ->  exprA.toString() + exprB.toString()\n      if (numParts == 3 && !parts[0].length && !parts[1].length && !parts[2].length) {\n        let exprA = expressions[0];\n        let exprB = expressions[1];\n\n        let lhs = this.makeToString(\n          this.compileExpression(exprA, stringType),\n          this.currentType, exprA\n        );\n        let rhs = this.makeToString(\n          this.compileExpression(exprB, stringType),\n          this.currentType, exprB\n        );\n        let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n        return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n      }\n\n      // Compile to a `StaticArray<string>#join(\"\") in the general case\n      let expressionPositions = new Array<i32>(numExpressions);\n      let values = new Array<usize>();\n      if (parts[0].length > 0) values.push(this.ensureStaticString(parts[0]));\n      for (let i = 1; i < numParts; ++i) {\n        expressionPositions[i - 1] = values.length;\n        values.push(module.usize(0));\n        if (parts[i].length > 0) values.push(this.ensureStaticString(parts[i]));\n      }\n      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));\n      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);\n      this.program.OBJECTInstance.writeField(\"gcInfo\", 3, segment.buffer, 0); // use transparent gcinfo\n      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));\n      let joinInstance = assert(arrayInstance.getMethod(\"join\"));\n      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.IndexedSet, true));\n      let stmts = new Array<ExpressionRef>(2 * numExpressions + 1);\n      // Use one local per toString'ed subexpression, since otherwise recursion on the same\n      // static array would overwrite already prepared parts. Avoids a temporary array.\n      let temps = new Array<Local>(numExpressions);\n      let flow = this.currentFlow;\n      for (let i = 0; i < numExpressions; ++i) {\n        let expression = expressions[i];\n        let temp = flow.getTempLocal(stringType);\n        temps[i] = temp;\n        stmts[i] = module.local_set(temp.index,\n          this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          ),\n          true\n        );\n      }\n      // Populate the static array with the toString'ed subexpressions and call .join(\"\")\n      for (let i = 0; i < numExpressions; ++i) {\n        stmts[numExpressions + i] = this.makeCallDirect(indexedSetInstance, [\n          module.usize(offset),\n          module.i32(expressionPositions[i]),\n          module.local_get(temps[i].index, stringType.toRef())\n        ], expression);\n      }\n      stmts[2 * numExpressions] = this.makeCallDirect(joinInstance, [\n        module.usize(offset),\n        this.ensureStaticString(\"\")\n      ], expression);\n      return module.flatten(stmts, stringType.toRef());\n    }\n\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\n    let tsaArrayInstance = this.program.templateStringsArrayInstance;\n    let arrayInstance = tsaArrayInstance;\n    let target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.Swallow);\n    if (target) {\n      switch (target.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instance = this.resolver.resolveFunction(\n            <FunctionPrototype>target,\n            null,\n            new Map(),\n            ReportMode.Swallow\n          );\n          if (!instance) break;\n          target = instance;\n          // fall-through\n        }\n        case ElementKind.Function: {\n          let instance = <Function>target;\n          let parameterTypes = instance.signature.parameterTypes;\n          if (parameterTypes.length) {\n            let first = parameterTypes[0].getClass();\n            if (first && !first.extendsPrototype(tsaArrayInstance.prototype)) {\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    // Compile to a call to the tag function\n    let rawParts = expression.rawParts;\n    assert(rawParts.length == numParts);\n    let partExprs = new Array<ExpressionRef>(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      partExprs[i] = this.ensureStaticString(parts[i]);\n    }\n    let arraySegment: MemorySegment;\n    if (arrayInstance == tsaArrayInstance) {\n      let rawExprs = new Array<ExpressionRef>(numParts);\n      for (let i = 0; i < numParts; ++i) {\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\n      }\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n      let rawHeaderSegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\n      );\n      arrayInstance.writeField(\"raw\",\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\n        arraySegment.buffer\n      );\n    } else {\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n    }\n\n    // Desugar to compileCallExpression\n    let args = expressions.slice();\n    args.unshift(\n      Node.createCompiledExpression(\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\n        arrayInstance.type,\n        Source.native.range\n      )\n    );\n    // TODO: Requires ReadonlyArray to be safe\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      expression.range, \"Tagged template literals\"\n    );\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass && contextualClass.extendsPrototype(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    let element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.Class);\n    let arrayInstance = <Class>element;\n    let arrayType = arrayInstance.type;\n    let elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n    let arrayBufferInstance = assert(program.arrayBufferInstance);\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n    let tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.ConvImplicit);\n        if (getExpressionType(expr) != elementType.toRef()) {\n          isStatic = false;\n        } else {\n          let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            expr = precomp;\n          } else {\n            isStatic = false;\n          }\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let totalOverhead = program.totalOverhead;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PreferStatic) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        return this.makeNewArray(arrayInstance, length, bufferAddress, expression);\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeNewArray(arrayInstance, length, i64_new(0), expression),\n        arrayType.isManaged\n      )\n    );\n    // tempData = tempThis.dataStart\n    let dataStartMember = assert(arrayInstance.getMember(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.PropertyPrototype);\n    // is a field, so should have been resolved during class finalization\n    let dataStartProperty = (<PropertyPrototype>dataStartMember).instance;\n    if (!dataStartProperty) return module.unreachable();\n    assert(dataStartProperty.isField && dataStartProperty.memoryOffset >= 0);\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, arrayTypeRef),\n          arrayTypeRef,\n          dataStartProperty.memoryOffset\n        ),\n        true // ArrayBuffer\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // this[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  /** Makes a new array instance from a static buffer segment. */\n  private makeNewArray(\n    /** Concrete array class. */\n    arrayInstance: Class,\n    /** Length of the array. */\n    length: i32,\n    /** Source address to copy from. Array is zeroed if `0`. */\n    source: i64,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    assert(!arrayInstance.extendsPrototype(program.staticArrayPrototype));\n    let elementType = arrayInstance.getArrayValueType(); // asserts\n\n    // __newArray(length, alignLog2, classId, staticBuffer)\n    let expr = this.makeCallDirect(program.newArrayInstance, [\n      module.i32(length),\n      program.options.isWasm64\n        ? module.i64(elementType.alignLog2)\n        : module.i32(elementType.alignLog2),\n      module.i32(arrayInstance.id),\n      program.options.isWasm64\n        ? module.i64(i64_low(source), i64_high(source))\n        : module.i32(i64_low(source))\n    ], reportNode);\n    this.currentType = arrayInstance.type;\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    let arrayInstance = assert(contextualType.getClass());\n    let arrayType = arrayInstance.type;\n    let typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    let elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    let tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    let expressions = expression.elementExpressions;\n    let length = expressions.length;\n    let values = new Array<ExpressionRef>(length);\n    let isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType);\n      }\n    }\n\n    let isWasm64 = this.options.isWasm64;\n    let bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PreferStatic) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id),\n          isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    let indexedSet = arrayInstance.lookupOverload(OperatorKind.IndexedSet, true);\n    if (!indexedSet) {\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    let arrayTypeRef = arrayType.toRef();\n\n    let stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id)\n        ], expression),\n        arrayType.isManaged\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // array[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    let module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    let classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    let classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.kind == ElementKind.Interface) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        expression.range, \"Interface hidden classes\"\n      );\n      return module.unreachable();\n    }\n    if (classReference.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    let ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    let isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.Unmanaged, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    let names = expression.names;\n    let numNames = names.length;\n    let values = expression.values;\n    let members = classReference.members;\n    let hasErrors = false;\n    let exprs = new Array<ExpressionRef>();\n    let flow = this.currentFlow;\n    let tempLocal = flow.getTempLocal(classType);\n    let classTypeRef = classType.toRef();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    let omittedFields = new Set<Property>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member && member.kind == ElementKind.PropertyPrototype) {\n          // only interested in fields (resolved during class finalization)\n          let property = (<PropertyPrototype>member).instance;\n          if (property && property.isField) {\n            omittedFields.add(property); // incl. private/protected\n          }\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    let deferredProperties = new Array<Property>();\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member = classReference.getMember(memberName);\n      if (!member || member.kind != ElementKind.PropertyPrototype) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Private)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.Protected)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>member);\n      if (!propertyInstance) continue;\n      let setterInstance = propertyInstance.setterInstance;\n      if (!setterInstance) {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(propertyInstance);\n\n      // Defer real properties to be set after fields are initialized\n      if (!propertyInstance.isField) {\n        deferredProperties.push(propertyInstance);\n        continue;\n      }\n\n      let propertyType = propertyInstance.type;\n      let expr = this.makeCallDirect(setterInstance, [\n        module.local_get(tempLocal.index, classTypeRef),\n        this.compileExpression(values[i], propertyType, Constraints.ConvImplicit),\n      ], setterInstance.identifierNode, true);\n      if (this.currentType != Type.void) { // in case\n        expr = module.drop(expr);\n      }\n      exprs.push(expr);\n    }\n\n    // Call deferred real property setters after\n    for (let i = 0, k = deferredProperties.length; i < k; ++i) {\n      let propertyInstance = deferredProperties[i];\n      let setterInstance = assert(propertyInstance.setterInstance);\n      exprs.push(\n        this.makeCallDirect(setterInstance, [\n          module.local_get(tempLocal.index, classTypeRef),\n          this.compileExpression(values[i], propertyInstance.type, Constraints.ConvImplicit)\n        ], setterInstance.identifierNode)\n      );\n    }\n\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let propertyInstance = _values[j];\n      assert(propertyInstance.isField);\n      let propertyType = propertyInstance.type;\n\n      if (propertyInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (propertyType.isReference) {\n        if (!propertyType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, propertyInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (propertyType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.Bool:\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.Isize:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.Usize:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          // Can store zeroes directly (no need to __link)\n          exprs.push(\n            module.store(\n              propertyType.byteSize,\n              module.local_get(tempLocal.index, classTypeRef),\n              this.makeZero(propertyType),\n              propertyType.toRef(),\n              propertyInstance.memoryOffset\n            )\n          );\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, propertyInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    let ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.None, expression),\n        classType.isManaged\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, classTypeRef)\n    );\n\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, classTypeRef);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    let target = this.resolver.resolveTypeName(expression.typeName, flow.sourceFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.ClassPrototype) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.Abstract)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    let classPrototype = <ClassPrototype>target;\n    let classInstance: Class | null = null;\n    let typeArguments = expression.typeArguments;\n    let classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) &&\n      classReference.prototype == classPrototype &&\n      classReference.is(CommonFlags.Generic)\n    ) {\n      // e.g. `arr: Array<T> = new Array()`\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        cloneMap(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.sourceFunction.parent, // relative to caller\n        cloneMap(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WillDrop;\n    let ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.Inline)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    let instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.Compiled)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.Inline)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class. note that we cannot just\n      // call the base ctor since the derived class may have additional fields.\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = cloneMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          Signature.create(\n            this.program,\n            baseCtor.signature.parameterTypes,\n            classInstance.type,\n            classInstance.type,\n            baseCtor.signature.requiredParameters,\n            baseCtor.signature.hasRest\n          ),\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.Instance | CommonFlags.Constructor\n            )\n          ),\n          null,\n          Signature.create(this.program, [], classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n      }\n\n      instance.set(CommonFlags.Compiled);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      if (classInstance.is(CommonFlags.ModuleExport)) {\n        instance.set(CommonFlags.ModuleExport);\n      }\n      classInstance.constructorInstance = instance;\n      let members = classInstance.members;\n      if (!members) classInstance.members = members = new Map();\n      members.set(\"constructor\", instance.prototype);\n\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let sizeTypeRef = this.options.sizeTypeRef;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   this = <COND_ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      stmts.push(\n        this.makeConditionalAllocation(classInstance, 0)\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, sizeTypeRef);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\n            baseClass.type.isManaged\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      stmts.push(\n        module.local_get(0, sizeTypeRef)\n      );\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\n      }\n      let funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        varTypes,\n        module.flatten(stmts, sizeTypeRef)\n      );\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    let ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind != ElementKind.PropertyPrototype || element.parent != classInstance) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>element).instance;\n        if (!property || !property.isField) continue;\n        if (!property.initializerNode && !flow.isThisFieldFlag(property, FieldFlags.Initialized)) {\n          if (!property.is(CommonFlags.DefinitelyAssigned)) {\n            if (relatedNode) {\n              this.errorRelated(\n                DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                property.declaration.name.range,\n                relatedNode.range,\n                property.internalName\n              );\n            } else {\n              this.error(\n                DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                property.declaration.name.range,\n                property.internalName\n              );\n            }\n          }\n        } else if (property.is(CommonFlags.DefinitelyAssigned)) {\n          if (property.type.isReference) {\n            this.warning( // involves a runtime check\n              DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n              property.identifierNode.range,\n              property.internalName\n            );\n          } else {\n            this.pedantic( // is a nop anyway\n              DiagnosticCode.Unnecessary_definite_assignment,\n              property.identifierNode.range\n            );\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.Constructor));\n    let parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(reportNode);\n    let expr = this.compileCallDirect(\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType),\n      constraints\n    );\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    let thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.Unsafe)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.Global: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobalLazy(global, expression)) {\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.Inlined)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        let expr = module.global_get(global.internalName, globalType.toRef());\n        if (global.is(CommonFlags.DefinitelyAssigned) && globalType.isReference && !globalType.isNullableReference) {\n          expr = this.makeRuntimeNonNullCheck(expr, globalType, expression);\n        }\n        this.currentType = globalType;\n        return expr;\n      }\n      case ElementKind.EnumValue: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.Enum);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.Inlined)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.Integer);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>target;\n        if (propertyInstance.isField) {\n          if (\n            flow.sourceFunction.is(CommonFlags.Constructor) &&\n            assert(thisExpression).kind == NodeKind.This &&\n            !flow.isThisFieldFlag(propertyInstance, FieldFlags.Initialized) &&\n            !propertyInstance.is(CommonFlags.DefinitelyAssigned)\n          ) {\n            this.errorRelated(\n              DiagnosticCode.Property_0_is_used_before_being_assigned,\n              expression.range,\n              propertyInstance.identifierNode.range,\n              propertyInstance.internalName\n            );\n          }\n        }\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) return module.unreachable(); // failed earlier\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.Instance)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.ConvImplicit | Constraints.IsThis\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let ifThen = expression.ifThen;\n    let ifElse = expression.ifElse;\n\n    let condExpr = this.compileExpression(expression.condition, Type.bool);\n    let condExprTrueish = this.makeIsTrueish(condExpr, this.currentType, expression.condition);\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    let condKind = this.evaluateCondition(condExprTrueish);\n    if (condKind == ConditionKind.True) {\n      return module.maybeDropCondition(condExprTrueish, this.compileExpression(ifThen, contextualType));\n    }\n    if (condKind == ConditionKind.False) {\n      return module.maybeDropCondition(condExprTrueish, this.compileExpression(ifElse, contextualType));\n    }\n\n    let outerFlow = this.currentFlow;\n    let ifThenFlow = outerFlow.forkThen(condExpr);\n    this.currentFlow = ifThenFlow;\n    let ifThenExpr = this.compileExpression(ifThen, contextualType);\n    let ifThenType = this.currentType;\n\n    let ifElseFlow = outerFlow.forkElse(condExpr);\n    this.currentFlow = ifElseFlow;\n    let ifElseExpr = this.compileExpression(ifElse, contextualType == Type.auto ? ifThenType : contextualType);\n    let ifElseType = this.currentType;\n\n    if (contextualType == Type.void) { // values, including type mismatch, are irrelevant\n      if (ifThenType != Type.void) {\n        ifThenExpr = module.drop(ifThenExpr);\n        ifThenType = Type.void;\n      }\n      if (ifElseType != Type.void) {\n        ifElseExpr = module.drop(ifElseExpr);\n        ifElseType = Type.void;\n      }\n      this.currentType = Type.void;\n    } else {\n      let commonType = Type.commonType(ifThenType, ifElseType, contextualType);\n      if (!commonType) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          ifElse.range, ifElseType.toString(), ifThenType.toString()\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n      ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n      ifThenType = commonType;\n      ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n      ifElseType = commonType;\n      this.currentType = commonType;\n    }\n\n    outerFlow.inheritAlternatives(ifThenFlow, ifElseFlow);\n    this.currentFlow = outerFlow;\n\n    return module.if(condExprTrueish, ifThenExpr, ifElseExpr);\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    let getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.None\n    );\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    let tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue,\n        this.currentType.isManaged\n      );\n    }\n\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus_Plus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixInc);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PostfixDec);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.Instance);\n            if (tempLocal && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.Instance)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    let setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    let typeRef = tempLocal.type.toRef();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, typeRef)\n    ], typeRef); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let module = this.module;\n    let compound = false;\n    let expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.Plus: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Plus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.Minus: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.None, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Minus);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              this.makeZero(this.currentType),\n              expr\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Plus_Plus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixInc);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.AddSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Minus_Minus: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PrefixDec);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.Instance)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.SubSize,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.Exclamation: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.Tilde: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.None\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.Bool:\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          case TypeKind.Isize:\n          case TypeKind.Usize: {\n            expr = module.binary(\n              BinaryOp.XorSize,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TypeOf: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      case Token.Dot_Dot_Dot: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"Spread operator\"\n        );\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    let resolver = this.resolver;\n    let target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    let operand = expression.operand;\n    let expr: ExpressionRef = 0;\n    let stringInstance = this.program.stringInstance;\n    let typeString: string;\n    if (operand.kind == NodeKind.Null) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.Swallow);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.Identifier: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PropertyAccess:\n          case NodeKind.ElementAccess: {\n            operand = operand.kind == NodeKind.PropertyAccess\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.Report);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.ClassPrototype:\n          case ElementKind.Namespace:\n          case ElementKind.Enum: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FunctionPrototype: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype == stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.Bool: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend8I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SignExtension)\n            ? module.unary(UnaryOp.Extend16I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    let targetFunction = this.currentFlow.targetFunction;\n    let source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    targetFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    let supported = true;\n    let explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.program.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    let parameterTypes = signature.parameterTypes;\n    let parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.program.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.program.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    let type = getExpressionType(expr);\n    if (type == TypeRef.Unreachable)\n      return ConditionKind.Unknown;\n\n    assert(type == TypeRef.I32);\n    let module = this.module;\n    let evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.True\n        : ConditionKind.False;\n    }\n    return ConditionKind.Unknown;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // TODO: what if not nullable?\n        return module.ref_null(type.toRef());\n      }\n      case TypeKind.I31ref: {\n        if (type.is(TypeFlags.Nullable)) return module.ref_null(type.toRef());\n        return module.i31_new(module.i32(0));\n      }\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n      case TypeKind.I31ref: return module.i31_new(module.i32(1));\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n      case TypeKind.V128: return module.v128(v128_ones);\n      case TypeKind.I31ref: return module.i31_new(module.i32(-1));\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.Bool: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: return expr;\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f32_u(f32.ceil(f32.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF32ToU32,\n                module.unary(UnaryOp.CeilF32,\n                  module.unary(UnaryOp.AbsF32, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n          //\n          // and finally:\n          // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n          return module.binary(BinaryOp.LeU32,\n            module.binary(BinaryOp.SubI32,\n              module.binary(BinaryOp.ShlI32,\n                module.unary(UnaryOp.ReinterpretF32ToI32, expr),\n                module.i32(1)\n              ),\n              module.i32(2) // 1 << 1\n            ),\n            module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.F64: {\n        let options = this.options;\n        if (\n          options.shrinkLevelHint > 1 &&\n          options.hasFeature(Feature.NontrappingF2I)\n        ) {\n          // Use more compact but slower 5-byte (3 bytes in best case) approach\n          // !!(i32.trunc_sat_f64_u(f64.ceil(f64.abs(x))))\n          return module.unary(UnaryOp.EqzI32,\n            module.unary(UnaryOp.EqzI32,\n              module.unary(UnaryOp.TruncSatF64ToU32,\n                module.unary(UnaryOp.CeilF64,\n                  module.unary(UnaryOp.AbsF64, expr)\n                )\n              )\n            )\n          );\n        } else {\n          // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n          // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n          //\n          // and finally:\n          // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n          return module.binary(BinaryOp.LeU64,\n            module.binary(BinaryOp.SubI64,\n              module.binary(BinaryOp.ShlI64,\n                module.unary(UnaryOp.ReinterpretF64ToI64, expr),\n                module.i64(1)\n              ),\n              module.i64(2) // 1 << 1\n            ),\n            module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n          );\n        }\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128, expr);\n      }\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\n        // which means `ref.is_null` returns false (i.e. zero).\n        return module.unary(UnaryOp.EqzI32, module.ref_is_null(expr));\n      }\n      case TypeKind.Void:\n      default: {\n        this.error(\n          DiagnosticCode.An_expression_of_type_0_cannot_be_tested_for_truthiness,\n          reportNode.range, type.toString()\n        );\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes a string conversion of the given expression. */\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    let stringType = this.program.stringInstance.type;\n    if (type == stringType) {\n      return expr;\n    }\n    let classType = type.getClassOrWrapper(this.program);\n    if (classType) {\n      let toStringInstance = classType.getMethod(\"toString\");\n      if (toStringInstance) {\n        let toStringSignature = toStringInstance.signature;\n        if (!this.checkCallSignature( // reports\n          toStringSignature,\n          0,\n          true,\n          reportNode\n        )) {\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\n          this.errorRelated(\n            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n            reportNode.range, toStringInstance.identifierAndSignatureRange\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        let toStringReturnType = toStringSignature.returnType;\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\n          this.errorRelated(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\n      }\n    }\n    this.error(\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n      reportNode.range, type.toString(), stringType.toString()\n    );\n    this.currentType = stringType;\n    return this.module.unreachable();\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    let program = this.program;\n    assert(classInstance.program == program);\n    let module = this.module;\n    let options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.sizeTypeRef);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.sizeTypeRef);\n    }\n  }\n\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\n  makeConditionalAllocation(\n    classInstance: Class,\n    thisIndex: i32\n  ): ExpressionRef {\n    let module = this.module;\n    let classType = classInstance.type;\n    let classTypeRef = classType.toRef();\n    assert(classTypeRef == this.options.sizeTypeRef);\n    return module.if(\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n        module.local_get(thisIndex, classTypeRef)\n      ),\n      module.local_set(thisIndex,\n        this.makeAllocation(classInstance),\n        classInstance.type.isManaged\n      )\n    );\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    let members = classInstance.members;\n    if (!members) return stmts;\n\n    let module = this.module;\n    let flow = this.currentFlow;\n    let isInline = flow.isInline;\n    let thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\n    let sizeTypeRef = this.options.sizeTypeRef;\n    let nonParameterFields: Property[] | null = null;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (member.kind != ElementKind.PropertyPrototype) continue;\n      // only interested in fields (resolved during class finalization)\n      let property = (<PropertyPrototype>member).instance;\n      if (!property || !property.isField || property.getBoundClassOrInterface() != classInstance) continue;\n      assert(!property.isAny(CommonFlags.Const));\n      let fieldPrototype = property.prototype;\n      let parameterIndex = fieldPrototype.parameterIndex;\n\n      // Defer non-parameter fields until parameter fields are initialized\n      if (parameterIndex < 0) {\n        if (!nonParameterFields) nonParameterFields = new Array();\n        nonParameterFields.push(property);\n        continue;\n      }\n\n      // Initialize constructor parameter field\n      let fieldType = property.type;\n      let fieldTypeRef = fieldType.toRef();\n      assert(!fieldPrototype.initializerNode);\n      let setterInstance = assert(property.setterInstance);\n      let expr = this.makeCallDirect(setterInstance, [\n        module.local_get(thisLocalIndex, sizeTypeRef),\n        module.local_get(\n          isInline\n            ? flow.lookupLocal(property.name)!.index\n            : 1 + parameterIndex, // `this` is local 0\n          fieldTypeRef\n        )\n      ], setterInstance.identifierNode, true);\n      if (this.currentType != Type.void) { // in case\n        expr = module.drop(expr);\n      }\n      stmts.push(expr);\n    }\n\n    // Initialize deferred non-parameter fields\n    if (nonParameterFields) {\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\n        let field = unchecked(nonParameterFields[i]);\n        let fieldType = field.type;\n        let fieldPrototype = field.prototype;\n        let initializerNode = fieldPrototype.initializerNode;\n        assert(fieldPrototype.parameterIndex < 0);\n        let setterInstance = assert(field.setterInstance);\n        let expr = this.makeCallDirect(setterInstance, [\n          module.local_get(thisLocalIndex, sizeTypeRef),\n          initializerNode // use initializer if present, otherwise initialize with zero\n            ? this.compileExpression(initializerNode, fieldType, Constraints.ConvImplicit)\n            : this.makeZero(fieldType)\n        ], field.identifierNode, true);\n        if (this.currentType != Type.void) { // in case\n          expr = module.drop(expr);\n        }\n        stmts.push(expr);\n      }\n    }\n\n    this.currentType = Type.void;\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    let stringInstance = program.stringInstance;\n    let messageArg: ExpressionRef;\n    if (message) {\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.ConvImplicit);\n    } else {\n      messageArg = this.makeZero(stringInstance.type);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    let program = this.program;\n    let module = this.module;\n    let abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    let filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    let range = codeLocation.range;\n    let source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        TypeRef.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(tempIndex, LocalFlags.Wrapped);\n    flow.setLocalFlag(tempIndex, LocalFlags.NonNull);\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"Unexpected 'null' (not assigned or failed cast)\"),\n      reportNode\n    ); // TODO: throw\n\n    if (type.isExternalReference) {\n      let nonNullExpr = module.local_get(tempIndex, type.toRef());\n      if (this.options.hasFeature(Feature.GC)) {\n        nonNullExpr = module.ref_as_nonnull(nonNullExpr);\n      }\n      expr = module.if(\n        module.ref_is_null(\n          module.local_tee(tempIndex, expr, false)\n        ),\n        staticAbortCallExpr,\n        nonNullExpr\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(tempIndex, expr, type.isManaged),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    }\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime downcast check, e.g. on `<Child>parent`. */\n  makeRuntimeDowncastCheck(\n    /** Expression being downcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    let module = this.module;\n    let flow = this.currentFlow;\n    let temp = flow.getTempLocal(type);\n    let tempIndex = temp.index;\n\n    let staticAbortCallExpr = this.makeStaticAbort(\n      this.ensureStaticString(\"invalid downcast\"),\n      reportNode\n    ); // TODO: throw\n\n    if (!toType.isNullableReference || flow.isNonnull(expr, type)) {\n      // Simplify if the value cannot be `null`. If toType is non-nullable, a\n      // null-check would have been emitted separately so is not necessary here.\n      // instanceof(t = expr) ? t : abort()\n      expr = module.if(\n        module.call(this.prepareInstanceOf(toType.classReference!), [\n          module.local_tee(tempIndex, expr, type.isManaged)\n        ], TypeRef.I32),\n        module.local_get(tempIndex, type.toRef()),\n        staticAbortCallExpr\n      );\n    } else {\n      // !(t = expr) ? 0 : instanceof(t) ? t : abort()\n      expr = module.if(\n        module.unary(\n          UnaryOp.EqzI32,\n          module.local_tee(tempIndex, expr, type.isManaged)\n        ),\n        module.usize(0),\n        module.if(\n          module.call(this.prepareInstanceOf(toType.classReference!), [\n            module.local_get(tempIndex, type.toRef()),\n          ], TypeRef.I32),\n          module.local_get(tempIndex, type.toRef()),\n          staticAbortCallExpr\n        )\n      );\n    }\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\n\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.Instance), true\n  );\n  // override module name if a `module` statement is present\n  let overriddenModuleName = declaration.overriddenModuleName;\n  if (overriddenModuleName) mangleImportName_moduleName = overriddenModuleName;\n\n  if (!element.hasDecorator(DecoratorFlags.External)) return;\n\n  let program = element.program;\n  let decorator = assert(findDecorator(DecoratorKind.External, declaration.decorators));\n  let args = decorator.args;\n  if (args && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.String)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.String)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n","/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  Null = 0,\n  LineFeed = 0x0A,\n  CarriageReturn = 0x0D,\n  LineSeparator = 0x2028,\n  ParagraphSeparator = 0x2029,\n  NextLine = 0x0085,\n\n  Space = 0x20,\n  NonBreakingSpace = 0xA0,\n  EnQuad = 0x2000,\n  EmQuad = 0x2001,\n  EnSpace = 0x2002,\n  EmSpace = 0x2003,\n  ThreePerEmSpace = 0x2004,\n  FourPerEmSpace = 0x2005,\n  SixPerEmSpace = 0x2006,\n  FigureSpace = 0x2007,\n  PunctuationSpace = 0x2008,\n  ThinSpace = 0x2009,\n  HairSpace = 0x200A,\n  ZeroWidthSpace = 0x200B,\n  NarrowNoBreakSpace = 0x202F,\n  IdeographicSpace = 0x3000,\n  MathematicalSpace = 0x205F,\n  Ogham = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  Ampersand = 0x26,\n  Asterisk = 0x2A,\n  At = 0x40,\n  Backslash = 0x5C,\n  Backtick = 0x60,\n  Bar = 0x7C,\n  Caret = 0x5E,\n  CloseBrace = 0x7D,\n  CloseBracket = 0x5D,\n  CloseParen = 0x29,\n  Colon = 0x3A,\n  Comma = 0x2C,\n  Dollar = 0x24,\n  Dot = 0x2E,\n  DoubleQuote = 0x22,\n  Equals = 0x3D,\n  Exclamation = 0x21,\n  GreaterThan = 0x3E,\n  Hash = 0x23,\n  LessThan = 0x3C,\n  Minus = 0x2D,\n  OpenBrace = 0x7B,\n  OpenBracket = 0x5B,\n  OpenParen = 0x28,\n  Percent = 0x25,\n  Plus = 0x2B,\n  Question = 0x3F,\n  Semicolon = 0x3B,\n  SingleQuote = 0x27,\n  Slash = 0x2F,\n  Tilde = 0x7E,\n\n  Backspace = 0x08,\n  FormFeed = 0x0C,\n  ByteOrderMark = 0xFEFF,\n  Tab = 0x09,\n  VerticalTab = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: i32): bool {\n  switch (c) {\n    case CharCode.LineFeed:\n    case CharCode.CarriageReturn:\n    case CharCode.LineSeparator:\n    case CharCode.ParagraphSeparator: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  // NOTE: Calling code assumes that there are no supplementary whitespaces.\n  // If Unicode ever adds one, uses of this function must be updated to\n  // conditionally advance by two code units, i.e. using `numCodeUnits`.\n  switch (c) {\n    case CharCode.Space:\n    case CharCode.Tab:\n    case CharCode.VerticalTab:\n    case CharCode.FormFeed:\n    case CharCode.NonBreakingSpace:\n    case CharCode.NextLine:\n    case CharCode.Ogham:\n    case CharCode.NarrowNoBreakSpace:\n    case CharCode.MathematicalSpace:\n    case CharCode.IdeographicSpace:\n    case CharCode.ByteOrderMark: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.EnQuad && c <= CharCode.ZeroWidthSpace;\n    }\n  }\n}\n\n/** First high (lead) surrogate. */\nexport const SURROGATE_HIGH = 0xD800;\n\n/** First low (trail) surrogate. */\nexport const SURROGATE_LOW = 0xDC00;\n\n/** Tests if a code unit or code point is a surrogate. */\nexport function isSurrogate(c: i32): bool {\n  // F800: 11111 0 0000000000 Mask\n  // D800: 11011 X XXXXXXXXXX Any surrogate\n  return (c & 0xF800) == SURROGATE_HIGH;\n}\n\n/** Tests if a surrogate is a high (lead) surrogate. */\nexport function isSurrogateHigh(c: i32): bool {\n  // D800-DBFF\n  return c < SURROGATE_LOW;\n}\n\n/** Tests if a surrogate is a low (trail) surrogate. */\nexport function isSurrogateLow(c: i32): bool {\n  // DC00-DFFF\n  return c >= SURROGATE_LOW;\n}\n\n/** Tests if a code unit or code point is a high (lead) surrogate. */\nexport function isHighSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // D800: 11011 0 XXXXXXXXXX High/Lead surrogate\n  return (c & 0xFC00) == SURROGATE_HIGH;\n}\n\n/** Tests if a code unit or code point is a low (trail) surrogate. */\nexport function isLowSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // DC00: 11011 1 XXXXXXXXXX Low/Trail surrogate\n  return (c & 0xFC00) == SURROGATE_LOW;\n}\n\n/** Converts a surrogate pair to its respective code point. */\nexport function combineSurrogates(hi: i32, lo: i32): i32 {\n  return 0x10000 + ((hi & 0x3FF) << 10) | (lo & 0x3FF);\n}\n\n/** Gets the number of UTF-16 code units of the specified code point. */\nexport function numCodeUnits(cp: i32): i32 {\n  return 1 + i32(cp > 0xffff);\n}\n\nexport function isAlpha(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is a valid hexadecimal symbol [a-f]. */\nexport function isHexBase(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - f|F\n  return c0 >= CharCode.a && c0 <= CharCode.f;\n}\n\n/** Tests if the specified character code is a valid hexadecimal digit. */\nexport function isHexOrDecimal(c: i32): bool {\n  return isDecimal(c) || isHexBase(c);\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isAlphaOrDecimal(c: i32): bool {\n  return isAlpha(c) || isDecimal(c);\n}\n\n/** Tests if the specified code point is a valid start of an identifier. */\nexport function isIdentifierStart(cp: i32): bool {\n  return isAlpha(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierStartMin && cp <= unicodeIdentifierStartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierStart);\n}\n\n/** Tests if the specified code point is a valid part of an identifier. */\nexport function isIdentifierPart(cp: i32): bool {\n  return isAlphaOrDecimal(cp)\n      || cp == CharCode._\n      || cp == CharCode.Dollar\n      || cp >= unicodeIdentifierPartMin && cp <= unicodeIdentifierPartMax\n         && lookupInUnicodeMap(cp, unicodeIdentifierPart);\n}\n\n/** Tests if the specified string is a valid identifer. */\nexport function isIdentifier(str: string): bool {\n  let len = str.length;\n  if (!len) return false;\n  let cp = <i32>str.codePointAt(0);\n  if (!isIdentifierStart(cp)) return false;\n  let i = numCodeUnits(cp);\n  while (i < len) {\n    cp = <i32>str.codePointAt(i);\n    if (!isIdentifierPart(cp)) return false;\n    i += numCodeUnits(cp);\n  }\n  return true;\n}\n\n/** Unicode 14.0 ID_Start/Other_ID_Start ranges */\nconst unicodeIdentifierStart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 186   , 186   , 192   , 214   ,\n  216   , 246   , 248   , 705   , 710   , 721   , 736   , 740   ,\n  748   , 748   , 750   , 750   , 880   , 884   , 886   , 887   ,\n  890   , 893   , 895   , 895   , 902   , 902   , 904   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1162  , 1327  , 1329  , 1366  , 1369  , 1369  , 1376  , 1416  ,\n  1488  , 1514  , 1519  , 1522  , 1568  , 1610  , 1646  , 1647  ,\n  1649  , 1747  , 1749  , 1749  , 1765  , 1766  , 1774  , 1775  ,\n  1786  , 1788  , 1791  , 1791  , 1808  , 1808  , 1810  , 1839  ,\n  1869  , 1957  , 1969  , 1969  , 1994  , 2026  , 2036  , 2037  ,\n  2042  , 2042  , 2048  , 2069  , 2074  , 2074  , 2084  , 2084  ,\n  2088  , 2088  , 2112  , 2136  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2208  , 2249  , 2308  , 2361  , 2365  , 2365  ,\n  2384  , 2384  , 2392  , 2401  , 2417  , 2432  , 2437  , 2444  ,\n  2447  , 2448  , 2451  , 2472  , 2474  , 2480  , 2482  , 2482  ,\n  2486  , 2489  , 2493  , 2493  , 2510  , 2510  , 2524  , 2525  ,\n  2527  , 2529  , 2544  , 2545  , 2556  , 2556  , 2565  , 2570  ,\n  2575  , 2576  , 2579  , 2600  , 2602  , 2608  , 2610  , 2611  ,\n  2613  , 2614  , 2616  , 2617  , 2649  , 2652  , 2654  , 2654  ,\n  2674  , 2676  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2749  , 2749  ,\n  2768  , 2768  , 2784  , 2785  , 2809  , 2809  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2877  , 2877  , 2908  , 2909  , 2911  , 2913  ,\n  2929  , 2929  , 2947  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3024  , 3024  ,\n  3077  , 3084  , 3086  , 3088  , 3090  , 3112  , 3114  , 3129  ,\n  3133  , 3133  , 3160  , 3162  , 3165  , 3165  , 3168  , 3169  ,\n  3200  , 3200  , 3205  , 3212  , 3214  , 3216  , 3218  , 3240  ,\n  3242  , 3251  , 3253  , 3257  , 3261  , 3261  , 3293  , 3294  ,\n  3296  , 3297  , 3313  , 3314  , 3332  , 3340  , 3342  , 3344  ,\n  3346  , 3386  , 3389  , 3389  , 3406  , 3406  , 3412  , 3414  ,\n  3423  , 3425  , 3450  , 3455  , 3461  , 3478  , 3482  , 3505  ,\n  3507  , 3515  , 3517  , 3517  , 3520  , 3526  , 3585  , 3632  ,\n  3634  , 3635  , 3648  , 3654  , 3713  , 3714  , 3716  , 3716  ,\n  3718  , 3722  , 3724  , 3747  , 3749  , 3749  , 3751  , 3760  ,\n  3762  , 3763  , 3773  , 3773  , 3776  , 3780  , 3782  , 3782  ,\n  3804  , 3807  , 3840  , 3840  , 3904  , 3911  , 3913  , 3948  ,\n  3976  , 3980  , 4096  , 4138  , 4159  , 4159  , 4176  , 4181  ,\n  4186  , 4189  , 4193  , 4193  , 4197  , 4198  , 4206  , 4208  ,\n  4213  , 4225  , 4238  , 4238  , 4256  , 4293  , 4295  , 4295  ,\n  4301  , 4301  , 4304  , 4346  , 4348  , 4680  , 4682  , 4685  ,\n  4688  , 4694  , 4696  , 4696  , 4698  , 4701  , 4704  , 4744  ,\n  4746  , 4749  , 4752  , 4784  , 4786  , 4789  , 4792  , 4798  ,\n  4800  , 4800  , 4802  , 4805  , 4808  , 4822  , 4824  , 4880  ,\n  4882  , 4885  , 4888  , 4954  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5905  , 5919  , 5937  ,\n  5952  , 5969  , 5984  , 5996  , 5998  , 6000  , 6016  , 6067  ,\n  6103  , 6103  , 6108  , 6108  , 6176  , 6264  , 6272  , 6312  ,\n  6314  , 6314  , 6320  , 6389  , 6400  , 6430  , 6480  , 6509  ,\n  6512  , 6516  , 6528  , 6571  , 6576  , 6601  , 6656  , 6678  ,\n  6688  , 6740  , 6823  , 6823  , 6917  , 6963  , 6981  , 6988  ,\n  7043  , 7072  , 7086  , 7087  , 7098  , 7141  , 7168  , 7203  ,\n  7245  , 7247  , 7258  , 7293  , 7296  , 7304  , 7312  , 7354  ,\n  7357  , 7359  , 7401  , 7404  , 7406  , 7411  , 7413  , 7414  ,\n  7418  , 7418  , 7424  , 7615  , 7680  , 7957  , 7960  , 7965  ,\n  7968  , 8005  , 8008  , 8013  , 8016  , 8023  , 8025  , 8025  ,\n  8027  , 8027  , 8029  , 8029  , 8031  , 8061  , 8064  , 8116  ,\n  8118  , 8124  , 8126  , 8126  , 8130  , 8132  , 8134  , 8140  ,\n  8144  , 8147  , 8150  , 8155  , 8160  , 8172  , 8178  , 8180  ,\n  8182  , 8188  , 8305  , 8305  , 8319  , 8319  , 8336  , 8348  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11502 , 11506 , 11507 ,\n  11520 , 11557 , 11559 , 11559 , 11565 , 11565 , 11568 , 11623 ,\n  11631 , 11631 , 11648 , 11670 , 11680 , 11686 , 11688 , 11694 ,\n  11696 , 11702 , 11704 , 11710 , 11712 , 11718 , 11720 , 11726 ,\n  11728 , 11734 , 11736 , 11742 , 12293 , 12295 , 12321 , 12329 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12443 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42527 , 42538 , 42539 ,\n  42560 , 42606 , 42623 , 42653 , 42656 , 42735 , 42775 , 42783 ,\n  42786 , 42888 , 42891 , 42954 , 42960 , 42961 , 42963 , 42963 ,\n  42965 , 42969 , 42994 , 43009 , 43011 , 43013 , 43015 , 43018 ,\n  43020 , 43042 , 43072 , 43123 , 43138 , 43187 , 43250 , 43255 ,\n  43259 , 43259 , 43261 , 43262 , 43274 , 43301 , 43312 , 43334 ,\n  43360 , 43388 , 43396 , 43442 , 43471 , 43471 , 43488 , 43492 ,\n  43494 , 43503 , 43514 , 43518 , 43520 , 43560 , 43584 , 43586 ,\n  43588 , 43595 , 43616 , 43638 , 43642 , 43642 , 43646 , 43695 ,\n  43697 , 43697 , 43701 , 43702 , 43705 , 43709 , 43712 , 43712 ,\n  43714 , 43714 , 43739 , 43741 , 43744 , 43754 , 43762 , 43764 ,\n  43777 , 43782 , 43785 , 43790 , 43793 , 43798 , 43808 , 43814 ,\n  43816 , 43822 , 43824 , 43866 , 43868 , 43881 , 43888 , 44002 ,\n  44032 , 55203 , 55216 , 55238 , 55243 , 55291 , 63744 , 64109 ,\n  64112 , 64217 , 64256 , 64262 , 64275 , 64279 , 64285 , 64285 ,\n  64287 , 64296 , 64298 , 64310 , 64312 , 64316 , 64318 , 64318 ,\n  64320 , 64321 , 64323 , 64324 , 64326 , 64433 , 64467 , 64829 ,\n  64848 , 64911 , 64914 , 64967 , 65008 , 65019 , 65136 , 65140 ,\n  65142 , 65276 , 65313 , 65338 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66176 , 66204 , 66208 , 66256 , 66304 , 66335 , 66349 , 66378 ,\n  66384 , 66421 , 66432 , 66461 , 66464 , 66499 , 66504 , 66511 ,\n  66513 , 66517 , 66560 , 66717 , 66736 , 66771 , 66776 , 66811 ,\n  66816 , 66855 , 66864 , 66915 , 66928 , 66938 , 66940 , 66954 ,\n  66956 , 66962 , 66964 , 66965 , 66967 , 66977 , 66979 , 66993 ,\n  66995 , 67001 , 67003 , 67004 , 67072 , 67382 , 67392 , 67413 ,\n  67424 , 67431 , 67456 , 67461 , 67463 , 67504 , 67506 , 67514 ,\n  67584 , 67589 , 67592 , 67592 , 67594 , 67637 , 67639 , 67640 ,\n  67644 , 67644 , 67647 , 67669 , 67680 , 67702 , 67712 , 67742 ,\n  67808 , 67826 , 67828 , 67829 , 67840 , 67861 , 67872 , 67897 ,\n  67968 , 68023 , 68030 , 68031 , 68096 , 68096 , 68112 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68192 , 68220 , 68224 , 68252 ,\n  68288 , 68295 , 68297 , 68324 , 68352 , 68405 , 68416 , 68437 ,\n  68448 , 68466 , 68480 , 68497 , 68608 , 68680 , 68736 , 68786 ,\n  68800 , 68850 , 68864 , 68899 , 69248 , 69289 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69445 , 69488 , 69505 ,\n  69552 , 69572 , 69600 , 69622 , 69635 , 69687 , 69745 , 69746 ,\n  69749 , 69749 , 69763 , 69807 , 69840 , 69864 , 69891 , 69926 ,\n  69956 , 69956 , 69959 , 69959 , 69968 , 70002 , 70006 , 70006 ,\n  70019 , 70066 , 70081 , 70084 , 70106 , 70106 , 70108 , 70108 ,\n  70144 , 70161 , 70163 , 70187 , 70272 , 70278 , 70280 , 70280 ,\n  70282 , 70285 , 70287 , 70301 , 70303 , 70312 , 70320 , 70366 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70461 , 70461 , 70480 , 70480 ,\n  70493 , 70497 , 70656 , 70708 , 70727 , 70730 , 70751 , 70753 ,\n  70784 , 70831 , 70852 , 70853 , 70855 , 70855 , 71040 , 71086 ,\n  71128 , 71131 , 71168 , 71215 , 71236 , 71236 , 71296 , 71338 ,\n  71352 , 71352 , 71424 , 71450 , 71488 , 71494 , 71680 , 71723 ,\n  71840 , 71903 , 71935 , 71942 , 71945 , 71945 , 71948 , 71955 ,\n  71957 , 71958 , 71960 , 71983 , 71999 , 71999 , 72001 , 72001 ,\n  72096 , 72103 , 72106 , 72144 , 72161 , 72161 , 72163 , 72163 ,\n  72192 , 72192 , 72203 , 72242 , 72250 , 72250 , 72272 , 72272 ,\n  72284 , 72329 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72750 , 72768 , 72768 , 72818 , 72847 , 72960 , 72966 ,\n  72968 , 72969 , 72971 , 73008 , 73030 , 73030 , 73056 , 73061 ,\n  73063 , 73064 , 73066 , 73097 , 73112 , 73112 , 73440 , 73458 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92784 , 92862 , 92880 , 92909 , 92928 , 92975 ,\n  92992 , 92995 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94032 , 94032 , 94099 , 94111 , 94176 , 94177 ,\n  94179 , 94179 , 94208 , 100343, 100352, 101589, 101632, 101640,\n  110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882,\n  110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770,\n  113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892,\n  119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974,\n  119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003,\n  120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092,\n  120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134,\n  120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538,\n  120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654,\n  120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770,\n  120772, 120779, 122624, 122654, 123136, 123180, 123191, 123197,\n  123214, 123214, 123536, 123565, 123584, 123627, 124896, 124902,\n  124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124,\n  125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791,\n  173824, 177976, 177984, 178205, 178208, 183969, 183984, 191456,\n  194560, 195101, 196608, 201546,\n];\nconst unicodeIdentifierStartMin = 170;\nconst unicodeIdentifierStartMax = 201546;\n\n/** Unicode 14.0 ID_Continue/Other_ID_Continue + ID_Start/Other_ID_Start ranges*/\nconst unicodeIdentifierPart: i32[] = [/*\n| from  ...  to | from  ...  to | from  ...  to | from  ...  to |*/\n  170   , 170   , 181   , 181   , 183   , 183   , 186   , 186   ,\n  192   , 214   , 216   , 246   , 248   , 705   , 710   , 721   ,\n  736   , 740   , 748   , 748   , 750   , 750   , 768   , 884   ,\n  886   , 887   , 890   , 893   , 895   , 895   , 902   , 906   ,\n  908   , 908   , 910   , 929   , 931   , 1013  , 1015  , 1153  ,\n  1155  , 1159  , 1162  , 1327  , 1329  , 1366  , 1369  , 1369  ,\n  1376  , 1416  , 1425  , 1469  , 1471  , 1471  , 1473  , 1474  ,\n  1476  , 1477  , 1479  , 1479  , 1488  , 1514  , 1519  , 1522  ,\n  1552  , 1562  , 1568  , 1641  , 1646  , 1747  , 1749  , 1756  ,\n  1759  , 1768  , 1770  , 1788  , 1791  , 1791  , 1808  , 1866  ,\n  1869  , 1969  , 1984  , 2037  , 2042  , 2042  , 2045  , 2045  ,\n  2048  , 2093  , 2112  , 2139  , 2144  , 2154  , 2160  , 2183  ,\n  2185  , 2190  , 2200  , 2273  , 2275  , 2403  , 2406  , 2415  ,\n  2417  , 2435  , 2437  , 2444  , 2447  , 2448  , 2451  , 2472  ,\n  2474  , 2480  , 2482  , 2482  , 2486  , 2489  , 2492  , 2500  ,\n  2503  , 2504  , 2507  , 2510  , 2519  , 2519  , 2524  , 2525  ,\n  2527  , 2531  , 2534  , 2545  , 2556  , 2556  , 2558  , 2558  ,\n  2561  , 2563  , 2565  , 2570  , 2575  , 2576  , 2579  , 2600  ,\n  2602  , 2608  , 2610  , 2611  , 2613  , 2614  , 2616  , 2617  ,\n  2620  , 2620  , 2622  , 2626  , 2631  , 2632  , 2635  , 2637  ,\n  2641  , 2641  , 2649  , 2652  , 2654  , 2654  , 2662  , 2677  ,\n  2689  , 2691  , 2693  , 2701  , 2703  , 2705  , 2707  , 2728  ,\n  2730  , 2736  , 2738  , 2739  , 2741  , 2745  , 2748  , 2757  ,\n  2759  , 2761  , 2763  , 2765  , 2768  , 2768  , 2784  , 2787  ,\n  2790  , 2799  , 2809  , 2815  , 2817  , 2819  , 2821  , 2828  ,\n  2831  , 2832  , 2835  , 2856  , 2858  , 2864  , 2866  , 2867  ,\n  2869  , 2873  , 2876  , 2884  , 2887  , 2888  , 2891  , 2893  ,\n  2901  , 2903  , 2908  , 2909  , 2911  , 2915  , 2918  , 2927  ,\n  2929  , 2929  , 2946  , 2947  , 2949  , 2954  , 2958  , 2960  ,\n  2962  , 2965  , 2969  , 2970  , 2972  , 2972  , 2974  , 2975  ,\n  2979  , 2980  , 2984  , 2986  , 2990  , 3001  , 3006  , 3010  ,\n  3014  , 3016  , 3018  , 3021  , 3024  , 3024  , 3031  , 3031  ,\n  3046  , 3055  , 3072  , 3084  , 3086  , 3088  , 3090  , 3112  ,\n  3114  , 3129  , 3132  , 3140  , 3142  , 3144  , 3146  , 3149  ,\n  3157  , 3158  , 3160  , 3162  , 3165  , 3165  , 3168  , 3171  ,\n  3174  , 3183  , 3200  , 3203  , 3205  , 3212  , 3214  , 3216  ,\n  3218  , 3240  , 3242  , 3251  , 3253  , 3257  , 3260  , 3268  ,\n  3270  , 3272  , 3274  , 3277  , 3285  , 3286  , 3293  , 3294  ,\n  3296  , 3299  , 3302  , 3311  , 3313  , 3314  , 3328  , 3340  ,\n  3342  , 3344  , 3346  , 3396  , 3398  , 3400  , 3402  , 3406  ,\n  3412  , 3415  , 3423  , 3427  , 3430  , 3439  , 3450  , 3455  ,\n  3457  , 3459  , 3461  , 3478  , 3482  , 3505  , 3507  , 3515  ,\n  3517  , 3517  , 3520  , 3526  , 3530  , 3530  , 3535  , 3540  ,\n  3542  , 3542  , 3544  , 3551  , 3558  , 3567  , 3570  , 3571  ,\n  3585  , 3642  , 3648  , 3662  , 3664  , 3673  , 3713  , 3714  ,\n  3716  , 3716  , 3718  , 3722  , 3724  , 3747  , 3749  , 3749  ,\n  3751  , 3773  , 3776  , 3780  , 3782  , 3782  , 3784  , 3789  ,\n  3792  , 3801  , 3804  , 3807  , 3840  , 3840  , 3864  , 3865  ,\n  3872  , 3881  , 3893  , 3893  , 3895  , 3895  , 3897  , 3897  ,\n  3902  , 3911  , 3913  , 3948  , 3953  , 3972  , 3974  , 3991  ,\n  3993  , 4028  , 4038  , 4038  , 4096  , 4169  , 4176  , 4253  ,\n  4256  , 4293  , 4295  , 4295  , 4301  , 4301  , 4304  , 4346  ,\n  4348  , 4680  , 4682  , 4685  , 4688  , 4694  , 4696  , 4696  ,\n  4698  , 4701  , 4704  , 4744  , 4746  , 4749  , 4752  , 4784  ,\n  4786  , 4789  , 4792  , 4798  , 4800  , 4800  , 4802  , 4805  ,\n  4808  , 4822  , 4824  , 4880  , 4882  , 4885  , 4888  , 4954  ,\n  4957  , 4959  , 4969  , 4977  , 4992  , 5007  , 5024  , 5109  ,\n  5112  , 5117  , 5121  , 5740  , 5743  , 5759  , 5761  , 5786  ,\n  5792  , 5866  , 5870  , 5880  , 5888  , 5909  , 5919  , 5940  ,\n  5952  , 5971  , 5984  , 5996  , 5998  , 6000  , 6002  , 6003  ,\n  6016  , 6099  , 6103  , 6103  , 6108  , 6109  , 6112  , 6121  ,\n  6155  , 6157  , 6159  , 6169  , 6176  , 6264  , 6272  , 6314  ,\n  6320  , 6389  , 6400  , 6430  , 6432  , 6443  , 6448  , 6459  ,\n  6470  , 6509  , 6512  , 6516  , 6528  , 6571  , 6576  , 6601  ,\n  6608  , 6618  , 6656  , 6683  , 6688  , 6750  , 6752  , 6780  ,\n  6783  , 6793  , 6800  , 6809  , 6823  , 6823  , 6832  , 6845  ,\n  6847  , 6862  , 6912  , 6988  , 6992  , 7001  , 7019  , 7027  ,\n  7040  , 7155  , 7168  , 7223  , 7232  , 7241  , 7245  , 7293  ,\n  7296  , 7304  , 7312  , 7354  , 7357  , 7359  , 7376  , 7378  ,\n  7380  , 7418  , 7424  , 7957  , 7960  , 7965  , 7968  , 8005  ,\n  8008  , 8013  , 8016  , 8023  , 8025  , 8025  , 8027  , 8027  ,\n  8029  , 8029  , 8031  , 8061  , 8064  , 8116  , 8118  , 8124  ,\n  8126  , 8126  , 8130  , 8132  , 8134  , 8140  , 8144  , 8147  ,\n  8150  , 8155  , 8160  , 8172  , 8178  , 8180  , 8182  , 8188  ,\n  8255  , 8256  , 8276  , 8276  , 8305  , 8305  , 8319  , 8319  ,\n  8336  , 8348  , 8400  , 8412  , 8417  , 8417  , 8421  , 8432  ,\n  8450  , 8450  , 8455  , 8455  , 8458  , 8467  , 8469  , 8469  ,\n  8472  , 8477  , 8484  , 8484  , 8486  , 8486  , 8488  , 8488  ,\n  8490  , 8505  , 8508  , 8511  , 8517  , 8521  , 8526  , 8526  ,\n  8544  , 8584  , 11264 , 11492 , 11499 , 11507 , 11520 , 11557 ,\n  11559 , 11559 , 11565 , 11565 , 11568 , 11623 , 11631 , 11631 ,\n  11647 , 11670 , 11680 , 11686 , 11688 , 11694 , 11696 , 11702 ,\n  11704 , 11710 , 11712 , 11718 , 11720 , 11726 , 11728 , 11734 ,\n  11736 , 11742 , 11744 , 11775 , 12293 , 12295 , 12321 , 12335 ,\n  12337 , 12341 , 12344 , 12348 , 12353 , 12438 , 12441 , 12447 ,\n  12449 , 12538 , 12540 , 12543 , 12549 , 12591 , 12593 , 12686 ,\n  12704 , 12735 , 12784 , 12799 , 13312 , 19903 , 19968 , 42124 ,\n  42192 , 42237 , 42240 , 42508 , 42512 , 42539 , 42560 , 42607 ,\n  42612 , 42621 , 42623 , 42737 , 42775 , 42783 , 42786 , 42888 ,\n  42891 , 42954 , 42960 , 42961 , 42963 , 42963 , 42965 , 42969 ,\n  42994 , 43047 , 43052 , 43052 , 43072 , 43123 , 43136 , 43205 ,\n  43216 , 43225 , 43232 , 43255 , 43259 , 43259 , 43261 , 43309 ,\n  43312 , 43347 , 43360 , 43388 , 43392 , 43456 , 43471 , 43481 ,\n  43488 , 43518 , 43520 , 43574 , 43584 , 43597 , 43600 , 43609 ,\n  43616 , 43638 , 43642 , 43714 , 43739 , 43741 , 43744 , 43759 ,\n  43762 , 43766 , 43777 , 43782 , 43785 , 43790 , 43793 , 43798 ,\n  43808 , 43814 , 43816 , 43822 , 43824 , 43866 , 43868 , 43881 ,\n  43888 , 44010 , 44012 , 44013 , 44016 , 44025 , 44032 , 55203 ,\n  55216 , 55238 , 55243 , 55291 , 63744 , 64109 , 64112 , 64217 ,\n  64256 , 64262 , 64275 , 64279 , 64285 , 64296 , 64298 , 64310 ,\n  64312 , 64316 , 64318 , 64318 , 64320 , 64321 , 64323 , 64324 ,\n  64326 , 64433 , 64467 , 64829 , 64848 , 64911 , 64914 , 64967 ,\n  65008 , 65019 , 65024 , 65039 , 65056 , 65071 , 65075 , 65076 ,\n  65101 , 65103 , 65136 , 65140 , 65142 , 65276 , 65296 , 65305 ,\n  65313 , 65338 , 65343 , 65343 , 65345 , 65370 , 65382 , 65470 ,\n  65474 , 65479 , 65482 , 65487 , 65490 , 65495 , 65498 , 65500 ,\n  65536 , 65547 , 65549 , 65574 , 65576 , 65594 , 65596 , 65597 ,\n  65599 , 65613 , 65616 , 65629 , 65664 , 65786 , 65856 , 65908 ,\n  66045 , 66045 , 66176 , 66204 , 66208 , 66256 , 66272 , 66272 ,\n  66304 , 66335 , 66349 , 66378 , 66384 , 66426 , 66432 , 66461 ,\n  66464 , 66499 , 66504 , 66511 , 66513 , 66517 , 66560 , 66717 ,\n  66720 , 66729 , 66736 , 66771 , 66776 , 66811 , 66816 , 66855 ,\n  66864 , 66915 , 66928 , 66938 , 66940 , 66954 , 66956 , 66962 ,\n  66964 , 66965 , 66967 , 66977 , 66979 , 66993 , 66995 , 67001 ,\n  67003 , 67004 , 67072 , 67382 , 67392 , 67413 , 67424 , 67431 ,\n  67456 , 67461 , 67463 , 67504 , 67506 , 67514 , 67584 , 67589 ,\n  67592 , 67592 , 67594 , 67637 , 67639 , 67640 , 67644 , 67644 ,\n  67647 , 67669 , 67680 , 67702 , 67712 , 67742 , 67808 , 67826 ,\n  67828 , 67829 , 67840 , 67861 , 67872 , 67897 , 67968 , 68023 ,\n  68030 , 68031 , 68096 , 68099 , 68101 , 68102 , 68108 , 68115 ,\n  68117 , 68119 , 68121 , 68149 , 68152 , 68154 , 68159 , 68159 ,\n  68192 , 68220 , 68224 , 68252 , 68288 , 68295 , 68297 , 68326 ,\n  68352 , 68405 , 68416 , 68437 , 68448 , 68466 , 68480 , 68497 ,\n  68608 , 68680 , 68736 , 68786 , 68800 , 68850 , 68864 , 68903 ,\n  68912 , 68921 , 69248 , 69289 , 69291 , 69292 , 69296 , 69297 ,\n  69376 , 69404 , 69415 , 69415 , 69424 , 69456 , 69488 , 69509 ,\n  69552 , 69572 , 69600 , 69622 , 69632 , 69702 , 69734 , 69749 ,\n  69759 , 69818 , 69826 , 69826 , 69840 , 69864 , 69872 , 69881 ,\n  69888 , 69940 , 69942 , 69951 , 69956 , 69959 , 69968 , 70003 ,\n  70006 , 70006 , 70016 , 70084 , 70089 , 70092 , 70094 , 70106 ,\n  70108 , 70108 , 70144 , 70161 , 70163 , 70199 , 70206 , 70206 ,\n  70272 , 70278 , 70280 , 70280 , 70282 , 70285 , 70287 , 70301 ,\n  70303 , 70312 , 70320 , 70378 , 70384 , 70393 , 70400 , 70403 ,\n  70405 , 70412 , 70415 , 70416 , 70419 , 70440 , 70442 , 70448 ,\n  70450 , 70451 , 70453 , 70457 , 70459 , 70468 , 70471 , 70472 ,\n  70475 , 70477 , 70480 , 70480 , 70487 , 70487 , 70493 , 70499 ,\n  70502 , 70508 , 70512 , 70516 , 70656 , 70730 , 70736 , 70745 ,\n  70750 , 70753 , 70784 , 70853 , 70855 , 70855 , 70864 , 70873 ,\n  71040 , 71093 , 71096 , 71104 , 71128 , 71133 , 71168 , 71232 ,\n  71236 , 71236 , 71248 , 71257 , 71296 , 71352 , 71360 , 71369 ,\n  71424 , 71450 , 71453 , 71467 , 71472 , 71481 , 71488 , 71494 ,\n  71680 , 71738 , 71840 , 71913 , 71935 , 71942 , 71945 , 71945 ,\n  71948 , 71955 , 71957 , 71958 , 71960 , 71989 , 71991 , 71992 ,\n  71995 , 72003 , 72016 , 72025 , 72096 , 72103 , 72106 , 72151 ,\n  72154 , 72161 , 72163 , 72164 , 72192 , 72254 , 72263 , 72263 ,\n  72272 , 72345 , 72349 , 72349 , 72368 , 72440 , 72704 , 72712 ,\n  72714 , 72758 , 72760 , 72768 , 72784 , 72793 , 72818 , 72847 ,\n  72850 , 72871 , 72873 , 72886 , 72960 , 72966 , 72968 , 72969 ,\n  72971 , 73014 , 73018 , 73018 , 73020 , 73021 , 73023 , 73031 ,\n  73040 , 73049 , 73056 , 73061 , 73063 , 73064 , 73066 , 73102 ,\n  73104 , 73105 , 73107 , 73112 , 73120 , 73129 , 73440 , 73462 ,\n  73648 , 73648 , 73728 , 74649 , 74752 , 74862 , 74880 , 75075 ,\n  77712 , 77808 , 77824 , 78894 , 82944 , 83526 , 92160 , 92728 ,\n  92736 , 92766 , 92768 , 92777 , 92784 , 92862 , 92864 , 92873 ,\n  92880 , 92909 , 92912 , 92916 , 92928 , 92982 , 92992 , 92995 ,\n  93008 , 93017 , 93027 , 93047 , 93053 , 93071 , 93760 , 93823 ,\n  93952 , 94026 , 94031 , 94087 , 94095 , 94111 , 94176 , 94177 ,\n  94179 , 94180 , 94192 , 94193 , 94208 , 100343, 100352, 101589,\n  101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590,\n  110592, 110882, 110928, 110930, 110948, 110951, 110960, 111355,\n  113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817,\n  113821, 113822, 118528, 118573, 118576, 118598, 119141, 119145,\n  119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213,\n  119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967,\n  119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993,\n  119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074,\n  120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126,\n  120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485,\n  120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596,\n  120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712,\n  120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831,\n  121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476,\n  121499, 121503, 121505, 121519, 122624, 122654, 122880, 122886,\n  122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922,\n  123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214,\n  123536, 123566, 123584, 123641, 124896, 124902, 124904, 124907,\n  124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142,\n  125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495,\n  126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,\n  126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530,\n  126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543,\n  126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553,\n  126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562,\n  126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583,\n  126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619,\n  126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041,\n  131072, 173791, 173824, 177976, 177984, 178205, 178208, 183969,\n  183984, 191456, 194560, 195101, 196608, 201546, 917760, 917999,\n];\nconst unicodeIdentifierPartMin = 170;\nconst unicodeIdentifierPartMax = 917999;\n\nfunction lookupInUnicodeMap(code: i32, map: i32[]): bool {\n  let lo = 0;\n  let hi = map.length;\n  while (lo + 1 < hi) {\n    let mid = lo + ((hi - lo) >>> 1);\n    mid -= (mid & 1);\n    let midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\n/** Creates an indentation matching the number of specified levels. */\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX3 = \"      \";\nconst indentX4 = \"        \";\nconst indentCache = new Map<i32,string>();\n\nexport function indent(sb: string[], level: i32): void {\n  if (level <= 4) {\n    switch (level) {\n      case 1: sb.push(indentX1); break;\n      case 2: sb.push(indentX2); break;\n      case 3: sb.push(indentX3); break;\n      case 4: sb.push(indentX4); break;\n    }\n  } else {\n    let indents: string;\n    // Limit number of indent entries to 1024 for avoiding unnecessary\n    // memory consumetion\n    if (indentCache.size <= 1024) {\n      if (indentCache.has(level)) {\n        indents = assert(indentCache.get(level));\n      } else {\n        indentCache.set(level, (indents = indentX1.repeat(level)));\n      }\n    } else {\n      indents = indentX1.repeat(level);\n    }\n    sb.push(indents);\n  }\n}\n\n/** Escapes a string using the specified kind of quote. */\nexport function escapeString(str: string, quote: CharCode): string {\n  let sb = new Array<string>();\n  let off = 0;\n  let i = 0;\n  for (let k = str.length; i < k;) {\n    switch (str.charCodeAt(i)) {\n      case CharCode.Null: {\n        if (i > off) sb.push(str.substring(off, off = i + 1));\n        sb.push(\"\\\\0\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backspace: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\b\");\n        break;\n      }\n      case CharCode.Tab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\t\");\n        break;\n      }\n      case CharCode.LineFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\n\");\n        break;\n      }\n      case CharCode.VerticalTab: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\v\");\n        break;\n      }\n      case CharCode.FormFeed: {\n        if (i > off) sb.push(str.substring(off, i));\n        off = ++i;\n        sb.push(\"\\\\f\");\n        break;\n      }\n      case CharCode.CarriageReturn: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\r\");\n        off = ++i;\n        break;\n      }\n      case CharCode.DoubleQuote: {\n        if (quote == CharCode.DoubleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\"\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.SingleQuote: {\n        if (quote == CharCode.SingleQuote) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\'\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      case CharCode.Backslash: {\n        if (i > off) sb.push(str.substring(off, i));\n        sb.push(\"\\\\\\\\\");\n        off = ++i;\n        break;\n      }\n      case CharCode.Backtick: {\n        if (quote == CharCode.Backtick) {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\`\");\n          off = ++i;\n        } else {\n          ++i;\n        }\n        break;\n      }\n      default: {\n        ++i;\n        break;\n      }\n    }\n  }\n  if (i > off) sb.push(str.substring(off, i));\n  return sb.join(\"\");\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.Slash;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  let pos = 0;\n  let len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.Dot &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  let atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.Dot\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.Dot ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.Dot &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.Dot ||\n              path.charCodeAt(ipos + 2) != CharCode.Dot\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.Dot ||\n            path.charCodeAt(1) != CharCode.Dot\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  let pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n","/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\n/** Gray terminal color code. */\nexport const COLOR_GRAY = \"\\u001b[90m\";\n/** Red terminal color code. */\nexport const COLOR_RED = \"\\u001b[91m\";\n/** Green terminal color code. */\nexport const COLOR_GREEN = \"\\u001b[92m\";\n/** Yellow terminal color code. */\nexport const COLOR_YELLOW = \"\\u001b[93m\";\n/** Blue terminal color code. */\nexport const COLOR_BLUE = \"\\u001b[94m\";\n/** Magenta terminal color code. */\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\n/** Cyan terminal color code. */\nexport const COLOR_CYAN = \"\\u001b[96m\";\n/** White terminal color code. */\nexport const COLOR_WHITE = \"\\u001b[97m\";\n/** Terminal color reset code. */\nexport const COLOR_RESET = \"\\u001b[0m\";\n\n/** Whether terminal colors are enabled or not. */\nlet colorsEnabled = true;\n\n/** Checks whether terminal colors are enabled or not. */\nexport function isColorsEnabled(): bool {\n  return colorsEnabled;\n}\n\n/** Sets whether terminal colors are enabled or not. */\nexport function setColorsEnabled(isEnabled: bool): bool {\n  let wasEnabled = isEnabled;\n  colorsEnabled = isEnabled;\n  return wasEnabled;\n}\n\n/** Wraps the specified text in the specified terminal color code. */\nexport function colorize(text: string, color: string): string {\n  return colorsEnabled ? color + text + COLOR_RESET : text;\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n/** v128 all ones constant. */\nexport const v128_ones = new Uint8Array(16).fill(0xFF);\n","export function REVERSE<T>(ptr: usize, len: usize): void {\n  if (len > 1) {\n    let\n      i: usize = 0,\n      tail: usize,\n      hlen: usize = len >> 1;\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (sizeof<T>() == 1) {\n        // TODO: Decide later: Does we need this fast path cases?\n        //\n        // if (len == 4) {\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\n        //   return;\n        // }\n        // if (len == 8) {\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\n        //   return;\n        // }\n        tail = len - 8;\n        while (i + 7 < hlen) {\n          let front = ptr + i;\n          let back  = ptr + tail - i;\n          let temp  = bswap(load<u64>(front));\n          store<u64>(front, bswap(load<u64>(back)));\n          store<u64>(back, temp);\n          i += 8;\n        }\n      }\n\n      if (sizeof<T>() == 2) {\n        tail = len - 2;\n        while (i + 1 < hlen) {\n          let front = ptr + (i << 1);\n          let back  = ptr + (tail - i << 1);\n          let temp  = rotr(load<u32>(back), 16);\n          store<u32>(back, rotr(load<u32>(front), 16));\n          store<u32>(front, temp);\n          i += 2;\n        }\n      }\n    }\n\n    tail = len - 1;\n    while (i < hlen) {\n      let front = ptr + (i << alignof<T>());\n      let back  = ptr + (tail - i << alignof<T>());\n      let temp  = load<T>(front);\n      store<T>(front, load<T>(back));\n      store<T>(back, temp);\n      i++;\n    }\n  }\n}\n\nexport function FILL<T>(\n  ptr: usize,\n  len: usize,\n  value: T,\n  start: isize,\n  end: isize\n): void {\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        ptr + <usize>start,\n        u8(value),\n        <usize>(end - start)\n      );\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL <= 1) {\n      if (isInteger<T>()) {\n        // @ts-ignore\n        if (value == <T>0 | value == <T>-1) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              u8(value),\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      } else if (isFloat<T>()) {\n        // for floating non-negative zeros we can use fast memory.fill\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              0,\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      }\n    }\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n}\n","/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimal,\n  isOctal,\n  isHexBase,\n  isHighSurrogate,\n  combineSurrogates,\n  numCodeUnits\n} from \"./util\";\n\n/** Named token types. */\nexport const enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  Abstract,\n  As,\n  Async,\n  Await,        // ES2017\n  Break,        // ES2017\n  Case,         // ES2017\n  Catch,        // ES2017\n  Class,        // ES2017\n  Const,        // ES2017\n  Continue,     // ES2017\n  Constructor,\n  Debugger,     // ES2017\n  Declare,\n  Default,      // ES2017\n  Delete,       // ES2017\n  Do,           // ES2017\n  Else,         // ES2017\n  Enum,         // ES2017 future\n  Export,       // ES2017\n  Extends,      // ES2017\n  False,        // ES\n  Finally,      // ES2017\n  For,          // ES2017\n  From,         // AS possible identifier\n  Function,     // ES2017\n  Get,\n  If,           // ES2017\n  Implements,   // ES2017 non-lexical\n  Import,       // ES2017\n  In,           // ES2017\n  InstanceOf,   // ES2017\n  Interface,    // ES2017 non-lexical\n  Is,\n  KeyOf,\n  Let,          // ES2017 non-lexical\n  Module,       // AS possible identifier\n  Namespace,    // AS possible identifier\n  New,          // ES2017\n  Null,         // ES\n  Of,\n  Override,\n  Package,      // ES2017 non-lexical\n  Private,      // ES2017 non-lexical\n  Protected,    // ES2017 non-lexical\n  Public,       // ES2017 non-lexical\n  Readonly,\n  Return,       // ES2017\n  Set,\n  Static,       // ES2017 non-lexical\n  Super,        // ES2017\n  Switch,       // ES2017\n  This,         // ES2017\n  Throw,        // ES2017\n  True,         // ES\n  Try,          // ES2017\n  Type,         // AS possible identifier\n  TypeOf,       // ES2017\n  Var,          // ES2017\n  Void,         // ES2017\n  While,        // ES2017\n  With,         // ES2017\n  Yield,        // ES2017\n\n  // punctuation\n\n  OpenBrace,\n  CloseBrace,\n  OpenParen,\n  CloseParen,\n  OpenBracket,\n  CloseBracket,\n  Dot,\n  Dot_Dot_Dot,\n  Semicolon,\n  Comma,\n  LessThan,\n  GreaterThan,\n  LessThan_Equals,\n  GreaterThan_Equals,\n  Equals_Equals,\n  Exclamation_Equals,\n  Equals_Equals_Equals,\n  Exclamation_Equals_Equals,\n  Equals_GreaterThan,\n  Plus,\n  Minus,\n  Asterisk_Asterisk,\n  Asterisk,\n  Slash,\n  Percent,\n  Plus_Plus,\n  Minus_Minus,\n  LessThan_LessThan,\n  GreaterThan_GreaterThan,\n  GreaterThan_GreaterThan_GreaterThan,\n  Ampersand,\n  Bar,\n  Caret,\n  Exclamation,\n  Tilde,\n  Ampersand_Ampersand,\n  Bar_Bar,\n  Question,\n  Colon,\n  Equals,\n  Plus_Equals,\n  Minus_Equals,\n  Asterisk_Equals,\n  Asterisk_Asterisk_Equals,\n  Slash_Equals,\n  Percent_Equals,\n  LessThan_LessThan_Equals,\n  GreaterThan_GreaterThan_Equals,\n  GreaterThan_GreaterThan_GreaterThan_Equals,\n  Ampersand_Equals,\n  Bar_Equals,\n  Caret_Equals,\n  At,\n\n  // literals\n\n  Identifier,\n  StringLiteral,\n  IntegerLiteral,\n  FloatLiteral,\n  TemplateLiteral,\n\n  // meta\n\n  Invalid,\n  EndOfFile\n}\n\nexport const enum IdentifierHandling {\n  Default,\n  Prefer,\n  Always\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  let len = text.length;\n  assert(len);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (len == 5) {\n        if (text == \"async\") return Token.Async;\n        if (text == \"await\") return Token.Await;\n        break;\n      }\n      if (text == \"as\") return Token.As;\n      if (text == \"abstract\") return Token.Abstract;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.Break;\n      break;\n    }\n    case CharCode.c: {\n      if (len == 5) {\n        if (text == \"const\") return Token.Const;\n        if (text == \"class\") return Token.Class;\n        if (text == \"catch\") return Token.Catch;\n        break;\n      }\n      if (text == \"case\") return Token.Case;\n      if (text == \"continue\") return Token.Continue;\n      if (text == \"constructor\") return Token.Constructor;\n      break;\n    }\n    case CharCode.d: {\n      if (len == 7) {\n        if (text == \"default\") return Token.Default;\n        if (text == \"declare\") return Token.Declare;\n        break;\n      }\n      if (text == \"do\") return Token.Do;\n      if (text == \"delete\") return Token.Delete;\n      if (text == \"debugger\") return Token.Debugger;\n      break;\n    }\n    case CharCode.e: {\n      if (len == 4) {\n        if (text == \"else\") return Token.Else;\n        if (text == \"enum\") return Token.Enum;\n        break;\n      }\n      if (text == \"export\") return Token.Export;\n      if (text == \"extends\") return Token.Extends;\n      break;\n    }\n    case CharCode.f: {\n      if (len <= 5) {\n        if (text == \"false\") return Token.False;\n        if (text == \"for\") return Token.For;\n        if (text == \"from\") return Token.From;\n        break;\n      }\n      if (text == \"function\") return Token.Function;\n      if (text == \"finally\") return Token.Finally;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.Get;\n      break;\n    }\n    case CharCode.i: {\n      if (len == 2) {\n        if (text == \"if\") return Token.If;\n        if (text == \"in\") return Token.In;\n        if (text == \"is\") return Token.Is;\n        break;\n      }\n      switch (text.charCodeAt(3)) {\n        case CharCode.l: {\n          if (text == \"implements\") return Token.Implements;\n          break;\n        }\n        case CharCode.o: {\n          if (text == \"import\") return Token.Import;\n          break;\n        }\n        case CharCode.t: {\n          if (text == \"instanceof\") return Token.InstanceOf;\n          break;\n        }\n        case CharCode.e: {\n          if (text == \"interface\") return Token.Interface;\n          break;\n        }\n      }\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KeyOf;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.Let;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.Module;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"new\") return Token.New;\n      if (text == \"null\") return Token.Null;\n      if (text == \"namespace\") return Token.Namespace;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.Of;\n      if (text == \"override\") return Token.Override;\n      break;\n    }\n    case CharCode.p: {\n      if (len == 7) {\n        if (text == \"private\") return Token.Private;\n        if (text == \"package\") return Token.Package;\n        break;\n      }\n      if (text == \"public\") return Token.Public;\n      if (text == \"protected\") return Token.Protected;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"return\") return Token.Return;\n      if (text == \"readonly\") return Token.Readonly;\n      break;\n    }\n    case CharCode.s: {\n      if (len == 6) {\n        if (text == \"switch\") return Token.Switch;\n        if (text == \"static\") return Token.Static;\n        break;\n      }\n      if (text == \"set\") return Token.Set;\n      if (text == \"super\") return Token.Super;\n      break;\n    }\n    case CharCode.t: {\n      if (len == 4) {\n        if (text == \"true\") return Token.True;\n        if (text == \"this\") return Token.This;\n        if (text == \"type\") return Token.Type;\n        break;\n      }\n      if (text == \"try\") return Token.Try;\n      if (text == \"throw\") return Token.Throw;\n      if (text == \"typeof\") return Token.TypeOf;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.Var;\n      if (text == \"void\") return Token.Void;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.While;\n      if (text == \"with\") return Token.With;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.Yield;\n      break;\n    }\n  }\n  return Token.Invalid;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.Abstract:\n    case Token.As:\n    case Token.Constructor:\n    case Token.Declare:\n    case Token.Delete:\n    case Token.From:\n    case Token.For:\n    case Token.Get:\n    case Token.InstanceOf:\n    case Token.Is:\n    case Token.KeyOf:\n    case Token.Module:\n    case Token.Namespace:\n    case Token.Null:\n    case Token.Readonly:\n    case Token.Set:\n    case Token.Type:\n    case Token.Void: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.Delete: return \"delete\";\n    case Token.In: return \"in\";\n    case Token.InstanceOf: return \"instanceof\";\n    case Token.New: return \"new\";\n    case Token.TypeOf: return \"typeof\";\n    case Token.Void: return \"void\";\n    case Token.Yield: return \"yield\";\n    case Token.Dot_Dot_Dot: return \"...\";\n    case Token.Comma: return \",\";\n    case Token.LessThan: return \"<\";\n    case Token.GreaterThan: return \">\";\n    case Token.LessThan_Equals: return \"<=\";\n    case Token.GreaterThan_Equals: return \">=\";\n    case Token.Equals_Equals: return \"==\";\n    case Token.Exclamation_Equals: return \"!=\";\n    case Token.Equals_Equals_Equals: return \"===\";\n    case Token.Exclamation_Equals_Equals: return \"!==\";\n    case Token.Plus: return \"+\";\n    case Token.Minus: return \"-\";\n    case Token.Asterisk_Asterisk: return \"**\";\n    case Token.Asterisk: return \"*\";\n    case Token.Slash: return \"/\";\n    case Token.Percent: return \"%\";\n    case Token.Plus_Plus: return \"++\";\n    case Token.Minus_Minus: return \"--\";\n    case Token.LessThan_LessThan: return \"<<\";\n    case Token.GreaterThan_GreaterThan: return \">>\";\n    case Token.GreaterThan_GreaterThan_GreaterThan: return \">>>\";\n    case Token.Ampersand: return \"&\";\n    case Token.Bar: return \"|\";\n    case Token.Caret: return \"^\";\n    case Token.Exclamation: return \"!\";\n    case Token.Tilde: return \"~\";\n    case Token.Ampersand_Ampersand: return \"&&\";\n    case Token.Bar_Bar: return \"||\";\n    case Token.Equals: return \"=\";\n    case Token.Plus_Equals: return \"+=\";\n    case Token.Minus_Equals: return \"-=\";\n    case Token.Asterisk_Equals: return \"*=\";\n    case Token.Asterisk_Asterisk_Equals: return \"**=\";\n    case Token.Slash_Equals: return \"/=\";\n    case Token.Percent_Equals: return \"%=\";\n    case Token.LessThan_LessThan_Equals: return \"<<=\";\n    case Token.GreaterThan_GreaterThan_Equals: return \">>=\";\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return \">>>=\";\n    case Token.Ampersand_Equals: return \"&=\";\n    case Token.Bar_Equals: return \"|=\";\n    case Token.Caret_Equals: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Whether a token begins on a new line, if known. */\nenum OnNewLine {\n  No,\n  Yes,\n  Unknown\n}\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: OnNewLine = OnNewLine.Unknown;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    let text = source.text;\n    let end = text.length;\n    let pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.ByteOrderMark\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.Hash &&\n      text.charCodeAt(pos + 1) == CharCode.Exclamation\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LineFeed\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.Default): Token {\n    this.clearNextToken();\n    let token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.Invalid);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CarriageReturn: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LineFeed\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LineFeed:\n        case CharCode.Tab:\n        case CharCode.VerticalTab:\n        case CharCode.FormFeed:\n        case CharCode.Space: {\n          ++pos;\n          break;\n        }\n        case CharCode.Exclamation: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.Equals\n            ) {\n              this.pos = pos + 1;\n              return Token.Exclamation_Equals_Equals;\n            }\n            this.pos = pos;\n            return Token.Exclamation_Equals;\n          }\n          this.pos = pos;\n          return Token.Exclamation;\n        }\n        case CharCode.DoubleQuote:\n        case CharCode.SingleQuote: {\n          this.pos = pos;\n          return Token.StringLiteral;\n        }\n        case CharCode.Backtick: {\n          this.pos = pos;\n          return Token.TemplateLiteral;\n        }\n        case CharCode.Percent: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Percent_Equals;\n          }\n          this.pos = pos;\n          return Token.Percent;\n        }\n        case CharCode.Ampersand: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Ampersand) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Ampersand;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Ampersand_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Ampersand;\n        }\n        case CharCode.OpenParen: {\n          this.pos = pos + 1;\n          return Token.OpenParen;\n        }\n        case CharCode.CloseParen: {\n          this.pos = pos + 1;\n          return Token.CloseParen;\n        }\n        case CharCode.Asterisk: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Asterisk_Equals;\n            }\n            if (chr == CharCode.Asterisk) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Asterisk_Asterisk_Equals;\n              }\n              this.pos = pos;\n              return Token.Asterisk_Asterisk;\n            }\n          }\n          this.pos = pos;\n          return Token.Asterisk;\n        }\n        case CharCode.Plus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Plus) {\n              this.pos = pos + 1;\n              return Token.Plus_Plus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Plus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Plus;\n        }\n        case CharCode.Comma: {\n          this.pos = pos + 1;\n          return Token.Comma;\n        }\n        case CharCode.Minus: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Minus) {\n              this.pos = pos + 1;\n              return Token.Minus_Minus;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Minus_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Minus;\n        }\n        case CharCode.Dot: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimal(chr)) {\n              this.pos = pos - 1;\n              return Token.FloatLiteral; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.Dot &&\n              text.charCodeAt(pos + 1) == CharCode.Dot\n            ) {\n              this.pos = pos + 2;\n              return Token.Dot_Dot_Dot;\n            }\n          }\n          this.pos = pos;\n          return Token.Dot;\n        }\n        case CharCode.Slash: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Slash) { // single-line\n              let commentKind = CommentKind.Line;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.Slash\n              ) {\n                ++pos;\n                commentKind = CommentKind.Triple;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LineFeed) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Asterisk) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.Asterisk &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.Slash\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.Block,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Slash_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Slash;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.IntegerLiteral // expects a call to readInteger\n            : Token.FloatLiteral;  // expects a call to readFloat\n        }\n        case CharCode.Colon: {\n          this.pos = pos + 1;\n          return Token.Colon;\n        }\n        case CharCode.Semicolon: {\n          this.pos = pos + 1;\n          return Token.Semicolon;\n        }\n        case CharCode.LessThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LessThan) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.LessThan_LessThan_Equals;\n              }\n              this.pos = pos;\n              return Token.LessThan_LessThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.LessThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.LessThan;\n        }\n        case CharCode.Equals: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Equals) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.Equals\n              ) {\n                this.pos = pos + 1;\n                return Token.Equals_Equals_Equals;\n              }\n              this.pos = pos;\n              return Token.Equals_Equals;\n            }\n            if (chr == CharCode.GreaterThan) {\n              this.pos = pos + 1;\n              return Token.Equals_GreaterThan;\n            }\n          }\n          this.pos = pos;\n          return Token.Equals;\n        }\n        case CharCode.GreaterThan: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GreaterThan) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GreaterThan) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.Equals\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GreaterThan_GreaterThan_GreaterThan_Equals;\n                  }\n                  this.pos = pos;\n                  return Token.GreaterThan_GreaterThan_GreaterThan;\n                }\n                if (chr == CharCode.Equals) {\n                  this.pos = pos + 1;\n                  return Token.GreaterThan_GreaterThan_Equals;\n                }\n              }\n              this.pos = pos;\n              return Token.GreaterThan_GreaterThan;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.GreaterThan_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.GreaterThan;\n        }\n        case CharCode.Question: {\n          this.pos = pos + 1;\n          return Token.Question;\n        }\n        case CharCode.OpenBracket: {\n          this.pos = pos + 1;\n          return Token.OpenBracket;\n        }\n        case CharCode.CloseBracket: {\n          this.pos = pos + 1;\n          return Token.CloseBracket;\n        }\n        case CharCode.Caret: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.Equals\n          ) {\n            this.pos = pos + 1;\n            return Token.Caret_Equals;\n          }\n          this.pos = pos;\n          return Token.Caret;\n        }\n        case CharCode.OpenBrace: {\n          this.pos = pos + 1;\n          return Token.OpenBrace;\n        }\n        case CharCode.Bar: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.Bar) {\n              this.pos = pos + 1;\n              return Token.Bar_Bar;\n            }\n            if (chr == CharCode.Equals) {\n              this.pos = pos + 1;\n              return Token.Bar_Equals;\n            }\n          }\n          this.pos = pos;\n          return Token.Bar;\n        }\n        case CharCode.CloseBrace: {\n          this.pos = pos + 1;\n          return Token.CloseBrace;\n        }\n        case CharCode.Tilde: {\n          this.pos = pos + 1;\n          return Token.Tilde;\n        }\n        case CharCode.At: {\n          this.pos = pos + 1;\n          return Token.At;\n        }\n        default: {\n          // Unicode-aware from here on\n          if (isHighSurrogate(c) && pos + 1 < end) {\n            c = combineSurrogates(c, text.charCodeAt(pos + 1));\n          }\n          if (isIdentifierStart(c)) {\n            let posBefore = pos;\n            while (\n              (pos += numCodeUnits(c)) < end &&\n              isIdentifierPart(c = <i32>text.codePointAt(pos))\n            ) { /* nop */ }\n            if (identifierHandling != IdentifierHandling.Always) {\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\n              if (\n                maybeKeywordToken != Token.Invalid &&\n                !(\n                  identifierHandling == IdentifierHandling.Prefer &&\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return maybeKeywordToken;\n              }\n            }\n            this.pos = posBefore;\n            return Token.Identifier;\n          } else if (isWhiteSpace(c)) {\n            ++pos; // assume no supplementary whitespaces\n            break;\n          }\n          let start = pos;\n          pos += numCodeUnits(c);\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.Invalid;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.EndOfFile;\n  }\n\n  peek(\n    identifierHandling: IdentifierHandling = IdentifierHandling.Default,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    let nextToken = this.nextToken;\n    if (nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.Invalid);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      this.nextTokenOnNewLine = OnNewLine.Unknown;\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return nextToken;\n  }\n\n  peekOnNewLine(): bool {\n    switch (this.nextTokenOnNewLine) {\n      case OnNewLine.No: return false;\n      case OnNewLine.Yes: return true;\n    }\n    this.peek();\n    let text = this.source.text;\n    for (let pos = this.pos, end = this.nextTokenPos; pos < end; ++pos) {\n      if (isLineBreak(text.charCodeAt(pos))) {\n        this.nextTokenOnNewLine = OnNewLine.Yes;\n        return true;\n      }\n    }\n    this.nextTokenOnNewLine = OnNewLine.No;\n    return false;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.Prefer): bool {\n    return this.skip(Token.Identifier, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.Default): bool {\n    let posBefore = this.pos;\n    let tokenBefore = this.token;\n    let tokenPosBefore = this.tokenPos;\n    let maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GreaterThan) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    let nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.Invalid);\n    if (nextToken == token) {\n      this.token = token;\n      this.clearNextToken();\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    let state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.clearNextToken();\n  }\n\n  clearNextToken(): void {\n    this.nextToken = -1;\n    this.nextTokenPos = 0;\n    this.nextTokenOnNewLine = OnNewLine.Unknown;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    let start = pos;\n    let c = <i32>text.codePointAt(pos);\n    assert(isIdentifierStart(c));\n    while (\n      (pos += numCodeUnits(c)) < end &&\n      isIdentifierPart(c = <i32>text.codePointAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readingTemplateString: bool = false;\n  readStringStart: i32 = 0;\n  readStringEnd: i32 = 0;\n\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\n    let text = this.source.text;\n    let end = this.end;\n    let pos = this.pos;\n    if (!quote) quote = text.charCodeAt(pos++);\n    let start = pos;\n    this.readStringStart = start;\n    let result = \"\";\n\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        this.readStringEnd = end;\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        this.readStringEnd = pos;\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.Backslash) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence(isTaggedTemplate);\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (quote == CharCode.Backtick) {\n        if (c == CharCode.Dollar && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OpenBrace) {\n          result += text.substring(start, pos);\n          this.readStringEnd = pos;\n          this.pos = pos + 2;\n          this.readingTemplateString = true;\n          return result;\n        }\n      } else if (isLineBreak(c)) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        this.readStringEnd = pos;\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    this.readingTemplateString = false;\n    return result;\n  }\n\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\n    let start = this.pos;\n    let end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    let text = this.source.text;\n    let c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: {\n        if (isTaggedTemplate && this.pos < end && isDecimal(text.charCodeAt(this.pos))) {\n          ++this.pos;\n          return text.substring(start, this.pos);\n        }\n        return \"\\0\";\n      }\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SingleQuote: return \"'\";\n      case CharCode.DoubleQuote: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OpenBrace\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\n      }\n      case CharCode.CarriageReturn: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LineFeed\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LineFeed:\n      case CharCode.LineSeparator:\n      case CharCode.ParagraphSeparator: return \"\";\n      default: return String.fromCodePoint(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.Backslash) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.Slash) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    let text = this.source.text;\n    let start = this.pos;\n    let end = this.end;\n    let flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.Dot || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctal(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_4 = i64_new(4);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // (value << 4) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (isHexBase(c)) {\n        // (value << 4) + (c | 32) + (10 - CharCode.a)\n        nextValue = i64_add(\n          i64_shl(value, i64_4),\n          i64_new((c | 32) + (10 - CharCode.a))\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_10 = i64_new(10);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isDecimal(c)) {\n        // value = value * 10 + c - CharCode._0;\n        nextValue = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start, pos),\n        this.source.text.substring(start, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let i64_3 = i64_new(3);\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (isOctal(c)) {\n        // (value << 3) + c - CharCode._0\n        nextValue = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt_u(value, nextValue)) {\n        // Unsigned overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    let start = pos;\n    let sepEnd = start;\n    let value = i64_zero;\n    let nextValue = value;\n    let overflowOccurred = false;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value << 1 | 0\n        nextValue = i64_shl(value, i64_one);\n      } else if (c == CharCode._1) {\n        // value << 1 | 1\n        nextValue = i64_or(\n          i64_shl(value, i64_one),\n          i64_one\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      if (i64_gt(value, nextValue)) {\n        // Overflow occurred\n        overflowOccurred = true;\n      }\n      value = nextValue;\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    } else if (overflowOccurred) {\n      this.error(\n        DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n        this.range(start - 2, pos),\n        this.source.text.substring(start - 2, pos)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // let text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    let text = this.source.text;\n    let end = this.end;\n    let start = this.pos;\n    let sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.Dot) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.Minus || c == CharCode.Plus &&\n          isDecimal(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    let text = this.source.text;\n    let pos = this.pos;\n    let start = pos;\n    let end = this.end;\n    let sepEnd = start;\n    let sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimal(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\n    let value = 0;\n    let text = this.source.text;\n    let pos = this.pos;\n    let end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (isDecimal(c)) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (isHexBase(c)) {\n        value = (value << 4) + (c | 32) + (10 - CharCode.a);\n      } else if (~startIfTaggedTemplate) {\n        this.pos = --pos;\n        return text.substring(startIfTaggedTemplate, pos);\n      } else {\n        this.pos = pos;\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) { // invalid\n      this.pos = pos;\n      if (~startIfTaggedTemplate) {\n        return text.substring(startIfTaggedTemplate, pos);\n      }\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCodePoint(value);\n  }\n\n  checkForIdentifierStartAfterNumericLiteral(): void {\n    // TODO: BigInt n\n    let pos = this.pos;\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\n      this.error(\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\n        this.range(pos)\n      );\n    }\n  }\n\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\n  }\n\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    let start = this.pos;\n    let value = this.readHexInteger();\n    let value32 = i64_low(value);\n    let invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    let end = this.end;\n    let text = this.source.text;\n    if (this.pos >= end) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unexpected_end_of_text,\n          this.range(start, end)\n        );\n      }\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CloseBrace) {\n      ++this.pos;\n    } else {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    if (invalid) {\n      return ~startIfTaggedTemplate\n        ? text.substring(startIfTaggedTemplate, this.pos)\n        : \"\";\n    }\n    return String.fromCodePoint(value32);\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nlet reusableState: State | null = null;\n","/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Program,\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Class,\n  TypedElement,\n  mangleInternalName,\n  Property,\n  PropertyPrototype\n} from \"./program\";\n\nimport {\n  TypeRef,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getUnaryValue,\n  getCallOperandAt,\n  getCallOperandCount,\n  isConstZero,\n  isConstNonZero\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  cloneMap\n} from \"./util\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  Returns = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  ReturnsWrapped = 1 << 1,\n  /** This flow always returns a non-null value. */\n  ReturnsNonNull = 1 << 2,\n  /** This flow always throws. */\n  Throws = 1 << 3,\n  /** This flow always breaks. */\n  Breaks = 1 << 4,\n  /** This flow always continues. */\n  Continues = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  AccessesThis = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CallsSuper = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  Terminates = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  ConditionallyReturns = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  ConditionallyThrows = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  ConditionallyBreaks = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  ConditionallyContinues = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  ConditionallyAccessesThis = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MayReturnNonThis = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UncheckedContext = 1 << 15,\n  /** This is a flow compiling a constructor parameter. */\n  CtorParamContext = 1 << 16,\n\n  // masks\n\n  /** Any categorical flag. */\n  AnyCategorical = FlowFlags.Returns\n                 | FlowFlags.ReturnsWrapped\n                 | FlowFlags.ReturnsNonNull\n                 | FlowFlags.Throws\n                 | FlowFlags.Breaks\n                 | FlowFlags.Continues\n                 | FlowFlags.AccessesThis\n                 | FlowFlags.CallsSuper\n                 | FlowFlags.Terminates,\n\n  /** Any conditional flag. */\n  AnyConditional = FlowFlags.ConditionallyReturns\n                 | FlowFlags.ConditionallyThrows\n                 | FlowFlags.ConditionallyBreaks\n                 | FlowFlags.ConditionallyContinues\n                 | FlowFlags.ConditionallyAccessesThis\n}\n\n/** Flags indicating the current state of a local. */\nexport const enum LocalFlags {\n  /** No specific conditions. */\n  None = 0,\n\n  /** Local is constant. */\n  Constant = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  Wrapped = 1 << 1,\n  /** Local is non-null. */\n  NonNull = 1 << 2,\n  /** Local is initialized. */\n  Initialized = 1 << 3\n}\n\n/** Flags indicating the current state of a field. */\nexport const enum FieldFlags {\n  None = 0,\n  Initialized = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  Unknown,\n  /** Condition is always true. */\n  True,\n  /** Condition is always false. */\n  False\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the default top-level flow of the specified function. */\n  static createDefault(targetFunction: Function): Flow {\n    let flow = new Flow(targetFunction);\n    if (targetFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    if (targetFunction.program.options.uncheckedBehavior === UncheckedBehavior.Always) {\n      flow.set(FlowFlags.UncheckedContext);\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow, compiling `inlineFunction` into `targetFunction`. */\n  static createInline(targetFunction: Function, inlineFunction: Function): Flow {\n    // Note that `targetFunction` and `inlineFunction` can be the same function\n    // when it is inlined into itself.\n    let flow = new Flow(targetFunction, inlineFunction);\n    flow.inlineReturnLabel = `${inlineFunction.internalName}|inlined.${(inlineFunction.nextInlineId++)}`;\n    if (inlineFunction.is(CommonFlags.Constructor)) {\n      flow.initThisFieldFlags();\n    }\n    if (targetFunction.program.options.uncheckedBehavior === UncheckedBehavior.Always) {\n      flow.set(FlowFlags.UncheckedContext);\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Target function this flow generates code into. */\n    public targetFunction: Function,\n    /** Inline function this flow generates code from, if any. */\n    public inlineFunction: Function | null = null\n  ) {\n    // Setup is performed above so inline ids and field flags are not reset\n    // when forking flows, which also uses the constructor.\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Outer flow. Only relevant for first-class functions. */\n  outer: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.None;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Property,FieldFlags> | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n  /** Alternative flows if a compound expression is true-ish. */\n  trueFlows: Map<ExpressionRef,Flow> | null = null;\n  /** Alternative flows if a compound expression is false-ish. */\n  falseFlows: Map<ExpressionRef,Flow> | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction != null;\n  }\n\n  /** Gets the source function being compiled. Differs from target when inlining. */\n  get sourceFunction(): Function {\n    // Obtaining the source function is useful when resolving elements relative\n    // to their source location. Note that the source function does not necessarily\n    // materialize in the binary, as it might be inlined. Code, locals, etc. must\n    // always be added to / maintained in the materializing target function instead.\n    let inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.targetFunction;\n  }\n\n  /** Gets the program this flow belongs to. */\n  get program(): Program {\n    return this.targetFunction.program;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.sourceFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.sourceFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  deriveConditionalFlags(): FlowFlags {\n    let condiFlags = this.flags & FlowFlags.AnyConditional;\n    if (this.is(FlowFlags.Returns)) {\n      condiFlags |= FlowFlags.ConditionallyReturns;\n    }\n    if (this.is(FlowFlags.Throws)) {\n      condiFlags |= FlowFlags.ConditionallyThrows;\n    }\n    if (this.is(FlowFlags.Breaks)) {\n      condiFlags |= FlowFlags.ConditionallyBreaks;\n    }\n    if (this.is(FlowFlags.Continues)) {\n      condiFlags |= FlowFlags.ConditionallyContinues;\n    }\n    if (this.is(FlowFlags.AccessesThis)) {\n      condiFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n    return condiFlags;\n  }\n\n  /** Forks this flow to a child flow. */\n  fork(\n    /** Whether a new break context is established, e.g. by a block. */\n    newBreakContext: bool = false,\n    /** Whether a new continue context is established, e.g. by a loop. */\n    newContinueContext: bool = newBreakContext\n  ): Flow {\n    let branch = new Flow(this.targetFunction, this.inlineFunction);\n    branch.parent = this;\n    branch.flags = this.flags;\n    branch.outer = this.outer;\n    if (newBreakContext) {\n      branch.flags &= ~(\n        FlowFlags.Breaks |\n        FlowFlags.ConditionallyBreaks\n      );\n    } else {\n      branch.breakLabel = this.breakLabel;\n    }\n    if (newContinueContext) {\n      branch.flags &= ~(\n        FlowFlags.Continues |\n        FlowFlags.ConditionallyContinues\n      );\n    } else {\n      branch.continueLabel = this.continueLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.sourceFunction.is(CommonFlags.Constructor)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = cloneMap(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Forks this flow to a child flow where `condExpr` is true-ish. */\n  forkThen(\n    /** Condition that turned out to be true. */\n    condExpr: ExpressionRef,\n    /** Whether a new break context is established, e.g. by a block. */\n    newBreakContext: bool = false,\n    /** Whether a new continue context is established, e.g. by a loop. */\n    newContinueContext: bool = newBreakContext\n  ): Flow {\n    let flow = this.fork(newBreakContext, newContinueContext);\n    let trueFlows = this.trueFlows;\n    if (trueFlows && trueFlows.has(condExpr)) {\n      flow.inherit(changetype<Flow>(trueFlows.get(condExpr)));\n    }\n    flow.inheritNonnullIfTrue(condExpr);\n    return flow;\n  }\n\n  /** Remembers the alternative flow if `condExpr` turns out `true`. */\n  noteThen(condExpr: ExpressionRef, trueFlow: Flow): void {\n    let trueFlows = this.trueFlows;\n    if (!trueFlows) this.trueFlows = trueFlows = new Map();\n    trueFlows.set(condExpr, trueFlow);\n  }\n\n  /** Forks this flow to a child flow where `condExpr` is false-ish. */\n  forkElse(\n    /** Condition that turned out to be false. */\n    condExpr: ExpressionRef\n  ): Flow {\n    let flow = this.fork();\n    let falseFlows = this.falseFlows;\n    if (falseFlows && falseFlows.has(condExpr)) {\n      flow.inherit(changetype<Flow>(falseFlows.get(condExpr)));\n    }\n    flow.inheritNonnullIfFalse(condExpr);\n    return flow;\n  }\n\n  /** Remembers the alternative flow if `condExpr` turns out `false`. */\n  noteElse(condExpr: ExpressionRef, falseFlow: Flow): void {\n    let falseFlows = this.falseFlows;\n    if (!falseFlows) this.falseFlows = falseFlows = new Map();\n    falseFlows.set(condExpr, falseFlow);\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type): Local {\n    let local = this.targetFunction.addLocal(type);\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    let scopedLocals = this.scopedLocals;\n    if (scopedLocals && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type): Local {\n    let scopedLocal = this.getTempLocal(type);\n    scopedLocal.name = name;\n    scopedLocal.internalName = mangleInternalName(name, scopedLocal.parent, false);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {\n    let scopedDummy = new Local(name, -1, type, this.targetFunction);\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else if (scopedLocals.has(name)) {\n      this.program.error(\n        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,\n        declarationNode.range, name\n      );\n    }\n    scopedDummy.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    let scopedLocals = this.scopedLocals;\n    if (!scopedLocals) {\n      this.scopedLocals = scopedLocals = new Map();\n    } else if (scopedLocals.has(name)) {\n      let existingLocal = assert(scopedLocals.get(name));\n      if (reportNode) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range,\n            existingLocal.declaration.name.range,\n            name\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range, name\n          );\n        }\n      }\n      return existingLocal;\n    }\n    assert(index < this.targetFunction.localsByIndex.length);\n    let scopedAlias = new Local(name, index, type, this.targetFunction);\n    scopedAlias.set(CommonFlags.Scoped);\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    let scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    let current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    let element = this.lookupLocal(name);\n    if (element) return element;\n    return this.sourceFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    let localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    let localFlags = this.localFlags;\n    let flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    let sourceFunction = this.sourceFunction;\n    assert(sourceFunction.is(CommonFlags.Constructor));\n    let parent = sourceFunction.parent;\n    assert(parent.kind == ElementKind.Class);\n    let classInstance = <Class>parent;\n    this.thisFieldFlags = new Map();\n    let members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>member).instance;\n        if (!property || !property.isField) continue;\n        if (\n          // guaranteed by super\n          property.prototype.parent != classInstance ||\n          // has field initializer\n          property.initializerNode ||\n          // is initialized as a ctor parameter\n          property.prototype.parameterIndex != -1 ||\n          // is safe to initialize with zero\n          property.type.isAny(TypeFlags.Value | TypeFlags.Nullable)\n        ) {\n          this.setThisFieldFlag(property, FieldFlags.Initialized);\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Property, flag: FieldFlags): bool {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Property, flag: FieldFlags): void {\n    let fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.sourceFunction.is(CommonFlags.Constructor));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.sourceFunction.is(CommonFlags.Constructor));\n    }\n  }\n\n  /** Pushes a new control flow label, for example when entering a loop that one can `break` from. */\n  pushControlFlowLabel(): i32 {\n    let targetFunction = this.targetFunction;\n    let id = targetFunction.nextBreakId++;\n    let stack = targetFunction.breakStack;\n    if (!stack) targetFunction.breakStack = [ id ];\n    else stack.push(id);\n    return id;\n  }\n\n  /** Pops the most recent control flow label and validates that it matches. */\n  popControlFlowLabel(expectedLabel: i32): void {\n    let targetFunction = this.targetFunction;\n    let stack = assert(targetFunction.breakStack); // should exist\n    assert(stack.length); // should not be empty\n    assert(stack.pop() == expectedLabel); // should match\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n    let otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.Breaks | FlowFlags.ConditionallyBreaks)) {\n        otherFlags &= ~FlowFlags.Terminates;\n      }\n      otherFlags &= ~(FlowFlags.Breaks | FlowFlags.ConditionallyBreaks);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.Continues | FlowFlags.ConditionallyContinues);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n\n  /** Merges only the side effects of a branch, i.e. when not taken. */\n  mergeSideEffects(other: Flow): void {\n    assert(other.targetFunction == this.targetFunction);\n\n    let thisFlags = this.flags;\n    let otherFlags = other.flags;\n    let newFlags = FlowFlags.None;\n\n    if (thisFlags & FlowFlags.Returns) { // nothing can change that\n      newFlags |= FlowFlags.Returns;\n    } else if (otherFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsWrapped;\n    newFlags |= thisFlags & otherFlags & FlowFlags.ReturnsNonNull;\n\n    if (thisFlags & FlowFlags.Throws) { // nothing can change that\n      newFlags |= FlowFlags.Throws;\n    } else if (otherFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (thisFlags & FlowFlags.Breaks) { // nothing can change that\n      newFlags |= FlowFlags.Breaks;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyBreaks;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (thisFlags & FlowFlags.Continues) { // nothing can change that\n      newFlags |= FlowFlags.Continues;\n    } else if (other.continueLabel == this.continueLabel) {\n      if (otherFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.ConditionallyContinues;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.ConditionallyContinues;\n    }\n\n    if (thisFlags & FlowFlags.AccessesThis) { // can become conditional\n      if (otherFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (otherFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MayReturnNonThis;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CallsSuper;\n\n    if (thisFlags & FlowFlags.Terminates) { // nothing can change that\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (thisFlags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n  }\n\n  /** Merges a branch joining again with this flow, i.e. then without else. */\n  mergeBranch(other: Flow): void {\n    this.mergeSideEffects(other);\n\n    // Local flags matter if the branch does not terminate\n    let thisLocalFlags = this.localFlags;\n    let numThisLocalFlags = thisLocalFlags.length;\n    let otherLocalFlags = other.localFlags;\n    let numOtherLocalFlags = otherLocalFlags.length;\n    let maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      thisLocalFlags[i] = thisFlags & otherFlags & (\n        LocalFlags.Constant  |\n        LocalFlags.Wrapped   |\n        LocalFlags.NonNull   |\n        LocalFlags.Initialized\n      );\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits two alternate branches to become this flow, i.e. then with else. */\n  inheritAlternatives(left: Flow, right: Flow): void {\n    assert(left.targetFunction == right.targetFunction);\n    assert(left.targetFunction == this.targetFunction);\n    // Differs from `mergeBranch` in that the alternatives are intersected to\n    // then become this branch.\n\n    let leftFlags = left.flags;\n    let rightFlags = right.flags;\n    let newFlags = FlowFlags.None;\n\n    if (leftFlags & FlowFlags.Returns) {\n      if (rightFlags & FlowFlags.Returns) {\n        newFlags |= FlowFlags.Returns;\n      } else {\n        newFlags |= FlowFlags.ConditionallyReturns;\n      }\n    } else if (rightFlags & FlowFlags.Returns) {\n      newFlags |= FlowFlags.ConditionallyReturns;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyReturns;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsWrapped) && (rightFlags & FlowFlags.ReturnsWrapped)) {\n      newFlags |= FlowFlags.ReturnsWrapped;\n    }\n\n    if ((leftFlags & FlowFlags.ReturnsNonNull) && (rightFlags & FlowFlags.ReturnsNonNull)) {\n      newFlags |= FlowFlags.ReturnsNonNull;\n    }\n\n    if (leftFlags & FlowFlags.Throws) {\n      if (rightFlags & FlowFlags.Throws) {\n        newFlags |= FlowFlags.Throws;\n      } else {\n        newFlags |= FlowFlags.ConditionallyThrows;\n      }\n    } else if (rightFlags & FlowFlags.Throws) {\n      newFlags |= FlowFlags.ConditionallyThrows;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyThrows;\n    }\n\n    if (leftFlags & FlowFlags.Breaks) {\n      if (rightFlags & FlowFlags.Breaks) {\n        newFlags |= FlowFlags.Breaks;\n      } else {\n        newFlags |= FlowFlags.ConditionallyBreaks;\n      }\n    } else if (rightFlags & FlowFlags.Breaks) {\n      newFlags |= FlowFlags.ConditionallyBreaks;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyBreaks;\n    }\n\n    if (leftFlags & FlowFlags.Continues) {\n      if (rightFlags & FlowFlags.Continues) {\n        newFlags |= FlowFlags.Continues;\n      } else {\n        newFlags |= FlowFlags.ConditionallyContinues;\n      }\n    } else if (rightFlags & FlowFlags.Continues) {\n      newFlags |= FlowFlags.ConditionallyContinues;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyContinues;\n    }\n\n    if (leftFlags & FlowFlags.AccessesThis) {\n      if (rightFlags & FlowFlags.AccessesThis) {\n        newFlags |= FlowFlags.AccessesThis;\n      } else {\n        newFlags |= FlowFlags.ConditionallyAccessesThis;\n      }\n    } else if (rightFlags & FlowFlags.AccessesThis) {\n      newFlags |= FlowFlags.ConditionallyAccessesThis;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.ConditionallyAccessesThis;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MayReturnNonThis;\n\n    if ((leftFlags & FlowFlags.CallsSuper) && (rightFlags & FlowFlags.CallsSuper)) {\n      newFlags |= FlowFlags.CallsSuper;\n    }\n\n    if ((leftFlags & FlowFlags.Terminates) && (rightFlags & FlowFlags.Terminates)) {\n      newFlags |= FlowFlags.Terminates;\n    }\n\n    this.flags = newFlags | (this.flags & (FlowFlags.UncheckedContext | FlowFlags.CtorParamContext));\n\n    // local flags\n    let thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.Terminates) {\n      if (!(rightFlags & FlowFlags.Terminates)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.Terminates) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        thisLocalFlags[i] = leftFlags & rightFlags & (\n          LocalFlags.Constant  |\n          LocalFlags.Wrapped   |\n          LocalFlags.NonNull   |\n          LocalFlags.Initialized\n        );\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    let leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Property,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.Initialized) != 0 && rightFieldFlags.has(key) &&\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.Initialized)\n        ) {\n          newFieldFlags.set(key, FieldFlags.Initialized);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if recompilation is needed due to incompatible local flags between loops, and resets if necessary. */\n  resetIfNeedsRecompile(\n    /** Resulting flow of the current compilation attempt. */\n    other: Flow,\n    /** Number of locals before the compilation attempt. */\n    numLocalsBefore: i32\n  ): bool {\n    let numThisLocalFlags = this.localFlags.length;\n    let numOtherLocalFlags = other.localFlags.length;\n    let targetFunction = this.targetFunction;\n    assert(targetFunction == other.targetFunction);\n    let localsByIndex = targetFunction.localsByIndex;\n    assert(localsByIndex == other.targetFunction.localsByIndex);\n    let needsRecompile = false;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (this.isLocalFlag(i, LocalFlags.Wrapped) && !other.isLocalFlag(i, LocalFlags.Wrapped)) {\n          this.unsetLocalFlag(i, LocalFlags.Wrapped); // assume not wrapped\n          needsRecompile = true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (this.isLocalFlag(i, LocalFlags.NonNull) && !other.isLocalFlag(i, LocalFlags.NonNull)) {\n          this.unsetLocalFlag(i, LocalFlags.NonNull); // assume possibly null\n          needsRecompile = true;\n        }\n      }\n    }\n    if (needsRecompile) {\n      // Reset function locals to state before the compilation attempt\n      assert(localsByIndex.length >= numLocalsBefore);\n      localsByIndex.length = numLocalsBefore;\n      if (this.localFlags.length > numLocalsBefore) {\n        this.localFlags.length = numLocalsBefore;\n      }\n    }\n    return needsRecompile;\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NonNull), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NonNull, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  private inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.targetFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NonNull)) {\n          this.setLocalFlag(local.index, LocalFlags.NonNull);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstZero(ifFalse)) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n          this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff); // !value -> value must have been false\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  private inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        let ifFalse = getIfFalse(expr);\n        if (ifFalse && isConstNonZero(ifTrue)) {\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n          this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n            } else if (isConstZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (isConstNonZero(left)) {\n              this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n            } else if (isConstNonZero(right)) {\n              this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        // handle string eq/ne/not overloads\n        let name = getCallTarget(expr);\n        if (name == BuiltinNames.String_eq) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(FALSE == right) -> right must have been true\n          } else if (isConstZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left == FALSE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_ne) {\n          assert(getCallOperandCount(expr) == 2);\n          let left = getCallOperandAt(expr, 0);\n          let right = getCallOperandAt(expr, 1);\n          if (isConstNonZero(left)) {\n            this.inheritNonnullIfTrue(right, iff); // !(TRUE != right) -> right must have been true\n          } else if (isConstNonZero(right)) {\n            this.inheritNonnullIfTrue(left, iff); // !(left != TRUE) -> left must have been true\n          }\n        } else if (name == BuiltinNames.String_not) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff); // !(!value) -> value must have been true\n        } else if (name == BuiltinNames.tostack) {\n          assert(getCallOperandCount(expr) == 1);\n          this.inheritNonnullIfFalse(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    let operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.targetFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.Wrapped, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.Global || global.kind == ElementKind.EnumValue);\n        return canConversionOverflow((<TypedElement>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n\n          // sign extensions overflow if result can have high garbage bits in the target type\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\n          case <u32>TypeRef.V128: return false;\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.Bool: return (value & ~1) != 0;\n          case TypeKind.I8:   return value < <i32>i8.MIN_VALUE  || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16:  return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8:   return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16:  return value < 0 || value > <i32>u16.MAX_VALUE;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.Function);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.ReturnsWrapped)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    let levels = 0;\n    let parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    let sb = new Array<string>();\n    if (this.is(FlowFlags.Returns)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.ReturnsWrapped)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.ReturnsNonNull)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.Throws)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.Breaks)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.Continues)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.AccessesThis)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CallsSuper)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.Terminates)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.ConditionallyReturns)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.ConditionallyThrows)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.ConditionallyBreaks)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.ConditionallyContinues)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.ConditionallyAccessesThis)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MayReturnNonThis)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return `Flow(${this.sourceFunction})[${levels}] ${sb.join(\" \")}`;\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n","/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// ├─DeclaredElement          Base class of elements with a declaration\n// │ ├─TypedElement           Base class of elements resolving to a type\n// │ │ ├─TypeDefinition       Type alias declaration\n// │ │ ├─VariableLikeElement  Base class of all variable-like elements\n// │ │ │ ├─EnumValue          Enum value\n// │ │ │ ├─Global             File global\n// │ │ │ ├─Local              Function local\n// │ │ │ └─Property           Class property (incl. instance fields)\n// │ │ ├─IndexSignature       Class index signature\n// │ │ ├─Function             Concrete function instance\n// │ │ └─Class                Concrete class instance\n// │ ├─Namespace              Namespace with static members\n// │ ├─FunctionPrototype      Prototype of concrete function instances\n// │ ├─PropertyPrototype      Prototype of concrete property instances\n// │ └─ClassPrototype         Prototype of concrete classe instances\n// └─File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target,\n  featureToString\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind,\n  ParameterNode,\n  TypeName\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment,\n  getFunctionName\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames,\n  builtinFunctions,\n  builtinVariables_onAccess\n} from \"./builtins\";\n\n// Memory manager constants\nconst AL_SIZE = 16;\nconst AL_MASK = AL_SIZE - 1;\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  Invalid,\n\n  // indexed access\n  IndexedGet,          // a[]\n  IndexedSet,          // a[]=b\n  UncheckedIndexedGet, // unchecked(a[])\n  UncheckedIndexedSet, // unchecked(a[]=b)\n\n  // binary\n  Add,                 // a + b\n  Sub,                 // a - b\n  Mul,                 // a * b\n  Div,                 // a / b\n  Rem,                 // a % b\n  Pow,                 // a ** b\n  BitwiseAnd,          // a & b\n  BitwiseOr,           // a | b\n  BitwiseXor,          // a ^ b\n  BitwiseShl,          // a << b\n  BitwiseShr,          // a >> b\n  BitwiseShrU,         // a >>> b\n  Eq,                  // a == b, a === b\n  Ne,                  // a != b, a !== b\n  Gt,                  // a > b\n  Ge,                  // a >= b\n  Lt,                  // a < b\n  Le,                  // a <= b\n\n  // unary prefix\n  Plus,                // +a\n  Minus,               // -a\n  Not,                 // !a\n  BitwiseNot,          // ~a\n  PrefixInc,           // ++a\n  PrefixDec,           // --a\n\n  // unary postfix\n  PostfixInc,          // a++\n  PostfixDec           // a--\n\n  // not overridable:\n  // LogicalAnd        // a && b\n  // LogicalOr         // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OpenBracket: {\n            if (arg == \"[]\") return OperatorKind.IndexedGet;\n            if (arg == \"[]=\") return OperatorKind.IndexedSet;\n            break;\n          }\n          case CharCode.OpenBrace: {\n            if (arg == \"{}\") return OperatorKind.UncheckedIndexedGet;\n            if (arg == \"{}=\") return OperatorKind.UncheckedIndexedSet;\n            break;\n          }\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Add;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Sub;\n            break;\n          }\n          case CharCode.Asterisk: {\n            if (arg == \"*\") return OperatorKind.Mul;\n            if (arg == \"**\") return OperatorKind.Pow;\n            break;\n          }\n          case CharCode.Slash: {\n            if (arg == \"/\") return OperatorKind.Div;\n            break;\n          }\n          case CharCode.Percent: {\n            if (arg == \"%\") return OperatorKind.Rem;\n            break;\n          }\n          case CharCode.Ampersand: {\n            if (arg == \"&\") return OperatorKind.BitwiseAnd;\n            break;\n          }\n          case CharCode.Bar: {\n            if (arg == \"|\") return OperatorKind.BitwiseOr;\n            break;\n          }\n          case CharCode.Caret: {\n            if (arg == \"^\") return OperatorKind.BitwiseXor;\n            break;\n          }\n          case CharCode.Equals: {\n            if (arg == \"==\") return OperatorKind.Eq;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!=\") return OperatorKind.Ne;\n            break;\n          }\n          case CharCode.GreaterThan: {\n            if (arg == \">\") return OperatorKind.Gt;\n            if (arg == \">=\") return OperatorKind.Ge;\n            if (arg == \">>\") return OperatorKind.BitwiseShr;\n            if (arg == \">>>\") return OperatorKind.BitwiseShrU;\n            break;\n          }\n          case CharCode.LessThan: {\n            if (arg == \"<\") return OperatorKind.Lt;\n            if (arg == \"<=\") return OperatorKind.Le;\n            if (arg == \"<<\") return OperatorKind.BitwiseShl;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPrefix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"+\") return OperatorKind.Plus;\n            if (arg == \"++\") return OperatorKind.PrefixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"-\") return OperatorKind.Minus;\n            if (arg == \"--\") return OperatorKind.PrefixDec;\n            break;\n          }\n          case CharCode.Exclamation: {\n            if (arg == \"!\") return OperatorKind.Not;\n            break;\n          }\n          case CharCode.Tilde: {\n            if (arg == \"~\") return OperatorKind.BitwiseNot;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OperatorPostfix: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.Plus: {\n            if (arg == \"++\") return OperatorKind.PostfixInc;\n            break;\n          }\n          case CharCode.Minus: {\n            if (arg == \"--\") return OperatorKind.PostfixDec;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus:\n      case Token.Plus_Equals: return OperatorKind.Add;\n      case Token.Minus:\n      case Token.Minus_Equals: return OperatorKind.Sub;\n      case Token.Asterisk:\n      case Token.Asterisk_Equals: return OperatorKind.Mul;\n      case Token.Slash:\n      case Token.Slash_Equals: return OperatorKind.Div;\n      case Token.Percent:\n      case Token.Percent_Equals: return OperatorKind.Rem;\n      case Token.Asterisk_Asterisk:\n      case Token.Asterisk_Asterisk_Equals: return OperatorKind.Pow;\n      case Token.Ampersand:\n      case Token.Ampersand_Equals: return OperatorKind.BitwiseAnd;\n      case Token.Bar:\n      case Token.Bar_Equals: return OperatorKind.BitwiseOr;\n      case Token.Caret:\n      case Token.Caret_Equals: return OperatorKind.BitwiseXor;\n      case Token.LessThan_LessThan:\n      case Token.LessThan_LessThan_Equals: return OperatorKind.BitwiseShl;\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShr;\n      case Token.GreaterThan_GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals: return OperatorKind.BitwiseShrU;\n      case Token.Equals_Equals: return OperatorKind.Eq;\n      case Token.Exclamation_Equals: return OperatorKind.Ne;\n      case Token.GreaterThan: return OperatorKind.Gt;\n      case Token.GreaterThan_Equals: return OperatorKind.Ge;\n      case Token.LessThan: return OperatorKind.Lt;\n      case Token.LessThan_Equals: return OperatorKind.Le;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus: return OperatorKind.Plus;\n      case Token.Minus: return OperatorKind.Minus;\n      case Token.Exclamation: return OperatorKind.Not;\n      case Token.Tilde: return OperatorKind.BitwiseNot;\n      case Token.Plus_Plus: return OperatorKind.PrefixInc;\n      case Token.Minus_Minus: return OperatorKind.PrefixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.Plus_Plus: return OperatorKind.PostfixInc;\n      case Token.Minus_Minus: return OperatorKind.PostfixDec;\n    }\n    return OperatorKind.Invalid;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    this.module = Module.create(options.stackSize > 0, options.sizeTypeRef);    \n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    let nativeFile = new File(this, Source.native);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Module instance. */\n  module: Module;\n  /** Parser instance. */\n  parser!: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Map<string, Signature> = new Map<string, Signature>();\n  /** Module imports. */\n  moduleImports: Map<string,Map<string,Element>> = new Map();\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    let cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    let cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    let cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    let cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    let cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    let cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    let cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    let cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    let cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    let cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    let cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    let cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    let cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    let cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    let cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    let cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    let cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    let cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `RegExp` instance. */\n  get regexpInstance(): Class {\n    let cached = this._regexpInstance;\n    if (!cached) this._regexpInstance = cached = this.requireClass(CommonNames.RegExp);\n    return cached;\n  }\n  private _regexpInstance: Class | null = null;\n\n  /** Gets the standard `Object` prototype. */\n  get objectPrototype(): ClassPrototype {\n    let cached = this._objectPrototype;\n    if (!cached) this._objectPrototype = cached = <ClassPrototype>this.require(CommonNames.Object, ElementKind.ClassPrototype);\n    return cached;\n  }\n  private _objectPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Object` instance. */\n  get objectInstance(): Class {\n    let cached = this._objectInstance;\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\n    return cached;\n  }\n  private _objectInstance: Class | null = null;\n\n  /** Gets the standard `TemplateStringsArray` instance. */\n  get templateStringsArrayInstance(): Class {\n    let cached = this._templateStringsArrayInstance;\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\n    return cached;\n  }\n  private _templateStringsArrayInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    let prototype = this.lookup(CommonNames.abort);\n    if (!prototype || prototype.kind != ElementKind.FunctionPrototype) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    let cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    let cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    let cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    let cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    let cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\n  get linkInstance(): Function {\n    let cached = this._linkInstance;\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\n    return cached;\n  }\n  private _linkInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    let cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    let cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    let cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    let cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    let cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    let cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    let sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the overhead of a memory manager block. */\n  get blockOverhead(): i32 {\n    // BLOCK | data...\n    //       ^ 16b alignment\n    return this.BLOCKInstance.nextMemoryOffset;\n  }\n\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\n  get objectOverhead(): i32 {\n    // OBJECT+align | data...\n    //        └ 0 ┘ ^ 16b alignment\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\n  }\n\n  /** Gets the total overhead of a managed object, incl. block overhead. */\n  get totalOverhead(): i32 {\n    // BLOCK | OBJECT+align | data...\n    // └     = TOTAL      ┘ ^ 16b alignment\n    return this.blockOverhead + this.objectOverhead;\n  }\n\n  searchFunctionByRef(ref: FunctionRef): Function | null {\n    const modifiedFunctionName = getFunctionName(ref);\n    if (modifiedFunctionName) {\n      const instancesByName = this.instancesByName;\n      if (instancesByName.has(modifiedFunctionName)) {\n        const element = assert(instancesByName.get(modifiedFunctionName));\n        if (element.kind == ElementKind.Function) {\n          return <Function>element;\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart(currentOffset: i32): i32 {\n    let blockOverhead = this.blockOverhead;\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart64(currentOffset: i64): i64 {\n    let blockOverhead = i64_new(this.blockOverhead);\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\n  }\n\n  /** Computes the size of a memory manager block, excl. block overhead. */\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\n    if (isManaged) payloadSize += this.objectOverhead;\n    // we know that payload must be aligned, and that block sizes must be chosen\n    // so that blocks are adjacent with the next payload aligned. hence, block\n    // size is payloadSize rounded up to where the next block would start:\n    let blockSize = this.computeBlockStart(payloadSize);\n    // make sure that block size is valid according to TLSF requirements\n    let blockOverhead = this.blockOverhead;\n    let blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\n    const tagsMask = 3;\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\n      throw new Error(\"invalid block size\");\n    }\n    return blockSize;\n  }\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.None\n  ): VariableDeclaration {\n    let range = Source.native.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None\n  ): TypeDeclaration {\n    let range = Source.native.range;\n    let identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.None\n  ): FunctionDeclaration {\n    let range = Source.native.range;\n    let signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.None, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.None\n  ): NamespaceDeclaration {\n    let range = Source.native.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.None,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    let elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    let options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\n      CommonNames.nonnull,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.Export | CommonFlags.Generic),\n      DecoratorFlags.Builtin\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n    this.registerNativeType(CommonNames.eqref, Type.eqref);\n    this.registerNativeType(CommonNames.structref, Type.structref);\n    this.registerNativeType(CommonNames.arrayref, Type.arrayref);\n    this.registerNativeType(CommonNames.i31ref, Type.i31ref);\n    this.registerNativeType(CommonNames.stringref, Type.stringref);\n    this.registerNativeType(CommonNames.stringview_wtf8, Type.stringview_wtf8);\n    this.registerNativeType(CommonNames.stringview_wtf16, Type.stringview_wtf16);\n    this.registerNativeType(CommonNames.stringview_iter, Type.stringview_iter);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.Wasm64 : Target.Wasm32));\n    this.registerConstantInteger(CommonNames.ASC_RUNTIME, Type.i32,\n      i64_new(options.runtime));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\n      i64_new(options.exportRuntime ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\n      i64_new(options.bundleMajorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\n      i64_new(options.bundleMinorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\n      i64_new(options.bundlePatchVersion));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SignExtension) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MutableGlobals) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NontrappingF2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BulkMemory) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.Simd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.Threads) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.ExceptionHandling) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TailCalls) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.ReferenceTypes) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MultiValue) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.Memory64) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_RELAXED_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.RelaxedSimd) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXTENDED_CONST, Type.bool,\n      i64_new(options.hasFeature(Feature.ExtendedConst) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_STRINGREF, Type.bool,\n      i64_new(options.hasFeature(Feature.Stringref) ? 1 : 0, 0));\n\n    // remember deferred elements\n    let queuedImports = new Array<QueuedImport>();\n    let queuedExports = new Map<File,Map<string,QueuedExport>>();\n    let queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    let queuedExtends = new Array<ClassPrototype>();\n    let queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.Export: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.ExportDefault: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.Import: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.Variable: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.ClassDeclaration: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.EnumDeclaration: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FunctionDeclaration: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.InterfaceDeclaration: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NamespaceDeclaration: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TypeDeclaration: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        // File must be found here, as it would otherwise already have been reported by the parser\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            foreignFile,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let localFile = queuedImport.localFile;\n          let localName = localIdentifier.text;\n          localFile.add(\n            localName,\n            foreignFile.asAliasNamespace(\n              localName,\n              localFile,\n              localIdentifier\n            ),\n            localIdentifier // isImport\n          );\n          queuedImports.splice(i, 1);\n          madeProgress = true;\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          // File must be found here, as it would otherwise already have been reported by the parser\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.getMember(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookup(localName);\n            if (globalElement && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register foundational classes with fixed ids\n    assert(this.objectInstance.id == 0);\n    assert(this.arrayBufferInstance.id == 1);\n    assert(this.stringInstance.id == 2);\n    assert(this.arrayBufferViewInstance.id == 3);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.Simd)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.ReferenceTypes)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);\n        this.registerWrapperClass(Type.structref, CommonNames.Structref);\n        this.registerWrapperClass(Type.arrayref, CommonNames.Arrayref);\n        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    let resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.ClassPrototype) {\n        if (baseElement.kind == ElementKind.ClassPrototype) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.Final)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.Unmanaged) !=\n            thisPrototype.hasDecorator(DecoratorFlags.Unmanaged)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.InterfacePrototype) {\n        if (baseElement.kind == ElementKind.InterfacePrototype) {\n          const basePrototype = <InterfacePrototype>baseElement;\n          if (!thisPrototype.extends(basePrototype)) {\n            thisPrototype.basePrototype = basePrototype;\n          } else {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              basePrototype.identifierNode.range,\n              basePrototype.identifierNode.text,\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // check override\n    for (let i = 0, k = queuedExtends.length; i < k; i++) {\n      let prototype = queuedExtends[i];\n      let instanesMembers = prototype.instanceMembers;\n      if (instanesMembers) {\n        let members = Map_values(instanesMembers);\n        for (let j = 0, k = members.length; j < k; j++) {\n          let member = members[j];\n          let declaration = member.declaration;\n          if (declaration.is(CommonFlags.Override)) {\n            let basePrototype = prototype.basePrototype;\n            let hasOverride = false;\n            while (basePrototype) {\n              let instanceMembers = basePrototype.instanceMembers;\n              if (instanceMembers) {\n                if (instanceMembers.has(member.name)) {\n                  hasOverride = true;\n                  break;\n                }\n              }\n              basePrototype = basePrototype.basePrototype;\n            }\n            if (!hasOverride) {\n              let basePrototype = assert(prototype.basePrototype);\n              this.error(\n                DiagnosticCode.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,\n                declaration.name.range,\n                basePrototype.name\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.InterfacePrototype) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // process overrides in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.processOverrides(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.processOverrides(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.processOverrides(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort, BuiltinNames.abort);\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace, BuiltinNames.trace);\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed, BuiltinNames.seed);\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            this.error(DiagnosticCode.Element_0_not_found, null, name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Processes overridden members by this class in a base class. */\n  private processOverrides(\n    thisPrototype: ClassPrototype,\n    basePrototype: ClassPrototype,\n  ): void {\n    // Note that we don't know concrete instances of class members, yet. Type\n    // checking of concrete (generic) instances happens upon resolve.\n    let thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      let thisMembers = Map_values(thisInstanceMembers);\n      let seen: Set<ClassPrototype> | null = null;\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let j = 0, l = thisMembers.length; j < l; ++j) {\n            let thisMember = thisMembers[j];\n            if (baseInstanceMembers.has(thisMember.name)) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              this.doProcessOverride(thisPrototype, thisMember, basePrototype, baseMember);\n            }\n          }\n        }\n        // A class can have a base class and multiple interfaces, but from the\n        // base member alone we only get one. Make sure we don't miss any.\n        let baseInterfacePrototypes = basePrototype.interfacePrototypes;\n        if (baseInterfacePrototypes) {\n          for (let i = 0, k = baseInterfacePrototypes.length; i < k; ++i) {\n            let baseInterfacePrototype = baseInterfacePrototypes[i];\n            if (baseInterfacePrototype != basePrototype) {\n              this.processOverrides(thisPrototype, baseInterfacePrototype);\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        // Break on circular inheritance. Is diagnosed later, when resolved.\n        if (!seen) seen = new Set();\n        seen.add(basePrototype);\n        if (seen.has(nextPrototype)) break;\n        // Otherwise traverse to next base prototype.\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Processes a single overridden member by this class in a base class. */\n  private doProcessOverride(\n    thisClass: ClassPrototype,\n    thisMember: DeclaredElement,\n    baseClass: ClassPrototype,\n    baseMember: DeclaredElement\n  ): void {\n    // Constructors and private members do not override\n    if (thisMember.isAny(CommonFlags.Constructor | CommonFlags.Private)) return;\n    if (\n      thisMember.kind == ElementKind.FunctionPrototype &&\n      baseMember.kind == ElementKind.FunctionPrototype\n    ) {\n      let thisMethod = <FunctionPrototype>thisMember;\n      let baseMethod = <FunctionPrototype>baseMember;\n      if (!thisMethod.visibilityEquals(baseMethod)) {\n        this.errorRelated(\n          DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n          thisMethod.identifierNode.range, baseMethod.identifierNode.range\n        );\n      }\n      baseMember.set(CommonFlags.Overridden);\n      let overrides = baseMethod.unboundOverrides;\n      if (!overrides) baseMethod.unboundOverrides = overrides = new Set();\n      overrides.add(<FunctionPrototype>thisMember);\n      let baseMethodInstances = baseMethod.instances;\n      if (baseMethodInstances) {\n        for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n          let baseMethodInstance = _values[a];\n          baseMethodInstance.set(CommonFlags.Overridden);\n        }\n      }\n    } else if (\n      thisMember.kind == ElementKind.PropertyPrototype &&\n      baseMember.kind == ElementKind.PropertyPrototype\n    ) {\n      let thisProperty = <PropertyPrototype>thisMember;\n      let baseProperty = <PropertyPrototype>baseMember;\n      if (!thisProperty.visibilityEquals(baseProperty)) {\n        this.errorRelated(\n          DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n          thisProperty.identifierNode.range, baseProperty.identifierNode.range\n        );\n      }\n      if (baseProperty.parent.kind != ElementKind.InterfacePrototype) {\n        // Interface fields/properties can be implemented by either, but other\n        // members must match to retain compatiblity with TS/JS.\n        let thisIsField = thisProperty.isField;\n        if (thisIsField != baseProperty.isField) {\n          if (thisIsField) { // base is property\n            this.errorRelated(\n              DiagnosticCode._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property,\n              thisProperty.identifierNode.range, baseProperty.identifierNode.range,\n              thisProperty.name, baseClass.internalName, thisClass.internalName\n            );\n          } else { // this is property, base is field\n            this.errorRelated(\n              DiagnosticCode._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor,\n              thisProperty.identifierNode.range, baseProperty.identifierNode.range,\n              thisProperty.name, baseClass.internalName, thisClass.internalName\n            );\n          }\n          return;\n        } else if (thisIsField) { // base is also field\n          // Fields don't override other fields and can only be redeclared\n          return;\n        }\n      }\n      baseProperty.set(CommonFlags.Overridden);\n      let baseGetter = baseProperty.getterPrototype;\n      if (baseGetter) {\n        baseGetter.set(CommonFlags.Overridden);\n        let thisGetter = thisProperty.getterPrototype;\n        if (thisGetter) {\n          let overrides = baseGetter.unboundOverrides;\n          if (!overrides) baseGetter.unboundOverrides = overrides = new Set();\n          overrides.add(thisGetter);\n        }\n        let baseGetterInstances = baseGetter.instances;\n        if (baseGetterInstances) {\n          for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n            let baseGetterInstance = _values[a];\n            baseGetterInstance.set(CommonFlags.Overridden);\n          }\n        }\n      }\n      let baseSetter = baseProperty.setterPrototype;\n      if (baseSetter && thisProperty.setterPrototype) {\n        baseSetter.set(CommonFlags.Overridden);\n        let thisSetter = thisProperty.setterPrototype;\n        if (thisSetter) {\n          let overrides = baseSetter.unboundOverrides;\n          if (!overrides) baseSetter.unboundOverrides = overrides = new Set();\n          overrides.add(thisSetter);\n        }\n        let baseSetterInstances = baseSetter.instances;\n        if (baseSetterInstances) {\n          for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n            let baseSetterInstance = _values[a];\n            baseSetterInstance.set(CommonFlags.Overridden);\n          }\n        }\n      }\n    } else {\n      this.errorRelated(\n        DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n        thisMember.identifierNode.range, baseMember.identifierNode.range,\n        thisMember.name, thisClass.internalName, baseClass.internalName\n      );\n    }\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookup(name: string): Element | null {\n    let elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    let element = this.lookup(name);\n    if (!element) throw new Error(`Missing standard library component: ${name}`);\n    if (element.kind != kind) throw Error(`Invalid standard library component kind: ${name}`);\n    return element;\n  }\n\n  /** Requires that a global variable is present and returns it. */\n  requireGlobal(name: string): Global {\n    return <Global>this.require(name, ElementKind.Global);\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  requireClass(name: string): Class {\n    let prototype = this.require(name, ElementKind.ClassPrototype);\n    let resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(`Invalid standard library class: ${name}`);\n    return resolved;\n  }\n\n  /** Requires that a global function is present and returns it. */\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    let prototype = <FunctionPrototype>this.require(name, ElementKind.FunctionPrototype);\n    let resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(`Invalid standard library function: ${name}`);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.ModuleExport);\n    switch (element.kind) {\n      case ElementKind.ClassPrototype: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.Property:\n      case ElementKind.Function:\n      case ElementKind.Class: assert(false); // assumes that there are no instances yet\n    }\n    let staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Marks an element as a module import. */\n  markModuleImport(moduleName: string, name: string, element: Element): void {\n    element.set(CommonFlags.ModuleImport);\n    let moduleImports = this.moduleImports;\n    let module: Map<string,Element>;\n    if (moduleImports.has(moduleName)) {\n      module = assert(moduleImports.get(moduleName));\n    } else {\n      module = new Map();\n      moduleImports.set(moduleName, module);\n    }\n    module.set(name, element);\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    let element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.Export),\n      DecoratorFlags.Builtin\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    let wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    let element = assert(this.lookup(className));\n    assert(element.kind == ElementKind.ClassPrototype);\n    let classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.Lazy,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    let global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.Lazy,\n      this.makeNativeVariableDeclaration(name, CommonFlags.Const | CommonFlags.Export)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    let elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing != element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    let filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** The other file. */\n    foreignFile: File,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      // check if already resolved\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // follow queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n\n          // re-exported from another file\n          if (queuedExportForeignPath) {\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\n            if (!otherFile) return null;\n            foreignName = queuedExport.localIdentifier.text;\n            foreignFile = otherFile;\n            continue;\n          }\n\n          // exported from this file\n          element = foreignFile.getMember(queuedExport.localIdentifier.text);\n          if (element) return element;\n        }\n      }\n      break;\n    } while (true);\n\n    // follow star exports\n    let exportsStar = foreignFile.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    let flags = DecoratorFlags.None;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    return flags;\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.Simd, reportNode);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode);\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        return this.checkFeatureEnabled(Feature.ReferenceTypes, reportNode)\n            && this.checkFeatureEnabled(Feature.Stringref, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while (classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    let name = declaration.name.text;\n    let element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Final |\n        DecoratorFlags.Unmanaged\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    let implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.Unmanaged)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) {\n      queuedExtends.push(element);\n    } else if (\n      !element.hasDecorator(DecoratorFlags.Unmanaged) &&\n      element.internalName != BuiltinNames.Object\n    ) {\n      element.implicitlyExtendsObject = true;\n    }\n\n    // initialize members\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method && methodDeclaration.name.kind == NodeKind.Constructor) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.IndexSignature: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let name = declaration.name.text;\n    let decorators = declaration.decorators;\n    let element: DeclaredElement;\n    let acceptedFlags: DecoratorFlags = DecoratorFlags.Unsafe;\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    if (declaration.is(CommonFlags.Static)) { // global variable\n      assert(parent.kind != ElementKind.InterfacePrototype);\n      acceptedFlags |= DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Readonly)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.Abstract | CommonFlags.Get | CommonFlags.Set));\n      element = PropertyPrototype.forField(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let isStatic = declaration.is(CommonFlags.Static);\n    let acceptedFlags = DecoratorFlags.Inline | DecoratorFlags.Unsafe;\n    if (!declaration.is(CommonFlags.Generic)) {\n      acceptedFlags |= DecoratorFlags.OperatorBinary\n                    |  DecoratorFlags.OperatorPrefix\n                    |  DecoratorFlags.OperatorPostfix;\n    }\n    if (parent.is(CommonFlags.Ambient)) {\n      acceptedFlags |= DecoratorFlags.External;\n    }\n    if (declaration.range.source.isLibrary) {\n      acceptedFlags |= DecoratorFlags.Builtin;\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (element.hasDecorator(DecoratorFlags.Builtin) && !builtinFunctions.has(element.internalName)) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        declaration.range, `Builtin '${element.internalName}'`\n      );\n    }\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.Constructor);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.Operator:\n          case DecoratorKind.OperatorBinary:\n          case DecoratorKind.OperatorPrefix:\n          case DecoratorKind.OperatorPostfix: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.String)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.Invalid) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.operatorOverloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    let name = declaration.name.text;\n    if (declaration.is(CommonFlags.Static)) {\n      let parentMembers = parent.members;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PropertyPrototype) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    let property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    let name = declaration.name.text;\n    let isGetter = declaration.is(CommonFlags.Get);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    let element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property.parent, // same level as property\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Inline | DecoratorFlags.Unsafe\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    let name = declaration.name.text;\n    let element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global |\n        DecoratorFlags.Inline |\n        DecoratorFlags.Lazy\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    let values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    let name = declaration.name.text;\n    let element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.None\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    let members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let localName = member.localName.text;\n    let foreignName = member.exportedName.text;\n\n    // check for duplicates\n    let element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath == null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.getMember(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    let declaration = statement.declaration;\n    let element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.EnumDeclaration: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FunctionDeclaration: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.ClassDeclaration: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.InterfaceDeclaration: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NamespaceDeclaration: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    let foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n    if (foreignFile) {\n      let element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\n      if (element) {\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\n        return;\n      }\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    let name = declaration.name.text;\n    let validDecorators = DecoratorFlags.Unsafe;\n    if (declaration.is(CommonFlags.Ambient)) {\n      validDecorators |= DecoratorFlags.External | DecoratorFlags.ExternalJs;\n    } else {\n      validDecorators |= DecoratorFlags.Inline;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.Export)) {\n        validDecorators |= DecoratorFlags.Lazy;\n      }\n    }\n    if (!declaration.is(CommonFlags.Instance)) {\n      if (parent.kind != ElementKind.ClassPrototype) {\n        validDecorators |= DecoratorFlags.Global;\n      }\n    }\n    if (declaration.range.source.isLibrary) {\n      validDecorators |= DecoratorFlags.Builtin;\n    }\n    let element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (element.hasDecorator(DecoratorFlags.Builtin) && !builtinFunctions.has(element.internalName)) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        declaration.range, `Builtin '${element.internalName}'`\n      );\n    }\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    let name = declaration.name.text;\n    let element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.Global\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    let memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FieldDeclaration: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.MethodDeclaration: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    let typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.Get,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.Readonly)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.Set,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    let name = declaration.name.text;\n    let original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.Global)\n    );\n    if (!parent.add(name, original)) return null;\n    let element = assert(parent.getMember(name)); // possibly merged\n    let members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.ClassDeclaration: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.EnumDeclaration: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FunctionDeclaration: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.InterfaceDeclaration: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NamespaceDeclaration: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TypeDeclaration: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.Variable: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // keep original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let name = declaration.name.text;\n    let element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.None)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    let declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.Global | DecoratorFlags.Lazy;\n      if (declaration.is(CommonFlags.Ambient)) {\n        acceptedFlags |= DecoratorFlags.External;\n      }\n      if (declaration.is(CommonFlags.Const)) {\n        acceptedFlags |= DecoratorFlags.Inline;\n      }\n      if (declaration.range.source.isLibrary) {\n        acceptedFlags |= DecoratorFlags.Builtin;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (element.hasDecorator(DecoratorFlags.Builtin) && !builtinVariables_onAccess.has(element.internalName)) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          declaration.range, `Builtin '${element.internalName}'`\n        );\n      }\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   let current: Class | null = target;\n  //   let arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport const enum ElementKind {\n  /** A {@link Global}. */\n  Global,\n  /** A {@link Local}. */\n  Local,\n  /** An {@link Enum}. */\n  Enum,\n  /** An {@link EnumValue}. */\n  EnumValue,\n  /** A {@link FunctionPrototype}. */\n  FunctionPrototype,\n  /** A {@link Function}. */\n  Function,\n  /** A {@link ClassPrototype}. */\n  ClassPrototype,\n  /** A {@link Class}. */\n  Class,\n  /** An {@link InterfacePrototype}. */\n  InterfacePrototype,\n  /** An {@link Interface}. */\n  Interface,\n  /** A {@link PropertyPrototype}.  */\n  PropertyPrototype,\n  /** A {@link Property}. */\n  Property,\n  /** A {@link Namespace}. */\n  Namespace,\n  /** A {@link File}. */\n  File,\n  /** A {@link TypeDefinition}.  */\n  TypeDefinition,\n  /** An {@link IndexSignature}. */\n  IndexSignature\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  None = 0,\n  /** Is a program global. */\n  Global = 1 << 0,\n  /** Is a binary operator overload. */\n  OperatorBinary = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OperatorPrefix = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OperatorPostfix = 1 << 3,\n  /** Is an unmanaged class. */\n  Unmanaged = 1 << 4,\n  /** Is a final class. */\n  Final = 1 << 5,\n  /** Is always inlined. */\n  Inline = 1 << 6,\n  /** Is using a different external name. */\n  External = 1 << 7,\n  /** Has external JavaScript code. */\n  ExternalJs = 1 << 8,\n  /** Is a builtin. */\n  Builtin = 1 << 9,\n  /** Is compiled lazily. */\n  Lazy = 1 << 10,\n  /** Is considered unsafe code. */\n  Unsafe = 1 << 11\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.Global: return DecoratorFlags.Global;\n      case DecoratorKind.Operator:\n      case DecoratorKind.OperatorBinary: return DecoratorFlags.OperatorBinary;\n      case DecoratorKind.OperatorPrefix: return DecoratorFlags.OperatorPrefix;\n      case DecoratorKind.OperatorPostfix: return DecoratorFlags.OperatorPostfix;\n      case DecoratorKind.Unmanaged: return DecoratorFlags.Unmanaged;\n      case DecoratorKind.Final: return DecoratorFlags.Final;\n      case DecoratorKind.Inline: return DecoratorFlags.Inline;\n      case DecoratorKind.External: return DecoratorFlags.External;\n      case DecoratorKind.ExternalJs: return DecoratorFlags.ExternalJs;\n      case DecoratorKind.Builtin: return DecoratorFlags.Builtin;\n      case DecoratorKind.Lazy: return DecoratorFlags.Lazy;\n      case DecoratorKind.Unsafe: return DecoratorFlags.Unsafe;\n      default: return DecoratorFlags.None;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.None;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.File);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    let current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.File) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n  /** Tests if this element has any of the specified decorator flags. */\n  hasAnyDecorator(flags: DecoratorFlags): bool { return (this.decoratorFlags & flags) != 0; }\n\n  /** Get the member with the specified name, if any. */\n  getMember(name: string): DeclaredElement | null {\n    let members = this.members;\n    if (members && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element. */\n  lookup(name: string, isType: bool = false): Element | null {\n    return this.parent.lookup(name, isType);\n  }\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    let originalDeclaration = element.declaration;\n    let members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent != this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    let program = this.program;\n    if (element.kind != ElementKind.FunctionPrototype || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.Private | CommonFlags.Protected);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.Public);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.Private | CommonFlags.Protected;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Tests if this element is bound to a class. */\n  get isBound(): bool {\n    let parent = this.parent;\n    switch (parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return true;\n    }\n    return false;\n  }\n\n  /** Gets the class or interface this element is bound to, if any. */\n  getBoundClassOrInterface(): Class | null {\n    let parent = this.parent;\n    switch (parent.kind) {\n      case ElementKind.Class:\n      case ElementKind.Interface: return <Class>parent;\n    }\n    return null;\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return `${this.internalName}, kind=${this.kind}`;\n  }\n}\n\n// Kinds of all declared elements\nlet declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    let declaration = this.declaration;\n    let identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FunctionDeclaration || declaration.kind == NodeKind.MethodDeclaration) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      if (identifierNode.range.source == signatureNode.range.source) {\n        return Range.join(identifierNode.range, signatureNode.range);\n      }\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n}\n\n// Kinds of all typed elements\nlet typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.Resolved));\n    this.type = type;\n    this.set(CommonFlags.Resolved);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.File,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    let startFunction = this.program.makeNativeFunction(\n      `start:${this.internalName}`,\n      Signature.create(program, [], Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.Global)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.getMember(name)); // possibly merged locally\n    if (element.is(CommonFlags.Export) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  getMember(name: string): DeclaredElement | null {\n    let element = super.getMember(name);\n    if (element) return element;\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].getMember(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let element = this.getMember(name);\n    if (element) return element;\n    return this.program.lookup(name); // has no meaningful parent\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    let exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LibraryEntry) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    let exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    let exports = this.exports;\n    if (exports && exports.has(name)) return assert(exports.get(name));\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string,\n    parent: Element,\n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    let declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    let ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.Scoped);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    let exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    let exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.TypeDefinition,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Namespace,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.Enum,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    let member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  None,\n  /** Constant integer value. */\n  Integer,\n  /** Constant float value. */\n  Float\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.None;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Integer;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.Float;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.Const | CommonFlags.Inlined | CommonFlags.Resolved);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.EnumValue,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Global,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a dummy local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.Local,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.Invalid;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overriding this one, if any. These are unbound. */\n  unboundOverrides: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None\n  ) {\n    super(\n      ElementKind.FunctionPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let declaration = this.declaration;\n    assert(declaration.kind == NodeKind.MethodDeclaration);\n    let bound = new FunctionPrototype(\n      this.name,\n      classInstance, // now bound\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.unboundOverrides = this.unboundOverrides;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Stub for calling overrides. */\n  overrideStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.Function,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.Resolved;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    let program = prototype.program;\n    this.type = signature.type;\n    let flow = Flow.createDefault(this);\n    this.flow = flow;\n    if (!prototype.is(CommonFlags.Ambient)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n        flow.setLocalFlag(local.index, LocalFlags.Initialized);\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        let scopedLocals = this.flow.scopedLocals;\n        if (!scopedLocals) this.flow.scopedLocals = scopedLocals = new Map();\n        scopedLocals.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n        flow.setLocalFlag(local.index, LocalFlags.Initialized);\n      }\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the types of additional locals that are not parameters. */\n  getNonParameterLocalTypes(): Type[] {\n    let localsByIndex = this.localsByIndex;\n    let signature = this.signature;\n    let numTotal = localsByIndex.length;\n    let numFixed = signature.parameterTypes.length;\n    if (signature.thisType) ++numFixed;\n    let numAdditional = numTotal - numFixed;\n    let types = new Array<Type>(numAdditional);\n    for (let i = 0; i < numAdditional; ++i) {\n      types[i] = localsByIndex[numFixed + i].type;\n    }\n    return types;\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    let parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or override calls. */\n  newStub(postfix: string, requiredParameters: i32 = this.signature.requiredParameters): Function {\n    let stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(requiredParameters),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.Compiled | CommonFlags.Stub);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    let localsByIndex = this.localsByIndex;\n    let localIndex = localsByIndex.length;\n    let localName = name != null ? name : localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    let local = new Local(localName, localIndex, type, this, declaration);\n    if (name) {\n      let defaultFlow = this.flow;\n      let scopedLocals = defaultFlow.scopedLocals;\n      if (!scopedLocals) defaultFlow.scopedLocals = scopedLocals = new Map();\n      if (scopedLocals.has(name)) throw new Error(\"duplicate local name\");\n      scopedLocals.set(name, local);\n    }\n    localsByIndex[localIndex] = local;\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    if (!isType) {\n      let scopedLocals = this.flow.scopedLocals;\n      if (scopedLocals && scopedLocals.has(name)) {\n        return assert(scopedLocals.get(name));\n      }\n    }\n    return super.lookup(name, isType);\n  }\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    let breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // should be empty\n    this.breakStack = null;\n    this.addDebugInfo(module, ref);\n  }\n\n  addDebugInfo(module: Module, ref: FunctionRef): void {\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n    if (this.program.options.debugInfo) {\n      let localNameMap = new Set<string>();\n      let localsByIndex = this.localsByIndex;\n      for (let i = 0, k = localsByIndex.length; i < k; i++) {\n        let localName = localsByIndex[i].name;\n        if (localNameMap.has(localName)) {\n          localName = `${localName}|${i}`;\n        }\n        localNameMap.add(localName);\n        module.setLocalName(ref, i, localName);\n      }\n    }\n  }\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Field declaration, if a field. */\n  fieldDeclaration: FieldDeclaration | null = null;\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Creates a property prototype representing a field. */\n  static forField(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Always a class prototype. */\n    parent: ClassPrototype,\n    /** Declaration of the field. */\n    fieldDeclaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n  ): PropertyPrototype {\n    // A field is a property with an attached memory offset. Unlike normal\n    // properties, accessors for fields are not explicitly declared, so we\n    // declare them implicitly here and compile them as built-ins when used.\n    // As a result, explicit and implicit accessors can override each other,\n    // which is useful when implementing interfaces declaring \"fields\". Such\n    // fields are satisfied by either a field or a normal property, so the\n    // override stub at the interface needs to handle both interchangeably.\n    let nativeRange = Source.native.range;\n    let typeNode = fieldDeclaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(fieldDeclaration.name.range.atEnd);\n    let getterDeclaration = new MethodDeclaration( // get name(): type\n      fieldDeclaration.name,\n      fieldDeclaration.decorators,\n      fieldDeclaration.flags | CommonFlags.Instance | CommonFlags.Get,\n      null,\n      new FunctionTypeNode([], typeNode, null, false, nativeRange),\n      null,\n      nativeRange\n    );\n    let setterDeclaration = new MethodDeclaration( // set name(name: type)\n      fieldDeclaration.name,\n      fieldDeclaration.decorators,\n      fieldDeclaration.flags | CommonFlags.Instance | CommonFlags.Set,\n      null,\n      new FunctionTypeNode(\n        [\n          new ParameterNode(\n            ParameterKind.Default,\n            fieldDeclaration.name,\n            typeNode, null, nativeRange\n          )\n        ],\n        new NamedTypeNode(\n          new TypeName(\n            new IdentifierExpression(\"\", false, nativeRange),\n            null, nativeRange\n          ),\n          null, false, nativeRange\n        ),\n        null, false, nativeRange\n      ),\n      null, nativeRange\n    );\n    let prototype = new PropertyPrototype(name, parent, getterDeclaration);\n    prototype.fieldDeclaration = fieldDeclaration;\n    prototype.decoratorFlags = decoratorFlags;\n    prototype.getterPrototype = new FunctionPrototype(GETTER_PREFIX + name, parent, getterDeclaration, decoratorFlags);\n    prototype.setterPrototype = new FunctionPrototype(SETTER_PREFIX + name, parent, setterDeclaration, decoratorFlags);\n    return prototype;\n  }\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PropertyPrototype,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.Get | CommonFlags.Set);\n  }\n\n  /** Tests if this property prototype represents a field. */\n  get isField(): bool {\n    return this.fieldDeclaration != null;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.type;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      let getterDeclaration = getterPrototype.declaration;\n      if (getterDeclaration.kind == NodeKind.FunctionDeclaration) {\n        return (<FunctionDeclaration>getterDeclaration).signature.returnType;\n      }\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      let setterDeclaration = setterPrototype.declaration;\n      if (setterDeclaration.kind == NodeKind.FunctionDeclaration) {\n        let setterParameters = (<FunctionDeclaration>setterDeclaration).signature.parameters;\n        if (setterParameters.length) return setterParameters[0].type;\n      }\n    }\n    return null;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.initializer;\n    return null;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    let fieldDeclaration = this.fieldDeclaration;\n    if (fieldDeclaration) return fieldDeclaration.parameterIndex;\n    return -1;\n  }\n\n  /** Gets the respective `this` type. */\n  get thisType(): Type {\n    let parent = this.parent;\n    assert(parent.kind == ElementKind.Class);\n    return (<Class>parent).type;\n  }\n\n  /** Creates a clone of this property prototype that is bound to a concrete class. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.Instance));\n    assert(!this.isBound);\n    let boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    let firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.MethodDeclaration);\n    let bound = new PropertyPrototype(\n      this.name,\n      classInstance, // now bound\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    bound.fieldDeclaration = this.fieldDeclaration;\n    let getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    let setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n  /** Field memory offset, if a (layed out) instance field. */\n  memoryOffset: i32 = -1;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.Property,\n      prototype.name,\n      parent,\n      prototype.isField\n        ? <VariableLikeDeclarationStatement>assert(prototype.fieldDeclaration)\n        : Node.createVariableDeclaration(\n            prototype.identifierNode,\n            null,\n            prototype.flags & CommonFlags.Instance,\n            null, null,\n            prototype.identifierNode.range\n          )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.Instance)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n\n  /** Tests if this property represents a field. */\n  get isField(): bool {\n    return this.prototype.isField;\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.IndexSignature,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedGet, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.IndexedSet, isUnchecked);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  operatorOverloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extenders: Set<ClassPrototype> = new Set();\n  /** Whether this class implicitly extends `Object`. */\n  implicitlyExtendsObject: bool = false;\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.None,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.InterfacePrototype : ElementKind.ClassPrototype,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.Instance)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    let arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    let current: ClassPrototype | null = this;\n    let seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current == basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    let originalDeclaration = element.declaration;\n    let instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.Export) && this.is(CommonFlags.ModuleExport)) {\n      element.set(CommonFlags.ModuleExport); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    let instances = this.instances;\n    if (instances && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    let instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if any. */\n  base: Class | null = null;\n  /** Directly implemented interfaces, if any. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  operatorOverloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly or indirectly extending this class, if any. */\n  extenders: Set<Class> | null = null;\n  /** Classes directly or indirectly implementing this interface, if any. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    let lengthField = this.getMember(\"length\");\n    if (!lengthField) return false;\n    return (\n      (\n        lengthField.kind == ElementKind.Property &&\n        (<Property>lengthField).getterInstance != null\n      ) || (\n        lengthField.kind == ElementKind.PropertyPrototype &&\n        (<PropertyPrototype>lengthField).getterPrototype != null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.IndexedGet) != null ||\n      this.lookupOverload(OperatorKind.UncheckedIndexedGet) != null\n    );\n  }\n\n  /** Tests if this is an interface. */\n  get isInterface(): bool {\n    return this.kind == ElementKind.Interface;\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.Interface : ElementKind.Class,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.Instance)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    let program = this.program;\n    let usizeType = program.options.usizeType;\n    let type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.Unmanaged)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    let typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Computes the least upper bound of two class types. */\n  static leastUpperBound(a: Class, b: Class): Class | null {\n    if (a == b) return a;\n    let candidates = new Set<Class>();\n    candidates.add(a);\n    candidates.add(b);\n    while (true) {\n      let aBase = a.base;\n      let bBase = b.base;\n      if (!aBase && !bBase) return null; // none\n      if (aBase) {\n        if (candidates.has(aBase)) return aBase;\n        candidates.add(a = aBase);\n      }\n      if (bBase) {\n        if (candidates.has(bBase)) return bBase;\n        candidates.add(b = bBase);\n      }\n    }\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n\n    // Inherit contextual type arguments from base class\n    let inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n\n    // This class and its extenders now extend each direct or indirect base class\n    base.propagateExtenderUp(this);\n    let extenders = this.extenders;\n    if (extenders) {\n      for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n        let extender = _values[i];\n        base.propagateExtenderUp(extender);\n      }\n    }\n\n    // Direct or indirect base interfaces are now implemented by this class and its extenders\n    let nextBase: Class | null = base;\n    do {\n      let baseInterfaces = nextBase.interfaces;\n      if (baseInterfaces) {\n        for (let _values = Set_values(baseInterfaces), i = 0, k = _values.length; i < k; ++i) {\n          let baseInterface = _values[i];\n          this.propagateInterfaceDown(baseInterface);\n        }\n      }\n      nextBase = nextBase.base;\n    } while (nextBase);\n  }\n\n  /** Propagates an extender to this class and its base classes. */\n  private propagateExtenderUp(extender: Class): void {\n    // Start with this class, adding the extender to it. Repeat for the class's\n    // bases that are indirectly extended by the extender.\n    let nextBase: Class | null = this;\n    do {\n      let extenders = nextBase.extenders;\n      if (!extenders) nextBase.extenders = extenders = new Set();\n      extenders.add(extender);\n      nextBase = nextBase.base;\n    } while (nextBase);\n  }\n\n  /** Propagates an interface and its base interfaces to this class and its extenders. */\n  private propagateInterfaceDown(iface: Interface): void {\n    // Start with the interface itself, adding this class and its extenders to\n    // its implementers. Repeat for the interface's bases that are indirectly\n    // implemented by means of being extended by the interface.\n    let nextIface: Interface | null = iface;\n    let extenders = this.extenders;\n    do {\n      let implementers = nextIface.implementers;\n      if (!implementers) nextIface.implementers = implementers = new Set();\n      implementers.add(this);\n      if (extenders) {\n        for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n          let extender = _values[i];\n          implementers.add(extender);\n        }\n      }\n      nextIface = <Interface | null>nextIface.base;\n    } while (nextIface);\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    let interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n\n    // This class and its extenders now implement the interface and its bases\n    this.propagateInterfaceDown(iface);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    // Q: When does the assignment in the comment below succeed?\n    if (target.isInterface) {\n      if (this.isInterface) {\n        // targetInterface = thisInterface\n        return this == target || this.extends(target);\n      } else {\n        // targetInterface = thisClass\n        return this.implements(<Interface>target);\n      }\n    } else {\n      if (this.isInterface) {\n        // targetClass = thisInterface\n        return target == this.program.objectInstance;\n      } else {\n        // targetClass = thisClass\n        return this == target || this.extends(target);\n      }\n    }\n  }\n\n  /** Tests if any subclass of this class is assignable to a target of the specified class type. */\n  hasSubclassAssignableTo(target: Class): bool {\n    // Q: When can the cast in the comment below succeed? (while an assignment would not)\n    if (target.isInterface) {\n      if (this.isInterface) {\n        // <TargetInterface>thisInterface\n        return this.hasImplementerImplementing(<Interface>target);\n      } else {\n        // <TargetInterface>thisClass\n        return this.hasExtenderImplementing(<Interface>target);\n      }\n    } else {\n      if (this.isInterface) {\n        // <TargetClass>thisInterface\n        return this.hasImplementer(target);\n      } else {\n        // <TargetClass>thisClass\n        return this.hasExtender(target);\n      }\n    }\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.IndexedGet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedGet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.IndexedSet: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UncheckedIndexedSet);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    let instance: Class | null = this;\n    do {\n      let overloads = instance.operatorOverloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /** Gets the method of the specified name, resolved with the given type arguments. */\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.FunctionPrototype) {\n      return this.program.resolver.resolveFunction(<FunctionPrototype>member, typeArguments);\n    }\n    return null;\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    let member = assert(this.getMember(fieldName));\n    assert(member.kind == ElementKind.PropertyPrototype);\n    let prototype = <PropertyPrototype>member;\n    let property = prototype.instance;\n    if (property) { // would have failed before\n      assert(property.isField && property.memoryOffset >= 0);\n      return property.memoryOffset;\n    }\n    return 0;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    let program = this.program;\n    let payloadSize = this.nextMemoryOffset + overhead;\n    let blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\n    let buffer = new Uint8Array(program.blockOverhead + blockSize);\n    let OBJECT = program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\n    let member = this.getMember(name);\n    if (member && member.kind == ElementKind.PropertyPrototype) {\n      let prototype = <PropertyPrototype>member;\n      let property = prototype.instance; // resolved during class finalization\n      if (!property) return 0; // failed before\n      assert(property.isField && property.memoryOffset >= 0);\n      let offset = baseOffset + property.memoryOffset;\n      let typeKind = property.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.Isize:\n        case TypeKind.Usize: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.Usize);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.Usize);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extendsPrototype(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    let current: Class | null = this;\n    do {\n      if (current.prototype == extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    let current: Class = this;\n    let program = this.program;\n    let arrayPrototype = program.arrayPrototype;\n    if (this.extendsPrototype(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    let staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extendsPrototype(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    let abvInstance = program.arrayBufferViewInstance;\n    while (current.base != abvInstance) {\n      current = assert(current.base);\n    }\n    let prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\n  get isPointerfree(): bool {\n    let program = this.program;\n\n    let instanceMembers = this.members;\n    if (instanceMembers) {\n\n      // Check that there are no managed instance fields\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.PropertyPrototype) {\n          let prototype = <PropertyPrototype>member;\n          let property = prototype.instance; // resolved during class finalization\n          if (!property) continue; // failed earlier\n          if (property.isField && property.type.isManaged) return false;\n        }\n      }\n\n      // Check that this isn't a managed collection\n      if (instanceMembers.has(CommonNames.visit)) {\n        let prototype = this.prototype;\n        if (\n          prototype == program.arrayPrototype ||\n          prototype == program.staticArrayPrototype ||\n          prototype == program.setPrototype ||\n          prototype == program.mapPrototype\n        ) {\n          // Note that we cannot know for sure anymore as soon as the collection\n          // is extended, because user code may implement a custom visitor.\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (typeArguments[i].isManaged) return false;\n          }\n          return true;\n        }\n        return false; // has a custom __visit\n      }\n    }\n    return true;\n  }\n\n  /** Tests if this class or interface extends the given class or interface. */\n  extends(other: Class): bool {\n    return other.hasExtender(this);\n  }\n\n  /** Tests if this class has a direct or indirect extender matching the given class. */\n  hasExtender(other: Class): bool {\n    let extenders = this.extenders;\n    return extenders != null && extenders.has(other);\n  }\n\n  /** Tests if this class has a direct or indirect extender that implements the given interface. */\n  hasExtenderImplementing(other: Interface): bool {\n    let extenders = this.extenders;\n    if (extenders) {\n      for (let _values = Set_values(extenders), i = 0, k = _values.length; i < k; ++i) {\n        let extender = _values[i];\n        if (extender.implements(other)) return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests if this class directly or indirectly implements the given interface. */\n  implements(other: Interface): bool {\n    return other.hasImplementer(this);\n  }\n\n  /** Tests if this interface has a direct or indirect implementer matching the given class. */\n  hasImplementer(other: Class): bool {\n    let implementers = this.implementers;\n    return implementers != null && implementers.has(other);\n  }\n\n  /** Tests if this interface has an implementer implementing the given interface. */\n  hasImplementerImplementing(other: Interface): bool {\n    let implementers = this.implementers;\n    if (implementers) {\n      for (let _values = Set_values(implementers), i = 0, k = _values.length; i < k; ++i) {\n        let implementer = _values[i];\n        if (implementer.implements(other)) return true;\n      }\n    }\n    return false;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program == newer.program);\n  if (newer.members) return null;\n  let merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FunctionPrototype: {\n      switch (newer.kind) {\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.ClassPrototype:\n    case ElementKind.Enum: {\n      if (newer.kind == ElementKind.Namespace) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.Namespace: {\n      switch (newer.kind) {\n        case ElementKind.Enum:\n        case ElementKind.ClassPrototype:      // TS2434\n        case ElementKind.FunctionPrototype: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.Namespace: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TypeDefinition: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.Global: {\n      if (newer.kind == ElementKind.TypeDefinition) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TypeDefinition: {\n      switch (newer.kind) {\n        case ElementKind.Global:\n        case ElementKind.FunctionPrototype:\n        case ElementKind.Namespace: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.Export) || older.hasDecorator(DecoratorFlags.Global);\n    let newerIsExport = newer.is(CommonFlags.Export) || newer.hasDecorator(DecoratorFlags.Global);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  let srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(\n  name: string,\n  parent: Element,\n  isInstance: bool,\n  asGlobal: bool = false\n): string {\n  switch (parent.kind) {\n    case ElementKind.File: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.Function: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PropertyPrototype: // properties are just containers\n    case ElementKind.Property: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return (\n        mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.Instance), asGlobal) +\n        (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name\n      );\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nlet cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(`$${i}`);\n  }\n  return cachedDefaultParameterNames[index];\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    let entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator(\"[]\")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) != null;\n  }\n\n  add(key: T): this {\n    let hashCode = HASH<T>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator(\"[]=\")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    let entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<T>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.key);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Set]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","/**\n * @fileoverview Portable definitions for Binaryen's C-API.\n *\n * tsc uses the .js file next to it, while asc makes it a Wasm import.\n *\n * See: https://github.com/WebAssembly/binaryen/blob/main/src/binaryen-c.h\n *\n * @license Apache-2.0\n */\nmodule \"binaryen\";\n\ntype Ref = usize;\n\nexport type Index = u32;\nexport type ExpressionId = i32;\nexport type FeatureFlags = u32;\nexport type Op = i32;\nexport type ExternalKind = u32;\nexport type SideEffects = u32;\nexport type ExpressionRunnerFlags = u32;\n\nexport type StringRef = Ref;\nexport type Pointer<T> = Ref;\nexport type ArrayRef<T> = Ref;\nexport type TypeRef = Ref;\nexport type HeapTypeRef = Ref;\nexport type PackedType = u32;\nexport type ModuleRef = Ref;\nexport type LiteralRef = Ref;\nexport type ExpressionRef = Ref;\nexport type FunctionRef = Ref;\nexport type ImportRef = Ref;\nexport type ExportRef = Ref;\nexport type GlobalRef = Ref;\nexport type TagRef = Ref;\nexport type TableRef = Ref;\nexport type ElementSegmentRef = Ref;\nexport type RelooperRef = Ref;\nexport type RelooperBlockRef = Ref;\nexport type ExpressionRunnerRef = Ref;\nexport type BinaryenModuleAllocateAndWriteResultRef = Ref;\nexport type TypeBuilderRef = Ref;\nexport type TypeBuilderErrorReason = u32;\nexport type TypeSystem = u32;\n\nexport declare function _BinaryenTypeCreate(types: ArrayRef<TypeRef>, numTypes: u32): TypeRef;\nexport declare function _BinaryenTypeArity(type: TypeRef): u32;\nexport declare function _BinaryenTypeExpand(type: TypeRef, typesOut: ArrayRef<TypeRef>): void;\nexport declare function _BinaryenTypeGetHeapType(type: TypeRef): HeapTypeRef;\nexport declare function _BinaryenTypeFromHeapType(heapType: HeapTypeRef, nullable: bool): TypeRef;\nexport declare function _BinaryenTypeIsNullable(type: TypeRef): bool;\n\nexport declare function _BinaryenTypeFuncref(): TypeRef;\nexport declare function _BinaryenTypeExternref(): TypeRef;\nexport declare function _BinaryenTypeAnyref(): TypeRef;\nexport declare function _BinaryenTypeEqref(): TypeRef;\nexport declare function _BinaryenTypeStructref(): TypeRef;\nexport declare function _BinaryenTypeArrayref(): TypeRef;\nexport declare function _BinaryenTypeI31ref(): TypeRef;\nexport declare function _BinaryenTypeStringref(): TypeRef;\nexport declare function _BinaryenTypeStringviewWTF8(): TypeRef;\nexport declare function _BinaryenTypeStringviewWTF16(): TypeRef;\nexport declare function _BinaryenTypeStringviewIter(): TypeRef;\nexport declare function _BinaryenTypeNullref(): TypeRef;\nexport declare function _BinaryenTypeNullExternref(): TypeRef;\nexport declare function _BinaryenTypeNullFuncref(): TypeRef;\n\nexport declare function _BinaryenHeapTypeFunc(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeExt(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeAny(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeEq(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeI31(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeStruct(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeArray(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeString(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeStringviewWTF8(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeStringviewWTF16(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeStringviewIter(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeNone(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeNoext(): HeapTypeRef;\nexport declare function _BinaryenHeapTypeNofunc(): HeapTypeRef;\n\nexport declare function _BinaryenHeapTypeIsBasic(heapType: HeapTypeRef): bool;\nexport declare function _BinaryenHeapTypeIsSignature(heapType: HeapTypeRef): bool;\nexport declare function _BinaryenHeapTypeIsStruct(heapType: HeapTypeRef): bool;\nexport declare function _BinaryenHeapTypeIsArray(heapType: HeapTypeRef): bool;\nexport declare function _BinaryenHeapTypeIsBottom(heapType: HeapTypeRef): bool;\nexport declare function _BinaryenHeapTypeGetBottom(heapType: HeapTypeRef): HeapTypeRef;\nexport declare function _BinaryenHeapTypeIsSubType(left: HeapTypeRef, right: HeapTypeRef): bool;\nexport declare function _BinaryenStructTypeGetNumFields(heapType: HeapTypeRef): Index;\nexport declare function _BinaryenStructTypeGetFieldType(heapType: HeapTypeRef, index: Index): TypeRef;\nexport declare function _BinaryenStructTypeGetFieldPackedType(heapType: HeapTypeRef, index: Index): PackedType;\nexport declare function _BinaryenStructTypeIsFieldMutable(heapType: HeapTypeRef, index: Index): bool;\nexport declare function _BinaryenArrayTypeGetElementType(heapType: HeapTypeRef): TypeRef;\nexport declare function _BinaryenArrayTypeGetElementPackedType(heapType: HeapTypeRef): PackedType;\nexport declare function _BinaryenArrayTypeIsElementMutable(heapType: HeapTypeRef): bool;\nexport declare function _BinaryenSignatureTypeGetParams(heapType: HeapTypeRef): TypeRef;\nexport declare function _BinaryenSignatureTypeGetResults(heapType: HeapTypeRef): TypeRef;\n\nexport declare function _BinaryenModuleCreate(): ModuleRef;\nexport declare function _BinaryenModuleDispose(module: ModuleRef): void;\n\nexport declare function _BinaryenSizeofLiteral(): usize;\nexport declare function _BinaryenLiteralInt32(literalOut: LiteralRef, x: i32): void;\nexport declare function _BinaryenLiteralInt64(literalOut: LiteralRef, x: i32, y: i32): void;\nexport declare function _BinaryenLiteralFloat32(literalOut: LiteralRef, x: f32): void;\nexport declare function _BinaryenLiteralFloat64(literalOut: LiteralRef, x: f64): void;\nexport declare function _BinaryenLiteralVec128(literalOut: LiteralRef, x: ArrayRef<u8>): void;\nexport declare function _BinaryenLiteralFloat32Bits(literalOut: LiteralRef, x: i32): void;\nexport declare function _BinaryenLiteralFloat64Bits(literalOut: LiteralRef, x: i32, y: i32): void;\n\nexport declare function _BinaryenExpressionGetId(expr: ExpressionRef): ExpressionId;\nexport declare function _BinaryenExpressionGetType(expr: ExpressionRef): TypeRef;\nexport declare function _BinaryenExpressionSetType(expr: ExpressionRef, type: TypeRef): void;\nexport declare function _BinaryenExpressionPrint(expr: ExpressionRef): void;\nexport declare function _BinaryenExpressionCopy(expr: ExpressionRef, module: ModuleRef): ExpressionRef;\nexport declare function _BinaryenExpressionFinalize(expr: ExpressionRef): void;\n\nexport declare function _BinaryenBlock(module: ModuleRef, name: StringRef, childExprs: ArrayRef<ExpressionRef>, numChildren: Index, type: TypeRef): ExpressionRef;\nexport declare function _BinaryenBlockGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenBlockSetName(expr: ExpressionRef, name: StringRef): void;\nexport declare function _BinaryenBlockGetNumChildren(expr: ExpressionRef): Index;\nexport declare function _BinaryenBlockGetChildAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenBlockSetChildAt(expr: ExpressionRef, index: Index, childExpr: ExpressionRef): void;\nexport declare function _BinaryenBlockAppendChild(expr: ExpressionRef, childExpr: ExpressionRef): Index;\nexport declare function _BinaryenBlockInsertChildAt(expr: ExpressionRef, index: Index, childExpr: ExpressionRef): void;\nexport declare function _BinaryenBlockRemoveChildAt(expr: ExpressionRef, index: Index): ExpressionRef;\n\nexport declare function _BinaryenIf(module: ModuleRef, conditionExpr: ExpressionRef, ifTrueExpr: ExpressionRef, ifFalseExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenIfGetCondition(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenIfSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;\nexport declare function _BinaryenIfGetIfTrue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenIfSetIfTrue(expr: ExpressionRef, ifTrueExpr: ExpressionRef): void;\nexport declare function _BinaryenIfGetIfFalse(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenIfSetIfFalse(expr: ExpressionRef, ifFalseExpr: ExpressionRef): void;\n\nexport declare function _BinaryenLoop(module: ModuleRef, name: StringRef, bodyExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenLoopGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenLoopSetName(expr: ExpressionRef, name: StringRef): void;\nexport declare function _BinaryenLoopGetBody(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenLoopSetBody(expr: ExpressionRef, bodyExpr: ExpressionRef): void;\n\nexport declare function _BinaryenBreak(module: ModuleRef, name: StringRef, conditionExpr: ExpressionRef, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBreakGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenBreakSetName(expr: ExpressionRef, name: StringRef): void;\nexport declare function _BinaryenBreakGetCondition(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBreakSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;\nexport declare function _BinaryenBreakGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBreakSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenSwitch(module: ModuleRef, names: ArrayRef<StringRef>, numNames: Index, defaultName: StringRef, conditionExpr: ExpressionRef, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSwitchGetNumNames(expr: ExpressionRef): Index;\nexport declare function _BinaryenSwitchGetNameAt(expr: ExpressionRef, index: Index): StringRef;\nexport declare function _BinaryenSwitchSetNameAt(expr: ExpressionRef, index: Index, name: StringRef): void;\nexport declare function _BinaryenSwitchAppendName(expr: ExpressionRef, name: StringRef): Index;\nexport declare function _BinaryenSwitchInsertNameAt(expr: ExpressionRef, index: Index, name: StringRef): void;\nexport declare function _BinaryenSwitchRemoveNameAt(expr: ExpressionRef, index: Index): StringRef;\nexport declare function _BinaryenSwitchGetDefaultName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenSwitchSetDefaultName(expr: ExpressionRef, defaultName: StringRef): void;\nexport declare function _BinaryenSwitchGetCondition(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSwitchSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;\nexport declare function _BinaryenSwitchGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSwitchSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenCall(module: ModuleRef, targetName: StringRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, returnType: TypeRef): ExpressionRef;\nexport declare function _BinaryenCallGetTarget(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenCallSetTarget(expr: ExpressionRef, targetName: StringRef): void;\nexport declare function _BinaryenCallGetNumOperands(expr: ExpressionRef): Index;\nexport declare function _BinaryenCallGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenCallSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenCallAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;\nexport declare function _BinaryenCallInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenCallRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenCallIsReturn(expr: ExpressionRef): bool;\nexport declare function _BinaryenCallSetReturn(expr: ExpressionRef, isReturn: bool): void;\n// ^ with return = true\nexport declare function _BinaryenReturnCall(module: ModuleRef, targetName: StringRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, returnType: TypeRef): ExpressionRef;\n\nexport declare function _BinaryenCallIndirect(module: ModuleRef, table: StringRef, targetExpr: ExpressionRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, params: TypeRef, results: TypeRef): ExpressionRef;\nexport declare function _BinaryenCallIndirectGetTable(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenCallIndirectSetTable(expr: ExpressionRef, table: StringRef): void;\nexport declare function _BinaryenCallIndirectGetTarget(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenCallIndirectSetTarget(expr: ExpressionRef, targetExpr: ExpressionRef): void;\nexport declare function _BinaryenCallIndirectGetNumOperands(expr: ExpressionRef): Index;\nexport declare function _BinaryenCallIndirectGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenCallIndirectSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenCallIndirectAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;\nexport declare function _BinaryenCallIndirectInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenCallIndirectRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenCallIndirectIsReturn(expr: ExpressionRef): bool;\nexport declare function _BinaryenCallIndirectSetReturn(expr: ExpressionRef, isReturn: bool): void;\n// ^ with return = true\nexport declare function _BinaryenReturnCallIndirect(module: ModuleRef, table: StringRef, targetExpr: ExpressionRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, params: TypeRef, results: TypeRef): ExpressionRef;\n\nexport declare function _BinaryenLocalGet(module: ModuleRef, index: Index, type: TypeRef): ExpressionRef;\nexport declare function _BinaryenLocalGetGetIndex(expr: ExpressionRef): Index;\nexport declare function _BinaryenLocalGetSetIndex(expr: ExpressionRef, index: Index): void;\n\nexport declare function _BinaryenLocalSet(module: ModuleRef, index: Index, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenLocalSetIsTee(expr: ExpressionRef): bool;\nexport declare function _BinaryenLocalSetGetIndex(expr: ExpressionRef): Index;\nexport declare function _BinaryenLocalSetSetIndex(expr: ExpressionRef, index: Index): void;\nexport declare function _BinaryenLocalSetGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenLocalSetSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n// ^ with type != none\nexport declare function _BinaryenLocalTee(module: ModuleRef, index: Index, valueExpr: ExpressionRef, type: TypeRef): ExpressionRef;\n\nexport declare function _BinaryenGlobalGet(module: ModuleRef, name: StringRef, type: TypeRef): ExpressionRef;\nexport declare function _BinaryenGlobalGetGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenGlobalGetSetName(expr: ExpressionRef, name: StringRef): void;\n\nexport declare function _BinaryenGlobalSet(module: ModuleRef, name: StringRef, value: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenGlobalSetGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenGlobalSetSetName(expr: ExpressionRef, name: StringRef): void;\nexport declare function _BinaryenGlobalSetGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenGlobalSetSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenMemorySize(module: ModuleRef, memoryName: StringRef, memoryIs64: bool): ExpressionRef;\n\nexport declare function _BinaryenMemoryGrow(module: ModuleRef, delta: ExpressionRef, memoryName: StringRef, memoryIs64: bool): ExpressionRef;\nexport declare function _BinaryenMemoryGrowGetDelta(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryGrowSetDelta(expr: ExpressionRef, delta: ExpressionRef): void;\n\nexport declare function _BinaryenLoad(module: ModuleRef, bytes: u32, signed: bool, offset: u32, align: u32, type: TypeRef, ptrExpr: ExpressionRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenLoadIsAtomic(expr: ExpressionRef): bool;\nexport declare function _BinaryenLoadSetAtomic(expr: ExpressionRef, isAtomic: bool): void;\nexport declare function _BinaryenLoadIsSigned(expr: ExpressionRef): bool;\nexport declare function _BinaryenLoadSetSigned(expr: ExpressionRef, isSigned: bool): void;\nexport declare function _BinaryenLoadGetOffset(expr: ExpressionRef): u32;\nexport declare function _BinaryenLoadSetOffset(expr: ExpressionRef, offset: u32): void;\nexport declare function _BinaryenLoadGetBytes(expr: ExpressionRef): u32;\nexport declare function _BinaryenLoadSetBytes(expr: ExpressionRef, bytes: u32): void;\nexport declare function _BinaryenLoadGetAlign(expr: ExpressionRef): u32;\nexport declare function _BinaryenLoadSetAlign(expr: ExpressionRef, align: u32): void;\nexport declare function _BinaryenLoadGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenLoadSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\n// ^ with atomic = true\nexport declare function _BinaryenAtomicLoad(module: ModuleRef, bytes: Index, offset: Index, type: TypeRef, ptrExpr: ExpressionRef, memoryName: StringRef): ExpressionRef;\n\nexport declare function _BinaryenStore(module: ModuleRef, bytes: u32, offset: u32, align: u32, ptrExpr: ExpressionRef, valueExpr: ExpressionRef, type: TypeRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenStoreIsAtomic(expr: ExpressionRef): bool;\nexport declare function _BinaryenStoreSetAtomic(expr: ExpressionRef, isAtomic: bool): void;\nexport declare function _BinaryenStoreGetBytes(expr: ExpressionRef): u32;\nexport declare function _BinaryenStoreSetBytes(expr: ExpressionRef, bytes: u32): void;\nexport declare function _BinaryenStoreGetOffset(expr: ExpressionRef): u32;\nexport declare function _BinaryenStoreSetOffset(expr: ExpressionRef, offset: u32): void;\nexport declare function _BinaryenStoreGetAlign(expr: ExpressionRef): u32;\nexport declare function _BinaryenStoreSetAlign(expr: ExpressionRef, align: u32): void;\nexport declare function _BinaryenStoreGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStoreSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenStoreGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStoreSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\nexport declare function _BinaryenStoreGetValueType(expr: ExpressionRef): TypeRef;\nexport declare function _BinaryenStoreSetValueType(expr: ExpressionRef, valueType: TypeRef): void;\n// ^ with atomic = true\nexport declare function _BinaryenAtomicStore(module: ModuleRef, bytes: Index, offset: Index, ptrExpr: ExpressionRef, valueExpr: ExpressionRef, type: TypeRef, memoryName: StringRef): ExpressionRef;\n\nexport declare function _BinaryenConst(module: ModuleRef, value: LiteralRef): ExpressionRef;\nexport declare function _BinaryenConstGetValueI32(expr: ExpressionRef): i32;\nexport declare function _BinaryenConstSetValueI32(expr: ExpressionRef, value: i32): void;\nexport declare function _BinaryenConstGetValueI64Low(expr: ExpressionRef): i32;\nexport declare function _BinaryenConstSetValueI64Low(expr: ExpressionRef, value: i32): void;\nexport declare function _BinaryenConstGetValueI64High(expr: ExpressionRef): i32;\nexport declare function _BinaryenConstSetValueI64High(expr: ExpressionRef, value: i32): void;\nexport declare function _BinaryenConstGetValueF32(expr: ExpressionRef): f32;\nexport declare function _BinaryenConstSetValueF32(expr: ExpressionRef, value: f32): void;\nexport declare function _BinaryenConstGetValueF64(expr: ExpressionRef): f64;\nexport declare function _BinaryenConstSetValueF64(expr: ExpressionRef, value: f64): void;\nexport declare function _BinaryenConstGetValueV128(expr: ExpressionRef, valueOut: ArrayRef<u8>): void;\nexport declare function _BinaryenConstSetValueV128(expr: ExpressionRef, value: ArrayRef<u8>): void;\n\nexport declare function _BinaryenUnary(module: ModuleRef, op: Op, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenUnaryGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenUnarySetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenUnaryGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenUnarySetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenBinary(module: ModuleRef, op: Op, leftExpr: ExpressionRef, rightExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBinaryGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenBinarySetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenBinaryGetLeft(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBinarySetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;\nexport declare function _BinaryenBinaryGetRight(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBinarySetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;\n\nexport declare function _BinaryenSelect(module: ModuleRef, conditionExpr: ExpressionRef, ifTrueExpr: ExpressionRef, ifFalseExpr: ExpressionRef, type: TypeRef): ExpressionRef;\nexport declare function _BinaryenSelectGetIfTrue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSelectSetIfTrue(expr: ExpressionRef, ifTrueExpr: ExpressionRef): void;\nexport declare function _BinaryenSelectGetIfFalse(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSelectSetIfFalse(expr: ExpressionRef, ifFalseExpr: ExpressionRef): void;\nexport declare function _BinaryenSelectGetCondition(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSelectSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;\n\nexport declare function _BinaryenDrop(module: ModuleRef, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenDropGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenDropSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenReturn(module: ModuleRef, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenReturnGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenReturnSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenNop(module: ModuleRef): ExpressionRef;\n\nexport declare function _BinaryenUnreachable(module: ModuleRef): ExpressionRef;\n\nexport declare function _BinaryenAtomicRMW(module: ModuleRef, op: Op, bytes: u32, offset: u32, ptrExpr: ExpressionRef, valueExpr: ExpressionRef, type: TypeRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenAtomicRMWGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenAtomicRMWSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenAtomicRMWGetBytes(expr: ExpressionRef): u32;\nexport declare function _BinaryenAtomicRMWSetBytes(expr: ExpressionRef, bytes: u32): void;\nexport declare function _BinaryenAtomicRMWGetOffset(expr: ExpressionRef): u32;\nexport declare function _BinaryenAtomicRMWSetOffset(expr: ExpressionRef, offset: u32): void;\nexport declare function _BinaryenAtomicRMWGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicRMWSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicRMWGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicRMWSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenAtomicCmpxchg(module: ModuleRef, bytes: u32, offset: u32, ptrExpr: ExpressionRef, expectedExpr: ExpressionRef, replacementExpr: ExpressionRef, type: TypeRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenAtomicCmpxchgGetBytes(expr: ExpressionRef): u32;\nexport declare function _BinaryenAtomicCmpxchgSetBytes(expr: ExpressionRef, bytes: u32): void;\nexport declare function _BinaryenAtomicCmpxchgGetOffset(expr: ExpressionRef): u32;\nexport declare function _BinaryenAtomicCmpxchgSetOffset(expr: ExpressionRef, offset: u32): void;\nexport declare function _BinaryenAtomicCmpxchgGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicCmpxchgSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicCmpxchgGetExpected(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicCmpxchgSetExpected(expr: ExpressionRef, expectedExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicCmpxchgGetReplacement(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicCmpxchgSetReplacement(expr: ExpressionRef, replacementExpr: ExpressionRef): void;\n\nexport declare function _BinaryenAtomicWait(module: ModuleRef, ptrExpr: ExpressionRef, expectedExpr: ExpressionRef, timeoutExpr: ExpressionRef, expectedType: TypeRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenAtomicWaitGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicWaitSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicWaitGetExpected(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicWaitSetExpected(expr: ExpressionRef, expectedExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicWaitGetTimeout(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicWaitSetTimeout(expr: ExpressionRef, timeoutExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicWaitGetExpectedType(expr: ExpressionRef): TypeRef;\nexport declare function _BinaryenAtomicWaitSetExpectedType(expr: ExpressionRef, expectedType: TypeRef): void;\n\nexport declare function _BinaryenAtomicNotify(module: ModuleRef, ptrExpr: ExpressionRef, notifyCountExpr: ExpressionRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenAtomicNotifyGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicNotifySetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenAtomicNotifyGetNotifyCount(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenAtomicNotifySetNotifyCount(expr: ExpressionRef, notifyCountExpr: ExpressionRef): void;\n\nexport declare function _BinaryenAtomicFence(module: ModuleRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenAtomicFenceGetOrder(expr: ExpressionRef): u8; // unused\nexport declare function _BinaryenAtomicFenceSetOrder(expr: ExpressionRef, order: u8): void; // unused\n\nexport declare function _BinaryenSIMDExtract(module: ModuleRef, op: Op, vecExpr: ExpressionRef, index: u8): ExpressionRef;\nexport declare function _BinaryenSIMDExtractGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenSIMDExtractSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenSIMDExtractGetVec(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDExtractSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDExtractGetIndex(expr: ExpressionRef): u8;\nexport declare function _BinaryenSIMDExtractSetIndex(expr: ExpressionRef, index: u8): void;\n\nexport declare function _BinaryenSIMDReplace(module: ModuleRef, op: Op, vecEpr: ExpressionRef, index: u8, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDReplaceGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenSIMDReplaceSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenSIMDReplaceGetVec(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDReplaceSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDReplaceGetIndex(expr: ExpressionRef): u8;\nexport declare function _BinaryenSIMDReplaceSetIndex(expr: ExpressionRef, index: u8): void;\nexport declare function _BinaryenSIMDReplaceGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDReplaceSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenSIMDShuffle(module: ModuleRef, leftExpr: ExpressionRef, rightExpr: ExpressionRef, mask: ArrayRef<u8>): ExpressionRef;\nexport declare function _BinaryenSIMDShuffleGetLeft(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDShuffleSetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDShuffleGetRight(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDShuffleSetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDShuffleGetMask(expr: ExpressionRef, maskOut: ArrayRef<u8>): void;\nexport declare function _BinaryenSIMDShuffleSetMask(expr: ExpressionRef, mask: ArrayRef<u8>): void;\n\nexport declare function _BinaryenSIMDTernary(module: ModuleRef, op: Op, aExpr: ExpressionRef, bExpr: ExpressionRef, cExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDTernaryGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenSIMDTernarySetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenSIMDTernaryGetA(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDTernarySetA(expr: ExpressionRef, aExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDTernaryGetB(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDTernarySetB(expr: ExpressionRef, bExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDTernaryGetC(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDTernarySetC(expr: ExpressionRef, cExpr: ExpressionRef): void;\n\nexport declare function _BinaryenSIMDShift(module: ModuleRef, op: Op, vecExpr: ExpressionRef, shiftExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDShiftGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenSIMDShiftSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenSIMDShiftGetVec(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDShiftSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDShiftGetShift(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDShiftSetShift(expr: ExpressionRef, shiftExpr: ExpressionRef): void;\n\nexport declare function _BinaryenSIMDLoad(module: ModuleRef, op: Op, offset: u32, align: u32, ptrExpr: ExpressionRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenSIMDLoadGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenSIMDLoadSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenSIMDLoadGetOffset(expr: ExpressionRef): u32;\nexport declare function _BinaryenSIMDLoadSetOffset(expr: ExpressionRef, offset: u32): void;\nexport declare function _BinaryenSIMDLoadGetAlign(expr: ExpressionRef): u32;\nexport declare function _BinaryenSIMDLoadSetAlign(expr: ExpressionRef, align: u32): void;\nexport declare function _BinaryenSIMDLoadGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDLoadSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\n\nexport declare function _BinaryenSIMDLoadStoreLane(module: ModuleRef, op: Op, offset: u32, align: u32, index: u8, ptr: ExpressionRef, vec: ExpressionRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenSIMDLoadStoreLaneGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenSIMDLoadStoreLaneSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenSIMDLoadStoreLaneGetOffset(expr: ExpressionRef): u32;\nexport declare function _BinaryenSIMDLoadStoreLaneSetOffset(expr: ExpressionRef, offset: u32): void;\nexport declare function _BinaryenSIMDLoadStoreLaneGetAlign(expr: ExpressionRef): u32;\nexport declare function _BinaryenSIMDLoadStoreLaneSetAlign(expr: ExpressionRef, align: u32): void;\nexport declare function _BinaryenSIMDLoadStoreLaneGetIndex(expr: ExpressionRef): u8;\nexport declare function _BinaryenSIMDLoadStoreLaneSetIndex(expr: ExpressionRef, index: u8): void;\nexport declare function _BinaryenSIMDLoadStoreLaneGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDLoadStoreLaneSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDLoadStoreLaneGetVec(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenSIMDLoadStoreLaneSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;\nexport declare function _BinaryenSIMDLoadStoreLaneIsStore(expr: ExpressionRef): bool;\n\nexport declare function _BinaryenMemoryInit(module: ModuleRef, segmentIndex: u32, destExpr: ExpressionRef, offsetExpr: ExpressionRef, sizeExpr: ExpressionRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenMemoryInitGetSegment(expr: ExpressionRef): u32;\nexport declare function _BinaryenMemoryInitSetSegment(expr: ExpressionRef, segmentIndex: u32): void;\nexport declare function _BinaryenMemoryInitGetDest(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryInitSetDest(expr: ExpressionRef, destExpr: ExpressionRef): void;\nexport declare function _BinaryenMemoryInitGetOffset(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryInitSetOffset(expr: ExpressionRef, offsetExpr: ExpressionRef): void;\nexport declare function _BinaryenMemoryInitGetSize(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryInitSetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;\n\nexport declare function _BinaryenDataDrop(module: ModuleRef, segmentIndex: u32): ExpressionRef;\nexport declare function _BinaryenDataDropGetSegment(expr: ExpressionRef): u32;\nexport declare function _BinaryenDataDropSetSegment(expr: ExpressionRef, segmentIndex: u32): void;\n\nexport declare function _BinaryenMemoryCopy(module: ModuleRef, destExpr: ExpressionRef, sourceExpr: ExpressionRef, sizeExpr: ExpressionRef, destMemoryName: StringRef, sourceMemoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenMemoryCopyGetDest(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryCopySetDest(expr: ExpressionRef, destExpr: ExpressionRef): void;\nexport declare function _BinaryenMemoryCopyGetSource(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryCopySetSource(expr: ExpressionRef, sourceExpr: ExpressionRef): void;\nexport declare function _BinaryenMemoryCopyGetSize(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryCopySetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;\n\nexport declare function _BinaryenMemoryFill(module: ModuleRef, destExpr: ExpressionRef, valueExpr: ExpressionRef, sizeExpr: ExpressionRef, memoryName: StringRef): ExpressionRef;\nexport declare function _BinaryenMemoryFillGetDest(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryFillSetDest(expr: ExpressionRef, destExpr: ExpressionRef): void;\nexport declare function _BinaryenMemoryFillGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryFillSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\nexport declare function _BinaryenMemoryFillGetSize(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenMemoryFillSetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;\n\nexport declare function _BinaryenRefNull(module: ModuleRef, type: TypeRef): ExpressionRef;\n\nexport declare function _BinaryenRefIsNull(module: ModuleRef, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefIsNullGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefIsNullSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenRefAs(module: ModuleRef, op: Op, valueExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefAsGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenRefAsSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenRefAsGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefAsSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenRefFunc(module: ModuleRef, funcName: StringRef, type: TypeRef): ExpressionRef;\nexport declare function _BinaryenRefFuncGetFunc(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenRefFuncSetFunc(expr: ExpressionRef, funcName: StringRef): void;\n\nexport declare function _BinaryenRefEq(module: ModuleRef, leftExpr: ExpressionRef, rightExpr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefEqGetLeft(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefEqSetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;\nexport declare function _BinaryenRefEqGetRight(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefEqSetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;\n\nexport declare function _BinaryenTableGet(module: ModuleRef, name: StringRef, index: ExpressionRef, type: TypeRef): ExpressionRef;\nexport declare function _BinaryenTableGetGetTable(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenTableGetSetTable(expr: ExpressionRef, table: StringRef): void;\nexport declare function _BinaryenTableGetGetIndex(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableGetSetIndex(expr: ExpressionRef, index: ExpressionRef): void;\n\nexport declare function _BinaryenTableSet(module: ModuleRef, name: StringRef, index: ExpressionRef, value: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableSetGetTable(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenTableSetSetTable(expr: ExpressionRef, table: StringRef): void;\nexport declare function _BinaryenTableSetGetIndex(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableSetSetIndex(expr: ExpressionRef, index: ExpressionRef): void;\nexport declare function _BinaryenTableSetGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableSetSetValue(expr: ExpressionRef, value: ExpressionRef): void;\n\nexport declare function _BinaryenTableSize(module: ModuleRef, name: StringRef): ExpressionRef;\nexport declare function _BinaryenTableSizeGetTable(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenTableSizeSetTable(expr: ExpressionRef, table: StringRef): void;\n\nexport declare function _BinaryenTableGrow(module: ModuleRef, name: StringRef, value: ExpressionRef, delta: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableGrowGetTable(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenTableGrowSetTable(expr: ExpressionRef, table: StringRef): void;\nexport declare function _BinaryenTableGrowGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableGrowSetValue(expr: ExpressionRef, value: ExpressionRef): void;\nexport declare function _BinaryenTableGrowGetDelta(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTableGrowSetDelta(expr: ExpressionRef, delta: ExpressionRef): void;\n\nexport declare function _BinaryenTry(module: ModuleRef, name: StringRef, bodyExpr: ExpressionRef, catchTags: ArrayRef<StringRef>, numCatchTags: Index, catchBodies: ArrayRef<ExpressionRef>, numCatchBodies: Index, delegateTarget: StringRef): ExpressionRef;\nexport declare function _BinaryenTryGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenTrySetName(expr: ExpressionRef, name: StringRef): void;\nexport declare function _BinaryenTryGetBody(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTrySetBody(expr: ExpressionRef, bodyExpr: ExpressionRef): void;\nexport declare function _BinaryenTryGetNumCatchTags(expr: ExpressionRef): Index;\nexport declare function _BinaryenTryGetNumCatchBodies(expr: ExpressionRef): Index;\nexport declare function _BinaryenTryGetCatchTagAt(expr: ExpressionRef, index: Index): StringRef;\nexport declare function _BinaryenTrySetCatchTagAt(expr: ExpressionRef, index: Index, catchTag: StringRef): void;\nexport declare function _BinaryenTryAppendCatchTag(expr: ExpressionRef, catchTag: StringRef): Index;\nexport declare function _BinaryenTryInsertCatchTagAt(expr: ExpressionRef, index: Index, catchTag: StringRef): void;\nexport declare function _BinaryenTryRemoveCatchTagAt(expr: ExpressionRef, index: Index): StringRef;\nexport declare function _BinaryenTryGetCatchBodyAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenTrySetCatchBodyAt(expr: ExpressionRef, index: Index, catchExpr: ExpressionRef): void;\nexport declare function _BinaryenTryAppendCatchBody(expr: ExpressionRef, catchExpr: ExpressionRef): Index;\nexport declare function _BinaryenTryInsertCatchBodyAt(expr: ExpressionRef, index: Index, catchExpr: ExpressionRef): void;\nexport declare function _BinaryenTryRemoveCatchBodyAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenTryHasCatchAll(expr: ExpressionRef): bool;\nexport declare function _BinaryenTryGetDelegateTarget(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenTrySetDelegateTarget(expr: ExpressionRef, delegateTarget: StringRef): void;\nexport declare function _BinaryenTryIsDelegate(expr: ExpressionRef): bool;\n\nexport declare function _BinaryenThrow(module: ModuleRef, tagName: StringRef, operands: ArrayRef<ExpressionRef>, numOperands: Index): ExpressionRef;\nexport declare function _BinaryenThrowGetTag(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenThrowSetTag(expr: ExpressionRef, tagName: StringRef): void;\nexport declare function _BinaryenThrowGetNumOperands(expr: ExpressionRef): Index;\nexport declare function _BinaryenThrowGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenThrowSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenThrowAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;\nexport declare function _BinaryenThrowInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenThrowRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\n\nexport declare function _BinaryenRethrow(module: ModuleRef, target: StringRef): ExpressionRef;\nexport declare function _BinaryenRethrowGetTarget(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenRethrowSetDepth(expr: ExpressionRef, target: StringRef): void;\n\nexport declare function _BinaryenTupleMake(module: ModuleRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index): ExpressionRef;\nexport declare function _BinaryenTupleMakeGetNumOperands(expr: ExpressionRef): Index;\nexport declare function _BinaryenTupleMakeGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenTupleMakeSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenTupleMakeAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;\nexport declare function _BinaryenTupleMakeInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenTupleMakeRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\n\nexport declare function _BinaryenTupleExtract(module: ModuleRef, tupleExpr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenTupleExtractGetTuple(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenTupleExtractSetTuple(expr: ExpressionRef, tupleExpr: ExpressionRef): void;\nexport declare function _BinaryenTupleExtractGetIndex(expr: ExpressionRef): Index;\nexport declare function _BinaryenTupleExtractSetIndex(expr: ExpressionRef, index: Index): void;\n\nexport declare function _BinaryenPop(module: ModuleRef, type: TypeRef): ExpressionRef;\n\nexport declare function _BinaryenI31New(module: ModuleRef, value: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenI31NewGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenI31NewSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenI31Get(module: ModuleRef, i31Expr: ExpressionRef, signed: bool): ExpressionRef;\nexport declare function _BinaryenI31GetGetI31(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenI31GetSetI31(expr: ExpressionRef, i31Expr: ExpressionRef): void;\nexport declare function _BinaryenI31GetIsSigned(expr: ExpressionRef): bool;\nexport declare function _BinaryenI31GetSetSigned(expr: ExpressionRef, signed: bool): void;\n\nexport declare function _BinaryenCallRef(module: ModuleRef, target: ExpressionRef, operands: ArrayRef<ExpressionRef>, numOperands: Index, type: TypeRef, isReturn: bool): ExpressionRef;\nexport declare function _BinaryenCallRefGetNumOperands(expr: ExpressionRef): Index;\nexport declare function _BinaryenCallRefGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenCallRefSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenCallRefAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;\nexport declare function _BinaryenCallRefInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenCallRefRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenCallRefGetTarget(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenCallRefSetTarget(expr: ExpressionRef, targetExpr: ExpressionRef): void;\nexport declare function _BinaryenCallRefIsReturn(expr: ExpressionRef): bool;\nexport declare function _BinaryenCallRefSetReturn(expr: ExpressionRef, isReturn: bool): void;\n\nexport declare function _BinaryenRefTest(module: ModuleRef, refExpr: ExpressionRef, castType: HeapTypeRef): ExpressionRef;\nexport declare function _BinaryenRefTestGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefTestSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenRefTestGetCastType(expr: ExpressionRef): HeapTypeRef;\nexport declare function _BinaryenRefTestSetCastType(expr: ExpressionRef, castType: HeapTypeRef): void;\n\nexport declare function _BinaryenRefCast(module: ModuleRef, refExpr: ExpressionRef, intendedType: HeapTypeRef): ExpressionRef;\nexport declare function _BinaryenRefCastGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenRefCastSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\n\nexport declare function _BinaryenBrOn(module: ModuleRef, op: Op, name: StringRef, ref: ExpressionRef, castType: HeapTypeRef): ExpressionRef;\nexport declare function _BinaryenBrOnGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenBrOnSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenBrOnGetName(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenBrOnSetName(expr: ExpressionRef, nameStr: StringRef): void;\nexport declare function _BinaryenBrOnGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenBrOnSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenBrOnGetCastType(expr: ExpressionRef): HeapTypeRef;\nexport declare function _BinaryenBrOnSetCastType(expr: ExpressionRef, castType: HeapTypeRef): void;\n\nexport declare function _BinaryenStructNew(module: ModuleRef, operands: ArrayRef<ExpressionRef>, numOperands: Index, type: HeapTypeRef): ExpressionRef;\nexport declare function _BinaryenStructNewGetNumOperands(expr: ExpressionRef): Index;\nexport declare function _BinaryenStructNewGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenStructNewSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenStructNewAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;\nexport declare function _BinaryenStructNewInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;\nexport declare function _BinaryenStructNewRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;\n\nexport declare function _BinaryenStructGet(module: ModuleRef, index: Index, ref: ExpressionRef, type: TypeRef, signed: bool): ExpressionRef;\nexport declare function _BinaryenStructGetGetIndex(expr: ExpressionRef): Index;\nexport declare function _BinaryenStructGetSetIndex(expr: ExpressionRef, index: Index): void;\nexport declare function _BinaryenStructGetGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStructGetSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStructGetIsSigned(expr: ExpressionRef): bool;\nexport declare function _BinaryenStructGetSetSigned(expr: ExpressionRef, signed: bool): void;\n\nexport declare function _BinaryenStructSet(module: ModuleRef, index: Index, ref: ExpressionRef, value: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStructSetGetIndex(expr: ExpressionRef): Index;\nexport declare function _BinaryenStructSetSetIndex(expr: ExpressionRef, index: Index): void;\nexport declare function _BinaryenStructSetGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStructSetSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStructSetGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStructSetSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenArrayNew(module: ModuleRef, type: HeapTypeRef, size: ExpressionRef, init: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayNewGetInit(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayNewSetInit(expr: ExpressionRef, initExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayNewGetSize(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayNewSetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;\n\n// TODO: BinaryenArrayNewSeg\n\nexport declare function _BinaryenArrayInit(module: ModuleRef, type: HeapTypeRef, values: ArrayRef<ExpressionRef>, numValues: Index): ExpressionRef;\nexport declare function _BinaryenArrayInitGetNumValues(expr: ExpressionRef): Index;\nexport declare function _BinaryenArrayInitGetValueAt(expr: ExpressionRef, index: Index): ExpressionRef;\nexport declare function _BinaryenArrayInitSetValueAt(expr: ExpressionRef, index: Index, valueExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayInitAppendValue(expr: ExpressionRef, valueExpr: ExpressionRef): Index;\nexport declare function _BinaryenArrayInitInsertValueAt(expr: ExpressionRef, index: Index, valueExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayInitRemoveValueAt(expr: ExpressionRef, index: Index): ExpressionRef;\n\nexport declare function _BinaryenArrayGet(module: ModuleRef, ref: ExpressionRef, index: ExpressionRef, type: TypeRef, signed: bool): ExpressionRef;\nexport declare function _BinaryenArrayGetGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayGetSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayGetGetIndex(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayGetSetIndex(expr: ExpressionRef, indexExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayGetIsSigned(expr: ExpressionRef): bool;\nexport declare function _BinaryenArrayGetSetSigned(expr: ExpressionRef, signed: bool): void;\n\nexport declare function _BinaryenArraySet(module: ModuleRef, ref: ExpressionRef, index: ExpressionRef, value: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArraySetGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArraySetSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenArraySetGetIndex(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArraySetSetIndex(expr: ExpressionRef, indexExpr: ExpressionRef): void;\nexport declare function _BinaryenArraySetGetValue(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArraySetSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;\n\nexport declare function _BinaryenArrayLen(module: ModuleRef, ref: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayLenGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayLenSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\n\nexport declare function _BinaryenArrayCopy(module: ModuleRef, destRef: ExpressionRef, destIndex: ExpressionRef, srcRef: ExpressionRef, srcIndex: ExpressionRef, length: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayCopyGetDestRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayCopySetDestRef(expr: ExpressionRef, destRefExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayCopyGetDestIndex(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayCopySetDestIndex(expr: ExpressionRef, destIndexExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayCopyGetSrcRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayCopySetSrcRef(expr: ExpressionRef, srcRefExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayCopyGetSrcIndex(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayCopySetSrcIndex(expr: ExpressionRef, srcIndexExpr: ExpressionRef): void;\nexport declare function _BinaryenArrayCopyGetLength(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenArrayCopySetLength(expr: ExpressionRef, lengthExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringNew(module: ModuleRef, op: Op, ptr: ExpressionRef, length: ExpressionRef, start: ExpressionRef, end: ExpressionRef, isTry: bool): ExpressionRef;\nexport declare function _BinaryenStringNewGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringNewSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringNewGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringNewSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenStringNewGetLength(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringNewSetLength(expr: ExpressionRef, lengthExpr: ExpressionRef): void;\nexport declare function _BinaryenStringNewGetStart(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringNewSetStart(expr: ExpressionRef, startExpr: ExpressionRef): void;\nexport declare function _BinaryenStringNewGetEnd(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringNewSetEnd(expr: ExpressionRef, endExpr: ExpressionRef): void;\nexport declare function _BinaryenStringNewIsTry(expr: ExpressionRef): bool;\nexport declare function _BinaryenStringNewSetTry(expr: ExpressionRef, isTry: bool): void;\n\nexport declare function _BinaryenStringConst(module: ExpressionRef, name: StringRef): ExpressionRef;\nexport declare function _BinaryenStringConstGetString(expr: ExpressionRef): StringRef;\nexport declare function _BinaryenStringConstSetString(expr: ExpressionRef, string: StringRef): void;\n\nexport declare function _BinaryenStringMeasure(module: ExpressionRef, op: Op, ref: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringMeasureGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringMeasureSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringMeasureGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringMeasureSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringEncode(module: ExpressionRef, op: Op, ref: ExpressionRef, ptr: ExpressionRef, start: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEncodeGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringEncodeSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringEncodeGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEncodeSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStringEncodeGetPtr(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEncodeSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;\nexport declare function _BinaryenStringEncodeGetStart(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEncodeSetStart(expr: ExpressionRef, startExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringConcat(module: ExpressionRef, left: ExpressionRef, right: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringConcatGetLeft(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringConcatSetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;\nexport declare function _BinaryenStringConcatGetRight(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringConcatSetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringEq(module: ExpressionRef, op: Op, left: ExpressionRef, right: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEqGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringEqSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringEqGetLeft(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEqSetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;\nexport declare function _BinaryenStringEqGetRight(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringEqSetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringAs(module: ExpressionRef, op: Op, ref: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringAsGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringAsSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringAsGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringAsSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringWTF8Advance(module: ExpressionRef, ref: ExpressionRef, pos: ExpressionRef, bytes: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF8AdvanceGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF8AdvanceSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStringWTF8AdvanceGetPos(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF8AdvanceSetPos(expr: ExpressionRef, posExpr: ExpressionRef): void;\nexport declare function _BinaryenStringWTF8AdvanceGetBytes(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF8AdvanceSetBytes(expr: ExpressionRef, bytesExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringWTF16Get(module: ExpressionRef, ref: ExpressionRef, pos: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF16GetGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF16GetSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStringWTF16GetGetPos(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringWTF16GetSetPos(expr: ExpressionRef, posExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringIterNext(module: ExpressionRef, ref: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringIterNextGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringIterNextSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringIterMove(module: ExpressionRef, op: Op, ref: ExpressionRef, num: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringIterMoveGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringIterMoveSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringIterMoveGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringIterMoveSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStringIterMoveGetNum(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringIterMoveSetNum(expr: ExpressionRef, numExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringSliceWTF(module: ExpressionRef, op: Op, ref: ExpressionRef, start: ExpressionRef, end: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceWTFGetOp(expr: ExpressionRef): Op;\nexport declare function _BinaryenStringSliceWTFSetOp(expr: ExpressionRef, op: Op): void;\nexport declare function _BinaryenStringSliceWTFGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceWTFSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStringSliceWTFGetStart(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceWTFSetStart(expr: ExpressionRef, startExpr: ExpressionRef): void;\nexport declare function _BinaryenStringSliceWTFGetEnd(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceWTFSetEnd(expr: ExpressionRef, endExpr: ExpressionRef): void;\n\nexport declare function _BinaryenStringSliceIter(module: ExpressionRef, ref: ExpressionRef, num: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceIterGetRef(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceIterSetRef(expr: ExpressionRef, refExpr: ExpressionRef): void;\nexport declare function _BinaryenStringSliceIterGetNum(expr: ExpressionRef): ExpressionRef;\nexport declare function _BinaryenStringSliceIterSetNum(expr: ExpressionRef, numExpr: ExpressionRef): void;\n\nexport declare function _BinaryenAddFunction(module: ModuleRef, name: StringRef, params: TypeRef, results: TypeRef, varTypes: ArrayRef<TypeRef>, numVarTypes: Index, body: ExpressionRef): FunctionRef;\nexport declare function _BinaryenGetFunction(module: ModuleRef, name: StringRef): FunctionRef;\nexport declare function _BinaryenRemoveFunction(module: ModuleRef, name: StringRef): void;\nexport declare function _BinaryenGetNumFunctions(module: ModuleRef): Index;\nexport declare function _BinaryenGetFunctionByIndex(module: ModuleRef, index: Index): FunctionRef;\n\nexport declare function _BinaryenFunctionGetName(func: FunctionRef): StringRef;\nexport declare function _BinaryenFunctionGetParams(func: FunctionRef): TypeRef;\nexport declare function _BinaryenFunctionGetResults(func: FunctionRef): TypeRef;\nexport declare function _BinaryenFunctionGetNumVars(func: FunctionRef): Index;\nexport declare function _BinaryenFunctionGetVar(func: FunctionRef, index: Index): TypeRef;\nexport declare function _BinaryenFunctionGetNumLocals(func: FunctionRef): Index;\nexport declare function _BinaryenFunctionHasLocalName(func: FunctionRef, index: Index): bool;\nexport declare function _BinaryenFunctionGetLocalName(func: FunctionRef, index: Index): StringRef;\nexport declare function _BinaryenFunctionSetLocalName(func: FunctionRef, index: Index, name: StringRef): void;\nexport declare function _BinaryenFunctionGetBody(func: FunctionRef): ExpressionRef;\nexport declare function _BinaryenFunctionSetBody(func: FunctionRef, bodyExpr: ExpressionRef): void;\nexport declare function _BinaryenFunctionOptimize(func: FunctionRef, module: ModuleRef): void;\nexport declare function _BinaryenFunctionRunPasses(func: FunctionRef, module: ModuleRef, passes: ArrayRef<StringRef>, numPasses: Index): void;\nexport declare function _BinaryenFunctionSetDebugLocation(func: FunctionRef, expr: ExpressionRef, fileIndex: Index, lineNumber: Index, columnNumber: Index): void;\n\nexport declare function _BinaryenAddFunctionImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, params: TypeRef, results: TypeRef): void;\nexport declare function _BinaryenAddTableImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef): void;\nexport declare function _BinaryenAddMemoryImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, shared:bool): void;\nexport declare function _BinaryenAddGlobalImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, globalType: TypeRef, mutable: bool): void;\nexport declare function _BinaryenAddTagImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, params: TypeRef, results: TypeRef): void;\n\nexport declare function _BinaryenAddFunctionExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;\nexport declare function _BinaryenAddTableExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;\nexport declare function _BinaryenAddMemoryExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;\nexport declare function _BinaryenAddGlobalExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;\nexport declare function _BinaryenAddTagExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;\nexport declare function _BinaryenGetExport(module: ModuleRef, externalName: StringRef): ExportRef;\nexport declare function _BinaryenRemoveExport(module: ModuleRef, externalName: StringRef): void;\nexport declare function _BinaryenGetNumExports(module: ModuleRef): Index;\nexport declare function _BinaryenGetExportByIndex(module: ModuleRef, index: Index): ExportRef;\nexport declare function _BinaryenExportGetKind(ref: ExportRef): ExternalKind;\nexport declare function _BinaryenExportGetName(ref: ExportRef): StringRef;\nexport declare function _BinaryenExportGetValue(ref: ExportRef): StringRef;\n\nexport declare function _BinaryenAddGlobal(module: ModuleRef, name: StringRef, type: TypeRef, mutable: bool, init: ExpressionRef): GlobalRef;\nexport declare function _BinaryenGetGlobal(module: ModuleRef, name: StringRef): GlobalRef;\nexport declare function _BinaryenRemoveGlobal(module: ModuleRef, name: StringRef): void;\nexport declare function _BinaryenGetNumGlobals(module: ModuleRef): Index;\nexport declare function _BinaryenGetGlobalByIndex(module: ModuleRef, index: Index): GlobalRef;\n\nexport declare function _BinaryenGlobalGetName(global: GlobalRef): StringRef;\nexport declare function _BinaryenGlobalGetType(global: GlobalRef): TypeRef;\nexport declare function _BinaryenGlobalIsMutable(global: GlobalRef): bool;\nexport declare function _BinaryenGlobalGetInitExpr(global: GlobalRef): ExpressionRef;\n\nexport declare function _BinaryenAddTag(module: ModuleRef, name: StringRef, params: TypeRef, results: TypeRef): TagRef;\nexport declare function _BinaryenGetTag(module: ModuleRef, name: StringRef): TagRef;\nexport declare function _BinaryenRemoveTag(module: ModuleRef, name: StringRef): void;\n\nexport declare function _BinaryenTagGetName(tag: TagRef): StringRef;\nexport declare function _BinaryenTagGetParams(tag: TagRef): TypeRef;\nexport declare function _BinaryenTagGetResults(tag: TagRef): TypeRef;\n\nexport declare function _BinaryenAddTable(module: ModuleRef, name: StringRef, initial: Index, maximum: Index, type: TypeRef): TableRef;\nexport declare function _BinaryenRemoveTable(module: ModuleRef, table: StringRef): void;\nexport declare function _BinaryenGetNumTables(module: ModuleRef): Index;\nexport declare function _BinaryenGetTable(module: ModuleRef, name: StringRef): TableRef;\nexport declare function _BinaryenGetTableByIndex(module: ModuleRef, index: Index): TableRef;\n\nexport declare function _BinaryenTableGetName(table: TableRef): StringRef;\nexport declare function _BinaryenTableSetName(table: TableRef, name: StringRef): void;\nexport declare function _BinaryenTableGetInitial(table: TableRef): Index;\nexport declare function _BinaryenTableSetInitial(table: TableRef, initial: Index): void;\nexport declare function _BinaryenTableHasMax(table: TableRef): bool;\nexport declare function _BinaryenTableGetMax(table: TableRef): Index;\nexport declare function _BinaryenTableSetMax(table: TableRef, max: Index): void;\n\nexport declare function _BinaryenAddActiveElementSegment(module: ModuleRef, table: StringRef, name: StringRef, funcNames: ArrayRef<StringRef>, numFuncNames: Index, offset: ExpressionRef): ElementSegmentRef;\nexport declare function _BinaryenAddPassiveElementSegment(module: ModuleRef, name: StringRef, funcNames: ArrayRef<StringRef>, numFuncNames: Index): ElementSegmentRef;\nexport declare function _BinaryenRemoveElementSegment(module: ModuleRef, name: StringRef): void;\nexport declare function _BinaryenGetNumElementSegments(module: ModuleRef, name: StringRef): Index;\nexport declare function _BinaryenGetElementSegment(module: ModuleRef, name: StringRef): ElementSegmentRef;\nexport declare function _BinaryenGetElementSegmentByIndex(module: ModuleRef, index: Index): ElementSegmentRef;\n\nexport declare function _BinaryenSetMemory(module: ModuleRef, initial: Index, maximum: Index, exportName: StringRef, segments: ArrayRef<ArrayRef<u8>>, segmentPassive: ArrayRef<bool>, segmentOffsets: ArrayRef<usize>, segmentSizes: ArrayRef<u32>, numSegments: Index, shared: bool, memory64: bool, name: StringRef): void;\nexport declare function _BinaryenGetNumMemorySegments(module: ModuleRef): Index;\nexport declare function _BinaryenGetMemorySegmentByteOffset(module: ModuleRef, index: Index): u32;\nexport declare function _BinaryenGetMemorySegmentByteLength(module: ModuleRef, id: Index): usize;\nexport declare function _BinaryenCopyMemorySegmentData(module: ModuleRef, id: Index, buffer: ArrayRef<u8>): void;\n\nexport declare function _BinaryenSetStart(module: ModuleRef, start: FunctionRef): void;\n\nexport declare function _BinaryenModuleParse(text: StringRef): ModuleRef;\nexport declare function _BinaryenModulePrint(module: ModuleRef): void;\nexport declare function _BinaryenModulePrintAsmjs(module: ModuleRef): void;\nexport declare function _BinaryenModuleValidate(module: ModuleRef): i32;\nexport declare function _BinaryenModuleOptimize(module: ModuleRef): void;\nexport declare function _BinaryenModuleRunPasses(module: ModuleRef, passes: ArrayRef<StringRef>, numPasses: Index): void;\nexport declare function _BinaryenModuleAutoDrop(module: ModuleRef): void;\nexport declare function _BinaryenSizeofAllocateAndWriteResult(): i32;\nexport declare function _BinaryenModuleAllocateAndWrite(resultOut: BinaryenModuleAllocateAndWriteResultRef, module: ModuleRef, sourceMapUrl: StringRef): void;\nexport declare function _BinaryenModuleAllocateAndWriteText(module: ModuleRef): StringRef;\nexport declare function _BinaryenModuleAllocateAndWriteStackIR(module: ModuleRef, optimize: bool): StringRef;\nexport declare function _BinaryenModuleRead(input: ArrayRef<u8>, inputSize: usize): ModuleRef;\nexport declare function _BinaryenModuleInterpret(module: ModuleRef): void;\nexport declare function _BinaryenModuleAddDebugInfoFileName(module: ModuleRef, filename: StringRef): Index;\nexport declare function _BinaryenModuleGetDebugInfoFileName(module: ModuleRef, index: Index): StringRef;\nexport declare function _BinaryenModuleGetFeatures(module: ModuleRef): FeatureFlags;\nexport declare function _BinaryenModuleSetFeatures(module: ModuleRef, featureFlags: FeatureFlags): void;\n\nexport declare function _BinaryenAddCustomSection(module: ModuleRef, name: StringRef, contents: ArrayRef<u8>, contentsSize: Index): void;\n\nexport declare function _BinaryenExpressionGetSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects;\n\nexport declare function _RelooperCreate(module: ModuleRef): RelooperRef;\nexport declare function _RelooperAddBlock(relooper: RelooperRef, code: ExpressionRef): RelooperBlockRef;\nexport declare function _RelooperAddBranch(from: RelooperBlockRef, to: RelooperBlockRef, condition: ExpressionRef, code: ExpressionRef): void;\nexport declare function _RelooperAddBlockWithSwitch(relooper: RelooperRef, code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef;\nexport declare function _RelooperAddBranchForSwitch(from: RelooperBlockRef, to: RelooperBlockRef, indexes: ArrayRef<Index>, numIndexes: Index, code: ExpressionRef): void;\nexport declare function _RelooperRenderAndDispose(relooper: RelooperRef, entry: RelooperBlockRef, labelHelper: Index): ExpressionRef;\n\nexport declare function _ExpressionRunnerCreate(module: ModuleRef, flags: ExpressionRunnerFlags, maxDepth: Index, maxLoopIterations: Index): ExpressionRunnerRef;\nexport declare function _ExpressionRunnerSetLocalValue(runner: ExpressionRunnerRef, index: Index, value: ExpressionRef): bool;\nexport declare function _ExpressionRunnerSetGlobalValue(runner: ExpressionRunnerRef, name: StringRef, value: ExpressionRef): bool;\nexport declare function _ExpressionRunnerRunAndDispose(runner: ExpressionRunnerRef, expr: ExpressionRef): ExpressionRef;\n\nexport declare function _TypeBuilderCreate(size: Index): TypeBuilderRef;\nexport declare function _TypeBuilderGrow(builder: TypeBuilderRef, count: Index): void;\nexport declare function _TypeBuilderGetSize(builder: TypeBuilderRef): Index;\nexport declare function _TypeBuilderSetBasicHeapType(builder: TypeBuilderRef, index: Index, basicHeapType: HeapTypeRef): void;\nexport declare function _TypeBuilderSetSignatureType(builder: TypeBuilderRef, index: Index, paramTypes: TypeRef, resultTypes: TypeRef): void;\nexport declare function _TypeBuilderSetStructType(builder: TypeBuilderRef, index: Index, fieldTypes: ArrayRef<TypeRef>, fieldPackedTypes: ArrayRef<PackedType>, fieldMutables: ArrayRef<bool>, numFields: i32): void;\nexport declare function _TypeBuilderSetArrayType(builder: TypeBuilderRef, index: Index, elementType: TypeRef, elementPackedTyype: PackedType, elementMutable: bool): void;\nexport declare function _TypeBuilderIsBasic(builder: TypeBuilderRef, index: Index): bool;\nexport declare function _TypeBuilderGetBasic(builder: TypeBuilderRef, index: Index): HeapTypeRef;\nexport declare function _TypeBuilderGetTempHeapType(builder: TypeBuilderRef, index: Index): HeapTypeRef;\nexport declare function _TypeBuilderGetTempTupleType(builder: TypeBuilderRef, types: ArrayRef<TypeRef>, numTypes: Index): TypeRef;\nexport declare function _TypeBuilderGetTempRefType(builder: TypeBuilderRef, heapType: HeapTypeRef, nullable: bool): TypeRef;\nexport declare function _TypeBuilderSetSubType(builder: TypeBuilderRef, index: Index, superType: HeapTypeRef): void;\nexport declare function _TypeBuilderCreateRecGroup(builder: TypeBuilderRef, index: Index, length: Index): void;\nexport declare function _TypeBuilderBuildAndDispose(builder: TypeBuilderRef, heapTypes: ArrayRef<HeapTypeRef>, errorIndex: Pointer<Index>, errorReason: Pointer<TypeBuilderErrorReason>): bool;\nexport declare function _BinaryenModuleSetTypeName(module: ModuleRef, heapType: HeapTypeRef, name: StringRef): void;\nexport declare function _BinaryenModuleSetFieldName(module: ModuleRef, heapType: HeapTypeRef, index: Index, name: StringRef): void;\n\nexport declare function _BinaryenGetOptimizeLevel(): i32;\nexport declare function _BinaryenSetOptimizeLevel(level: i32): void;\nexport declare function _BinaryenGetShrinkLevel(): i32;\nexport declare function _BinaryenSetShrinkLevel(level: i32): void;\nexport declare function _BinaryenGetDebugInfo(): bool;\nexport declare function _BinaryenSetDebugInfo(on: bool): void;\nexport declare function _BinaryenGetLowMemoryUnused(): bool;\nexport declare function _BinaryenSetLowMemoryUnused(on: bool): void;\nexport declare function _BinaryenGetZeroFilledMemory(): bool;\nexport declare function _BinaryenSetZeroFilledMemory(on: bool): void;\nexport declare function _BinaryenGetFastMath(): bool;\nexport declare function _BinaryenSetFastMath(on: bool): void;\nexport declare function _BinaryenGetPassArgument(key: StringRef): StringRef;\nexport declare function _BinaryenSetPassArgument(key: StringRef, value: StringRef): void;\nexport declare function _BinaryenClearPassArguments(): void;\nexport declare function _BinaryenGetAlwaysInlineMaxSize(): Index;\nexport declare function _BinaryenSetAlwaysInlineMaxSize(size: Index): void;\nexport declare function _BinaryenGetFlexibleInlineMaxSize(): Index;\nexport declare function _BinaryenSetFlexibleInlineMaxSize(size: Index): void;\nexport declare function _BinaryenGetOneCallerInlineMaxSize(): Index;\nexport declare function _BinaryenSetOneCallerInlineMaxSize(size: Index): void;\nexport declare function _BinaryenGetAllowInliningFunctionsWithLoops(): bool;\nexport declare function _BinaryenSetAllowInliningFunctionsWithLoops(enabled: bool): void;\nexport declare function _BinaryenGetTypeSystem(): TypeSystem;\nexport declare function _BinaryenSetTypeSystem(typeSystem: TypeSystem): void;\n\n// Helpers\n\nexport declare function _malloc(size: usize): usize;\nexport declare function _free(ptr: usize): void;\nexport declare function __i32_store8(ptr: usize, value: number): void;\nexport declare function __i32_store16(ptr: usize, value: number): void;\nexport declare function __i32_store(ptr: usize, value: number): void;\nexport declare function __f32_store(ptr: usize, value: number): void;\nexport declare function __f64_store(ptr: usize, value: number): void;\nexport declare function __i32_load8_s(ptr: usize): i8;\nexport declare function __i32_load8_u(ptr: usize): u8;\nexport declare function __i32_load16_s(ptr: usize): i16;\nexport declare function __i32_load16_u(ptr: usize): u16;\nexport declare function __i32_load(ptr: usize): i32;\nexport declare function __f32_load(ptr: usize): f32;\nexport declare function __f64_load(ptr: usize): f64;\n","/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  CommonNames\n} from \"./common\";\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  TypeRef,\n  createType,\n  HeapTypeRef,\n  ensureType\n} from \"./module\";\n\nimport * as binaryen from \"./glue/binaryen\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n  /** A 1-bit unsigned integer. */\n  Bool,\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  Isize,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  Usize,\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references (keep in same order as in Binaryen)\n\n  /** External reference. */\n  Externref,\n  /** Function reference. */\n  Funcref,\n  /** Any reference. */\n  Anyref,\n  /** Equatable reference. */\n  Eqref,\n  /** Struct reference. */\n  Structref,\n  /** Array reference. */\n  Arrayref,\n  /** 31-bit integer reference. */\n  I31ref,\n  /** String reference. */\n  Stringref,\n  /** WTF8 string view. */\n  StringviewWTF8,\n  /** WTF16 string view. */\n  StringviewWTF16,\n  /** String iterator. */\n  StringviewIter,\n\n  // other\n\n  /** No return type. */\n  Void\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  None = 0,\n  /** Is a signed type that can represent negative values. */\n  Signed = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  Unsigned = 1 << 1,\n  /** Is an integer type. */\n  Integer = 1 << 2,\n  /** Is a floating point type. */\n  Float = 1 << 3,\n  /** Is a varying (in size) type. */\n  Varying = 1 << 4,\n  /** Is smaller than 32-bits. */\n  Short = 1 << 5,\n  /** Is larger than 32-bits. */\n  Long = 1 << 6,\n  /** Is a value type. */\n  Value = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  Reference = 1 << 8,\n  /** Is a nullable type. */\n  Nullable = 1 << 9,\n  /** Is a vector type. */\n  Vector = 1 << 10,\n  /** Is an external type. */\n  External = 1 << 11,\n  /** Is a class. */\n  Class = 1 << 12,\n  /** Is a function. */\n  Function = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null = null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null = null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n  /** Cached Binaryen type reference. */\n  ref: TypeRef = 0;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    if (!(flags & TypeFlags.Nullable)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I32:\n      case TypeKind.F32:   return Type.i32;\n      case TypeKind.I8:    return Type.i8;\n      case TypeKind.I16:   return Type.i16;\n      case TypeKind.F64:\n      case TypeKind.I64:   return Type.i64;\n      case TypeKind.Isize: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8:    return Type.u8;\n      case TypeKind.U16:   return Type.u16;\n      case TypeKind.U32:   return Type.u32;\n      case TypeKind.U64:   return Type.u64;\n      case TypeKind.Usize: return this.size == 64 ? Type.usize64 : Type.usize32;\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    return this.kind == TypeKind.Void ? Type.auto : this;\n  }\n\n  /** Size in bytes. */\n  get byteSize(): i32 {\n    // ceiled div by 8\n    return this.size + 7 >>> 3;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.Short | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.Long | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.Signed | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.Unsigned | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.Varying | TypeFlags.Integer | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.Integer);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.Float | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.Vector | TypeFlags.Value);\n  }\n\n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.Nullable | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.Integer | TypeFlags.Reference);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.External | TypeFlags.Reference);\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.getClass() != null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.getSignature() != null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.Unmanaged);\n      return this.signatureReference != null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    let classReference = this.classReference;\n    return classReference != null && classReference.hasDecorator(DecoratorFlags.Unmanaged);\n  }\n\n  get isMemory(): bool {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64:\n      case TypeKind.V128: return true;\n    }\n    return false;\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    let size = this.size;\n    if (!this.is(TypeFlags.Unsigned)) size -= 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    let nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.Nullable, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Use unsigned type for according size if possible. */\n  toUnsigned(): Type {\n    switch (this.kind) {\n      case TypeKind.I8:    return Type.u8;\n      case TypeKind.I16:   return Type.u16;\n      case TypeKind.I32:   return Type.u32;\n      case TypeKind.I64:   return Type.u64;\n      case TypeKind.Isize: return this.size == 64 ? Type.usize64 : Type.usize32;\n    }\n    return this;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) {\n      return false;\n    }\n    if (this.isReference) {\n      let selfSignatureReference = this.signatureReference;\n      let otherSignatureReference = other.signatureReference;\n\n      return (\n        this.classReference == other.classReference\n        && selfSignatureReference == otherSignatureReference\n        && this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    let currentClass: Class | null;\n    let targetClass: Class | null;\n    let currentFunction: Signature | null;\n    let targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference) {\n            if (\n              this.kind == target.kind ||\n              (target.kind == TypeKind.Anyref && this.kind != TypeKind.Externref)\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type has a subtype assignable to the target type. */\n  hasSubtypeAssignableTo(target: Type): bool {\n    let thisClass = this.getClass();\n    let targetClass = target.getClass();\n    if (!thisClass || !targetClass) return false; // TODO: what about basic types?\n    return thisClass.hasSubclassAssignableTo(targetClass);\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.Integer) && target.is(TypeFlags.Integer)) {\n      let size = this.size;\n      return size == target.size && (\n        size >= 32 ||\n        this.is(TypeFlags.Signed) == target.is(TypeFlags.Signed)\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if this type can extend or implement the given type. */\n  canExtendOrImplement(base: Type): bool {\n    // Both must be class types\n    let thisClass = this.getClass();\n    let baseClass = base.getClass();\n    if (!thisClass || !baseClass) return false;\n    // Both types must be either managed or unmanaged\n    if (this.isManaged != base.isManaged) return false;\n    // Both types must be either internal or external references\n    if (this.isInternalReference) {\n      if (!base.isInternalReference) return false;\n    } else if (this.isExternalReference) {\n      if (!base.isExternalReference) return false;\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  /** Computes the common type of a binary-like expression, if any. */\n  static commonType(\n    /** LHS type. */\n    left: Type,\n    /** RHS type. */\n    right: Type,\n    /** Contextual type, if any. */\n    contextualType: Type = Type.auto,\n    /** Whether signedness is relevant. */\n    signednessIsRelevant: bool = false\n  ): Type | null {\n    // Compute LUB of internal reference types (classes)\n    if (left.isInternalReference) {\n      if (!right.isInternalReference) return null;\n      // Prefer contextual type if meaningful\n      if (contextualType != Type.void && left.isAssignableTo(contextualType) && right.isAssignableTo(contextualType)) {\n        return contextualType;\n      }\n      let leftClass = left.getClass();\n      let rightClass = right.getClass();\n      if (leftClass && rightClass) {\n        let lubClass = Class.leastUpperBound(leftClass, rightClass);\n        if (lubClass) {\n          let ret = left.is(TypeFlags.Nullable) || right.is(TypeFlags.Nullable) ? lubClass.type.asNullable() : lubClass.type;\n          return ret;\n        }\n      }\n    } else if (right.isInternalReference) {\n      return null;\n    }\n    // TODO: External reference types (needs nullability)\n    // Otherwise do a trivial check\n    if (right.isAssignableTo(left, signednessIsRelevant)) return left;\n    else if (left.isAssignableTo(right, signednessIsRelevant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat ? \"|null\" : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? `(${signatureReference.toString(validWat)})${nullablePostfix}`\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.Bool: return CommonNames.bool;\n      case TypeKind.I8: return CommonNames.i8;\n      case TypeKind.I16: return CommonNames.i16;\n      case TypeKind.I32: return CommonNames.i32;\n      case TypeKind.I64: return CommonNames.i64;\n      case TypeKind.Isize: return CommonNames.isize;\n      case TypeKind.U8: return CommonNames.u8;\n      case TypeKind.U16: return CommonNames.u16;\n      case TypeKind.U32: return CommonNames.u32;\n      case TypeKind.U64: return CommonNames.u64;\n      case TypeKind.Usize: return CommonNames.usize;\n      case TypeKind.F32: return CommonNames.f32;\n      case TypeKind.F64: return CommonNames.f64;\n      case TypeKind.V128: return CommonNames.v128;\n      case TypeKind.Funcref: return CommonNames.funcref;\n      case TypeKind.Externref: return CommonNames.externref;\n      case TypeKind.Anyref: return CommonNames.anyref;\n      case TypeKind.Eqref: return CommonNames.eqref;\n      case TypeKind.Structref: return CommonNames.structref;\n      case TypeKind.Arrayref: return CommonNames.arrayref;\n      case TypeKind.I31ref: return CommonNames.i31ref;\n      case TypeKind.Stringref: return CommonNames.stringref;\n      case TypeKind.StringviewWTF8: return CommonNames.stringview_wtf8;\n      case TypeKind.StringviewWTF16: return CommonNames.stringview_wtf16;\n      case TypeKind.StringviewIter: return CommonNames.stringview_iter;\n      default: assert(false);\n      case TypeKind.Void: return CommonNames.void_;\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective type reference. */\n  toRef(): TypeRef {\n    switch (this.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return TypeRef.I32;\n      case TypeKind.Isize:\n      case TypeKind.Usize: if (this.size != 64) return TypeRef.I32;\n      case TypeKind.I64:\n      case TypeKind.U64:  return TypeRef.I64;\n      case TypeKind.F32:  return TypeRef.F32;\n      case TypeKind.F64:  return TypeRef.F64;\n      case TypeKind.V128: return TypeRef.V128;\n      case TypeKind.Funcref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Externref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Anyref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Eqref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Structref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Struct, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Arrayref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.I31ref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Stringref: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewWTF8: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF8, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewWTF16: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF16, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.StringviewIter: {\n        return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewIter, this.is(TypeFlags.Nullable));\n      }\n      case TypeKind.Void: return TypeRef.None;\n    }\n    // TODO: not used yet\n    assert(false);\n    return ensureType(this);\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.Signed   |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.Isize,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.Usize,\n    TypeFlags.Unsigned |\n    TypeFlags.Long     |\n    TypeFlags.Integer  |\n    TypeFlags.Varying  |\n    TypeFlags.Value,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.Bool,\n    TypeFlags.Unsigned |\n    TypeFlags.Short    |\n    TypeFlags.Integer  |\n    TypeFlags.Value,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.Signed   |\n    TypeFlags.Float    |\n    TypeFlags.Value,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.Signed   |\n    TypeFlags.Long     |\n    TypeFlags.Float    |\n    TypeFlags.Value,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.Vector   |\n    TypeFlags.Value, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.Funcref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.Externref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.Anyref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Equatable reference. */\n  static readonly eqref: Type = new Type(TypeKind.Eqref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Struct reference. */\n  static readonly structref: Type = new Type(TypeKind.Structref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** Array reference. */\n  static readonly arrayref: Type = new Type(TypeKind.Arrayref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** 31-bit integer reference. */\n  static readonly i31ref: Type = new Type(TypeKind.I31ref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** String reference. */\n  static readonly stringref: Type = new Type(TypeKind.Stringref,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** WTF8 string view. */\n  static readonly stringview_wtf8: Type = new Type(TypeKind.StringviewWTF8,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** WTF16 string view. */\n  static readonly stringview_wtf16: Type = new Type(TypeKind.StringviewWTF16,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** String iterator. */\n  static readonly stringview_iter: Type = new Type(TypeKind.StringviewIter,\n    TypeFlags.External   |\n    TypeFlags.Nullable   |\n    TypeFlags.Reference, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.Void, TypeFlags.None, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of type references. */\nexport function typesToRefs(types: Type[]): TypeRef[] {\n  let numTypes = types.length;\n  let ret = new Array<TypeRef>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(ret[i] = types[i].toRef());\n  }\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  let numTypes = types.length;\n  if (!numTypes) return \"\";\n  let sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) {\n    unchecked(sb[i] = types[i].toString(true));\n  }\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Construct a new signature. */\n  public static create(\n    /** The program that created this signature. */\n    program: Program,\n    /** Parameter types, if any, excluding `this`. */\n    parameterTypes: Type[] = [],\n    /** Return type. */\n    returnType: Type = Type.void,\n    /** This type, if an instance signature. */\n    thisType: Type | null = null,\n    /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n    requiredParameters: i32 = parameterTypes ? parameterTypes.length : 0,\n    /** Whether the last parameter is a rest parameter. */\n    hasRest: bool = false,\n  ): Signature {\n    // get the usize type, and the type of the signature\n    let usizeType = program.options.usizeType;\n    let type = new Type(\n      usizeType.kind,\n      usizeType.flags & ~TypeFlags.Value | TypeFlags.Reference,\n      usizeType.size\n    );\n\n    // calculate the properties\n    let signatureTypes = program.uniqueSignatures;\n    let nextId = program.nextSignatureId;\n    \n    // construct the signature and calculate it's unique key\n    let signature = new Signature(program, parameterTypes, returnType, thisType, requiredParameters, hasRest, nextId, type);\n    let uniqueKey = signature.toString();\n\n    // check if it exists, and return it\n    if (signatureTypes.has(uniqueKey)) {\n      let existing = assert(signatureTypes.get(uniqueKey));\n      assert(signature.equals(existing));\n      return existing;\n    }\n\n    // otherwise increment the program's signature id, set the signature reference of the type, and memoize the signature\n    program.nextSignatureId = nextId + 1;\n    type.signatureReference = signature;\n    signatureTypes.set(uniqueKey, signature);\n    return signature;\n  }\n\n  /** Constructs a new signature. */\n  private constructor(\n    /** The program that created this signature. */\n    public readonly program: Program,\n    /** Parameter types, if any, excluding `this`. */\n    public readonly parameterTypes: Type[],\n    /** Return type. */\n    public readonly returnType: Type,\n    /** This type, if an instance signature. */\n    public readonly thisType: Type | null,\n    /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n    public readonly requiredParameters: i32,\n    /** Whether the last parameter is a rest parameter. */\n    public readonly hasRest: bool,\n    /** Unique id representing this signature. */\n    public readonly id: u32,\n    /** Respective function type. */\n    public readonly type: Type,\n  ) {}\n\n  get paramRefs(): TypeRef {\n    let thisType = this.thisType;\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      return thisType ? thisType.toRef() : TypeRef.None;\n    }\n    if (thisType) {\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\n      unchecked(typeRefs[0] = thisType.toRef());\n      for (let i = 0; i < numParameterTypes; ++i) {\n        unchecked(typeRefs[i + 1] = parameterTypes[i].toRef());\n      }\n      return createType(typeRefs);\n    }\n    return createType(typesToRefs(parameterTypes));\n  }\n\n  get resultRefs(): TypeRef {\n    return this.returnType.toRef();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    let thisThisType = this.thisType;\n    let otherThisType = other.thisType;\n    if (thisThisType) {\n      if (!otherThisType || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check return type\n    if (!this.returnType.equals(other.returnType)) return false;\n\n    // check parameter types\n    let selfParameterTypes = this.parameterTypes;\n    let otherParameterTypes = other.parameterTypes;\n    let numParameters = selfParameterTypes.length;\n    if (numParameters != otherParameterTypes.length)  return false;\n\n    for (let i = 0; i < numParameters; ++i) {\n      let selfParameterType = unchecked(selfParameterTypes[i]);\n      let otherParameterType = unchecked(otherParameterTypes[i]);\n      if (!selfParameterType.equals(otherParameterType)) return false;\n    }\n    return true;\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, checkCompatibleOverride: bool = false): bool {\n    let thisThisType = this.thisType;\n    let targetThisType = target.thisType;\n    if (checkCompatibleOverride) {\n      // check kind of `this` type\n      if (thisThisType) {\n        if (!targetThisType || !thisThisType.canExtendOrImplement(targetThisType)) {\n          return false;\n        }\n      } else if (targetThisType) {\n        return false;\n      }\n    } else {\n      // check `this` type (invariant)\n      if (thisThisType) {\n        if (targetThisType != targetThisType) return false;\n      } else if (targetThisType) {\n        return false;\n      }\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check return type (covariant)\n    let thisReturnType = this.returnType;\n    let targetReturnType = target.returnType;\n    if (!(thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType))) {\n      return false;\n    }\n    // check parameter types (invariant)\n    let thisParameterTypes = this.parameterTypes;\n    let targetParameterTypes = target.parameterTypes;\n    let numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = unchecked(thisParameterTypes[i]);\n      let targetParameterType = unchecked(targetParameterTypes[i]);\n      if (thisParameterType != targetParameterType) return false;\n    }\n    return true;\n  }\n\n  /** Tests if this signature has at least one managed operand. */\n  get hasManagedOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isManaged) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all managed operands. */\n  getManagedOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Tests if this signature has at least one v128 operand. */\n  get hasVectorValueOperands(): bool {\n    let thisType = this.thisType;\n    if (thisType && thisType.isVectorValue) {\n      return true;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all v128 operands. */\n  getVectorValueOperandIndices(): i32[] {\n    let indices = new Array<i32>();\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isVectorValue) indices.push(index);\n      ++index;\n    }\n    let parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (unchecked(parameterTypes[i]).isVectorValue) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    let sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    let index = 0;\n    let thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    let parameters = this.parameterTypes;\n    let numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(requiredParameters: i32 = this.requiredParameters, hasRest: bool = this.hasRest): Signature {\n    let parameterTypes = this.parameterTypes;\n    let numParameterTypes = parameterTypes.length;\n    let cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      unchecked(cloneParameterTypes[i] = parameterTypes[i]);\n    }\n    return Signature.create(\n      this.program,\n      cloneParameterTypes,\n      this.returnType,\n      this.thisType,\n      requiredParameters,\n      hasRest\n    );\n  }\n}\n","/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { BuiltinNames } from \"./builtins\";\nimport { CommonNames, Target } from \"./common\";\nimport {\n  isHighSurrogate,\n  isLowSurrogate,\n  combineSurrogates,\n  SURROGATE_HIGH,\n  SURROGATE_LOW\n} from \"./util\";\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\nimport {\n  ElementKind,\n  PropertyPrototype\n} from \"./program\";\nimport * as binaryen from \"./glue/binaryen\";\n\n/** A Binaryen-compatible index. */\nexport type Index = binaryen.Index;\n/** Reference to a Binaryen-compatible string. */\nexport type StringRef = binaryen.StringRef;\n/** Reference to a Binaryen module. */\nexport type ModuleRef = binaryen.ModuleRef;\n/** Reference to a Binaryen function. */\nexport type FunctionRef = binaryen.FunctionRef;\n/** Reference to a Binaryen expression. */\nexport type ExpressionRef = binaryen.ExpressionRef;\n/** Reference to a Binaryen global. */\nexport type GlobalRef = binaryen.GlobalRef;\n/** Reference to a Binaryen tag. */\nexport type TagRef = binaryen.TagRef;\n/** Reference to a Binaryen import. */\nexport type ImportRef = binaryen.ImportRef;\n/** Reference to a Binaryen export. */\nexport type ExportRef = binaryen.ExportRef;\n/** Reference to a Binaryen relooper. */\nexport type RelooperRef = binaryen.RelooperRef;\n/** Reference to a Binaryen relooper block. */\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\n/** Reference to a Binaryen type. */\nexport type TypeRef = binaryen.TypeRef;\nexport namespace TypeRef {\n  // special types\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\n  // value types\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\n  // reference/gc types\n  export const Funcref = binaryen._BinaryenTypeFuncref();\n  export const Externref = binaryen._BinaryenTypeExternref();\n  export const Anyref = binaryen._BinaryenTypeAnyref();\n  export const Eqref = binaryen._BinaryenTypeEqref();\n  export const Structref = binaryen._BinaryenTypeStructref();\n  export const Arrayref = binaryen._BinaryenTypeArrayref();\n  export const I31ref = binaryen._BinaryenTypeI31ref();\n  export const Stringref = binaryen._BinaryenTypeStringref();\n  export const StringviewWTF8 = binaryen._BinaryenTypeStringviewWTF8();\n  export const StringviewWTF16 = binaryen._BinaryenTypeStringviewWTF16();\n  export const StringviewIter = binaryen._BinaryenTypeStringviewIter();\n  export const Noneref = binaryen._BinaryenTypeNullref();\n  export const Nofuncref = binaryen._BinaryenTypeNullFuncref();\n  export const Noexternref = binaryen._BinaryenTypeNullExternref();\n}\n\n/** Reference to a Binaryen heap type. */\nexport type HeapTypeRef = binaryen.HeapTypeRef;\nexport namespace HeapTypeRef {\n\n  //        any                  extern      func\n  //         |                      |          |\n  //     __ eq __          ?     noextern    (...)\n  //    /    |   \\         |                   |\n  // i31  struct  array  string              nofunc\n  //  |      |      |      |\n  // none  (...)  (...)    ?\n  //         |      |\n  //        none   none\n  //\n  // where (...) represents the concrete subtypes\n\n  export const Extern: HeapTypeRef = 0 /* _BinaryenHeapTypeExt */;\n  export const Func: HeapTypeRef = 1 /* _BinaryenHeapTypeFunc */;\n  export const Any: HeapTypeRef = 2 /* _BinaryenHeapTypeAny */;\n  export const Eq: HeapTypeRef = 3 /* _BinaryenHeapTypeEq */;\n  export const I31: HeapTypeRef = 4 /* _BinaryenHeapTypeI31 */;\n  export const Struct: HeapTypeRef = 5 /* _BinaryenHeapTypeStruct */;\n  export const Array: HeapTypeRef = 6 /* _BinaryenHeapTypeArray */;\n  export const String: HeapTypeRef = 7 /* _BinaryenHeapTypeString */;\n  export const StringviewWTF8: HeapTypeRef = 8 /* _BinaryenHeapTypeStringviewWTF8 */;\n  export const StringviewWTF16: HeapTypeRef = 9 /* _BinaryenHeapTypeStringviewWTF16 */;\n  export const StringviewIter: HeapTypeRef = 10 /* _BinaryenHeapTypeStringviewIter */;\n  export const None: HeapTypeRef = 11 /* _BinaryenHeapTypeNone */;\n  export const Noextern: HeapTypeRef = 12 /* _BinaryenHeapTypeNoext */;\n  export const Nofunc: HeapTypeRef = 13 /* _BinaryenHeapTypeNofunc */;\n\n  export function isBottom(ht: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsBottom(ht);\n  }\n\n  export function getBottom(ht: HeapTypeRef): HeapTypeRef {\n    return binaryen._BinaryenHeapTypeGetBottom(ht);\n  }\n\n  export function isSubtype(ht: HeapTypeRef, superHt: HeapTypeRef): bool {\n    return binaryen._BinaryenHeapTypeIsSubType(ht, superHt);\n  }\n\n  export function leastUpperBound(a: HeapTypeRef, b: HeapTypeRef): HeapTypeRef {\n    // see binaryen/src/wasm/wasm-type.cpp\n    if (a == b) return a;\n    if (getBottom(a) != getBottom(b)) return -1;\n    if (isBottom(a)) return b;\n    if (isBottom(b)) return a;\n    if (a > b) {\n      let t = a;\n      a = b;\n      b = t;\n    }\n    switch (a) {\n      case HeapTypeRef.Extern:\n      case HeapTypeRef.Func: return -1;\n      case HeapTypeRef.Any: return a;\n      case HeapTypeRef.Eq: {\n        return b == HeapTypeRef.I31 || b == HeapTypeRef.Struct || b == HeapTypeRef.Array\n          ? HeapTypeRef.Eq\n          : HeapTypeRef.Any;\n      }\n      case HeapTypeRef.I31: {\n        return b == HeapTypeRef.Struct || b == HeapTypeRef.Array\n          ? HeapTypeRef.Eq\n          : HeapTypeRef.Any;\n      }\n      case HeapTypeRef.Struct: {\n        return b == HeapTypeRef.Array\n          ? HeapTypeRef.Eq\n          : HeapTypeRef.Any;\n      }\n      case HeapTypeRef.Array:\n      case HeapTypeRef.String:\n      case HeapTypeRef.StringviewWTF8:\n      case HeapTypeRef.StringviewWTF16:\n      case HeapTypeRef.StringviewIter: return HeapTypeRef.Any;\n    }\n    assert(false);\n    return -1;\n  }\n}\n\n/** Packed array element respectively struct field types. */\nexport type PackedType = binaryen.PackedType;\nexport namespace PackedType {\n  export const NotPacked: PackedType = 0 /* _BinaryenPackedTypeNotPacked */;\n  export const I8: PackedType = 1 /* _BinaryenPackedTypeInt8 */;\n  export const I16: PackedType = 2 /* _BinaryenPackedTypeInt16 */;\n}\n\n/** Type builder error reasons. */\nexport type TypeBuilderErrorReason = binaryen.TypeBuilderErrorReason;\nexport namespace TypeBuilderErrorReason {\n  /** Indicates a cycle in the supertype relation. */\n  export const SelfSupertype: TypeBuilderErrorReason = 0 /* _TypeBuilderErrorReasonSelfSupertype */;\n  /** Indicates that the declared supertype of a type is invalid. */\n  export const InvalidSupertype: TypeBuilderErrorReason = 1 /* _TypeBuilderErrorReasonInvalidSupertype */;\n  /** Indicates that the declared supertype is an invalid forward reference. */\n  export const ForwardSupertypeReference: TypeBuilderErrorReason = 2 /* _TypeBuilderErrorReasonForwardSupertypeReference */;\n  /** Indicates that a child of a type is an invalid forward reference. */\n  export const ForwardChildReference: TypeBuilderErrorReason = 3 /* _TypeBuilderErrorReasonForwardChildReference */;\n  /** Converts a type builder error reason to a string. */\n  export function toString(reason: TypeBuilderErrorReason): string {\n    switch (reason) {\n      case SelfSupertype: return \"SelfSupertype\";\n      case InvalidSupertype: return \"InvalidSupertype\";\n      case ForwardSupertypeReference: return \"ForwardSupertypeReference\";\n      case ForwardChildReference: return \"ForwardChildReference\";\n    }\n    assert(false);\n    return \"\";\n  }\n}\n\n/** Type system constants. */\nexport type TypeSystem = binaryen.TypeSystem;\nexport namespace TypeSystem {\n  export const Isorecursive: TypeSystem = 0 /* _BinaryenTypeSystemIsorecursive */;\n  export const Nominal: TypeSystem = 1 /* _BinaryenTypeSystemNominal */;\n}\n\n/** Binaryen feature constants. */\nexport const enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGlobals = 2 /* _BinaryenFeatureMutableGlobals */,\n  TruncSat = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\n  RelaxedSIMD = 8192 /* _BinaryenFeatureRelaxedSIMD */,\n  ExtendedConst = 16384 /* _BinaryenFeatureExtendedConst */,\n  Stringref = 32768 /* _BinaryenFeatureStrings */,\n  MultiMemory = 65536 /* _BinaryenFeatureMultiMemories */,\n  All = 126975 /* _BinaryenFeatureAll */\n}\n\n/** Binaryen expression id constants. */\nexport const enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIsNull = 42 /* _BinaryenRefIsNullId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  TableGet = 45 /* _BinaryenTableGetId */,\n  TableSet = 46 /* _BinaryenTableSetId */,\n  TableSize = 47 /* _BinaryenTableSizeId */,\n  TableGrow = 48 /* _BinaryenTableGrowId */,\n  Try = 49 /* _BinaryenTryId */,\n  Throw = 50 /* _BinaryenThrowId */,\n  Rethrow = 51 /* _BinaryenRethrowId */,\n  TupleMake = 52 /* _BinaryenTupleMakeId */,\n  TupleExtract = 53 /* _BinaryenTupleExtractId */,\n  I31New = 54 /* _BinaryenI31NewId */,\n  I31Get = 55 /* _BinaryenI31GetId */,\n  CallRef = 56 /* _BinaryenCallRefId */,\n  RefTest = 57 /* _BinaryenRefTestId */,\n  RefCast = 58 /* _BinaryenRefCastId */,\n  BrOn = 59 /* _BinaryenBrOnId */,\n  StructNew = 60 /* _BinaryenStructNewId */,\n  StructGet = 61 /* _BinaryenStructGetId */,\n  StructSet = 62 /* _BinaryenStructSetId */,\n  ArrayNew = 63 /* _BinaryenArrayNewId */,\n  ArrayNewSeg = 64 /* TODO_BinaryenArraySegId */,\n  ArrayInit = 65 /* _BinaryenArrayInitId */,\n  ArrayGet = 66 /* _BinaryenArrayGetId */,\n  ArraySet = 67 /* _BinaryenArraySetId */,\n  ArrayLen = 68 /* _BinaryenArrayLenId */,\n  ArrayCopy = 69 /* _BinaryenArrayCopyId */,\n  RefAs = 70 /* _BinaryenRefAsId */,\n  StringNew = 71 /* _BinaryenStringNewId */,\n  StringConst = 72 /* _BinaryenStringConstId */,\n  StringMeasure = 73 /* _BinaryenStringMeasureId */,\n  StringEncode = 74 /* _BinaryenStringEncodeId */,\n  StringConcat = 75 /* _BinaryenStringConcatId */,\n  StringEq = 76 /* _BinaryenStringEqId */,\n  StringAs = 77 /* _BinaryenStringAsId */,\n  StringWTF8Advance = 78 /* _BinaryenStringWTF8AdvanceId */,\n  StringWTF16Get = 79 /* _BinaryenStringWTF16GetId */,\n  StringIterNext = 80 /* _BinaryenStringIterNextId */,\n  StringIterMove = 81 /* _BinaryenStringIterMoveId */,\n  StringSliceWTF = 82 /* _BinaryenStringSliceWTFId */,\n  StringSliceIter = 83 /* _BinaryenStringSliceIterId */\n}\n\n/** Binaryen external kind constants. */\nexport const enum ExternalKind {\n  Function = 0 /* _BinaryenExternalFunction */,\n  Table = 1 /* _BinaryenExternalTable */,\n  Memory = 2 /* _BinaryenExternalMemory */,\n  Global = 3 /* _BinaryenExternalGlobal */,\n  Tag = 4 /* _BinaryenExternalTag */\n}\n\n/** Binaryen unary operation constants. */\nexport const enum UnaryOp {\n  /** i32.clz */\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  /** i64.clz */\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  /** i32.ctz */\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  /** i64.ctz */\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  /** i32.popcnt */\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  /** i64.popcnt */\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  /** f32.neg */\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  /** f64.neg */\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  /** f32.abs */\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  /** f64.abs */\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  /** f32.ceil */\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  /** f64.ceil */\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  /** f32.floor */\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  /** f64.floor */\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  /** f32.trunc */\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  /** f64.trunc */\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  /** f32.nearest */\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  /** f64.nearest */\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  /** f32.sqrt */\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  /** f64.sqrt */\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  /** i32.eqz */\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  /** i64.eqz */\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  /** i64.extend_i32_s */\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\n  /** i64.extend_i32_u */\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\n  /** i32.wrap_i64 */\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\n  /** i32.trunc_f32_s */\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  /** i64.trunc_f32_s */\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  /** i32.trunc_f32_u */\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  /** i64.trunc_f32_u */\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  /** i32.trunc_f64_s */\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  /** i64.trunc_f64_s */\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  /** i32.trunc_f64_u */\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  /** i64.trunc_f64_u */\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  /** i32.reinterpret_f32 */\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\n  /** i64.reinterpret_f64 */\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\n  /** f32.convert_i32_s */\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  /** f64.convert_i32_s */\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  /** f32.convert_i32_u */\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  /** f64.convert_i32_u */\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  /** f32.convert_i64_s */\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  /** f64.convert_i64_s */\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  /** f32.convert_i64_u */\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  /** f64.convert_i64_u */\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  /** f64.promote.f32 */\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\n  /** f32.demote_f64 */\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\n  /** f32.reinterpret_i32 */\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\n  /** f64.reinterpret_i64 */\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n\n  /** i32.extend8_s */\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\n  /** i32.extend16_s */\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\n  /** i64.extend8_s */\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\n  /** i64.extend16_s */\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\n  /** i64.extend32_s (i64 in, i64 out) */\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n\n  /** i32.trunc_sat_f32_s */\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  /** i32.trunc_sat_f32_u */\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  /** i32.trunc_sat_f64_s */\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  /** i32.trunc_sat_f64_u */\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  /** i64.trunc_sat_f32_s */\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  /** i64.trunc_sat_f32_u */\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  /** i64.trunc_sat_f64_s */\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  /** i64.trunc_sat_f64_u */\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.splat */\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  /** i16x8.splat */\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  /** i32x4.splat */\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  /** i64x2.splat */\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  /** f32x4.splat */\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  /** f64x2.splat */\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  /** v128.not */\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  /** v128.any_true */\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\n  /** i8x16.abs */\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\n  /** i8x16.neg */\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\n  /** i8x16.all_true */\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  /** i8x16.bitmask */\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\n  /** i8x16.popcnt */\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\n  /** i16x8.abs */\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\n  /** i16x8.neg */\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  /** i16x8.all_true */\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\n  /** i16x8.bitmask */\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\n  /** i32x4.abs */\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\n  /** i32x4.neg */\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\n  /** i32x4.all_true */\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\n  /** i32x4.bitmask */\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\n  /** i64x2.abs */\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\n  /** i64x2.neg */\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\n  /** i64x2.all_true */\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\n  /** i64x2.bitmask */\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\n  /** f32x4.abs */\n  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,\n  /** f32x4.neg */\n  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,\n  /** f32x4.sqrt */\n  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,\n  /** f32x4.ceil */\n  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,\n  /** f32x4.floor */\n  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,\n  /** f32x4.trunc */\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  /** f32x4.nearest */\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  /** f64x2.abs */\n  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,\n  /** f64x2.neg */\n  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,\n  /** f64x2.sqrt */\n  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,\n  /** f64x2.ceil */\n  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,\n  /** f64x2.floor */\n  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,\n  /** f64x2.trunc */\n  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,\n  /** f64x2.nearest */\n  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,\n  /** i16x8.extadd_pairwise_i8x16_s */\n  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\n  /** i16x8.extadd_pairwise.i8x16_u */\n  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\n  /** i32x4.extadd_pairwise.i16x8_s */\n  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\n  /** i32x4.extadd_pairwise.i64x8_u */\n  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\n  /** i32x4.trunc_sat_f32x4_s */\n  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  /** i32x4.trunc_sat_f32x4_u */\n  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  /** i16x8.extend_low_i8x16_s */\n  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_s */\n  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_low_i8x16_u */\n  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_u */\n  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\n  /** i32x4.extend_low_i16x8_s */\n  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_s */\n  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_low_i16x8_u */\n  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_u */\n  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\n  /** i64x2.extend_low_i32x4_s */\n  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_s */\n  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_low_i32x4_u */\n  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_u */\n  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\n  /** i32x4.trunc_sat_f64x2_s_zero */\n  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.trunc_sat_f64x2_u_zero */\n  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\n  /** f32x4.demote_f64x2_zero */\n  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\n  /** f64x2.promote_low_f32x4 */\n  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\n\n  // see: https://github.com/WebAssembly/relaxed-simd\n\n  /** i32x4.relaxed_trunc_f32x4_s */\n  RelaxedTruncF32x4ToI32x4 = 125 /* TODO_BinaryenRelaxedTruncSVecF32x4ToVecI32x4 */,\n  /** i32x4.relaxed_trunc_f32x4_u */\n  RelaxedTruncF32x4ToU32x4 = 126 /* TODO_BinaryenRelaxedTruncUVecF32x4ToVecI32x4 */,\n  /** i32x4.relaxed_trunc_f64x2_s_zero */\n  RelaxedTruncF64x2ToI32x4Zero = 127 /* TODO_BinaryenRelaxedTruncZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.relaxed_trunc_f64x2_u_zero */\n  RelaxedTruncF64x2ToU32x4Zero = 128 /* TODO_BinaryenRelaxedTruncZeroUVecF64x2ToVecI32x4 */,\n\n  _last = RelaxedTruncF64x2ToU32x4Zero,\n\n  // Target dependent\n\n  /** i32.clz or i64.clz, depending on target word size */\n  ClzSize,\n  /** i32.ctz or i64.ctz, depending on target word size */\n  CtzSize,\n  /** i32.popcnt or i64.popcnt, depending on target word size */\n  PopcntSize,\n  /** i32.eqz or i64.eqz, depending on target word size */\n  EqzSize\n}\n\n/** Binaryen binary operation constants. */\nexport const enum BinaryOp {\n  /** i32.add */\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  /** i32.sub */\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  /** i32.mul */\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  /** i32.div_s */\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  /** i32.div_u */\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  /** i32.rem_s */\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  /** i32.rem_u */\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  /** i32.and */\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  /** i32.or */\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  /** i32.xor */\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  /** i32.shl */\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  /** i32.shr_s */\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  /** i32.shr_u */\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  /** i32.rotl */\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  /** i32.rotr */\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  /** i32.eq */\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  /** i32.ne */\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  /** i32.lt_s */\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  /** i32.lt_u */\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  /** i32.le_s */\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  /** i32.le_u */\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  /** i32.gt_s */\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  /** i32.gt_u */\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  /** i32.ge_s */\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  /** i32.ge_u */\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  /** i64.add */\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  /** i64.sub */\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  /** i64.mul */\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  /** i64.div_s */\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  /** i64.div_u */\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  /** i64.rem_s */\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  /** i64.rem_u */\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  /** i64.and */\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  /** i64.or */\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  /** i64.xor */\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  /** i64.shl */\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  /** i64.shr_s */\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  /** i64.shr_u */\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  /** i64.rotl */\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  /** i64.rotr */\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  /** i64.eq */\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  /** i64.ne */\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  /** i64.lt_s */\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  /** i64.lt_u */\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  /** i64.le_s */\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  /** i64.le_u */\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  /** i64.gt_s */\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  /** i64.gt_u */\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  /** i64.ge_s */\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  /** i64.ge_u */\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  /** f32.add */\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  /** f32.sub */\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  /** f32.mul */\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  /** f32.div */\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  /** f32.copysign */\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  /** f32.min */\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  /** f32.max */\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  /** f32.eq */\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  /** f32.ne */\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  /** f32.lt */\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  /** f32.le */\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  /** f32.gt */\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  /** f32.ge */\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  /** f64.add */\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  /** f64.sub */\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  /** f64.mul */\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  /** f64.div */\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  /** f64.copysign */\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  /** f64.min */\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  /** f64.max */\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  /** f64.eq */\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  /** f64.ne */\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  /** f64.lt */\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  /** f64.le */\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  /** f64.gt */\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  /** f64.ge */\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.eq */\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  /** i8x16.he */\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  /** i8x16.lt_s */\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  /** i8x16.lt_u */\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  /** i8x16.gt_s */\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  /** i8x16.gt_u */\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  /** i8x16.le_s */\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  /** i8x16.le_u */\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  /** i8x16.ge_s */\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  /** i8x16.ge_u */\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  /** i16x8.eq */\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  /** i16x8.ne */\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  /** i16x8.lt_s */\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  /** i16x8.lt_u */\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  /** i16x8.gt_s */\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  /** i16x8.gt_u */\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  /** i16x8.le_s */\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  /** i16x8.le_u */\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  /** i16x8.ge_s */\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  /** i16x8.ge_u */\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  /** i32x4.eq */\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  /** i32x4.ne */\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  /** i32x4.lt_s */\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  /** i32x4.lt_u */\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  /** i32x4.gt_s */\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  /** i32x4.gt_u */\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  /** i32x4.le_s */\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  /** i32x4.le_u */\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  /** i32x4.ge_s */\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  /** i32x4.ge_u */\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  /** i64x2.eq */\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\n  /** i64x2.ne */\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\n  /** i64x2.lt_s */\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\n  /** i64x2.gt_s */\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\n  /** i64x2.le_s */\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\n  /** i64x2.ge_s */\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\n  /** f32x4.eq */\n  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,\n  /** f32x4.ne */\n  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,\n  /** f32x4.lt */\n  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,\n  /** f32x4.gt */\n  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,\n  /** f32x4.le */\n  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,\n  /** f32x4.ge */\n  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,\n  /** f64x2.eq */\n  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,\n  /** f64x2.ne */\n  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,\n  /** f64x2.lt */\n  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,\n  /** f64x2.gt */\n  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,\n  /** f64x2.le */\n  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,\n  /** f64x2.ge */\n  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,\n  /** v128.and */\n  AndV128 = 124 /* _BinaryenAndVec128 */,\n  /** v128.or */\n  OrV128 = 125 /* _BinaryenOrVec128 */,\n  /** v128.xor */\n  XorV128 = 126 /* _BinaryenXorVec128 */,\n  /** v128.andnot */\n  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,\n  /** i8x16.add */\n  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,\n  /** i8x16.add_sat_s */\n  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,\n  /** i8x16.add_sat_u */\n  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,\n  /** i8x16.sub */\n  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,\n  /** i8x16.sub_sat_s */\n  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,\n  /** i8x16.sub_sat_u */\n  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,\n  /** i8x16.min_s */\n  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,\n  /** i8x16.min_u */\n  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,\n  /** i8x16.max_s */\n  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,\n  /** i8x16.max_u */\n  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,\n  /** i8x16.avgr_u */\n  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,\n  /** i16x8.add */\n  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,\n  /** i16x8.add_sat_s */\n  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,\n  /** i16x8.add_sat_u */\n  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,\n  /** i16x8.sub */\n  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,\n  /** i16x8.sub_sat_s */\n  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,\n  /** i16x8.sub_sat_u */\n  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,\n  /** i16x8.mul */\n  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,\n  /** i16x8.min_s */\n  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,\n  /** i16x8.min_u */\n  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,\n  /** i16x8.max_s */\n  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,\n  /** i16x8.max_u */\n  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,\n  /** i16x8.avgr_u */\n  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,\n  /** i16x8.q15mulr_sat_s */\n  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_s */\n  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_s */\n  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_u */\n  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_u */\n  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,\n  /** i32x4.add */\n  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,\n  /** i32x4.sub */\n  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,\n  /** i32x4.mul */\n  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,\n  /** i32x4.min_s */\n  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,\n  /** i32x4.min_u */\n  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,\n  /** i32x4.max_s */\n  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,\n  /** i32x4.max_u */\n  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,\n  /** i32x4.dot_i16x8_s */\n  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_s */\n  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_s */\n  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_u */\n  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_u */\n  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,\n  /** i64x2.add */\n  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,\n  /** i64x2.sub */\n  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,\n  /** i64x2.mul */\n  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_s */\n  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_s */\n  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_u */\n  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_u */\n  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,\n  /** f32x4.add */\n  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,\n  /** f32x4.sub */\n  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,\n  /** f32x4.mul */\n  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,\n  /** f32x4.div */\n  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,\n  /** f32x4.min */\n  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,\n  /** f32x4.max */\n  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,\n  /** f32x4.pmin */\n  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,\n  /** f32x4.pmax */\n  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,\n  /** f64x2.add */\n  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,\n  /** f64x2.sub */\n  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,\n  /** f64x2.mul */\n  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,\n  /** f64x2.div */\n  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,\n  /** f64x2.min */\n  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,\n  /** f64x2.max */\n  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,\n  /** f64x2.pmin */\n  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,\n  /** f64x2.pmax */\n  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,\n  /** i8x16.narrow_i16x8_s */\n  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  /** i8x16.narrow_i16x8_u */\n  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  /** i16x8.narrow_i32x4_s */\n  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  /** i16x8.narrow_i32x4_u */\n  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  /** i8x16.swizzle */\n  SwizzleI8x16 = 195 /* _BinaryenSwizzleVecI8x16 */,\n\n  // see: https://github.com/WebAssembly/relaxed-simd\n\n  /** i8x16.relaxed_swizzle */\n  RelaxedSwizzleI8x16 = 196 /* TODO_BinaryenRelaxedSwizzleVecI8x16 */,\n  /** f32x4.relaxed_min */\n  RelaxedMinF32x4 = 197 /* TODO_BinaryenRelaxedMinVecF32x4 */,\n  /** f32x4.relaxed_max */\n  RelaxedMaxF32x4 = 198 /* TODO_BinaryenRelaxedMaxVecF32x4 */,\n  /** f64x2.relaxed_min */\n  RelaxedMinF64x2 = 199 /* TODO_BinaryenRelaxedMinVecF64x2 */,\n  /** f64x2.relaxed_max */\n  RelaxedMaxF64x2 = 200 /* TODO_BinaryenRelaxedMaxVecF64x2 */,\n  /** i16x8.relaxed_q15mulr_s */\n  RelaxedQ15MulrI16x8 = 201 /* TODO_BinaryenRelaxedQ15MulrSVecI16x8 */,\n  /** i16x8.relaxed_dot_i8x16_i7x16_s */\n  RelaxedDotI8x16I7x16ToI16x8 = 202 /* TODO_BinaryenDotI8x16I7x16SToVecI16x8 */,\n\n  _last = RelaxedDotI8x16I7x16ToI16x8,\n\n  // Target dependent\n\n  /** i32.add or i64.add, depending on target word size */\n  AddSize,\n  /** i32.sub or i64.sub, depending on target word size */\n  SubSize,\n  /** i32.mul or i64.mul, depending on target word size */\n  MulSize,\n  /** i32.div_s or i64.div_s, depending on target word size */\n  DivISize,\n  /** i32.div_u or i64.div_u, depending on target word size */\n  DivUSize,\n  /** i32.rem_s or i64.rem_s, depending on target word size */\n  RemISize,\n  /** i32.rem_u or i64.rem_u, depending on target word size */\n  RemUSize,\n  /** i32.and or i64.and, depending on target word size */\n  AndSize,\n  /** i32.or or i64.or, depending on target word size */\n  OrSize,\n  /** i32.xor or i64.xor, depending on target word size */\n  XorSize,\n  /** i32.shl or i64.shl, depending on target word size */\n  ShlSize,\n  /** i32.shr_s or i64.shr_s, depending on target word size */\n  ShrISize,\n  /** i32.shr_u or i64.shr_u, depending on target word size */\n  ShrUSize,\n  /** i32.rotl or i64.rotl, depending on target word size */\n  RotlSize,\n  /** i32.rotr or i64.rotr, depending on target word size */\n  RotrSize,\n  /** i32.eq or i64.eq, depending on target word size */\n  EqSize,\n  /** i32.ne or i64.ne, depending on target word size */\n  NeSize,\n  /** i32.lt_s or i64.lt_s, depending on target word size */\n  LtISize,\n  /** i32.lt_u or i64.lt_u, depending on target word size */\n  LtUSize,\n  /** i32.le_s or i64.le_s, depending on target word size */\n  LeISize,\n  /** i32.le_u or i64.le_u, depending on target word size */\n  LeUSize,\n  /** i32.gt_s or i64.gt_s, depending on target word size */\n  GtISize,\n  /** i32.gt_u or i64.gt_u, depending on target word size */\n  GtUSize,\n  /** i32.ge_s or i64.ge_s, depending on target word size */\n  GeISize,\n  /** i32.ge_u or i64.ge_u, depending on target word size */\n  GeUSize\n}\n\n/** Binaryen atomic read-modify-write operation constants. */\nexport const enum AtomicRMWOp {\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\n/** Binaryen SIMD extract operation constants. */\nexport const enum SIMDExtractOp {\n  /** i8x16.extract_lane_s */\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  /** i8x16.extract_lane_u */\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  /** i16x8.extract_lane_s */\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  /** i16x8.extract_lane_u */\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  /** i32x4.extract_lane_s */\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  /** i32x4.extract_lane_u */\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  /** i64x2.extract_lane_s */\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  /** i64x2.extract_lane_u */\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\n/** Binaryen SIMD replace operation constants. */\nexport const enum SIMDReplaceOp {\n  /** i8x16.replace_lane */\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  /** i16x8.replace_lane */\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  /** i32x4.replace_lane */\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  /** i64x2.replace_lane */\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  /** f32x4.replace_lane */\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  /** f64x2.replace_lane */\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\n/** Binaryen SIMD shift operation constants. */\nexport const enum SIMDShiftOp {\n  /** i8x16.shl */\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  /** i8x16.shr_s */\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  /** i8x16.shr_u */\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  /** i16x8.shl */\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  /** i16x8.shr_s */\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  /** i16x8.shr_u */\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  /** i16x8.shl */\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  /** i32x4.shr_s */\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  /** i32x4.shr_u */\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  /** i64x2.shl */\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\n/** Binaryen SIMD load operation constants. */\nexport const enum SIMDLoadOp {\n  /** v128.load8_splat */\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\n  /** v128.load16_splat */\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\n  /** v128.load32_splat */\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\n  /** v128.load64_splat */\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\n  /** v128.load8x8_s */\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\n  /** v128.load8x8_u */\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\n  /** v128.load16x4_s */\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\n  /** v128.load16x4_u */\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\n  /** v128.load32x2_s */\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\n  /** v128.load32x2_u */\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\n  /** v128.load32_zero */\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\n  /** v128.load64_zero */\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\n}\n\n/** Binaryen SIMD load/store lane operation constants. */\nexport const enum SIMDLoadStoreLaneOp {\n  /** v128.load8_lane */\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\n  /** v128.load16_lane */\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\n  /** v128.load32_lane */\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\n  /** v128.load64_lane */\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\n  /** v128.store8_lane */\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\n  /** v128.store16_lane */\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\n  /** v128.store32_lane */\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\n  /** v128.store64_lane */\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\n}\n\n/** Binaryen SIMD ternary operation constants. */\nexport const enum SIMDTernaryOp {\n  /** v128.bitselect */\n  Bitselect = 0 /* _BinaryenBitselectVec128 */,\n\n  // see: https://github.com/WebAssembly/relaxed-simd\n\n  /** f32x4.relaxed_madd */\n  RelaxedMaddF32x4 = 1 /* TODO_BinaryenRelaxedFmaVecF32x4 */,\n  /** f32x4.relaxed_nmadd */\n  RelaxedNmaddF32x4 = 2 /* TODO_BinaryenRelaxedFmsVecF32x4 */,\n  /** f64x2.relaxed_madd */\n  RelaxedMaddF64x2 = 3 /* TODO_BinaryenRelaxedFmaVecF64x2 */,\n  /** f64x2.relaxed_nmadd */\n  RelaxedNmaddF64x2 = 4 /* TODO_BinaryenRelaxedFmsVecF64x2 */,\n  /** i8x16.relaxed_laneselect */\n  RelaxedLaneselectI8x16 = 5 /* TODO_BinaryenLaneselectI8x16 */,\n  /** i16x8.relaxed_laneselect */\n  RelaxedLaneselectI16x8 = 6 /* TODO_BinaryenLaneselectI16x8 */,\n  /** i32x4.relaxed_laneselect */\n  RelaxedLaneselectI32x4 = 7 /* TODO_BinaryenLaneselectI32x4 */,\n  /** i64x2.relaxed_laneselect */\n  RelaxedLaneselectI64x2 = 8 /* TODO_BinaryenLaneselectI64x2 */,\n  /** i32x4.relaxed_dot_i8x16_i7x16_add_s */\n  RelaxedDotI8x16I7x16AddToI32x4 = 9 /* TODO_BinaryenDotI8x16I7x16AddSToVecI32x4 */,\n}\n\n/** Binaryen RefAs operation constants. */\nexport const enum RefAsOp {\n  /** ref.as_non_null */\n  NonNull = 0 /* _BinaryenRefAsNonNull */,\n  /** extern.internalize */\n  ExternInternalize = 1 /* _BinaryenRefAsExternInternalize */,\n  /** extern.externalize */\n  ExternExternalize = 2 /* _BinaryenRefAsExternExternalize */\n}\n\n/** Binaryen BrOn operation constants. */\nexport const enum BrOnOp {\n  /** br_on_null */\n  Null = 0 /* _BinaryenBrOnNull */,\n  /** br_on_non_null */\n  NonNull = 1 /* _BinaryenBrOnNonNull */,\n  /** br_on_cast */\n  Cast = 2 /* _BinaryenBrOnCast */,\n  /** br_on_cast_fail */\n  CastFail = 3 /* _BinaryenBrOnCastFail */\n}\n\n/** Binaryen StringNew operation constants. */\nexport const enum StringNewOp {\n  /** string.new_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringNewUTF8 */,\n  /** string.new_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringNewWTF8 */,\n  /** string.new_wtf8 replace */\n  Replace = 2 /* _BinaryenStringNewReplace */,\n  /** string.new_wtf16 */\n  WTF16 = 3 /* _BinaryenStringNewWTF16 */,\n  /** string.new_wtf8_array utf8 */\n  UTF8Array = 4 /* _BinaryenStringNewUTF8Array */,\n  /** string.new_wtf8_array wtf8 */\n  WTF8Array = 5 /* _BinaryenStringNewWTF8Array */,\n  /** string.new_wtf8_array replace */\n  ReplaceArray = 6 /* _BinaryenStringNewReplaceArray */,\n  /** string.new_wtf16_array */\n  WTF16Array = 7 /* _BinaryenStringNewWTF16Array */,\n  /** string.from_code_point */\n  FromCodePoint = 8 /* _BinaryenStringNewFromCodePoint */\n}\n\n/** Binaryen StringMeasure operation constants. */\nexport const enum StringMeasureOp {\n  /** string.measure_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringMeasureUTF8 */,\n  /** string.measure_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringMeasureWTF8 */,\n  /** string.measure_wtf16 */\n  WTF16 = 2 /* _BinaryenStringMeasureWTF16 */,\n  /** string.is_usv_sequence */\n  IsUSV = 3 /* _BinaryenStringMeasureIsUSV */,\n  /** stringview_wtf16.length */\n  WTF16View = 4 /* _BinaryenStringMeasureWTF16View */\n}\n\n/** Binaryen StringEncode operation constants. */\nexport const enum StringEncodeOp {\n  /** string.encode_wtf8 utf8 */\n  UTF8 = 0 /* _BinaryenStringEncodeUTF8 */,\n  /** string.encode_wtf8 wtf8 */\n  WTF8 = 1 /* _BinaryenStringEncodeWTF8 */,\n  /** string.encode_wtf16 */\n  WTF16 = 2 /* _BinaryenStringEncodeWTF16 */,\n  /** string.encode_wtf8_array utf8 */\n  UTF8Array = 3 /* _BinaryenStringEncodeUTF8Array */,\n  /** string.encode_wtf8_array wtf8 */\n  WTF8Array = 4 /* _BinaryenStringEncodeWTF8Array */,\n  /** string.encode_wtf16_array */\n  WTF16Array = 5 /* _BinaryenStringEncodeWTF16Array */\n}\n\n/** Binaryen StringEq operation constants. */\nexport const enum StringEqOp {\n  /** string.eq */\n  Equal = 0 /* _BinaryenStringEqEqual */,\n  /** string.compare */\n  Compare = 1 /* _BinaryenStringEqCompare */\n}\n\n/** Binaryen StringAs operation constants. */\nexport const enum StringAsOp {\n  /** string.as_wtf8 */\n  WTF8 = 0 /* _BinaryenStringAsWTF8 */,\n  /** string.as_wtf16 */\n  WTF16 = 1 /* _BinaryenStringAsWTF16 */,\n  /** string.as_iter */\n  Iter = 2 /* _BinaryenStringAsIter */\n}\n\n/** Binaryen StringIterMove operation constants. */\nexport const enum StringIterMoveOp {\n  /** stringview_iter.advance */\n  Advance = 0 /* _BinaryenStringIterMoveAdvance */,\n  /** stringview_iter.rewind */\n  Rewind = 1 /* _BinaryenStringIterMoveRewind */\n}\n\n/** Binaryen StringSlice operation constants. */\nexport const enum StringSliceWTFOp {\n  /** stringview_wtf8.slice */\n  WTF8 = 0 /* _BinaryenStringSliceWTF8 */,\n  /** stringview_wtf16.slice */\n  WTF16 = 1 /* _BinaryenStringSliceWTF16 */\n}\n\n/** Binaryen expression runner flags. */\nexport const enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef,\n    /** Whether a shadow stack is used. */\n    public useShadowStack: bool,\n    /** Architecture-dependent size type. */\n    public sizeType: TypeRef\n  ) {\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n    binaryen._BinaryenSetTypeSystem(TypeSystem.Nominal);\n  }\n\n  private lit: usize;\n\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\n  }\n\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\n    let cArr = allocU8Array(buffer);\n    let module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  // isize<T>(value: T): ExpressionRef {\n  //   if (i64_is(value)) {\n  //     if (this.sizeType == TypeRef.I64) {\n  //       return this.i64(i64_low(value), i64_high(value));\n  //     }\n  //     assert(i64_is_i32(value));\n  //     return this.i32(i64_low(value));\n  //   }\n  //   return this.sizeType == TypeRef.I64\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\n  //     : this.i32(i32(value));\n  // }\n\n  usize<T>(value: T): ExpressionRef {\n    if (i64_is(value)) {\n      if (this.sizeType == TypeRef.I64) {\n        return this.i64(i64_low(value), i64_high(value));\n      }\n      assert(i64_is_u32(value));\n      return this.i32(i64_low(value));\n    }\n    return this.sizeType == TypeRef.I64\n      ? this.i64(i32(value))\n      : this.i32(i32(value));\n  }\n\n  f32(value: f32): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    let out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    let out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, unchecked(bytes[i]));\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: TypeRef): ExpressionRef {\n    // TODO: Provide the desired bottom type directly? Currently, Binaryen does\n    // this under the hood, but this API could change to take a heap type.\n    // type = binaryen._BinaryenTypeFromHeapType(\n    //   binaryen._BinaryenHeapTypeGetBottom(\n    //     binaryen._BinaryenTypeGetHeapType(type)\n    //   ),\n    //   true\n    // );\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenRefEq(this.ref, left, right);\n  }\n\n  string_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenStringEq(this.ref, StringEqOp.Equal, left, right);\n  }\n\n  string_compare(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenStringEq(this.ref, StringEqOp.Compare, left, right);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    value: ExpressionRef\n  ): ExpressionRef {\n    if (op > UnaryOp._last) {\n      let isWam64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case UnaryOp.ClzSize:    op = isWam64 ? UnaryOp.ClzI64    : UnaryOp.ClzI32; break;\n        case UnaryOp.CtzSize:    op = isWam64 ? UnaryOp.CtzI64    : UnaryOp.CtzI32; break;\n        case UnaryOp.PopcntSize: op = isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32; break;\n        case UnaryOp.EqzSize:    op = isWam64 ? UnaryOp.EqzI64    : UnaryOp.EqzI32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenUnary(this.ref, op, value);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    if (op > BinaryOp._last) {\n      let isWasm64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case BinaryOp.AddSize:  op = isWasm64 ? BinaryOp.AddI64  : BinaryOp.AddI32; break;\n        case BinaryOp.SubSize:  op = isWasm64 ? BinaryOp.SubI64  : BinaryOp.SubI32; break;\n        case BinaryOp.MulSize:  op = isWasm64 ? BinaryOp.MulI64  : BinaryOp.MulI32; break;\n        case BinaryOp.DivISize: op = isWasm64 ? BinaryOp.DivI64  : BinaryOp.DivI32; break;\n        case BinaryOp.DivUSize: op = isWasm64 ? BinaryOp.DivU64  : BinaryOp.DivU32; break;\n        case BinaryOp.RemISize: op = isWasm64 ? BinaryOp.RemI64  : BinaryOp.RemI32; break;\n        case BinaryOp.RemUSize: op = isWasm64 ? BinaryOp.RemU64  : BinaryOp.RemU32; break;\n        case BinaryOp.AndSize:  op = isWasm64 ? BinaryOp.AndI64  : BinaryOp.AndI32; break;\n        case BinaryOp.OrSize:   op = isWasm64 ? BinaryOp.OrI64   : BinaryOp.OrI32; break;\n        case BinaryOp.XorSize:  op = isWasm64 ? BinaryOp.XorI64  : BinaryOp.XorI32; break;\n        case BinaryOp.ShlSize:  op = isWasm64 ? BinaryOp.ShlI64  : BinaryOp.ShlI32; break;\n        case BinaryOp.ShrISize: op = isWasm64 ? BinaryOp.ShrI64  : BinaryOp.ShrI32; break;\n        case BinaryOp.ShrUSize: op = isWasm64 ? BinaryOp.ShrU64  : BinaryOp.ShrU32; break;\n        case BinaryOp.RotlSize: op = isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32; break;\n        case BinaryOp.RotrSize: op = isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32; break;\n        case BinaryOp.EqSize:   op = isWasm64 ? BinaryOp.EqI64   : BinaryOp.EqI32; break;\n        case BinaryOp.NeSize:   op = isWasm64 ? BinaryOp.NeI64   : BinaryOp.NeI32; break;\n        case BinaryOp.LtISize:  op = isWasm64 ? BinaryOp.LtI64   : BinaryOp.LtI32; break;\n        case BinaryOp.LtUSize:  op = isWasm64 ? BinaryOp.LtU64   : BinaryOp.LtU32; break;\n        case BinaryOp.LeISize:  op = isWasm64 ? BinaryOp.LeI64   : BinaryOp.LeI32; break;\n        case BinaryOp.LeUSize:  op = isWasm64 ? BinaryOp.LeU64   : BinaryOp.LeU32; break;\n        case BinaryOp.GtISize:  op = isWasm64 ? BinaryOp.GtI64   : BinaryOp.GtI32; break;\n        case BinaryOp.GtUSize:  op = isWasm64 ? BinaryOp.GtU64   : BinaryOp.GtU32; break;\n        case BinaryOp.GeISize:  op = isWasm64 ? BinaryOp.GeI64   : BinaryOp.GeI32; break;\n        case BinaryOp.GeUSize:  op = isWasm64 ? BinaryOp.GeU64   : BinaryOp.GeU32; break;\n        default: assert(false);\n      }\n    }\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemorySize(this.ref, cStr, is64);\n  }\n\n  memory_grow(delta: ExpressionRef, name: string = CommonNames.DefaultMemory, is64: bool = false): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryGrow(this.ref, delta, cStr, is64);\n  }\n\n  table_size(name: string): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSize(this.ref, cStr);\n  }\n\n  table_grow(name: string, delta: ExpressionRef, value: ExpressionRef = 0): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGrow(this.ref, cStr, value, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  tostack(value: ExpressionRef): ExpressionRef {\n    if (this.useShadowStack) {\n      let type = binaryen._BinaryenExpressionGetType(value);\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\n      return this.call(BuiltinNames.tostack, [ value ], type);\n    }\n    return value;\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    isManaged: bool,\n    type: TypeRef = -1,\n  ): ExpressionRef {\n    if (type == -1) type = binaryen._BinaryenExpressionGetType(value);\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  table_get(\n    name: string,\n    index: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGet(this.ref, cStr, index, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr, cStr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes, // naturally aligned by default\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type, cStr);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr, cStr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type, cStr);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type, cStr);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: TypeRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType, cStr);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount, cStr);\n  }\n\n  atomic_fence(name: string | null = null): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAtomicFence(this.ref, cStr);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef,\n    isManaged: bool\n  ): ExpressionRef {\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  table_set(\n    name: string,\n    index: ExpressionRef,\n    value: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSet(this.ref, cStr, index, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    let cArr = allocPtrArray(children);\n    let ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    let length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      if (singleType != TypeRef.Unreachable && singleType != type) {\n        // can happen when there was a diagnostic prior\n        return this.unreachable();\n      }\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  /** Drops an expression if it evaluates to a value. */\n  maybeDrop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    let type = binaryen._BinaryenExpressionGetType(expression);\n    if (type != TypeRef.None && type != TypeRef.Unreachable) {\n      return binaryen._BinaryenDrop(this.ref, expression);\n    }\n    return expression;\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition, this.ref) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    let numNames = names.length;\n    let strs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(strs[i] = this.allocStringCached(names[i]));\n    }\n    let cArr = allocPtrArray(strs);\n    let cStr = this.allocStringCached(defaultName);\n    let ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tableName != null\n      ? tableName\n      : CommonNames.DefaultTable\n    );\n    let cArr = allocPtrArray(operands);\n    let ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef\n  ): ExpressionRef {\n    return this.call_indirect(tableName, index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef,\n    destName: string = CommonNames.DefaultMemory,\n    sourceName: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr1 = this.allocStringCached(destName);\n    let cStr2 = this.allocStringCached(sourceName);\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size, cStr1, cStr2);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size, cStr);\n  }\n\n  // exception handling\n\n  try(\n    name: string | null,\n    body: ExpressionRef,\n    catchTags: string[],\n    catchBodies: ExpressionRef[],\n    delegateTarget: string | null = null\n  ): ExpressionRef {\n    let numCatchTags = catchTags.length;\n    let strs = new Array<TagRef>(numCatchTags);\n    for (let i = 0; i < numCatchTags; ++i) {\n      strs[i] = this.allocStringCached(catchTags[i]);\n    }\n    let cArr1 = allocPtrArray(strs);\n    let cArr2 = allocPtrArray(catchBodies);\n    let cStr1 = this.allocStringCached(name);\n    let cStr2 = this.allocStringCached(delegateTarget);\n    let ret = binaryen._BinaryenTry(\n      this.ref, cStr1, body, cArr1, numCatchTags, cArr2, catchBodies.length, cStr2\n    );\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    return ret;\n  }\n\n  throw(\n    tagName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(tagName);\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    target: string\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(target);\n    return binaryen._BinaryenRethrow(this.ref, cStr);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    let cArr = allocPtrArray(operands);\n    let ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    let cArr = allocU8Array(mask);\n    let ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr, cStr);\n  }\n\n  simd_loadstorelane(\n    op: SIMDLoadStoreLaneOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    index: u8,\n    vec: ExpressionRef,\n    name: string = CommonNames.DefaultMemory\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec, cStr);\n  }\n\n  // reference types / gc\n\n  ref_is_null(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIsNull(this.ref, expr);\n  }\n\n  ref_as(\n    op: RefAsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\n  }\n\n  ref_as_nonnull(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    if (isNullableType(getExpressionType(expr))) {\n      return binaryen._BinaryenRefAs(this.ref, RefAsOp.NonNull, expr);\n    } else {\n      return expr;\n    }\n  }\n\n  ref_func(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr, type);\n  }\n\n  i31_new(\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenI31New(this.ref, value);\n  }\n\n  i31_get(\n    expr: ExpressionRef,\n    signed: bool\n  ): ExpressionRef {\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: TypeRef,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): bool {\n    let cStr = this.allocStringCached(name);\n    if (!binaryen._BinaryenGetGlobal(this.ref, cStr)) return false;\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n    return true;\n  }\n\n  // tags\n\n  addTag(\n    name: string,\n    params: TypeRef,\n    results: TypeRef\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\n  }\n\n  getTag(\n    name: string\n  ): TagRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetTag(this.ref, cStr);\n  }\n\n  removeTag(\n    name: string\n  ): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: TypeRef,\n    results: TypeRef,\n    varTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocPtrArray(varTypes);\n    let ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  setLocalName(funcRef: FunctionRef, index: u32, name: string): void {\n    binaryen._BinaryenFunctionSetLocalName(funcRef, index, this.allocStringCached(name));\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    let cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  hasFunction(name: string): bool {\n    let cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: TypeRef,\n    paramTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    let cArr = allocPtrArray(paramTypes);\n    let ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    let tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addTagExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    let cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  hasExport(externalName: string): bool {\n    let cStr = this.allocStringCached(externalName);\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: TypeRef,\n    mutable: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addTagImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    let cStr1 = this.allocStringCached(internalName);\n    let cStr2 = this.allocStringCached(externalModuleName);\n    let cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTagImport(\n      this.ref, cStr1, cStr2, cStr3, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    name: string = CommonNames.DefaultMemory,\n    shared: bool = false\n  ): void {\n    let cStr1 = this.allocStringCached(exportName);\n    let cStr2 = this.allocStringCached(name);\n    let k = segments.length;\n    let segs = new Array<usize>(k);\n    let psvs = new Uint8Array(k);\n    let offs = new Array<ExpressionRef>(k);\n    let sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = unchecked(segments[i]);\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      unchecked(segs[i] = allocU8Array(buffer));\n      unchecked(psvs[i] = 0); // no passive segments currently\n      unchecked(offs[i] = target == Target.Wasm64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset))\n      );\n      unchecked(sizs[i] = buffer.length);\n    }\n    let cArr1 = allocPtrArray(segs);\n    let cArr2 = allocU8Array(psvs);\n    let cArr3 = allocPtrArray(offs);\n    let cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr1, cArr1, cArr2, cArr3, cArr4, k, shared, false, cStr2\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(unchecked(segs[i]));\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  addFunctionTable(\n    name: string,\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let cStr = this.allocStringCached(name);\n    let numNames = funcs.length;\n    let names = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      unchecked(names[i] = this.allocStringCached(funcs[i]));\n    }\n    let cArr = allocPtrArray(names);\n    let tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\n    if (!tableRef) {\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum, TypeRef.Funcref);\n    } else {\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\n    }\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\n    binaryen._free(cArr);\n  }\n\n  /* setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    let numNames = funcs.length;\n    let names = new Array<CString>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    let cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  } */\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    let cStr = this.allocStringCached(name);\n    let cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getZeroFilledMemory(): bool {\n    return binaryen._BinaryenGetZeroFilledMemory();\n  }\n\n  setZeroFilledMemory(on: bool): void {\n    binaryen._BinaryenSetZeroFilledMemory(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    let cStr = this.allocStringCached(key);\n    let ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    let cStr1 = this.allocStringCached(key);\n    let cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    let numNames = passes.length;\n    let cStrs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    let cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(\n    optimizeLevel: i32,\n    shrinkLevel: i32,\n    debugInfo: bool = false,\n    zeroFilledMemory: bool = false\n  ): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setZeroFilledMemory(zeroFilledMemory);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n      if (optimizeLevel >= 2) {\n        passes.push(\"once-reduction\");\n        passes.push(\"inlining\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"local-cse\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"gufa-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"simplify-locals-nostructure\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"vacuum\");\n        passes.push(\"licm\");\n        passes.push(\"merge-locals\");\n        passes.push(\"reorder-locals\");\n      }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n      }\n      passes.push(\"simplify-locals-notee-nostructure\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"local-cse\");\n      }\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 && (this.getFeatures() & FeatureFlags.GC) != 0) {\n        passes.push(\"heap2local\");\n        passes.push(\"merge-locals\");\n        passes.push(\"local-subtyping\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n          passes.push(\"local-cse\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"rse\");\n          passes.push(\"vacuum\");\n          passes.push(\"ssa-nomerge\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"optimize-instructions\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"reorder-globals\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"optimize-instructions\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      if (shrinkLevel >= 2) {\n        passes.push(\"merge-similar-functions\");\n      }\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    assert(\n      binaryen._BinaryenSizeofLiteral() >=\n      binaryen._BinaryenSizeofAllocateAndWriteResult()\n    );\n\n    // now safely reuse lit buffer for BinaryenModuleAllocateAndWriteResult\n    let resPtr = this.lit;\n    let urlPtr = allocString(sourceMapUrl);\n\n    binaryen._BinaryenModuleAllocateAndWrite(resPtr, this.ref, urlPtr);\n\n    // read BinaryenModuleAllocateAndWriteResult struct\n    let binaryPtr = binaryen.__i32_load(resPtr + 0) as usize; // non-nullabe\n    let binaryLen = binaryen.__i32_load(resPtr + 4);\n    let srcMapPtr = binaryen.__i32_load(resPtr + 8) as usize; // nullable\n\n    let binary = new BinaryModule(\n      readBuffer(assert(binaryPtr), binaryLen),\n      readString(srcMapPtr)\n    );\n\n    if (urlPtr) binaryen._free(urlPtr);\n    if (srcMapPtr) binaryen._free(srcMapPtr);\n    binaryen._free(binaryPtr);\n\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    let textPtr = watFormat\n      ? binaryen._BinaryenModuleAllocateAndWriteStackIR(this.ref, true)\n      : binaryen._BinaryenModuleAllocateAndWriteText(this.ref);\n    let text = readString(textPtr);\n    if (textPtr) binaryen._free(textPtr);\n    return text || \"\";\n  }\n\n  private cachedStringsToPointers: Map<string,usize> = new Map();\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\n\n  allocStringCached(str: string | null): usize {\n    if (str == null) return 0;\n    let cached = this.cachedStringsToPointers;\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\n    let ptr = allocString(str);\n    cached.set(str, ptr);\n    return ptr;\n  }\n\n  readStringCached(ptr: usize): string | null {\n    // Binaryen internalizes names, so using this method where it's safe can\n    // avoid quite a bit of unnecessary garbage.\n    if (ptr == 0) return null;\n    let cached = this.cachedPointersToStrings;\n    if (cached.has(ptr)) return changetype<string>(cached.get(ptr));\n    let str = readString(ptr);\n    cached.set(ptr, str);\n    return str;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStringsToPointers.clear();\n    this.cachedPointersToStrings.clear();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  /** Makes a copy of a trivial expression (doesn't contain subexpressions). Returns `0` if non-trivial. */\n  tryCopyTrivialExpression(expr: ExpressionRef): ExpressionRef {\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.LocalGet:\n      case ExpressionId.GlobalGet:\n      case ExpressionId.Const:\n      case ExpressionId.MemorySize:\n      case ExpressionId.Nop:\n      case ExpressionId.Unreachable:\n      case ExpressionId.DataDrop:\n      case ExpressionId.RefNull: return this.copyExpression(expr);\n    }\n    return 0;\n  }\n\n  /** Makes a copy of any expression including all subexpressions. */\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    // TODO: Copy debug location as well (needs Binaryen support)\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    let runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    let precomp = binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      if (!this.isConstExpression(precomp)) return 0;\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  isConstExpression(expr: ExpressionRef): bool {\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Const:\n      case ExpressionId.RefNull:\n      case ExpressionId.RefFunc:\n      case ExpressionId.I31New: return true;\n      case ExpressionId.Binary: {\n        if (this.getFeatures() & FeatureFlags.ExtendedConst) {\n          switch (getBinaryOp(expr)) {\n            case BinaryOp.AddI32:\n            case BinaryOp.SubI32:\n            case BinaryOp.MulI32:\n            case BinaryOp.AddI64:\n            case BinaryOp.SubI64:\n            case BinaryOp.MulI64:\n              return (\n                this.isConstExpression(getBinaryLeft(expr)) &&\n                this.isConstExpression(getBinaryRight(expr))\n              );\n          }\n        }\n        break;\n      }\n    }\n    return false;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    let cStr = allocString(name);\n    let ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: TypeRef[] | null): TypeRef {\n  if (!types) return TypeRef.None;\n  switch (types.length) {\n    case 0: return TypeRef.None;\n    case 1: return types[0];\n  }\n  let cArr = allocPtrArray(types);\n  let ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: TypeRef): TypeRef[] {\n  let arity = binaryen._BinaryenTypeArity(type);\n  let cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  let types = new Array<TypeRef>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    unchecked(types[i] = binaryen.__i32_load(cArr + (<usize>i << 2)));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\nexport function isNullableType(type: TypeRef): bool {\n  return binaryen._BinaryenTypeIsNullable(type);\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function getConstValueV128(expr: ExpressionRef): Uint8Array {\n  let cArr = binaryen._malloc(16);\n  binaryen._BinaryenConstGetValueV128(expr, cArr);\n  let out = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    out[i] = binaryen.__i32_load8_u(cArr + i);\n  }\n  binaryen._free(cArr);\n  return out;\n}\n\nexport function isConstZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) == 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\n  return false;\n}\n\nexport function isConstNonZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) != 0;\n  if (type == TypeRef.I64) return (getConstValueI64Low(expr) | getConstValueI64High(expr)) != 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) != 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) != 0;\n  return false;\n}\n\nexport function isConstNegZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) {\n    let d = getConstValueF32(expr);\n    return d == 0 && f32_as_i32(d) < 0;\n  }\n  if (type == TypeRef.F64) {\n    let d = getConstValueF64(expr);\n    return d == 0 && i64_signbit(f64_as_i64(d));\n  }\n  return false;\n}\n\nexport function isConstNaN(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32) return isNaN(getConstValueF32(expr));\n  if (type == TypeRef.F64) return isNaN(getConstValueF64(expr));\n  return false;\n}\n\nexport function isConstExpressionNaN(module: Module, expr: ExpressionRef): bool {\n  let id = getExpressionId(expr);\n  let type = getExpressionType(expr);\n  if (type == TypeRef.F32 || type == TypeRef.F64) {\n    if (id == ExpressionId.Const) {\n      return isNaN(\n        type == TypeRef.F32\n          ? getConstValueF32(expr)\n          : getConstValueF64(expr)\n      );\n    } else if (id == ExpressionId.GlobalGet) {\n      let precomp = module.runExpression(expr, ExpressionRunnerFlags.Default, 8);\n      if (precomp) {\n        return isNaN(\n          type == TypeRef.F32\n            ? getConstValueF32(precomp)\n            : getConstValueF64(precomp)\n        );\n      }\n    }\n  }\n  return false;\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\n  let count = binaryen._BinaryenFunctionGetNumVars(func);\n  let types = new Array<TypeRef>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    unchecked(types[i] = binaryen._BinaryenFunctionGetVar(func, i));\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): TypeRef {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// tags\n\nexport function getTagName(tag: TagRef): string | null {\n  return readString(binaryen._BinaryenTagGetName(tag));\n}\n\nexport function getTagParams(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetParams(tag);\n}\n\nexport function getTagResults(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetResults(tag);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    let cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    let cases = this.cases;\n    let index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    let cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    let module = this.module;\n    let cases = this.cases;\n    let numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    let values = this.values;\n    let numValues = values.length;\n    let indexes = this.indexes;\n    let entry = new Array<ExpressionRef>(1 + numValues + 1);\n    let labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      unchecked(labels[i] = `case${i}${labelPostfix}`);\n    }\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\n    for (let i = 0; i < numValues; ++i) {\n      let index = unchecked(indexes[i]);\n      unchecked(entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, TypeRef.I32),\n          module.i32(values[i])\n        )\n      ));\n    }\n    let defaultIndex = this.defaultIndex;\n    let defaultLabel = `default${labelPostfix}`;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    let current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(unchecked(labels[i]), block);\n    }\n    let lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport const enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ReadsTable = 256 /* _BinaryenSideEffectReadsTable */,\n  WritesTable = 512 /* _BinaryenSideEffectWritesTable */,\n  ImplicitTrap = 1024 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 2048 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 4096 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 8192 /* _BinaryenSideEffectDanglingPop */,\n  TrapsNeverHappen = 16384 /* _BinaryenSideEffectTrapsNeverHappen */,\n  Any = 32767 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, module);\n}\n\nexport function mustPreserveSideEffects(expr: ExpressionRef, module: ModuleRef): bool {\n  return (getSideEffects(expr, module) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  let len = u8s.length;\n  let ptr = binaryen._malloc(len);\n  for (let i = 0; i < len; ++i) {\n    binaryen.__i32_store8(ptr + i, unchecked(u8s[i]));\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  let len = i32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(i32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  let len = u32s.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = unchecked(u32s[i]);\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nexport function allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.Wasm64);\n  let len = ptrs.length;\n  let ptr = binaryen._malloc(len << 2);\n  let idx = ptr;\n  for (let i = 0, k = len; i < k; ++i) {\n    let val = unchecked(ptrs[i]);\n    binaryen.__i32_store(idx, <i32>val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  let len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let c1 = str.charCodeAt(i) >>> 0;\n    if (c1 <= 0x7F) {\n      len += 1;\n    } else if (c1 <= 0x7FF) {\n      len += 2;\n    } else if (\n      isHighSurrogate(c1) && i + 1 < k &&\n      isLowSurrogate(str.charCodeAt(i + 1))\n    ) {\n      i++;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str == null) return 0;\n  let len = stringLengthUTF8(str);\n  let ptr = binaryen._malloc(len + 1) >>> 0;\n  let idx = ptr;\n  if (len == str.length) {\n    // fast path when all chars are ascii\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let u = str.charCodeAt(i) >>> 0;\n      binaryen.__i32_store8(idx++, u as u8);\n    }\n  } else {\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let c1 = str.charCodeAt(i) >>> 0, c2: i32;\n      if (c1 <= 0x7F) {\n        binaryen.__i32_store8(idx++, c1 as u8);\n      } else if (c1 <= 0x7FF) {\n        binaryen.__i32_store8(idx++, (0xC0 |  (c1 >>> 6)       ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else if (\n        isHighSurrogate(c1) && i + 1 < k &&\n        isLowSurrogate(c2 = str.charCodeAt(i + 1))\n      ) {\n        c1 = combineSurrogates(c1, c2);\n        ++i;\n        binaryen.__i32_store8(idx++, (0xF0 |  (c1 >>> 18)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>> 12) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else {\n        binaryen.__i32_store8(idx++, (0xE0 |  (c1 >>> 12)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      }\n    }\n  }\n  binaryen.__i32_store8(idx, 0); // \\0\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  let ret = new Uint8Array(len);\n  for (let i = 0; i < len; ++i) {\n    unchecked(ret[i] = binaryen.__i32_load8_u(ptr + <usize>i));\n  }\n  return ret;\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  let arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  let cp: u32;\n  let u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(SURROGATE_HIGH | (ch >>> 10));\n      arr.push(SURROGATE_LOW | (ch & 0x3FF));\n    }\n  }\n  // TODO: implement and use String.fromCodePoints\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n// TypeBuilder\n\nconst DEBUG_TYPEBUILDER = false;\n\n/** Ensures that the given potentially complex type has a corresponding GC type. */\nexport function ensureType(type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  // From here on we are dealing with heap types independent of nullability.\n  // Nullability is applied again when returning the final type.\n  let originalType = type;\n  type = type.nonNullableType;\n\n  // Obtain cached type if already built. Guaranteed to be not a temp type.\n  if (typeRef = type.ref) {\n    return binaryen._BinaryenTypeFromHeapType(\n      binaryen._BinaryenTypeGetHeapType(typeRef),\n      originalType.is(TypeFlags.Nullable) // apply nullability\n    );\n  }\n\n  // Otherwise use a type builder\n  if (ASC_TARGET) {\n    // @ts-ignore: Wasm only\n    assert(sizeof<usize>() == 4); // ABI code below assumes 32-bit pointers\n  }\n  assert(binaryen._BinaryenGetTypeSystem() == TypeSystem.Nominal);\n  let builder = binaryen._TypeBuilderCreate(0);\n  let seen = new Map<Type,HeapTypeRef>();\n  prepareType(builder, seen, type); // drop temp return\n  let size = binaryen._TypeBuilderGetSize(builder);\n  let out = binaryen._malloc(max(4 * size, 8)); // either each heap type or index + reason\n  if (!binaryen._TypeBuilderBuildAndDispose(builder, out, out, out + 4)) {\n    let errorIndex = binaryen.__i32_load(out);\n    let errorReason = binaryen.__i32_load(out + 4);\n    binaryen._free(out);\n    throw new Error(`type builder error at index ${errorIndex}: ${TypeBuilderErrorReason.toString(errorReason)}`);\n  }\n\n  // Assign all the built types to their respective non-nullable type\n  for (let _keys = Map_keys(seen), i = 0, k = _keys.length; i < k; ++i) {\n    let seenType = _keys[i];\n    assert(!seenType.is(TypeFlags.Nullable)); // non-nullable only\n    let heapType = <HeapTypeRef>binaryen.__i32_load(out + 4 * i);\n    let fullType = binaryen._BinaryenTypeFromHeapType(heapType, false);\n    assert(!seenType.ref);\n    seenType.ref = fullType;\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` set ${seenType.toString()}`);\n    }\n    let classInstance = seenType.getClass();\n    if (classInstance) {\n      let module = classInstance.program.module;\n      binaryen._BinaryenModuleSetTypeName(module.ref, heapType, module.allocStringCached(classInstance.internalName));\n      let members = classInstance.members;\n      if (members) {\n        let numFieldsInType = binaryen._BinaryenStructTypeGetNumFields(heapType);\n        let numFieldsInClass = 0;\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let member = _values[i];\n          if (member.kind != ElementKind.PropertyPrototype) continue;\n          // only interested in fields (resolved during class finalization)\n          let property = (<PropertyPrototype>member).instance;\n          if (!property || !property.isField) continue;\n          binaryen._BinaryenModuleSetFieldName(module.ref, heapType, numFieldsInClass++, module.allocStringCached(property.name));\n        }\n        assert(numFieldsInType == numFieldsInClass);\n      }\n    }\n  }\n  binaryen._free(out);\n\n  // Initial type should now exist in its non-nullable variant\n  if (DEBUG_TYPEBUILDER) {\n    console.log(` finalize ${type.toString()}`);\n  }\n  typeRef = assert(type.ref);\n  return binaryen._BinaryenTypeFromHeapType(\n    binaryen._BinaryenTypeGetHeapType(typeRef),\n    originalType.is(TypeFlags.Nullable) // apply nullability\n  );\n}\n\n/** Obtains the basic type of the given type, if any. */\nfunction tryEnsureBasicType(type: Type): TypeRef {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8:\n    case TypeKind.I16:\n    case TypeKind.U16:\n    case TypeKind.I32:\n    case TypeKind.U32: return TypeRef.I32;\n    case TypeKind.I64:\n    case TypeKind.U64: return TypeRef.I64;\n    case TypeKind.Isize:\n    case TypeKind.Usize: {\n      if (type.isInternalReference) break; // non-basic\n      return type.size == 64 ? TypeRef.I64 : TypeRef.I32;\n    }\n    case TypeKind.F32: return TypeRef.F32;\n    case TypeKind.F64: return TypeRef.F64;\n    case TypeKind.V128: return TypeRef.V128;\n    case TypeKind.Funcref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Func, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Externref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Extern, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Anyref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Any, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Eqref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Eq, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Structref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Struct, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Arrayref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.Array, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.I31ref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.I31, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Stringref: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.String, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewWTF8: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF8, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewWTF16: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewWTF16, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.StringviewIter: {\n      return binaryen._BinaryenTypeFromHeapType(HeapTypeRef.StringviewIter, type.is(TypeFlags.Nullable));\n    }\n    case TypeKind.Void: assert(false); // invalid here\n  }\n  return 0; // non-basic\n}\n\n/** Determines the packed GC type of the given type, if applicable. */\nfunction determinePackedType(type: Type): PackedType {\n  switch (type.kind) {\n    case TypeKind.Bool:\n    case TypeKind.I8:\n    case TypeKind.U8: return PackedType.I8;\n    case TypeKind.I16:\n    case TypeKind.U16: return PackedType.I16;\n  }\n  return PackedType.NotPacked;\n}\n\n/** Recursively prepares the given GC type, potentially returning a temporary type. */\nfunction prepareType(builder: binaryen.TypeBuilderRef, seen: Map<Type,HeapTypeRef>, type: Type): TypeRef {\n  // Obtain basic type if applicable\n  if (type == Type.void) return TypeRef.None;\n  let typeRef = tryEnsureBasicType(type);\n  if (typeRef) return typeRef;\n\n  assert(!type.is(TypeFlags.Nullable)); // operating on non-nullable types only\n\n  // Reuse existing type\n  if (typeRef = type.ref) return typeRef;\n\n  // Reuse seen temporary type if it exists\n  if (seen.has(type)) {\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` prepare ${type.toString()} (seen)`);\n    }\n    return changetype<HeapTypeRef>(seen.get(type));\n  }\n\n  if (DEBUG_TYPEBUILDER) {\n    console.log(`prepare ${type.toString()}`);\n  }\n\n  // Otherwise construct a new class type. Note that arrays are not supported, as these would\n  // have to involve a Wasm-level `array`, either wrapped in `Array` or `Uint8Array` etc., or\n  // directly representing an `ArrayBuffer` or `StaticArray`. TBD.\n  let classReference = type.getClass();\n  if (classReference) {\n    // Make sure the base type has been built prior, at a lower index\n    let base = classReference.base;\n    let baseRef: HeapTypeRef = 0;\n    if (base) baseRef = prepareType(builder, seen, base.type); // might be temporary, is non-nullable\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` block [${index}]: ${type.toString()}`);\n    }\n    let heapTypeRef = binaryen._TypeBuilderGetTempHeapType(builder, index);\n    typeRef = binaryen._TypeBuilderGetTempRefType(builder, heapTypeRef, false);\n    seen.set(type, typeRef);\n\n    // Populate the struct type (TODO: names)\n    let fieldTypes = new Array<TypeRef>();\n    let packedTypes = new Array<PackedType>();\n    let fieldMutables = new Array<u32>();\n    let members = classReference.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // only interested in fields (resolved during class finalization)\n        let property = (<PropertyPrototype>member).instance;\n        if (!property || !property.isField) continue;\n        let fieldType = property.type;\n        if (DEBUG_TYPEBUILDER) {\n          console.log(`  field ${fieldType.toString()}`);\n        }\n        if (fieldType.is(TypeFlags.Nullable)) {\n          fieldTypes.push(\n            binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, fieldType.nonNullableType)\n              ),\n              true\n            )\n          );\n        } else {\n          fieldTypes.push(prepareType(builder, seen, fieldType));\n        }\n        packedTypes.push(determinePackedType(fieldType));\n        fieldMutables.push(1);\n      }\n    }\n    let cArrFT = allocPtrArray(fieldTypes);\n    let cArrPT = allocU32Array(packedTypes);\n    let cArrFM = allocU32Array(fieldMutables);\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetStructType(builder, index, cArrFT, cArrPT, cArrFM, fieldTypes.length);\n    if (base) {\n      if (DEBUG_TYPEBUILDER) {\n        console.log(` set super [${index}]: ${type.toString()} <: ${base.type.toString()} ${baseRef == base.type.ref ? \" (known)\" : \"\"}`);\n      }\n      binaryen._TypeBuilderSetSubType(builder, index, binaryen._BinaryenTypeGetHeapType(baseRef));\n    }\n    binaryen._free(cArrFM);\n    binaryen._free(cArrPT);\n    binaryen._free(cArrFT);\n    return typeRef;\n  }\n\n  // Respectively a new signature type\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n\n    // Block this index with a temporary type and cache\n    let index = binaryen._TypeBuilderGetSize(builder);\n    binaryen._TypeBuilderGrow(builder, 1);\n    let tempTypeRef = binaryen._TypeBuilderGetTempRefType(\n      builder,\n      binaryen._TypeBuilderGetTempHeapType(builder, index),\n      false\n    );\n    seen.set(type, tempTypeRef);\n\n    let paramTypes = new Array<TypeRef>();\n    let resultTypes = new Array<TypeRef>();\n    let parameterTypes = signatureReference.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let paramType = parameterTypes[i];\n      if (paramType.is(TypeFlags.Nullable)) {\n        paramTypes.push(\n          binaryen._TypeBuilderGetTempRefType(\n            builder,\n            binaryen._BinaryenTypeGetHeapType(\n              prepareType(builder, seen, paramType.nonNullableType)\n            ),\n            true\n          )\n        );\n      } else {\n        paramTypes.push(prepareType(builder, seen, paramType));\n      }\n    }\n    let returnType = signatureReference.returnType;\n    resultTypes.push(\n      returnType == Type.void\n        ? TypeRef.None\n        : returnType.is(TypeFlags.Nullable)\n          ? binaryen._TypeBuilderGetTempRefType(\n              builder,\n              binaryen._BinaryenTypeGetHeapType(\n                prepareType(builder, seen, returnType.nonNullableType)\n              ),\n              true\n            )\n          : prepareType(builder, seen, returnType)\n    );\n    let tempParamType: TypeRef;\n    if (paramTypes.length > 1) {\n      let cArrPT = allocPtrArray(paramTypes);\n      tempParamType = binaryen._TypeBuilderGetTempTupleType(builder, cArrPT, paramTypes.length);\n      binaryen._free(cArrPT);\n    } else {\n      tempParamType = paramTypes.length ? paramTypes[0] : TypeRef.None;\n    }\n    let tempResultType: TypeRef;\n    if (resultTypes.length > 1) {\n      let cArrRT = allocPtrArray(resultTypes);\n      tempResultType = binaryen._TypeBuilderGetTempTupleType(builder, cArrRT, resultTypes.length);\n      binaryen._free(cArrRT);\n    } else {\n      tempResultType = resultTypes[0];\n    }\n    if (DEBUG_TYPEBUILDER) {\n      console.log(` concretize [${index}]: ${type.toString()}`);\n    }\n    binaryen._TypeBuilderSetSignatureType(builder, index, tempParamType, tempResultType);\n    return tempTypeRef;\n  }\n\n  throw new Error(`unexpected complex type: ${type.toString()}`);\n}\n","/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Range\n} from \"./diagnostics\";\n\nimport {\n  Token\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode\n} from \"./util\";\n\nimport {\n  ExpressionRef\n} from \"./module\";\n\nimport {\n  Type\n} from \"./types\";\n\n/** Indicates the kind of a node. */\nexport const enum NodeKind {\n\n  Source,\n\n  // types\n  NamedType,\n  FunctionType,\n  TypeName,\n  TypeParameter,\n  Parameter,\n\n  // expressions\n  Identifier,\n  Assertion,\n  Binary,\n  Call,\n  Class,\n  Comma,\n  ElementAccess,\n  False,\n  Function,\n  InstanceOf,\n  Literal,\n  New,\n  Null,\n  Omitted,\n  Parenthesized,\n  PropertyAccess,\n  Ternary,\n  Super,\n  This,\n  True,\n  Constructor,\n  UnaryPostfix,\n  UnaryPrefix,\n  Compiled,\n\n  // statements\n  Block,\n  Break,\n  Continue,\n  Do,\n  Empty,\n  Export,\n  ExportDefault,\n  ExportImport,\n  Expression,\n  For,\n  ForOf,\n  If,\n  Import,\n  Return,\n  Switch,\n  Throw,\n  Try,\n  Variable,\n  Void,\n  While,\n  Module,\n\n  // declaration statements\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  // special\n  Decorator,\n  ExportMember,\n  SwitchCase,\n  IndexSignature,\n  Comment\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createTemplateLiteralExpression(\n    tag: Expression | null,\n    parts: string[],\n    rawParts: string[],\n    expressions: Expression[],\n    range: Range\n  ): TemplateLiteralExpression {\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  static createCompiledExpression(\n    expr: ExpressionRef,\n    type: Type,\n    range: Range\n  ): Expression {\n    return new CompiledExpression(expr, type, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    body: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(body, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    body: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, body, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    body: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, body, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    bodyStatements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(bodyStatements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createModuleDeclaration(\n    name: string,\n    flags: CommonFlags,\n    range: Range\n  ): ModuleDeclaration {\n    return new ModuleDeclaration(name, flags, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.Literal\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.Literal) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.Float:\n        case LiteralKind.Integer: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.Literal: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.Float:\n          case LiteralKind.Integer:\n          case LiteralKind.String: return true;\n        }\n        break;\n      }\n      case NodeKind.Null:\n      case NodeKind.True:\n      case NodeKind.False: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.Call) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PropertyAccess) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.This);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.Super);\n  }\n\n  get isEmpty(): bool {\n    return this.kind == NodeKind.Empty;\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Whether this type node is currently in the process of being resolved. */\n  currentlyResolving: bool = false;\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FunctionType) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeName, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamedType, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    let typeArguments = this.typeArguments;\n    return typeArguments != null && typeArguments.length > 0;\n  }\n\n  /** Tests if this type is \"null\". */\n  get isNull(): bool {\n    return this.name.identifier.text == \"null\";\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionType, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeParameter, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport const enum ParameterKind {\n  /** No specific flags. */\n  Default,\n  /** Is an optional parameter. */\n  Optional,\n  /** Is a rest parameter. */\n  Rest\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parameter, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.None;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  Custom,\n  Global,\n  Operator,\n  OperatorBinary,\n  OperatorPrefix,\n  OperatorPostfix,\n  Unmanaged,\n  Final,\n  Inline,\n  External,\n  ExternalJs,\n  Builtin,\n  Lazy,\n  Unsafe\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.Identifier) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.Builtin;\n          break;\n        }\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.External;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.Final;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.Global;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.Inline;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.Lazy;\n          break;\n        }\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.Operator;\n          break;\n        }\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.Unmanaged;\n          if (nameStr == \"unsafe\") return DecoratorKind.Unsafe;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PropertyAccess) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.Identifier) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OperatorBinary;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OperatorPrefix;\n              if (propStr == \"postfix\") return DecoratorKind.OperatorPostfix;\n              break;\n            }\n          }\n        } else if (nameStr == \"external\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.j: {\n              if (propStr == \"js\") return DecoratorKind.ExternalJs;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.Custom;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Decorator, range);\n  }\n}\n\n/** Comment kinds. */\nexport const enum CommentKind {\n  /** Line comment. */\n  Line,\n  /** Triple-slash line comment. */\n  Triple,\n  /** Block comment. */\n  Block\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comment, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Identifier, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport const enum LiteralKind {\n  Float,\n  Integer,\n  String,\n  Template,\n  RegExp,\n  Array,\n  Object\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Literal, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Array, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport const enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  Prefix,\n  /** An as assertion, i.e. `expr as T`. */\n  As,\n  /** A non-null assertion, i.e. `!expr`. */\n  NonNull,\n  /** A const assertion, i.e. `expr as const`. */\n  Const\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Assertion, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Binary, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Call, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.Class, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Comma, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.Constructor;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ElementAccess, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Float, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.Function, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.InstanceOf, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Integer, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.New, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    let typeArguments = this.typeArguments;\n    let numTypeArguments: i32;\n    if (typeArguments && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    let args = this.args;\n    let numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.Null;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Object, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Omitted, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Parenthesized, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PropertyAccess, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.RegExp, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Ternary, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.String, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.Super;\n  }\n}\n\n/** Represents a template literal expression. */\nexport class TemplateLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Tag expression, if any. */\n    public tag: Expression | null,\n    /** String parts. */\n    public parts: string[],\n    /** Raw string parts. */\n    public rawParts: string[],\n    /** Expression parts. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.Template, range);\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.This;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.True;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.False;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPostfix, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UnaryPrefix, operator, operand, range);\n  }\n}\n\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\nexport class CompiledExpression extends Expression {\n  constructor(\n    /** Compiled expression. */\n    public expr: ExpressionRef,\n    /** Type of the compiled expression. */\n    public type: Type,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Compiled, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport const enum SourceKind {\n  /** User-provided file. */\n  User = 0,\n  /** User-provided entry file. */\n  UserEntry = 1,\n  /** Library-provided file. */\n  Library = 2,\n  /** Library-provided entry file. */\n  LibraryEntry = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n\n  /** Gets the special native source. */\n  static get native(): Source {\n    let source = Source._native;\n    if (!source) Source._native = source = new Source(SourceKind.LibraryEntry, LIBRARY_PREFIX + \"native.ts\", \"[native code]\");\n    return source;\n  }\n  private static _native: Source | null = null;\n\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.Source, new Range(0, text.length));\n    let internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    let pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    let kind = this.sourceKind;\n    return kind == SourceKind.Library || kind == SourceKind.LibraryEntry;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    let lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LineFeed) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    let l = 0;\n    let r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n  /** Overridden module name from preceeding `module` statement. */\n  public overriddenModuleName: string | null = null;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IndexSignature, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Block, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Break, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ClassDeclaration, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Continue, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Do, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Empty, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EnumValueDeclaration, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportImport, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportMember, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Export, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ExportDefault, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.Expression, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FieldDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.For, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ForOf, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  None,\n  /** Parenthesized parameter list. */\n  Parenthesized,\n  /** Single parameter without parenthesis. */\n  Single\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FunctionDeclaration, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    let typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.If, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ImportDeclaration, name, null, CommonFlags.None, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Import, range);\n    let normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = mangleInternalPath(normalizedPath);\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.InterfaceDeclaration;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.None, range);\n    this.kind = NodeKind.MethodDeclaration;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NamespaceDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Return, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SwitchCase, range);\n  }\n\n  get isDefault(): bool {\n    return this.label == null;\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Switch, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Throw, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public bodyStatements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Try, range);\n  }\n}\n\n/** Represents a `module` statement. */\nexport class ModuleDeclaration extends Statement {\n  constructor(\n    /** Module name. */\n    public moduleName: string,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Module, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TypeDeclaration, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VariableDeclaration, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Variable, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.Void, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Body statement being looped over. */\n    public body: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.While, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  if (path.endsWith(\"/\")) {\n    path += \"index\";\n  } else if (path.endsWith(\".ts\")) {\n    path = path.substring(0, path.length - 3);\n  }\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NamedType) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next || name.identifier.text.length > 0);\n  }\n  return false;\n}\n","// GENERATED FILE. DO NOT EDIT.\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Transform_0_1 = 109,\n  Start_function_name_0_is_invalid_or_conflicts_with_another_export = 110,\n  Element_0_not_found = 111,\n  Exchange_of_0_values_is_not_supported_by_all_embeddings = 112,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Expression_does_not_compile_to_a_value_at_runtime = 234,\n  Only_variables_functions_and_enums_become_WebAssembly_module_exports = 235,\n  Literal_0_does_not_fit_into_i64_or_u64_types = 236,\n  Index_signature_accessors_in_type_0_differ_in_types = 237,\n  Initializer_definitive_assignment_or_nullable_type_expected = 238,\n  Definitive_assignment_has_no_effect_on_local_variables = 239,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  _NaN_does_not_compare_equal_to_any_other_value_including_itself_Use_isNaN_x_instead = 907,\n  Comparison_with_0_0_is_sign_insensitive_Use_Object_is_x_0_0_if_the_sign_matters = 908,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  _0_modifier_cannot_appear_on_class_elements_of_this_kind = 1031,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Declarations_with_initializers_cannot_also_have_definite_assignment_assertions = 1263,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  A_default_export_can_only_be_used_in_a_module = 1319,\n  An_expression_of_type_0_cannot_be_tested_for_truthiness = 1345,\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Property_0_is_private_in_type_1_but_not_in_type_2 = 2325,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = 2416,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Types_have_separate_declarations_of_a_private_property_0 = 2442,\n  Property_0_is_protected_in_type_1_but_public_in_type_2 = 2444,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  Cannot_redeclare_block_scoped_variable_0 = 2451,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Variable_0_is_used_before_being_assigned = 2454,\n  Type_alias_0_circularly_references_itself = 2456,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property = 2610,\n  _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor = 2611,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  Cannot_extend_a_class_0_Class_constructor_is_marked_as_private = 2675,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0 = 4117,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without = 6234,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 109: return \"Transform '{0}': {1}\";\n    case 110: return \"Start function name '{0}' is invalid or conflicts with another export.\";\n    case 111: return \"Element '{0}' not found.\";\n    case 112: return \"Exchange of '{0}' values is not supported by all embeddings\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 234: return \"Expression does not compile to a value at runtime.\";\n    case 235: return \"Only variables, functions and enums become WebAssembly module exports.\";\n    case 236: return \"Literal '{0}' does not fit into 'i64' or 'u64' types.\";\n    case 237: return \"Index signature accessors in type '{0}' differ in types.\";\n    case 238: return \"Initializer, definitive assignment or nullable type expected.\";\n    case 239: return \"Definitive assignment has no effect on local variables.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 907: return \"'NaN' does not compare equal to any other value including itself. Use isNaN(x) instead.\";\n    case 908: return \"Comparison with -0.0 is sign insensitive. Use Object.is(x, -0.0) if the sign matters.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1031: return \"'{0}' modifier cannot appear on class elements of this kind.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1263: return \"Declarations with initializers cannot also have definite assignment assertions.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 1319: return \"A default export can only be used in a module.\";\n    case 1345: return \"An expression of type '{0}' cannot be tested for truthiness.\";\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2325: return \"Property '{0}' is private in type '{1}' but not in type '{2}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2416: return \"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2442: return \"Types have separate declarations of a private property '{0}'.\";\n    case 2444: return \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2451: return \"Cannot redeclare block-scoped variable '{0}'\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2454: return \"Variable '{0}' is used before being assigned.\";\n    case 2456: return \"Type alias '{0}' circularly references itself.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2610: return \"'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property.\";\n    case 2611: return \"'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2675: return \"Cannot extend a class '{0}'. Class constructor is marked as private.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 4117: return \"This member cannot have an 'override' modifier because it is not declared in the base class '{0}'.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 6234: return \"This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n","/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures,\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression,\n  IdentifierExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  SIMDLoadOp,\n  SIMDLoadStoreLaneOp,\n  TypeRef,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags,\n  mustPreserveSideEffects\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Global,\n  DecoratorFlags,\n  Class,\n  PropertyPrototype,\n  VariableLikeElement\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isVector = \"~lib/builtins/isVector\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const bswap = \"~lib/builtins/bswap\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const eq = \"~lib/builtins/eq\";\n  export const ne = \"~lib/builtins/ne\";\n  export const rem = \"~lib/builtins/rem\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_eq = \"~lib/builtins/i32.eq\";\n  export const i64_eq = \"~lib/builtins/i64.eq\";\n  export const f32_eq = \"~lib/builtins/f32.eq\";\n  export const f64_eq = \"~lib/builtins/f64.eq\";\n  export const i32_ne = \"~lib/builtins/i32.ne\";\n  export const i64_ne = \"~lib/builtins/i64.ne\";\n  export const f32_ne = \"~lib/builtins/f32.ne\";\n  export const f64_ne = \"~lib/builtins/f64.ne\";\n\n  export const i32_rem_s = \"~lib/builtins/i32.rem_s\";\n  export const i32_rem_u = \"~lib/builtins/i32.rem_u\";\n  export const i64_rem_s = \"~lib/builtins/i64.rem_s\";\n  export const i64_rem_u = \"~lib/builtins/i64.rem_u\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const memory_atomic_wait32 = \"~lib/memory/memory.atomic.wait32\";\n  export const memory_atomic_wait64 = \"~lib/memory/memory.atomic.wait64\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\n  export const i16x8_shuffle = \"~lib/builtins/i16x8.shuffle\";\n  export const i16x8_swizzle = \"~lib/builtins/i16x8.swizzle\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\n  export const i32x4_shuffle = \"~lib/builtins/i32x4.shuffle\";\n  export const i32x4_swizzle = \"~lib/builtins/i32x4.swizzle\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\n  export const i64x2_shuffle = \"~lib/builtins/i64x2.shuffle\";\n  export const i64x2_swizzle = \"~lib/builtins/i64x2.swizzle\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\n  export const f32x4_shuffle = \"~lib/builtins/f32x4.shuffle\";\n  export const f32x4_swizzle = \"~lib/builtins/f32x4.swizzle\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\n  export const f64x2_shuffle = \"~lib/builtins/f64x2.shuffle\";\n  export const f64x2_swizzle = \"~lib/builtins/f64x2.swizzle\";\n\n  export const i31_new = \"~lib/builtins/i31.new\";\n  export const i31_get = \"~lib/builtins/i31.get\";\n\n  // internals\n  export const data_end = \"~lib/memory/__data_end\";\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n  export const tostack = \"~lib/rt/__tostack\";\n\n  // std/number.ts\n  export const NaN = \"~lib/number/NaN\";\n  export const Infinity = \"~lib/number/Infinity\";\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n  export const Function_call = \"~lib/function/Function#call\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/string.ts\n  export const String_raw = \"~lib/string/String.raw\";\n  export const String_eq = \"~lib/string/String.__eq\";\n  export const String_ne = \"~lib/string/String.__ne\";\n  export const String_not = \"~lib/string/String.__not\";\n\n  // std/object.ts\n  export const Object = \"~lib/object/Object\";\n}\n\n/** Builtin variable compilation context. */\nexport class BuiltinVariableContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Variable being accessed. */\n    public element: VariableLikeElement,\n    /** Contextual type. */\n    public contextualType: Type = element.type,\n    /** Respective report expression. */\n    public reportNode: IdentifierExpression = element.identifierNode\n  ) {}\n}\n\n/** Builtin function compilation context. */\nexport class BuiltinFunctionContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Builtin functions map. */\nexport const builtinFunctions = new Map<string, (ctx: BuiltinFunctionContext) => ExpressionRef>();\n\n/** Builtin variables map. */\nexport const builtinVariables_onCompile = new Map<string, (ctx: BuiltinVariableContext) => void>();\nexport const builtinVariables_onAccess = new Map<string, (ctx: BuiltinVariableContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// helper global used by checkConstantType\nlet checkConstantType_expr: ExpressionRef = 0;\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isBooleanValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isIntegerValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isSignedIntegerValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFloatValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isVector<T!>() / isVector<T?>(value: T) -> bool\nfunction builtin_isVector(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isVectorValue ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isVector, builtin_isVector);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isReference ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isAssignableTo(compiler.program.stringInstance)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltinFunctions.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.extendsPrototype(compiler.program.arrayPrototype)\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltinFunctions.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  let classReference = type.getClass();\n  return reifyConstantType(ctx,\n    module.i32(\n      classReference && classReference.isArrayLike\n        ? 1\n        : 0\n    )\n  );\n}\nbuiltinFunctions.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isFunction ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isNullableReference ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinFunctionContext): ExpressionRef {\n  // Note that `isDefined` neither compiles nor evaluates the given expression\n  // but exclusively performs a check whether it can be compiled in theory.\n  // This is not exactly unsafe due to only seemingly having side effects which\n  // actually never happen, but may confuse tooling unaware of its semantics.\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.Swallow\n  );\n  return module.i32(element ? 1 : 0);\n}\nbuiltinFunctions.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  if (!mustPreserveSideEffects(expr, module.ref)) {\n    return module.i32(module.isConstExpression(expr) ? 1 : 0);\n  }\n  return module.block(null, [\n    module.maybeDrop(expr),\n    module.i32(0)\n  ], getExpressionType(expr));\n}\nbuiltinFunctions.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.isManaged ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return reifyConstantType(ctx, module.i32(type.kind == TypeKind.Void ? 1 : 0));\n}\nbuiltinFunctions.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return reifyConstantType(ctx, module.i32(signatureReference.parameterTypes.length));\n}\nbuiltinFunctions.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltinFunctions.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  let type = ctx.typeArguments![0];\n  let byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltinFunctions.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let type = ctx.typeArguments![0];\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.String)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let fieldMember = classReference.getMember(fieldName);\n    if (fieldMember && fieldMember.kind == ElementKind.PropertyPrototype) {\n      let property = (<PropertyPrototype>fieldMember).instance;\n      if (property && property.isField) {\n        assert(property.memoryOffset >= 0);\n        return contextualUsize(compiler, i64_new(property.memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltinFunctions.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let resultType = checkConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  let value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return reifyConstantType(ctx, compiler.ensureStaticString(value));\n}\nbuiltinFunctions.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let type = checkConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return reifyConstantType(ctx, module.i32(signatureReference.id));\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference && !classReference.hasDecorator(DecoratorFlags.Unmanaged)) {\n    return reifyConstantType(ctx, module.i32(classReference.id));\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.idof, builtin_idof);\n\n// bswap<T?>(value: T) -> T\nfunction builtin_bswap(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        ctx.operands[0],\n        typeArguments[0].toUnsigned(),\n        Constraints.ConvImplicit | Constraints.MustWrap\n      )\n    : compiler.compileExpression(\n        ctx.operands[0],\n        Type.u32,\n        Constraints.MustWrap\n      );\n\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.U8: return arg0;\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        // <T>(x << 8 | x >> 8)\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped);\n\n        let res = module.binary(\n          BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp.index, arg0, false),\n            module.i32(8)\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp.index, TypeRef.I32),\n            module.i32(8)\n          )\n        );\n        // avoid wrapping for u16 due to it's already done for input arg\n        if (type.kind == TypeKind.I16) {\n          res = compiler.ensureSmallIntegerWrap(res, Type.i16);\n        }\n        return res;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (type.size == 32) {\n          // rotl(x & 0xFF00FF00, 8) | rotr(x & 0x00FF00FF, 8)\n          let flow = compiler.currentFlow;\n          let temp = flow.getTempLocal(type);\n          flow.setLocalFlag(temp.index, LocalFlags.Wrapped);\n\n          let res = module.binary(\n            BinaryOp.OrI32,\n            module.binary(\n              BinaryOp.RotlI32,\n              module.binary(\n                BinaryOp.AndI32,\n                module.local_tee(temp.index, arg0, false),\n                module.i32(0xFF00FF00)\n              ),\n              module.i32(8)\n            ),\n            module.binary(\n              BinaryOp.RotrI32,\n              module.binary(\n                BinaryOp.AndI32,\n                module.local_get(temp.index, TypeRef.I32),\n                module.i32(0x00FF00FF)\n              ),\n              module.i32(8)\n            ),\n          );\n          return res;\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        // let t =\n        //   ((x >>> 8) & 0x00FF00FF00FF00FF) |\n        //   ((x & 0x00FF00FF00FF00FF) << 8)\n        //\n        // let res =\n        //   ((t >>> 16) & 0x0000FFFF0000FFFF) |\n        //   ((t & 0x0000FFFF0000FFFF) << 16)\n        //\n        // rotr(res, 32)\n\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        // t = ((x >>> 8) & 0x00FF00FF00FF00FF) | ((x & 0x00FF00FF00FF00FF) << 8)\n        let expr = module.local_tee(\n          temp2.index,\n          module.binary(\n            BinaryOp.OrI64,\n            module.binary(\n              BinaryOp.AndI64,\n              module.binary(\n                BinaryOp.ShrU64,\n                module.local_tee(temp1.index, arg0, false),\n                module.i64(8)\n              ),\n              module.i64(0x00FF00FF, 0x00FF00FF)\n            ),\n            module.binary(\n              BinaryOp.ShlI64,\n              module.binary(\n                BinaryOp.AndI64,\n                module.local_get(temp1.index, TypeRef.I64),\n                module.i64(0x00FF00FF, 0x00FF00FF)\n              ),\n              module.i64(8)\n            ),\n          ),\n          false\n        );\n\n        // ((t >>> 16) & 0x0000FFFF0000FFFF) | ((t & 0x0000FFFF0000FFFF) << 16)\n        let res = module.binary(\n          BinaryOp.OrI64,\n          module.binary(\n            BinaryOp.AndI64,\n            module.binary(\n              BinaryOp.ShrU64,\n              expr,\n              module.i64(16)\n            ),\n            module.i64(0x0000FFFF, 0x0000FFFF)\n          ),\n          module.binary(\n            BinaryOp.ShlI64,\n            module.binary(\n              BinaryOp.AndI64,\n              module.local_get(temp2.index, TypeRef.I64),\n              module.i64(0x0000FFFF, 0x0000FFFF)\n            ),\n            module.i64(16)\n          ),\n        );\n\n        // rotr(res, 32)\n        res = module.binary(\n          BinaryOp.RotrI64,\n          res,\n          module.i64(32)\n        );\n        return res;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"bswap\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.bswap, builtin_bswap);\n\n// === Math ===================================================================================\n\n// NaN\nfunction builtin_NaN_compile(ctx: BuiltinVariableContext): void {\n  let element = ctx.element;\n  if (element.is(CommonFlags.ModuleExport)) {\n    let module = ctx.compiler.module;\n    module.addGlobal(element.internalName, TypeRef.F64, false, module.f64(NaN));\n  }\n}\nbuiltinVariables_onCompile.set(BuiltinNames.NaN, builtin_NaN_compile);\n\n// NaN -> f32 | f64\nfunction builtin_NaN_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (ctx.contextualType == Type.f32) {\n    compiler.currentType = Type.f32;\n    return module.f32(<f32>NaN);\n  }\n  compiler.currentType = Type.f64;\n  return module.f64(NaN);\n}\nbuiltinVariables_onAccess.set(BuiltinNames.NaN, builtin_NaN_access);\n\n// Infinity\nfunction builtin_Infinity_compile(ctx: BuiltinVariableContext): void {\n  let element = ctx.element;\n  if (element.is(CommonFlags.ModuleExport)) {\n    let module = ctx.compiler.module;\n    module.addGlobal(element.internalName, TypeRef.F64, false, module.f64(Infinity));\n  }\n}\nbuiltinVariables_onCompile.set(BuiltinNames.Infinity, builtin_Infinity_compile);\n\n// Infinity -> f32 | f64\nfunction builtin_Infinity_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (ctx.contextualType == Type.f32) {\n    compiler.currentType = Type.f32;\n    return module.f32(<f32>Infinity);\n  }\n  compiler.currentType = Type.f64;\n  return module.f64(Infinity);\n}\nbuiltinVariables_onAccess.set(BuiltinNames.Infinity, builtin_Infinity_access);\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.ClzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.CtzSize, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.unary(UnaryOp.PopcntSize, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotlSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.Bool: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(BinaryOp.RotrSize, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32\n                module.i32(31)\n              ),\n              false // i32\n            ),\n            module.local_get(temp1.index, TypeRef.I32)\n          ),\n          module.local_get(temp2.index, TypeRef.I32)\n        );\n        return ret;\n      }\n      case TypeKind.Isize: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(BinaryOp.XorSize,\n          module.binary(BinaryOp.AddSize,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrISize,\n                module.local_tee(temp1.index, arg0, false), // i32/i64\n                compiler.options.isWasm64\n                  ? module.i64(63)\n                  : module.i32(31)\n              ),\n              false // i32/i64\n            ),\n            module.local_get(temp1.index, options.sizeTypeRef)\n          ),\n          module.local_get(temp2.index, options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0, false), // i64\n                module.i64(63)\n              ),\n              false // i64\n            ),\n            module.local_get(temp1.index, TypeRef.I64)\n          ),\n          module.local_get(temp2.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.GtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.GtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.GtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.GtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MustWrap);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MustWrap);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.ConvImplicit | Constraints.MustWrap);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit | Constraints.MustWrap);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:   { op = BinaryOp.LtI32; break; }\n      case TypeKind.Bool:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:   { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:   { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:   { op = BinaryOp.LtU64; break; }\n      case TypeKind.Isize: { op = BinaryOp.LtISize; break; }\n      case TypeKind.Usize: { op = BinaryOp.LtUSize; break; }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp1.index, LocalFlags.Wrapped);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.Wrapped);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.ConvImplicit);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let isWasm64 = compiler.options.isWasm64;\n        let arg0 = compiler.compileExpression(operands[0],\n          isWasm64 ? Type.f64 : Type.f32,\n          Constraints.ConvImplicit\n        );\n        compiler.currentType = type;\n        return module.unary(\n          isWasm64\n            ? UnaryOp.ReinterpretF64ToI64\n            : UnaryOp.ReinterpretF32ToI32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.ConvImplicit);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.None);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0, false), // f32\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0, false), // f64\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.local_get(temp.index, TypeRef.F32)\n          ),\n          module.f32(0)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.local_get(temp.index, TypeRef.F64)\n          ),\n          module.f64(0)\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// __heap_base\nfunction builtin_heap_base_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Heap;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.heap_base, builtin_heap_base_compile);\n\n// __heap_base -> usize\nfunction builtin_heap_base_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Heap;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.heap_base, builtin_heap_base_access);\n\n// __data_end\nfunction builtin_data_end_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Data;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.data_end, builtin_data_end_compile);\n\n// __data_end -> usize\nfunction builtin_data_end_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Data;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.data_end, builtin_data_end_access);\n\n// __stack_pointer\nfunction builtin_stack_pointer_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Stack;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.stack_pointer, builtin_stack_pointer_compile);\n\n// __stack_pointer -> usize\nfunction builtin_stack_pointer_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Stack;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.stack_pointer, builtin_stack_pointer_access);\n\n// __rtti_base\nfunction builtin_rtti_base_compile(ctx: BuiltinVariableContext): void {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Rtti;\n  module.addGlobal(element.internalName, type.toRef(), true, compiler.makeZero(type)); // dummy\n}\nbuiltinVariables_onCompile.set(BuiltinNames.rtti_base, builtin_rtti_base_compile);\n\n// __rtti_base -> usize\nfunction builtin_rtti_base_access(ctx: BuiltinVariableContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let element = ctx.element;\n  let type = element.type;\n  compiler.runtimeFeatures |= RuntimeFeatures.Rtti;\n  compiler.currentType = type;\n  return module.global_get(element.internalName, type.toRef());\n}\nbuiltinVariables_onAccess.set(BuiltinNames.rtti_base, builtin_rtti_base_access);\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n\n  let outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n\n  if (!outType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"load\", outType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toRef(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltinFunctions.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (!inType.isMemory) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"store\", inType.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\n}\nbuiltinFunctions.set(BuiltinNames.store, builtin_store);\n\n// rem<T?>(left: T, right: T) -> T\nfunction builtin_rem(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isIntegerValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isIntegerValue) {\n      return compiler.makeRem(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"rem\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.rem, builtin_rem);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.div, builtin_div);\n\n// eq<T?>(left: T, right: T) -> i32\nfunction builtin_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeEq(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"eq\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.eq, builtin_eq);\n\n// ne<T?>(left: T, right: T) -> i32\nfunction builtin_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let left = operands[0];\n  let arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.ConvImplicit\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.ConvImplicit\n      );\n    }\n    if (type.isNumericValue) {\n      compiler.currentType = Type.i32;\n      return compiler.makeNe(arg0, arg1, type, ctx.reportNode);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"ne\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.ne, builtin_ne);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  let outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toRef(),\n    immOffset\n  );\n}\nbuiltinFunctions.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\n}\nbuiltinFunctions.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinFunctionContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltinFunctions.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let contextualType = ctx.contextualType;\n  let type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.ConvImplicit\n  );\n  let arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.ConvImplicit\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.None // no need to convert to small int (but now might result in a float)\n          : Constraints.ConvImplicit\n      );\n  let inType = compiler.currentType;\n  let arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.ConvImplicit\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  let immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\n}\nbuiltinFunctions.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout?: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = operands.length == 3\n    ? compiler.compileExpression(operands[2], Type.i64, Constraints.ConvImplicit)\n    : module.i64(-1, -1); // Infinite timeout\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.Isize:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.Usize: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count?: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = operands.length == 2\n    ? compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit)\n    : module.i32(-1); // Inifinity count of waiters\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltinFunctions.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.Threads) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltinFunctions.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit)\n    : compiler.compileExpression(operands[0], Type.auto);\n  let type = compiler.currentType;\n  if (!type.isAny(TypeFlags.Value | TypeFlags.Reference)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  let arg1 = compiler.compileExpression(operands[1], type, Constraints.ConvImplicit);\n  let arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2, type.toRef());\n}\nbuiltinFunctions.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltinFunctions.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.ConvImplicit));\n}\nbuiltinFunctions.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltinFunctions.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BulkMemory)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  let usizeType = compiler.options.usizeType;\n  let arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.ConvImplicit);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltinFunctions.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  let typeArguments = ctx.typeArguments;\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  let usizeType = compiler.options.usizeType;\n  let offset: i64;\n  if (typeArguments && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.Literal || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.Array) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.Omitted) {\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.ConvImplicit);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltinFunctions.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === GC =====================================================================================\n\nfunction builtin_i31_new(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.i31ref;\n  return module.i31_new(arg0);\n}\nbuiltinFunctions.set(BuiltinNames.i31_new, builtin_i31_new);\n\nfunction builtin_i31_get(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.ConvImplicit);\n  if (ctx.contextualType.is(TypeFlags.Unsigned)) {\n    compiler.currentType = Type.u32;\n    return module.i31_get(arg0, false);\n  } else {\n    compiler.currentType = Type.i32;\n    return module.i31_get(arg0, true);\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i31_get, builtin_i31_get);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let toType = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.auto);\n  let fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltinFunctions.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  let typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let contextualType = ctx.contextualType;\n  let arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit | Constraints.MustWrap)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MustWrap);\n  let type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  let evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>TypeRef.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  let abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.if(module.unary(UnaryOp.EqzSize, arg0), abort);\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: return module.if(module.ref_is_null(arg0), abort);\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.Bool:\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.Wrapped); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0, false), // numeric\n          module.local_get(temp.index, TypeRef.I32),\n          abort\n        );\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0, false) // i64\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.I64)\n        );\n        return ret;\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            UnaryOp.EqzSize,\n            module.local_tee(temp.index, arg0, type.isManaged)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\n        );\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        return ret;\n      }\n      case TypeKind.Funcref:\n      case TypeKind.Externref:\n      case TypeKind.Anyref:\n      case TypeKind.Eqref:\n      case TypeKind.Structref:\n      case TypeKind.Arrayref:\n      case TypeKind.I31ref:\n      case TypeKind.Stringref:\n      case TypeKind.StringviewWTF8:\n      case TypeKind.StringviewWTF16:\n      case TypeKind.StringviewIter: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is_null(\n            module.local_tee(temp.index, arg0, false) // ref\n          ),\n          abort,\n          module.local_get(temp.index, type.toRef())\n        );\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltinFunctions.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  let flow = compiler.currentFlow;\n  let ignoreUnchecked = compiler.options.uncheckedBehavior === UncheckedBehavior.Never;\n  let alreadyUnchecked = flow.is(FlowFlags.UncheckedContext);\n  if (ignoreUnchecked) assert(!alreadyUnchecked);\n  else flow.set(FlowFlags.UncheckedContext);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  let expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UncheckedContext);\n  return expr;\n}\nbuiltinFunctions.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  let indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  let numOperands = operands.length - 1;\n  let operandExprs = new Array<ExpressionRef>(numOperands);\n  let paramTypeRefs = new Array<TypeRef>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    paramTypeRefs[i] = compiler.currentType.toRef();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(null /* TODO */, indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\n}\nbuiltinFunctions.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let typeArgument = typeArguments[0];\n  let classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  let ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.None, ctx.reportNode);\n}\nbuiltinFunctions.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinFunctionContext, category: DiagnosticCategory): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  checkTypeAbsent(ctx);\n  let operands = ctx.operands;\n  let reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.Error\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Error);\n}\nbuiltinFunctions.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Warning);\n}\nbuiltinFunctions.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.Info);\n}\nbuiltinFunctions.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.Class);\n  let classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  let typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  let ftype = typeArguments[0];\n  let signature = assert(ftype.getSignature());\n  let returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  let functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.ConvImplicit);\n  let thisOperand = assert(ctx.operands.shift());\n  let thisType = signature.thisType;\n  let thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.ConvImplicit);\n  } else if (thisOperand.kind != NodeKind.Null) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nbuiltinFunctions.set(BuiltinNames.Function_call, builtin_function_call);\n\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\nfunction builtin_string_raw(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\n  compiler.error(\n    DiagnosticCode.Not_implemented_0,\n    ctx.reportNode.range, \"String.raw\"\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.String_raw, builtin_string_raw);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinFunctionContext, toType: Type): ExpressionRef {\n  let compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.ConvExplicit);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltinFunctions.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltinFunctions.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltinFunctions.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltinFunctions.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltinFunctions.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltinFunctions.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltinFunctions.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltinFunctions.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltinFunctions.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltinFunctions.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltinFunctions.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltinFunctions.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltinFunctions.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(16);\n  let numVars = 0;\n\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 16;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI8x16, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 16; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(8);\n  let numVars = 0;\n\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 8;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI16x8, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 8; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp),  bytes, off + 0);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatI64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(4);\n  let numVars = 0;\n\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 4;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF32x4, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 4; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let bytes = new Uint8Array(16);\n  let vars  = new Array<ExpressionRef>(2);\n  let numVars = 0;\n\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      vars[i] = expr;\n      numVars++;\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (numVars == 0) {\n    // all constants\n    return module.v128(bytes);\n  } else {\n    let vec: ExpressionRef;\n    let fullVars = numVars == 2;\n    if (fullVars) {\n      // all variants\n      vec = module.unary(UnaryOp.SplatF64x2, vars[0]);\n    } else {\n      // mixed constants / variants\n      vec = module.v128(bytes);\n    }\n    for (let i = i32(fullVars); i < 2; i++) {\n      let expr = vars[i];\n      if (expr) vec = module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, vec, <u8>i, expr);\n    }\n    return vec;\n  }\n}\nbuiltinFunctions.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  compiler.currentType = type;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], type, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  let idx = 0;\n  let precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(Number.isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.Isize:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.ConvImplicit);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\n}\nbuiltinFunctions.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_load(\n          compiler.options.isWasm64\n            ? SIMDLoadOp.Load64Zero\n            : SIMDLoadOp.Load32Zero,\n          arg0,\n          immOffset,\n          immAlign\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\n\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Load64Lane\n            : SIMDLoadStoreLaneOp.Load32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\n\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_store_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.ConvImplicit);\n  let idx = 0;\n  let precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  let numOperands = operands.length;\n  let immOffset = 0;\n  let immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_loadstorelane(\n          compiler.options.isWasm64\n            ? SIMDLoadStoreLaneOp.Store64Lane\n            : SIMDLoadStoreLaneOp.Store32Lane,\n          arg0,\n          immOffset,\n          immAlign,\n          <u8>idx,\n          arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\n\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\n      // no LtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\n      // no LeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\n      // no GtU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\n      // no GeU64x2\n      case TypeKind.Isize: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\n      case TypeKind.Isize: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.Usize: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.convert_low<T!>(a: v128) -> v128\nfunction builtin_v128_convert_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\n\n// v128.extend_low<T!>(a: v128) -> v128\nfunction builtin_v128_extend_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\n\n// v128.extend_high<T!>(a: v128) -> v128\nfunction builtin_v128_extend_high(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\n      case TypeKind.Isize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\n      case TypeKind.Usize: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.Isize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.Usize: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinFunctionContext, op: BinaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinFunctionContext, op: UnaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltinFunctions.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinFunctionContext, op: SIMDTernaryOp): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  let arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.ConvImplicit);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinFunctionContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltinFunctions.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\n}\nbuiltinFunctions.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AllTrueI64x2\n            : UnaryOp.AllTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\n      case TypeKind.Isize:\n      case TypeKind.Usize: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.BitmaskI64x2\n            : UnaryOp.BitmaskI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.popcnt<T!>(a: v128) -> v128\nfunction builtin_v128_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\n\n// v128.extadd_pairwise<T!>(a: v128) -> v128\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let type = ctx.typeArguments![0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\n\n// v128.demote_zero<T?>(a: v128) -> v128\nfunction builtin_v128_demote_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f64;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\n\n// v128.promote_low<T?>(a: v128) -> v128\nfunction builtin_v128_promote_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  let type = typeArguments ? typeArguments[0] : Type.f32;\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\n\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\n\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_low(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\n\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_high(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.Simd) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments!;\n  let type = typeArguments[0];\n  let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.ConvImplicit);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltinFunctions.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\n}\nbuiltinFunctions.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinFunctionContext): ExpressionRef {\n  let compiler = ctx.compiler;\n  let module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  let operands = ctx.operands;\n  let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.ConvImplicit);\n  let arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.ConvImplicit);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\n}\nbuiltinFunctions.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.rem_s -> rem<i32>\nfunction builtin_i32_rem_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rem_s, builtin_i32_rem_s);\n\n// i32.rem_u -> rem<u32>\nfunction builtin_i32_rem_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_rem_u, builtin_i32_rem_u);\n\n// i64.rem_s -> rem<i64>\nfunction builtin_i64_rem_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rem_s, builtin_i64_rem_s);\n\n// i64.rem_u -> rem<u64>\nfunction builtin_i64_rem_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_rem(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_rem_u, builtin_i64_rem_u);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.eq -> eq<i32>\nfunction builtin_i32_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_eq, builtin_i32_eq);\n\n// i64.eq -> eq<i64>\nfunction builtin_i64_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_eq, builtin_i64_eq);\n\n// f32.eq -> eq<f32>\nfunction builtin_f32_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_eq, builtin_f32_eq);\n\n// f64.eq -> eq<f64>\nfunction builtin_f64_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_eq, builtin_f64_eq);\n\n// i32.ne -> ne<i32>\nfunction builtin_i32_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_ne, builtin_i32_ne);\n\n// i64.ne -> ne<i64>\nfunction builtin_i64_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_ne, builtin_i64_ne);\n\n// f32.ne -> ne<f32>\nfunction builtin_f32_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_ne, builtin_f32_ne);\n\n// f64.ne-> ne<f64>\nfunction builtin_f64_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_ne, builtin_f64_ne);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// memory.atomic.wait32 -> atomic.wait<i32>\nfunction builtin_memory_atomic_wait32(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.memory_atomic_wait32, builtin_memory_atomic_wait32);\n\n// memory.atomic.wait64 -> atomic.wait<i64>\nfunction builtin_memory_atomic_wait64(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.memory_atomic_wait64, builtin_memory_atomic_wait64);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.load8x8_s -> v128.load_ext<i8>\nfunction builtin_v128_load8x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\n\n// v128.load8x8_u -> v128.load_ext<u8>\nfunction builtin_v128_load8x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\n\n// v128.load16x4_s -> v128.load_ext<i16>\nfunction builtin_v128_load16x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\n\n// v128.load16x4_u -> v128.load_ext<u16>\nfunction builtin_v128_load16x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\n\n// v128.load32x2_s -> v128.load_ext<i32>\nfunction builtin_v128_load32x2_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\n\n// v128.load32x2_u -> v128.load_ext<u32>\nfunction builtin_v128_load32x2_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\n\n// v128.load8_splat -> v128.load_splat<u8>\nfunction builtin_v128_load8_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\n\n// v128.load16_splat -> v128.load_splat<u16>\nfunction builtin_v128_load16_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\n\n// v128.load32_splat -> v128.load_splat<u32>\nfunction builtin_v128_load32_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\n\n// v128.load64_splat -> v128.load_splat<u64>\nfunction builtin_v128_load64_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\n\n// v128.load32_zero -> v128.load_zero<u32>\nfunction builtin_v128_load32_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\n\n// v128.load64_zero -> v128.load_zero<u64>\nfunction builtin_v128_load64_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\n\n// v128.load8_lane -> v128.load_lane<u8>\nfunction builtin_v128_load8_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\n\n// v128.load16_lane -> v128.load_lane<u16>\nfunction builtin_v128_load16_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\n\n// v128.load32_lane -> v128.load_lane<u32>\nfunction builtin_v128_load32_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\n\n// v128.load64_lane -> v128.load_lane<u64>\nfunction builtin_v128_load64_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\n\n// v128.store8_lane -> v128.store_lane<u8>\nfunction builtin_v128_store8_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\n\n// v128.store16_lane -> v128.store_lane<u16>\nfunction builtin_v128_store16_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\n\n// v128.store32_lane -> v128.store_lane<u32>\nfunction builtin_v128_store32_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\n\n// v128.store64_lane -> v128.store_lane<u64>\nfunction builtin_v128_store64_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_sat_s -> v128.add_sat<i8>\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\n\n// i8x16.add_sat_u -> v128.add_sat<u8>\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\n\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\n\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.popcnt -> v128.popcnt<i8>\nfunction builtin_i8x16_popcnt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_popcnt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_i8x16_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\n\n// i8x16.swizzle -> v128.swizzle\nfunction builtin_i8x16_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_sat_s -> v128.add_sat<i16>\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\n\n// i16x8.add_sat_u -> v128.add_sat<u16>\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\n\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\n\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\n\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\n\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\n\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\n\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\n\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\n\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_q15mulr_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\n\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\n\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\n\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\n\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\n\n// i16x8.shuffle -> v128.shuffle<i16>\nfunction builtin_i16x8_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_shuffle, builtin_i16x8_shuffle);\n\n// i16x8.swizzle -> v128.swizzle\nfunction builtin_i16x8_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i16x8_swizzle, builtin_i16x8_swizzle);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\n\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\n\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\n\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\n\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\n\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\n\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\n\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\n\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\n\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\n\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\n\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\n\n// i32x4.shuffle -> v128.shuffle<i32>\nfunction builtin_i32x4_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_shuffle, builtin_i32x4_shuffle);\n\n// i32x4.swizzle -> v128.swizzle\nfunction builtin_i32x4_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i32x4_swizzle, builtin_i32x4_swizzle);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.mul -> v128.mul<i64>\nfunction builtin_i64x2_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\n\n// i64x2.abs -> v128.abs<i64>\nfunction builtin_i64x2_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.bitmask -> v128.bitmask<i64>\nfunction builtin_i64x2_bitmask(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\n\n// i64x2.eq -> v128.eq<i64>\nfunction builtin_i64x2_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\n\n// i64x2.ne -> v128.ne<i64>\nfunction builtin_i64x2_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\n\n// i64x2.lt_s -> v128.lt<i64>\nfunction builtin_i64x2_lt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\n\n// i64x2.le_s -> v128.le<i64>\nfunction builtin_i64x2_le_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\n\n// i64x2.gt_s -> v128.gt<i64>\nfunction builtin_i64x2_gt_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\n\n// i64x2.ge_s -> v128.ge<i64>\nfunction builtin_i64x2_ge_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\n\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\n\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\n\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\n\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\n\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\n\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\n\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\n\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\n\n// i64x2.shuffle -> v128.shuffle<i64>\nfunction builtin_i64x2_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_shuffle, builtin_i64x2_shuffle);\n\n// i64x2.swizzle -> v128.swizzle\nfunction builtin_i64x2_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.i64x2_swizzle, builtin_i64x2_swizzle);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_demote_zero(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\n\n// f32x4.shuffle -> v128.shuffle<f32>\nfunction builtin_f32x4_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_shuffle, builtin_f32x4_shuffle);\n\n// f32x4.swizzle -> v128.swizzle\nfunction builtin_f32x4_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f32x4_swizzle, builtin_f32x4_swizzle);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\n\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\n\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_promote_low(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\n\n// f64x2.shuffle -> v128.shuffle<f32>\nfunction builtin_f64x2_shuffle(ctx: BuiltinFunctionContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_shuffle, builtin_f64x2_shuffle);\n\n// f64x2.swizzle -> v128.swizzle\nfunction builtin_f64x2_swizzle(ctx: BuiltinFunctionContext): ExpressionRef {\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltinFunctions.set(BuiltinNames.f64x2_swizzle, builtin_f64x2_swizzle);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  let module = compiler.module;\n  let exprs = new Array<ExpressionRef>();\n  let sizeTypeRef = compiler.options.sizeTypeRef;\n  let visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.Global) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference &&\n      !classReference.hasDecorator(DecoratorFlags.Unmanaged) &&\n      global.is(CommonFlags.Compiled)\n    ) {\n      if (global.is(CommonFlags.Inlined)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value)),\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, sizeTypeRef),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, sizeTypeRef), // tempRef != null\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    TypeRef.I32,  // cookie\n    TypeRef.None, // => void\n    [ sizeTypeRef ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let sizeTypeSize = usizeType.byteSize;\n  let visitInstance = assert(program.visitInstance);\n  let body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  let base = instance.base;\n  if (base) {\n    body.push(\n      module.call(`${base.internalName}~visit`, [\n        module.local_get(0, sizeTypeRef), // this\n        module.local_get(1, TypeRef.I32)  // cookie\n      ], TypeRef.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  let hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.getMember(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FunctionPrototype);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, sizeTypeRef), // this\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  let needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        // Class should have resolved fields during finalization\n        let property = (<PropertyPrototype>member).instance;\n        if (!property) continue;\n        let fieldType = property.type;\n        if (!property.isField || property.getBoundClassOrInterface() != instance || !fieldType.isManaged) continue;\n        let fieldOffset = property.memoryOffset;\n        assert(fieldOffset >= 0);\n        needsTempValue = true;\n        body.push(\n          // if ($2 = value) __visit($2, $1)\n          module.if(\n            module.local_tee(2,\n              module.load(sizeTypeSize, false,\n                module.local_get(0, sizeTypeRef),\n                sizeTypeRef, fieldOffset\n              ),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(2, sizeTypeRef), // value\n              module.local_get(1, TypeRef.I32)  // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(`${instance.internalName}~visit`,\n    createType([sizeTypeRef, TypeRef.I32]),\n    TypeRef.None,\n    needsTempValue ? [ sizeTypeRef ] : null,\n    module.flatten(body, TypeRef.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base && base.type.isManaged) {\n    // errored earlier if not managed\n    ensureVisitMembersOf(compiler, base);\n  }\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let usizeType = program.options.usizeType;\n  let sizeTypeRef = usizeType.toRef();\n  let managedClasses = program.managedClasses;\n  let visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  let names = new Array<string>();\n  let cases = new Array<ExpressionRef>();\n  let nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    if (instance.isPointerfree) {\n      cases[i] = module.return();\n    } else {\n      cases[i] = module.block(null, [\n        module.call(`${instance.internalName}~visit`, [\n          module.local_get(0, sizeTypeRef), // this\n          module.local_get(1, TypeRef.I32)  // cookie\n        ], TypeRef.None),\n        module.return()\n      ], TypeRef.None);\n      ensureVisitMembersOf(compiler, instance);\n    }\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  let current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        sizeTypeRef == TypeRef.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, sizeTypeRef),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, sizeTypeRef),\n              module.i32(8) // rtId is at -8\n            ),\n        TypeRef.I32, 0\n      )\n    )\n  ], TypeRef.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], TypeRef.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], TypeRef.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\n    TypeRef.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  let flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.Signed))   flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.Float))    flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.Nullable)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged)              flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  let program = compiler.program;\n  let module = compiler.module;\n  let managedClasses = program.managedClasses;\n  let count = managedClasses.size;\n  let size = 4 + 4 * count; // count | TypeInfo*\n  let data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  let off = 4;\n  let abvInstance = program.arrayBufferViewInstance;\n  let abvPrototype = abvInstance.prototype;\n  let arrayPrototype = program.arrayPrototype;\n  let setPrototype = program.setPrototype;\n  let mapPrototype = program.mapPrototype;\n  let staticArrayPrototype = program.staticArrayPrototype;\n  let lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\n    if (instance != abvInstance && instance.extendsPrototype(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extendsPrototype(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extendsPrototype(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extendsPrototype(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0   * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extendsPrototype(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n  }\n  assert(off == size);\n  let usizeType = program.options.usizeType;\n  let segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n// Helpers\n\n/** Checks the constant type of a type argument *or* expression. */\nfunction checkConstantType(ctx: BuiltinFunctionContext): Type | null {\n  let compiler = ctx.compiler;\n  let operands = ctx.operands;\n  let typeArguments = ctx.typeArguments;\n  checkConstantType_expr = 0;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      checkConstantType_expr = compiler.compileExpression(operands[0], typeArguments[0], Constraints.ConvImplicit);\n    } else {\n      checkConstantType_expr = compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Reifies a constant type check potentially involving an expression. */\nfunction reifyConstantType(ctx: BuiltinFunctionContext, expr: ExpressionRef): ExpressionRef {\n  let module = ctx.compiler.module;\n  if (checkConstantType_expr && mustPreserveSideEffects(checkConstantType_expr, module.ref)) {\n    expr = module.block(null, [\n      module.maybeDrop(checkConstantType_expr),\n      expr\n    ], getExpressionType(expr));\n  }\n  return expr;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  let module = compiler.module;\n  let value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.ConvImplicit);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  let align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinFunctionContext, feature: Feature): i32 {\n  let compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinFunctionContext, setCurrentTypeOnError: bool = false): i32 {\n  let compiler = ctx.compiler;\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinFunctionContext, setCurrentTypeOnError: bool = false): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinFunctionContext): i32 {\n  let typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinFunctionContext, expected: i32): i32 {\n  let operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinFunctionContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  let operands = ctx.operands;\n  let numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  let module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak,\n  isWhiteSpace,\n  COLOR_CYAN,\n  COLOR_YELLOW,\n  COLOR_RED,\n  COLOR_MAGENTA,\n  COLOR_RESET,\n  isColorsEnabled,\n  setColorsEnabled,\n  CharCode\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport const enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  Pedantic,\n  /** Informatory message. */\n  Info,\n  /** Warning message. */\n  Warning,\n  /** Error message. */\n  Error\n}\n\nexport class Range {\n\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(public start: i32, public end: i32) {}\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return (\n      this.source == other.source &&\n      this.start == other.start &&\n      this.end == other.end\n    );\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return \"PEDANTIC\";\n    case DiagnosticCategory.Info: return \"INFO\";\n    case DiagnosticCategory.Warning: return \"WARNING\";\n    case DiagnosticCategory.Error: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.Pedantic: return COLOR_MAGENTA;\n    case DiagnosticCategory.Info: return COLOR_CYAN;\n    case DiagnosticCategory.Warning: return COLOR_YELLOW;\n    case DiagnosticCategory.Error: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    let message = diagnosticCodeToString(code);\n    if (arg0 != null) message = message.replace(\"{0}\", arg0);\n    if (arg1 != null) message = message.replace(\"{1}\", arg1);\n    if (arg2 != null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    let thisRange = this.range;\n    let otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    let thisRelatedRange = this.relatedRange;\n    let otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRelatedRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    let category = diagnosticCategoryToString(this.category);\n    let range = this.range;\n    let code = this.code;\n    let message = this.message;\n    if (range) {\n      let source = range.source;\n      let path = source.normalizedPath;\n      let line = source.lineAt(range.start);\n      let column = source.columnAt();\n      let len = range.end - range.start;\n      return `${category} ${code}: \"${message}\" in ${path}(${line},${column}+${len})`;\n    }\n    return `${category} ${code}: ${message}`;\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n  let wasColorsEnabled = setColorsEnabled(useColors);\n\n  // general information\n  let sb: string[] = [];\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  let range = message.range;\n  if (range) {\n    let source = range.source;\n    let relatedRange = message.relatedRange;\n    let minLine = 0;\n    if (relatedRange) {\n      // Justify context indentation when multiple ranges are present\n      minLine = max(source.lineAt(range.start), relatedRange.source.lineAt(relatedRange.start));\n    }\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range, minLine));\n    } else {\n      sb.push(\"\\n in \");\n      sb.push(source.normalizedPath);\n    }\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange, minLine));\n      } else {\n        sb.push(\"\\n in \");\n        sb.push(relatedSource.normalizedPath);\n      }\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  setColorsEnabled(wasColorsEnabled);\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nfunction formatDiagnosticContext(range: Range, minLine: i32 = 0): string {\n  let source = range.source;\n  let text = source.text;\n  let len = text.length;\n  let start = range.start;\n  let end = start;\n  let lineNumber = source.lineAt(start).toString();\n  let lineNumberLength = minLine\n    ? max(minLine.toString().length, lineNumber.length)\n    : lineNumber.length;\n  let lineSpace = \" \".repeat(lineNumberLength);\n  // Find preceeding line break\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  // Skip leading whitespace (assume no supplementary whitespaces)\n  while (start < len && isWhiteSpace(text.charCodeAt(start))) start++;\n  // Find next line break\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  let sb: string[] = [\n    lineSpace,\n    \"  :\\n \",\n    \" \".repeat(lineNumberLength - lineNumber.length),\n    lineNumber,\n    \" │ \",\n    text.substring(start, end).replaceAll(\"\\t\", \"  \"),\n    \"\\n \",\n    lineSpace,\n    \" │ \"\n  ];\n  while (start < range.start) {\n    if (text.charCodeAt(start) == CharCode.Tab) {\n      sb.push(\"  \");\n      start += 2;\n    } else {\n      sb.push(\" \");\n      start++;\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      let cc = text.charCodeAt(start);\n      if (cc == CharCode.Tab) {\n        sb.push(\"~~\");\n      } else if (isLineBreak(cc)) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      } else {\n        sb.push(\"~\");\n      }\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(\"\\n \");\n  sb.push(lineSpace);\n  sb.push(\" └─ in \");\n  sb.push(source.normalizedPath);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    let message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Pedantic, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Info, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Warning, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.Error, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Clone map. Typically used to track contextual type arguments. */\nexport function cloneMap<K,V>(map: Map<K,V> | null): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    // fast path for js target\n    return new Map<K,V>(map);\n  } else {\n    let out = new Map<K,V>();\n    if (map) {\n      // TODO: for (let [k, v] of map) {\n      for (let _keys = Map_keys(map), i = 0, k = _keys.length; i < k; ++i) {\n        let k = unchecked(_keys[i]);\n        let v = assert(map.get(k));\n        out.set(k, v);\n      }\n    }\n    return out;\n  }\n}\n\n/** Merge two maps in into new one. */\nexport function mergeMaps<K,V>(map1: Map<K,V>, map2: Map<K,V>): Map<K,V> {\n  if (!ASC_TARGET) { // JS\n    let out = new Map<K,V>(map1);\n    map2.forEach((v, k) => out.set(k, v));\n    return out;\n  } else {\n    let out = new Map<K,V>();\n    // TODO: for (let [k, v] of map1) {\n    for (let _keys = Map_keys(map1), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map1.get(k));\n      out.set(k, v);\n    }\n    // TODO: for (let [k, v] of map2) {\n    for (let _keys = Map_keys(map2), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(map2.get(k));\n      out.set(k, v);\n    }\n    return out;\n  }\n}\n\n/** BitSet represent growable sequence of N bits. It's faster alternative of Set<i32> when elements\n * are not too much sparsed. Also it's more memory and cache efficient than Array<bool>.\n * The best way to use it for short bit sequences (less than 32*(2**16)).\n */\nexport class BitSet {\n  words!: Uint32Array;\n\n  constructor() {\n    this.clear();\n  }\n\n  get size(): i32 {\n    let count = 0;\n    let words = this.words;\n    for (let i = 0, len = words.length; i < len; i++) {\n      let word = unchecked(words[i]);\n      if (word) count += popcnt(word);\n    }\n    return count;\n  }\n\n  add(index: i32): this {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) { // resize\n      this.words = new Uint32Array(idx + 16);\n      this.words.set(words);\n      words = this.words;\n    }\n    unchecked(words[idx] |= 1 << index);\n    return this;\n  }\n\n  delete(index: i32): void {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return;\n    unchecked(words[idx] &= ~(1 << index));\n  }\n\n  has(index: i32): bool {\n    let idx = index >>> 5;\n    let words = this.words;\n    if (idx >= words.length) return false;\n    return (unchecked(words[index >>> 5]) & (1 << index)) !== 0;\n  }\n\n  clear(): void {\n    this.words = new Uint32Array(16);\n  }\n\n  toArray(): i32[] {\n    let res = new Array<i32>(this.size);\n    for (let i = 0, p = 0, len = this.words.length; i < len; ++i) {\n      let word = unchecked(this.words[i]);\n      while (word) {\n        let mask = word & -word;\n        unchecked(res[p++] = (i << 5) + popcnt(mask - 1));\n        word ^= mask;\n      }\n    }\n    return res;\n  }\n\n  toString(): string {\n    return `BitSet { ${this.toArray()} }`;\n  }\n}\n","/**\n * @fileoverview Collections glue code for WebAssembly.\n * @license Apache-2.0\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@global @inline\nfunction Map_keys<K,V>(map: Map<K,V>): K[] {\n  return map.keys(); // preliminary\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction Map_values<K,V>(map: Map<K,V>): V[] {\n  return map.values(); // preliminary\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction Set_values<V>(set: Set<V>): V[] {\n  return set.values(); // preliminary\n}\n","/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Range,\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression,\n  ArrowKind,\n  ExpressionStatement\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  cloneMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport const enum ReportMode {\n  /** Report errors. */\n  Report,\n  /** Swallow errors. */\n  Swallow\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n  /** Whether a new override has been discovered. */\n  discoveredOverride: bool = false;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    if (node.currentlyResolving) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        node.range, \"Recursive types\"\n      );\n      return null;\n    }\n    node.currentlyResolving = true;\n    let resolved: Type | null = null;\n    switch (node.kind) {\n      case NodeKind.NamedType: {\n        resolved = this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n        break;\n      }\n      case NodeKind.FunctionType: {\n        resolved = this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n        break;\n      }\n      default: assert(false);\n    }\n    node.currentlyResolving = false;\n    return resolved;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let nameNode = node.name;\n    let typeArgumentNodes = node.typeArguments;\n    let isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    let element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    let shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.Enum) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, `${element.name}/i32`\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.ClassPrototype ||\n        element.kind == ElementKind.InterfacePrototype\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          cloneMap(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TypeDefinition) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.Resolved)) {\n        if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native)   return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof)  return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof)  return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.nonnull)  return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = cloneMap(ctxTypes), // update\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let explicitThisType = node.explicitThisType;\n    let thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    let parameterNodes = node.parameters;\n    let numParameters = parameterNodes.length;\n    let parameterTypes = new Array<Type>(numParameters);\n    let requiredParameters = 0;\n    let hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.Default: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.Rest: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    let returnTypeNode = node.returnType;\n    let returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    let signature = Signature.create(this.program, parameterTypes, returnType, thisType, requiredParameters, hasRest);\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:  return Type.i32;\n      case TypeKind.Isize: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64:  return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.Bool: return Type.u32;\n      case TypeKind.Usize: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64:  return Type.u64;\n      case TypeKind.F32:  return Type.f32;\n      case TypeKind.F64:  return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.Void: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNode.range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n    if (overload) {\n      let parameterTypes = overload.signature.parameterTypes;\n      if (overload.is(CommonFlags.Static)) {\n        assert(parameterTypes.length == 2);\n        return parameterTypes[1];\n      } else {\n        assert(parameterTypes.length == 1);\n        return parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.IndexedGet);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    let signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinNotNullableType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    let typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    if (!typeArgument.isNullableReference) return typeArgument;\n    return typeArgument.nonNullableType;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = ctxElement.lookup(node.identifier.text, true);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    let prev = node;\n    let next = node.next;\n    while (next) {\n      if (!(element = element.getMember(next.identifier.text))) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type[] | null {\n    var\n      minParameterCount = 0,\n      maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    let argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    let typeArguments = new Array<Type>(maxParameterCount);\n    let oldCtxTypes = cloneMap(ctxTypes);\n    ctxTypes.clear();\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            oldCtxTypes, // update\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            cloneMap(ctxTypes), // don't update\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.Generic)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.Generic)) {\n      let contextualTypeArguments = cloneMap(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments\n          ? argumentNodes[i]\n          : parameterNodes[i].initializer;\n        if (!argumentExpression) {\n          // optional but not have initializer should be handled in the other place\n          if (parameterNodes[i].parameterKind == ParameterKind.Optional) {\n            continue;\n          }\n          // missing initializer -> too few arguments\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.Swallow);\n          if (type) {\n            this.propagateInferredGenericTypes(\n              typeNode,\n              type,\n              prototype,\n              contextualTypeArguments,\n              typeParameterNames\n            );\n          }\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let typeParameterNode = typeParameterNodes[i];\n        let name = typeParameterNode.name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n          let defaultType = typeParameterNode.defaultType;\n          if (defaultType) {\n            // Default parameters are resolved in context of the called function, not the calling function\n            let parent = prototype.parent;\n            let defaultTypeContextualTypeArguments: Map<string, Type> | null = null;\n            if (parent.kind == ElementKind.Class) {\n              defaultTypeContextualTypeArguments = (<Class>parent).contextualTypeArguments;\n            } else if (parent.kind == ElementKind.Function) {\n              defaultTypeContextualTypeArguments = (<Function>parent).contextualTypeArguments;\n            }\n            let resolvedDefaultType = this.resolveType(\n              defaultType,\n              prototype,\n              defaultTypeContextualTypeArguments,\n              reportMode\n            );\n            if (!resolvedDefaultType) return null;\n            resolvedTypeArguments[i] = resolvedDefaultType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, new Map(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NamedType) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxElement);\n          if (!classPrototype || classPrototype.kind != ElementKind.ClassPrototype) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(\n                  typeArgumentNodes[i],\n                  typeArguments[i],\n                  ctxElement,\n                  ctxTypes,\n                  typeParameterNames\n                );\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (\n            currentType == Type.auto ||\n            (typeParameterNames.has(name) && currentType.isAssignableTo(type))\n          ) ctxTypes.set(name, type);\n        }\n      }\n    } else if (node.kind == NodeKind.FunctionType) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      let signatureReference = type.signatureReference;\n      if (signatureReference) {\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = min(parameterTypes.length, parameterNodes.length) ; i < k; ++i) {\n          this.propagateInferredGenericTypes(\n            parameterNodes[i].type,\n            parameterTypes[i],\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let returnType = signatureReference.returnType;\n        if (returnType != Type.void) {\n          this.propagateInferredGenericTypes(\n            functionTypeNode.returnType,\n            returnType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        let thisType = signatureReference.thisType;\n        let explicitThisType = functionTypeNode.explicitThisType;\n        if (thisType && explicitThisType) {\n          this.propagateInferredGenericTypes(\n            explicitThisType,\n            thisType,\n            ctxElement,\n            ctxTypes,\n            typeParameterNames\n          );\n        }\n        return;\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    let kind = element.kind;\n    if (kind == ElementKind.Global) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.Swallow)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** resolving expressions */\n  private resolvingExpressions: Set<Expression> = new Set();\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const resolvingExpressions = this.resolvingExpressions;\n    if (resolvingExpressions.has(node)) return null;\n    resolvingExpressions.add(node);\n    const resolved = this.doResolveExpression(node, ctxFlow, ctxType, reportMode);\n    resolvingExpressions.delete(node);\n    return resolved;\n  }\n\n  /** Resolves an expression to its static type. (may cause stack overflow) */\n  private doResolveExpression(\n    node: Expression,\n    ctxFlow: Flow,\n    ctxType: Type = Type.auto,\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    while (node.kind == NodeKind.Parenthesized) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.Assertion: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Binary: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Call: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Comma: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ElementAccess: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Function: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Identifier:\n      case NodeKind.False:\n      case NodeKind.Null:\n      case NodeKind.True: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.sourceFunction, reportMode\n        );\n      }\n      case NodeKind.This: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Super: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.InstanceOf: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Literal: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.New: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PropertyAccess: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.Ternary: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPostfix: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UnaryPrefix: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False:\n      case NodeKind.Null: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    let name = node.text;\n    let element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    let outerFlow = ctxFlow.outer;\n    if (outerFlow) {\n      if (element = outerFlow.lookup(name)) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return element;\n      }\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.sourceFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.True:\n      case NodeKind.False: return Type.bool;\n      case NodeKind.Null: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    let element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FunctionPrototype) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, new Map(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.Report): bool {\n    if (global.is(CommonFlags.Resolved)) return true;\n    let typeNode = global.typeNode;\n    let type = typeNode\n      ? this.resolveType(typeNode, global.parent, null, reportMode)\n      : this.resolveExpression(\n          assert(global.initializerNode),\n          global.file.startFunction.flow,\n          Type.auto,\n          reportMode\n        );\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetNode = node.expression;\n    let target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    let propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.Global: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.EnumValue:\n      case ElementKind.Local: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        if (type == Type.void) return null; // errored earlier\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PropertyPrototype: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.IndexSignature: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.Class);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.IndexedGet);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FunctionPrototype: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.Resolved)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.Generic)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let ownMember = target.getMember(propertyName);\n          if (!ownMember) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, new Map(), ReportMode.Swallow);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.ClassPrototype:\n      case ElementKind.InterfacePrototype:\n      case ElementKind.Class:\n      case ElementKind.Interface: {\n        do {\n          let member = target.getMember(propertyName);\n          if (member) {\n            if (member.kind == ElementKind.PropertyPrototype) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.Static)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.ClassPrototype ||\n            target.kind == ElementKind.InterfacePrototype\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.Class ||\n            target.kind == ElementKind.Interface\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let member = target.getMember(propertyName);\n        if (member) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return member; // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let targetExpression = node.expression;\n    let targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    expr: IntegerLiteralExpression,\n    /** Has unary minus before literal. */\n    negate: bool,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    let intValue = expr.value;\n    if (negate) {\n      // x + i64.min > 0   ->   underflow\n      if (i64_gt(i64_add(intValue, i64_minimum), i64_zero)) {\n        let range = expr.range;\n        this.error(\n          DiagnosticCode.Literal_0_does_not_fit_into_i64_or_u64_types,\n          range, range.source.text.substring(range.start - 1, range.end)\n        );\n      } else if (i64_eq(intValue, i64_zero)) {\n        // Special handling for -0\n        if (ctxType.isFloatValue) {\n          return ctxType.kind == TypeKind.F32\n            ? Type.f32\n            : Type.f64;\n        } else if (!ctxType.isIntegerValue) {\n          // If it's unknown just always assume this is f64\n          return Type.f64;\n        }\n      }\n      intValue = i64_neg(intValue);\n    }\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.Bool: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.Isize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.Usize: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NonNull: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.Const: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.Class && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.As:\n      case AssertionKind.Prefix: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.sourceFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NonNull: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.Const: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operand = node.operand;\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Minus: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.Integer)) {\n          return this.determineIntegerLiteralType(\n            <IntegerLiteralExpression>operand,\n            true,\n            ctxType\n          );\n        }\n        // fall-through\n      }\n      case Token.Plus:\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.Exclamation: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.Not);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.Tilde: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BitwiseNot);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      case Token.Dot_Dot_Dot: {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            node.range, \"Spread operator\"\n          );\n        }\n        return null;\n      }\n      case Token.TypeOf: {\n        return this.program.stringInstance.type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let operator = node.operator;\n    switch (operator) {\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let left = node.left;\n    let right = node.right;\n    let operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.Equals:\n      case Token.Plus_Equals:\n      case Token.Minus_Equals:\n      case Token.Asterisk_Equals:\n      case Token.Asterisk_Asterisk_Equals:\n      case Token.Slash_Equals:\n      case Token.Percent_Equals:\n      case Token.LessThan_LessThan_Equals:\n      case Token.GreaterThan_GreaterThan_Equals:\n      case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n      case Token.Ampersand_Equals:\n      case Token.Bar_Equals:\n      case Token.Caret_Equals: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LessThan:\n      case Token.GreaterThan:\n      case Token.LessThan_Equals:\n      case Token.GreaterThan_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.Equals_Equals:\n      case Token.Exclamation_Equals: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.Equals_Equals_Equals:\n      case Token.Exclamation_Equals_Equals: {\n        return Type.bool;\n      }\n\n      // in operator\n\n      case Token.In: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.Plus:\n      case Token.Minus:\n      case Token.Asterisk:\n      case Token.Slash:\n      case Token.Percent: // mod has special logic, but also behaves like this\n      case Token.Asterisk_Asterisk: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LessThan_LessThan:\n      case Token.GreaterThan_GreaterThan:\n      case Token.GreaterThan_GreaterThan_GreaterThan: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.Ampersand:\n      case Token.Bar:\n      case Token.Caret: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical\n\n      case Token.Ampersand_Ampersand: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, \"&&\", leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n      case Token.Bar_Bar: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonType(leftType, rightType, ctxType);\n        if (!commonType) {\n          if (reportMode == ReportMode.Report) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, \"||\", leftType.toString(), rightType.toString()\n            );\n          }\n          return null;\n        }\n        // `LHS || RHS` can only be null if both LHS and RHS are null\n        return leftType.is(TypeFlags.Nullable) && rightType.is(TypeFlags.Nullable)\n          ? commonType\n          : commonType.nonNullableType;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    let parent = ctxFlow.sourceFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    let parent: Element | null = ctxFlow.sourceFunction.parent;\n    if (parent && parent.kind == ElementKind.Class) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.Integer: {\n        let intType = this.determineIntegerLiteralType(\n          <IntegerLiteralExpression>node,\n          false,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.Float: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.String:\n      case LiteralKind.Template: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.RegExp: {\n        return this.program.regexpInstance;\n      }\n      case LiteralKind.Array: {\n        let classReference = ctxType.getClass();\n        if (classReference && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.Null && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonType(elementType, currentType, elementType);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            if (reportMode == ReportMode.Report) {\n              this.error(\n                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n                node.range, \"T\"\n              );\n            }\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n      case LiteralKind.Object: {\n        if (ctxType.isClass) return ctxType.classReference;\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            node.range\n          );\n        }\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let targetExpression = node.expression;\n    let target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FunctionPrototype: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let functionInstance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!functionInstance) return null;\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.Function: {\n        return (<Function>target).signature.returnType;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      default: {\n        if (!isTypedElement(target.kind)) break;\n        let targetElement = this.getElementOfType((<TypedElement>target).type);\n        if (!targetElement || targetElement.kind != ElementKind.Class) break;\n        target = targetElement;\n        // fall-through\n      }\n      case ElementKind.Class: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (!(typeArguments && typeArguments.length)) break;\n        let signature = assert(typeArguments[0].getSignature());\n        return signature.returnType;\n      }\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    let elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    let commonType = Type.commonType(thenType, elseType, ctxType);\n    if (!commonType) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let element = this.resolveTypeName(node.typeName, ctxFlow.sourceFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.ClassPrototype) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.sourceFunction,\n        cloneMap(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.Report) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    let element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    let type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Element | null {\n    let type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    let element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Type | null {\n    const declaration = node.declaration;\n    const signature = declaration.signature;\n    const body = declaration.body;\n    let functionType = this.resolveType(signature, ctxFlow.sourceFunction, ctxFlow.contextualTypeArguments, reportMode);\n    if (\n      functionType &&\n      declaration.arrowKind != ArrowKind.None &&\n      body && body.kind == NodeKind.Expression &&\n      isTypeOmitted(signature.returnType)\n    ) {\n      // (x) => ret, infer return type accordingt to `ret`\n      const expr = (<ExpressionStatement>body).expression;\n      let signatureReference = assert(functionType.getSignature());\n      // create a temp flow to resolve expression\n      let tempFlow = Flow.createDefault(ctxFlow.sourceFunction);\n      let parameters = signature.parameters;\n      // return type of resolveFunctionType should have same parameter length with signature\n      assert(signatureReference.parameterTypes.length == parameters.length);\n      for (let i = 0, k = parameters.length; i < k; i++) {\n        const parameter = parameters[i];\n        const type = signatureReference.parameterTypes[i];\n        tempFlow.addScopedDummyLocal(parameter.name.text, type, parameter);\n      }\n      const type = this.resolveExpression(expr, tempFlow, ctxType, reportMode);\n      if (type) {\n        functionType.signatureReference = Signature.create(\n          this.program,\n          signatureReference.parameterTypes,\n          type,\n          signatureReference.thisType,\n          signatureReference.requiredParameters,\n          signatureReference.hasRest,\n        );\n      }\n    }\n    return functionType;\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let classInstance: Class | null = null; // if an instance method\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.Instance)) {\n      classInstance = assert(prototype.getBoundClassOrInterface());\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          // override contextual\n          ctxTypes.set(classTypeParameterName, classTypeArguments[i]);\n        }\n      }\n    } else {\n      assert(!prototype.isBound);\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    let signatureNode = prototype.functionTypeNode;\n    let typeParameterNodes = prototype.typeParameterNodes;\n    let numFunctionTypeArguments: i32;\n    if (typeArguments && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    let thisType: Type | null = null;\n    let explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    let signatureParameters = signatureNode.parameters;\n    let numSignatureParameters = signatureParameters.length;\n    let parameterTypes = new Array<Type>(numSignatureParameters);\n    let requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.Default) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    let returnType: Type;\n    if (prototype.is(CommonFlags.Set)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.Constructor)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    let signature = Signature.create(this.program, parameterTypes, returnType, thisType, requiredParameters);\n\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    let instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n\n    // check against overridden base member\n    if (classInstance) {\n      let methodOrPropertyName = instance.declaration.name.text;\n      let baseClass = classInstance.base;\n      if (baseClass) {\n        let baseMember = baseClass.getMember(methodOrPropertyName);\n        if (baseMember) {\n          // note override discovery (used by stub finalization)\n          this.discoveredOverride = true;\n          // verify that this is a compatible override\n          let incompatibleOverride = true;\n          if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n            if (baseMember.kind == ElementKind.PropertyPrototype) {\n              let baseProperty = this.resolveProperty(<PropertyPrototype>baseMember, reportMode);\n              if (baseProperty) {\n                if (instance.is(CommonFlags.Get)) {\n                  let baseGetter = baseProperty.getterInstance;\n                  if (baseGetter && instance.signature.isAssignableTo(baseGetter.signature, true)) {\n                    incompatibleOverride = false;\n                  }\n                } else {\n                  assert(instance.is(CommonFlags.Set));\n                  let baseSetter = baseProperty.setterInstance;\n                  if (baseSetter && instance.signature.isAssignableTo(baseSetter.signature, true)) {\n                    incompatibleOverride = false;\n                  }\n                }\n              }\n            }\n          } else if (instance.is(CommonFlags.Constructor)) {\n            incompatibleOverride = false;\n          } else {\n            if (baseMember.kind == ElementKind.FunctionPrototype) {\n              // Possibly generic. Resolve with same type arguments to obtain the correct one.\n              let basePrototype = <FunctionPrototype>baseMember;\n              let baseFunction = this.resolveFunction(basePrototype, typeArguments, new Map(), ReportMode.Swallow);\n              if (baseFunction && instance.signature.isAssignableTo(baseFunction.signature, true)) {\n                incompatibleOverride = false;\n              }\n            }\n          }\n          if (incompatibleOverride) {\n            this.errorRelated(\n              DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n              instance.identifierAndSignatureRange, baseMember.identifierAndSignatureRange\n            );\n          }\n        }\n      }\n    }\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Function | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.Instance)) {\n        let classInstance = assert(prototype.getBoundClassOrInterface());\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves reachable overrides of the given instance method. */\n  resolveOverrides(instance: Function): Function[] | null {\n    let overridePrototypes = instance.prototype.unboundOverrides;\n    if (!overridePrototypes) return null;\n\n    let parentClassInstance = assert(instance.getBoundClassOrInterface());\n    let overrides = new Set<Function>();\n\n    // A method's `overrides` property contains its unbound override prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved.\n    for (let _values = Set_values(overridePrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverridePrototype = _values[i];\n      assert(!unboundOverridePrototype.isBound);\n      let unboundOverrideParent = unboundOverridePrototype.parent;\n      let classInstances: Map<string,Class> | null;\n      assert(unboundOverrideParent.kind == ElementKind.ClassPrototype);\n      classInstances = (<ClassPrototype>unboundOverrideParent).instances;\n      if (!classInstances) continue;\n      for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n        let classInstance = _values[j];\n        // Check if the parent class is a subtype of instance's class\n        if (!classInstance.isAssignableTo(parentClassInstance)) continue;\n        let overrideInstance: Function | null = null;\n        if (instance.isAny(CommonFlags.Get | CommonFlags.Set)) {\n          let propertyName = instance.declaration.name.text;\n          let boundPropertyPrototype = assert(classInstance.getMember(propertyName));\n          assert(boundPropertyPrototype.kind == ElementKind.PropertyPrototype);\n          let boundPropertyInstance = this.resolveProperty(<PropertyPrototype>boundPropertyPrototype);\n          if (!boundPropertyInstance) continue;\n          if (instance.is(CommonFlags.Get)) {\n            overrideInstance = boundPropertyInstance.getterInstance;\n          } else {\n            assert(instance.is(CommonFlags.Set));\n            overrideInstance = boundPropertyInstance.setterInstance;\n          }\n        } else {\n          let boundPrototype = classInstance.getMember(unboundOverridePrototype.name);\n          if (boundPrototype) { // might have errored earlier and wasn't added\n            assert(boundPrototype.kind == ElementKind.FunctionPrototype);\n            overrideInstance = this.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n          }\n        }\n        if (overrideInstance) overrides.add(overrideInstance);\n      }\n    }\n    return Set_values(overrides);\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = new Map(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    let instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    let nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += `<${instanceKey}>`;\n    if (prototype.kind == ElementKind.InterfacePrototype) {\n      instance = new Interface(nameInclTypeParameters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParameters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    let pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    let anyPending = false;\n\n    // Resolve base class if applicable\n    let basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        cloneMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n\n    // Implicitly extend `Object` if a derived object\n    } else if (prototype.implicitlyExtendsObject) {\n      instance.setBase(this.program.objectInstance);\n    }\n\n    // Resolve interfaces if applicable\n    let interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          cloneMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.Interface);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Checks whether an override's visibility is valid. */\n  private checkOverrideVisibility(\n    /** Name to report. */\n    name: string,\n    /** Overriding member. */\n    thisMember: DeclaredElement,\n    /** Overriding class. */\n    thisClass: Class,\n    /** Overridden member. */\n    baseMember: DeclaredElement,\n    /** Overridden class. */\n    baseClass: Class,\n    /** Report mode. */\n    reportMode: ReportMode\n  ): bool {\n    let hasErrors = false;\n    if (thisMember.is(CommonFlags.Constructor)) {\n      assert(baseMember.is(CommonFlags.Constructor));\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      }\n    } else if (thisMember.is(CommonFlags.Private)) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Types_have_separate_declarations_of_a_private_property_0,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name\n          );\n        }\n        hasErrors = true;\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, thisClass.internalName, baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      }\n    } else if (thisMember.is(CommonFlags.Protected)) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else if (baseMember.isPublic) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, thisClass.internalName, baseClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else {\n        assert(baseMember.is(CommonFlags.Protected));\n      }\n    } else if (thisMember.isPublic) {\n      if (baseMember.is(CommonFlags.Private)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else if (baseMember.is(CommonFlags.Protected)) {\n        if (reportMode == ReportMode.Report) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n            thisMember.identifierNode.range, baseMember.identifierNode.range,\n            name, baseClass.internalName, thisClass.internalName\n          );\n        }\n        hasErrors = true;\n      } else {\n        assert(baseMember.isPublic);\n      }\n    }\n    return !hasErrors;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    let members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    let pendingClasses = this.resolveClassPending;\n    let unimplemented = new Map<string,DeclaredElement>();\n    // Alias implemented interface members\n    let interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let ifaceMember = assert(ifaceMembers.get(memberName));\n            let existingMember = instance.getMember(memberName);\n            if (existingMember && !this.checkOverrideVisibility(memberName, existingMember, instance, ifaceMember, iface, reportMode)) {\n              continue; // keep previous\n            }\n            members.set(memberName, ifaceMember);\n            unimplemented.set(memberName, ifaceMember);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    let memoryOffset: u32 = 0;\n    let base = instance.base;\n    if (base) {\n      let implicitlyExtendsObject = instance.prototype.implicitlyExtendsObject;\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let baseMember = assert(baseMembers.get(memberName));\n          if (implicitlyExtendsObject && baseMember.is(CommonFlags.Static)) continue;\n          let existingMember = instance.getMember(memberName);\n          if (existingMember && !this.checkOverrideVisibility(memberName, existingMember, instance, baseMember, base, reportMode)) {\n            continue; // keep previous\n          }\n          members.set(memberName, baseMember);\n          if (baseMember.is(CommonFlags.Abstract)) {\n            unimplemented.set(memberName, baseMember);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    let prototype = instance.prototype;\n    let instanceMemberPrototypes = prototype.instanceMembers;\n    let properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        if (base) {\n          let baseMember = base.getMember(memberName);\n          if (baseMember) this.checkOverrideVisibility(memberName, member, instance, baseMember, base, reportMode);\n        }\n        switch (member.kind) {\n          case ElementKind.FunctionPrototype: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PropertyPrototype: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            if (boundPrototype.isField) { // resolve and lay out\n              let boundInstance = this.resolveProperty(boundPrototype, reportMode);\n              if (boundInstance) {\n                let fieldType = boundInstance.type;\n                if (fieldType == Type.void) break; // failed to resolve earlier\n                let needsLayout = true;\n                if (base) {\n                  let existingMember = base.getMember(boundPrototype.name);\n                  if (existingMember && existingMember.kind == ElementKind.PropertyPrototype) {\n                    let existingPrototype = <PropertyPrototype>existingMember;\n                    let existingProperty = this.resolveProperty(existingPrototype, reportMode);\n                    if (existingProperty && existingProperty.isField) {\n                      if (existingProperty.type != boundInstance.type) {\n                        // make sure fields are invariant (Binaryen would otherwise error)\n                        this.errorRelated(\n                          DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n                          boundInstance.identifierNode.range, existingProperty.identifierNode.range,\n                          boundInstance.name, instance.internalName, base.internalName\n                        );\n                        break; // keep existing\n                      }\n                      boundInstance.memoryOffset = existingProperty.memoryOffset;\n                      needsLayout = false;\n                    }\n                  }\n                }\n                if (needsLayout) {\n                  let byteSize = fieldType.byteSize;\n                  assert(isPowerOf2(byteSize));\n                  let mask = byteSize - 1;\n                  if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n                  boundInstance.memoryOffset = memoryOffset;\n                  memoryOffset += byteSize;\n                }\n                boundPrototype.instance = boundInstance;\n                instance.add(boundPrototype.name, boundPrototype); // reports\n                // field materializes here, so check for supported type early\n                // (other checks are performed once an element is compiled)\n                let typeNode = assert(boundPrototype.fieldDeclaration).type;\n                if (typeNode) this.program.checkTypeSupported(fieldType, typeNode);\n              }\n            } else {\n              instance.add(boundPrototype.name, boundPrototype); // reports\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.Abstract)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.Interface) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.Abstract) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.getMember(CommonNames.constructor);\n        if (ctorPrototype && ctorPrototype.parent == instance) {\n          assert(ctorPrototype.kind == ElementKind.FunctionPrototype);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    let overloadPrototypes = prototype.operatorOverloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.Invalid);\n      if (overloadPrototype.is(CommonFlags.Generic)) {\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\n        continue;\n      }\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.Instance)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          new Map(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.operatorOverloads;\n      if (!overloads) instance.operatorOverloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.Instance)) {\n        switch (overloadKind) {\n          case OperatorKind.PrefixInc:\n          case OperatorKind.PrefixDec:\n          case OperatorKind.PostfixInc:\n          case OperatorKind.PostfixDec: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.Report) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.IndexedGet || overloadKind == OperatorKind.IndexedSet) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.IndexedGet) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base == instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface == instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Class | null {\n    let resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.Generic)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.Report) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): Property | null {\n    let instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(\n      prototype,\n      prototype.parent // same level as prototype\n    );\n    let getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    let setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        new Map(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.Resolved)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n\n  private ensureOneTypeArgument(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.Report\n  ): TypeNode | null {\n    let typeArgumentNodes = node.typeArguments;\n    let numTypeArguments = 0;\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\n      if (reportMode == ReportMode.Report) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    return typeArgumentNodes[0];\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\nexport function accuratePow64(x: f64, y: f64): f64 {\n  if (!ASC_TARGET) { // ASC_TARGET == JS\n    // Engines like V8, WebKit and SpiderMonkey uses powi fast path if exponent is integer\n    // This speculative optimization leads to loose precisions like 10 ** 208 != 1e208\n    // or/and 10 ** -5 != 1e-5 anymore. For avoid this behaviour we are forcing exponent\n    // to fractional form and compensate this afterwards.\n    if (isFinite(y) && Math.abs(y) >= 2 && Math.trunc(y) == y) {\n      if (y < 0) {\n        return Math.pow(x, y + 0.5) / Math.pow(x, 0.5);\n      } else {\n        return Math.pow(x, y - 0.5) * Math.pow(x, 0.5);\n      }\n    }\n  }\n  return Math.pow(x, y);\n}\n","/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8\n       | i32(buffer[offset + 2]) << 16\n       | i32(buffer[offset + 3]) << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  let lo = readI32(buffer, offset);\n  let hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  let valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n\n/** Reads a 128-bit vector from the specified buffer. */\nexport function readV128(buffer: Uint8Array, offset: i32): Uint8Array {\n  return buffer.slice(offset, offset + 16);\n}\n\n/** Writes a 128-bit vector to the specified buffer. */\nexport function writeV128(value: Uint8Array, buffer: Uint8Array, offset: i32): void {\n  assert(value.length == 16);\n  buffer.set(value, offset);\n}\n","/**\n * @fileoverview Floating point glue code for WebAssembly.\n * @license Apache-2.0\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@global @inline\nfunction f32_as_i32(value: f32): i32 {\n  return reinterpret<i32>(value);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i32_as_f32(value: i32): f32 {\n  return reinterpret<f32>(value);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction f64_as_i64(value: f64): i64 {\n  return reinterpret<i64>(value);\n}\n\n// @ts-ignore: decorator\n@global @inline\nfunction i64_as_f64(value: i64): f64 {\n  return reinterpret<f64>(value);\n}\n","import {\n  NodeKind,\n  DecoratorKind,\n  LiteralKind,\n  LiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  findDecorator,\n  Source\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ElementKind,\n  Element,\n  Program,\n  Function,\n  Global,\n  Class,\n  Interface,\n  Enum,\n  EnumValue,\n  PropertyPrototype\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags,\n  Signature\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent,\n  isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n// Limitations\n//\n// - Instrumented globals are no longer WebAssembly.Global, hence cannot be\n//   imported the same way as non-instrumented globals would allow. Affects both\n//   globals imported here and globals imported elsewhere.\n//\n// - Since little is known about how class imports and exports will behave,\n//   there is currently no glue generated for them. In IT there appears to be\n//   a concept of protocols that may or may not map in the future. In GC there\n//   doesn't appear to be a connection between classes and their methods so far.\n//\n//   Instead, generated bindings are limited to lifting and lowering of plain\n//   objects when the class has no constructor and no non-public elements. In\n//   any other sitation an internal or external reference is passed.\n//\n// - Linking two instrumented modules with separate bindings produces\n//   intermediate garbage (i.e. goes through a temporary JS object). Any native\n//   mechanism enabling communication between modules directly would help here.\n//\n// - Cycles between the internal and the external GC cannot be resolved. Using\n//   a common GC as envisioned by the GC proposal can help here, but so far it\n//   seems that the same limitations as for IT will remain.\n//\n// - Duplicate Wasm imports don't yet work when instrumentation is required as\n//   provided argument types cannot be told apart when these only come in as\n//   numbers. It might be possible to modify the binary post compilation, but\n//   this has not been attempted yet.\n//\n// Oddities\n//\n// - Interface Types `string` will be incompatible with JavaScript `String` and\n//   it remains unclear how to proceed on this front. We could either use the IT\n//   mechanism and accept potential hazards or keep using unfortunate glue code.\n//\n// - Functions with a variable number of arguments need some special glue to\n//   inform the binary how many arguments have been provided so it can fill in\n//   defaults for the omitted arguments. No native mechanism in sight, yet.\n//\n// - Optional BigInt arguments must be coerced to 0n since JS does not\n//   implicitly coerce from `null` or `undefined`. Numbers do, however.\n//\n// - Generated bindings assume little endian architecture with typed arrays as\n//   it appears to be more efficient than using a DataView and BE use cases\n//   haven't been seen in the wild so far.\n//\n// - It is assumed that generated import bindings call JavaScript and that the\n//   callee expects a properly coerced integer value, leading to more `>>> 0`\n//   coercions than necessary when the import is actually another Wasm module.\n\n/** Maps special imports to their actual modules. */\nfunction importToModule(moduleName: string): string {\n  // Map rtrace via `imports` in package.json\n  if (moduleName == \"rtrace\") return \"#rtrace\";\n  return moduleName;\n}\n\n/** Determines whether a module's imports should be instrumented. */\nfunction shouldInstrument(moduleName: string): bool {\n  return moduleName != \"rtrace\";\n}\n\n/** A JavaScript bindings builder. */\nexport class JSBuilder extends ExportsWalker {\n\n  /** Builds JavaScript bindings for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new JSBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  private needsLiftBuffer: bool = false;\n  private needsLowerBuffer: bool = false;\n  private needsLiftString: bool = false;\n  private needsLowerString: bool = false;\n  private needsLiftArray: bool = false;\n  private needsLowerArray: bool = false;\n  private needsLiftTypedArray: bool = false;\n  private needsLowerTypedArray: bool = false;\n  private needsLiftStaticArray: bool = false;\n  private needsLowerStaticArray: bool = false;\n  private needsLiftInternref: bool = false;\n  private needsLowerInternref: bool = false;\n  private needsRetain: bool = false;\n  private needsRelease: bool = false;\n  private needsNotNull: bool = false;\n  private needsSetU8: bool = false;\n  private needsSetU16: bool = false;\n  private needsSetU32: bool = false;\n  private needsSetU64: bool = false;\n  private needsSetF32: bool = false;\n  private needsSetF64: bool = false;\n  private needsGetI8: bool = false;\n  private needsGetU8: bool = false;\n  private needsGetI16: bool = false;\n  private needsGetU16: bool = false;\n  private needsGetI32: bool = false;\n  private needsGetU32: bool = false;\n  private needsGetI64: bool = false;\n  private needsGetU64: bool = false;\n  private needsGetF32: bool = false;\n  private needsGetF64: bool = false;\n\n  private deferredLifts: Set<Element> = new Set();\n  private deferredLowers: Set<Element> = new Set();\n  private deferredCode: string[] = new Array<string>();\n\n  private exports: string[] = new Array();\n  private importMappings: Map<string,i32> = new Map();\n\n  /** Constructs a new JavaScript bindings builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    this.exports.push(name);\n    if (!isPlainValue(type, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\": {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"valueOf() { return this.value; },\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"get value() {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"return \");\n      this.makeLiftFromValue(\"exports.\" + name + \".value\", type, sb);\n      sb.push(\";\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n      if (!element.is(CommonFlags.Const)) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(\"set value(value) {\\n\");\n        indent(sb, ++this.indentLevel);\n        sb.push(\"exports.\");\n        sb.push(name);\n        sb.push(\".value = \");\n        this.makeLowerToValue(\"value\", type, sb);\n        sb.push(\";\\n\");\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\");\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    this.exports.push(name);\n    indent(sb, this.indentLevel);\n    sb.push(name);\n    sb.push(\": (values => (\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let members = element.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let value = _values[i];\n        if (value.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"values[values.\");\n        sb.push(value.name);\n        if (value.is(CommonFlags.Inlined)) {\n          sb.push(\" = \");\n          sb.push(i64_low((<EnumValue>value).constantIntegerValue).toString());\n        } else {\n          sb.push(\" = exports[\\\"\");\n          sb.push(escapeString(name + \".\" + value.name, CharCode.DoubleQuote));\n          sb.push(\"\\\"].valueOf()\");\n        }\n        sb.push(\"] = \\\"\");\n        sb.push(escapeString(value.name, CharCode.DoubleQuote));\n        sb.push(\"\\\",\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"values\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"))({}),\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  makeGlobalImport(moduleName: string, name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\": \");\n    }\n    let moduleId = this.ensureModuleId(moduleName);\n    if (isPlainValue(type, Mode.Import)) {\n      sb.push(\"(\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(\": \");\n      sb.push(element.type.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"// not supported: cannot lower before instantiate completes\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  makeFunctionImport(moduleName: string, name: string, element: Function, code: string | null = null): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (isIdentifier(name)) {\n      sb.push(name);\n    } else {\n      sb.push(\"\\\"\");\n      sb.push(escapeString(name, CharCode.DoubleQuote));\n      sb.push(\"\\\"\");\n    }\n    if (isPlainFunction(signature, Mode.Import) && !code) {\n      sb.push(\": (\\n\");\n      indent(sb, this.indentLevel + 1);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel + 1);\n      if (moduleName != \"env\") {\n        sb.push(moduleName);\n        sb.push(\".\");\n      }\n      sb.push(name);\n      sb.push(\"\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\")\");\n    } else {\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let parameterNames = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        parameterNames.push(element.getParameterName(i));\n      }\n      sb.push(parameterNames.join(\", \"));\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(element.signature.toString());\n      sb.push(\"\\n\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Export)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          this.makeLiftFromValue(name, type, sb);\n          sb.push(\";\\n\");\n        }\n      }\n      let expr = new Array<string>();\n      let moduleId = this.ensureModuleId(moduleName);\n      if (code) {\n        expr.push(\"(() => {\\n\");\n        indent(expr, 1);\n        expr.push(\"// @external.js\\n\");\n        indentText(code, 1, expr);\n        expr.push(\"\\n})()\");\n      } else {\n        if (moduleName != \"env\") {\n          expr.push(\"__module\");\n          expr.push(moduleId.toString());\n          expr.push(\".\");\n        }\n        expr.push(name);\n        expr.push(\"(\");\n        expr.push(parameterNames.join(\", \"));\n        expr.push(\")\");\n      }\n      code = expr.join(\"\");\n      expr.length = 0;\n      indentText(code, this.indentLevel, expr, true);\n      code = expr.join(\"\");\n      indent(sb, this.indentLevel);\n      if (signature.returnType != Type.void) {\n        sb.push(\"return \");\n        this.makeLowerToValue(code, signature.returnType, sb);\n        sb.push(\";\\n\");\n      } else {\n        sb.push(code);\n        sb.push(\";\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    }\n    sb.push(\",\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.is(CommonFlags.Private)) return;\n    let sb = this.sb;\n    let signature = element.signature;\n    this.exports.push(name);\n    if (!isPlainFunction(signature, Mode.Export)) {\n      indent(sb, this.indentLevel);\n      sb.push(name);\n      sb.push(\"(\");\n      let parameterTypes = signature.parameterTypes;\n      let numReferences = 0;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (parameterTypes[i].isInternalReference) numReferences++;\n        if (i > 0) sb.push(\", \");\n        sb.push(element.getParameterName(i));\n      }\n      sb.push(\") {\\n\");\n      indent(sb, ++this.indentLevel);\n      sb.push(\"// \");\n      sb.push(element.internalName);\n      sb.push(signature.toString());\n      sb.push(\"\\n\");\n      let releases = new Array<string>();\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let type = parameterTypes[i];\n        if (!isPlainValue(type, Mode.Import)) {\n          let name = element.getParameterName(i);\n          indent(sb, this.indentLevel);\n          sb.push(name);\n          sb.push(\" = \");\n          let needsRetainRelease = type.isInternalReference && --numReferences > 0;\n          if (needsRetainRelease) {\n            this.needsRetain = true;\n            this.needsRelease = true;\n            sb.push(\"__retain(\");\n            releases.push(name);\n          }\n          this.makeLowerToValue(name, type, sb);\n          if (needsRetainRelease) {\n            sb.push(\")\");\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      if (releases.length) {\n        indent(sb, this.indentLevel++);\n        sb.push(\"try {\\n\");\n      }\n      if (signature.requiredParameters < parameterTypes.length) {\n        indent(sb, this.indentLevel);\n        sb.push(\"exports.__setArgumentsLength(arguments.length);\\n\");\n      }\n      const expr = new Array<string>();\n      expr.push(\"exports.\");\n      expr.push(name);\n      expr.push(\"(\");\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        if (i > 0) expr.push(\", \");\n        expr.push(element.getParameterName(i));\n      }\n      expr.push(\")\");\n      if (signature.returnType != Type.void) {\n        indent(sb, this.indentLevel);\n        sb.push(\"return \");\n        this.makeLiftFromValue(expr.join(\"\"), signature.returnType, sb);\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(expr.join(\"\"));\n      }\n      sb.push(\";\\n\");\n      if (releases.length) {\n        indent(sb, this.indentLevel - 1);\n        sb.push(\"} finally {\\n\");\n        for (let i = 0, k = releases.length; i < k; ++i) {\n          indent(sb, this.indentLevel);\n          sb.push(\"__release(\");\n          sb.push(releases[i]);\n          sb.push(\");\\n\");\n        }\n        indent(sb, --this.indentLevel);\n        sb.push(\"}\\n\");\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"},\\n\");\n    }\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n    // let sb = this.sb;\n    // sb.push(\"export const \");\n    // sb.push(name);\n    // sb.push(\" = \");\n    // sb.push(originalName);\n    // sb.push(\";\\n\");\n  }\n\n  getExternalCode(element: Function): string | null {\n    let decorator = findDecorator(DecoratorKind.ExternalJs, element.decoratorNodes);\n    if (decorator) {\n      let args = decorator.args;\n      if (args && args.length == 1) {\n        let codeArg = args[0];\n        if (codeArg.kind == NodeKind.Literal) {\n          let literal = <LiteralExpression>codeArg;\n          if (literal.literalKind == LiteralKind.String) {\n            return (<StringLiteralExpression>literal).value;\n          }\n          if (literal.literalKind == LiteralKind.Template) {\n            let parts = (<TemplateLiteralExpression>literal).parts;\n            if (parts.length == 1) {\n              return parts[0];\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  build(): string {\n    let exports = this.exports;\n    let moduleImports = this.program.moduleImports;\n    let program = this.program;\n    let options = program.options;\n    let sb = this.sb;\n\n    sb.push(\"\"); // placeholder\n    indent(sb, this.indentLevel++);\n    if (!this.esm) sb.push(\"export \");\n    sb.push(\"async function instantiate(module, imports = {}) {\\n\");\n    const insertPos = sb.push(\"\") - 1;\n\n    // Instrument module imports. Keeps raw (JS) imports on the respective\n    // prototypes and overrides selectively where instrumentation is required.\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedImports = {\\n\");\n    let sbLengthBefore = sb.length;\n    for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      let moduleId = this.ensureModuleId(moduleName);\n      let module = <Map<string,Element>>moduleImports.get(moduleName);\n      indent(sb, this.indentLevel);\n      if (isIdentifier(moduleName)) {\n        sb.push(moduleName);\n      } else {\n        sb.push(\"\\\"\");\n        sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n        sb.push(\"\\\"\");\n      }\n      if (!shouldInstrument(moduleName)) {\n        sb.push(\": __module\");\n        sb.push(moduleId.toString());\n        sb.push(\",\\n\");\n        continue;\n      }\n      let resetPos = sb.length;\n      sb.push(\": Object.assign(Object.create(\");\n      if (moduleName == \"env\") {\n        sb.push(\"globalThis\");\n      } else {\n        sb.push(\"__module\");\n        sb.push(moduleId.toString());\n      }\n      sb.push(\"), \");\n      if (moduleName == \"env\") {\n        sb.push(\"imports.env || {}, \");\n      }\n      sb.push(\"{\\n\");\n      ++this.indentLevel;\n      let numInstrumented = 0;\n      for (let _keys2 = Map_keys(module), j = 0, l = _keys2.length; j < l; ++j) {\n        let name = _keys2[j];\n        let elem = assert(module.get(name));\n        if (elem.kind == ElementKind.Function) {\n          let func = <Function>elem;\n          let code = this.getExternalCode(func);\n          if (!isPlainFunction(func.signature, Mode.Import) || !isIdentifier(name) || code) {\n            this.makeFunctionImport(moduleName, name, <Function>elem, code);\n            ++numInstrumented;\n          }\n        } else if (elem.kind == ElementKind.Global) {\n          let global = <Global>elem;\n          if (!isPlainValue(global.type, Mode.Import) || !isIdentifier(name)) {\n            this.makeGlobalImport(moduleName, name, global);\n            ++numInstrumented;\n          }\n        }\n      }\n      --this.indentLevel;\n      if (!numInstrumented) {\n        sb.length = resetPos;\n        if (moduleName == \"env\") {\n          sb.push(\": Object.assign(Object.create(globalThis), imports.env || {})\");\n        } else {\n          sb.push(\": __module\");\n          sb.push(moduleId.toString());\n        }\n        sb.push(\",\\n\");\n      } else {\n        indent(sb, this.indentLevel);\n        sb.push(\"}),\\n\");\n      }\n    }\n    --this.indentLevel;\n    let hasAdaptedImports = sb.length > sbLengthBefore;\n    if (hasAdaptedImports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"};\\n\");\n    } else {\n      sb.length = sbLengthBefore - 2; // incl. indent\n    }\n\n    let mappings = this.importMappings;\n    let map = new Array<string>();\n    for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n      let moduleName = _keys[i];\n      if (moduleName == \"env\") {\n        map.push(\"  const env = imports.env;\\n\");\n      } else {\n        let moduleId = <i32>mappings.get(moduleName);\n        if (moduleName == \"rtrace\") {\n          // Rtrace is special in that it needs to be installed on the imports\n          // object. Use sensible defaults and substitute the original import.\n          map.push(\"  ((rtrace) => {\\n\");\n          map.push(\"    delete imports.rtrace;\\n\");\n          map.push(\"    new rtrace.Rtrace({ getMemory() { return memory; }, onerror(err) { console.log(`RTRACE: ${err.stack}`); } }).install(imports);\\n\");\n          map.push(\"  })(imports.rtrace);\\n\");\n        }\n        map.push(\"  const __module\");\n        map.push(moduleId.toString());\n        map.push(\" = imports\");\n        if (isIdentifier(moduleName)) {\n          map.push(\".\");\n          map.push(moduleName);\n        } else {\n          map.push(\"[\\\"\");\n          map.push(escapeString(moduleName, CharCode.DoubleQuote));\n          map.push(\"\\\"]\");\n        }\n        map.push(\";\\n\");\n      }\n    }\n    sb[insertPos] = map.join(\"\");\n\n    indent(sb, this.indentLevel);\n    sb.push(\"const { exports } = await WebAssembly.instantiate(module\");\n    if (hasAdaptedImports) {\n      sb.push(\", adaptedImports);\\n\");\n    } else {\n      sb.push(\", imports);\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"const memory = exports.memory || imports.env.memory;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"const adaptedExports = Object.setPrototypeOf({\\n\");\n    sbLengthBefore = sb.length;\n\n    // Instrument module exports. Keeps raw (Wasm) exports on the prototype and\n    // overrides selectively where instrumentation is required.\n    this.walk();\n    --this.indentLevel;\n    let hasAdaptedExports = sb.length > sbLengthBefore;\n    if (hasAdaptedExports) {\n      indent(sb, this.indentLevel);\n      sb.push(\"}, exports);\\n\");\n    } else {\n      if (\n        this.needsLiftBuffer || this.needsLowerBuffer ||\n        this.needsLiftString || this.needsLowerString ||\n        this.needsLiftArray || this.needsLowerArray ||\n        this.needsLiftTypedArray || this.needsLowerTypedArray ||\n        this.needsLiftStaticArray\n      ) {\n        sb.length = sbLengthBefore - 2; // skip adaptedExports + 1x indent\n      } else {\n        sb.length = sbLengthBefore - 4; // skip memory and adaptedExports + 2x indent\n      }\n    }\n\n    // Add external JS code fragments\n    let deferredCode = this.deferredCode;\n    if (deferredCode.length) {\n      for (let i = 0, k = deferredCode.length; i < k; ++i) {\n        sb.push(deferredCode[i]);\n      }\n    }\n\n    // Add the respective lifting and lowering adapters\n    if (this.needsLiftBuffer) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      sb.push(`  function __liftBuffer(pointer) {\n    if (!pointer) return null;\n    return memory.buffer.slice(pointer, pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2]);\n  }\n`);\n    }\n    if (this.needsLowerBuffer) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      sb.push(`  function __lowerBuffer(value) {\n    if (value == null) return 0;\n    const pointer = exports.__new(value.byteLength, ${arrayBufferId}) >>> 0;\n    new Uint8Array(memory.buffer).set(new Uint8Array(value), pointer);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftString) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      let chunkSize = 1024;\n      sb.push(`  function __liftString(pointer) {\n    if (!pointer) return null;\n    const\n      end = pointer + new Uint32Array(memory.buffer)[pointer - ${-rtSizeOffset} >>> 2] >>> 1,\n      memoryU16 = new Uint16Array(memory.buffer);\n    let\n      start = pointer >>> 1,\n      string = \"\";\n    while (end - start > ${chunkSize}) string += String.fromCharCode(...memoryU16.subarray(start, start += ${chunkSize}));\n    return string + String.fromCharCode(...memoryU16.subarray(start, end));\n  }\n`);\n    }\n    if (this.needsLowerString) {\n      let stringId = program.stringInstance.id;\n      sb.push(`  function __lowerString(value) {\n    if (value == null) return 0;\n    const\n      length = value.length,\n      pointer = exports.__new(length << 1, ${stringId}) >>> 0,\n      memoryU16 = new Uint16Array(memory.buffer);\n    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);\n    return pointer;\n  }\n`);\n    }\n    if (this.needsLiftArray) {\n      let dataStartOffset = program.arrayBufferViewInstance.offsetof(\"dataStart\");\n      let lengthOffset = program.arrayBufferViewInstance.nextMemoryOffset;\n      this.needsGetU32 = true;\n      sb.push(`  function __liftArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      dataStart = __getU32(pointer + ${dataStartOffset}),\n      length = __dataview.getUint32(pointer + ${lengthOffset}, true),\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(dataStart + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let arraySize = arrayBufferViewInstance.nextMemoryOffset + 4; // + length\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      let lengthOffset = byteLengthOffset + 4;\n      this.needsSetU32 = true;\n      sb.push(`  function __lowerArray(lowerElement, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__pin(exports.__new(${arraySize}, id)) >>> 0;\n    __setU32(header + ${bufferOffset}, buffer);\n    __dataview.setUint32(header + ${dataStartOffset}, buffer, true);\n    __dataview.setUint32(header + ${byteLengthOffset}, length << align, true);\n    __dataview.setUint32(header + ${lengthOffset}, length, true);\n    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);\n    exports.__unpin(buffer);\n    exports.__unpin(header);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftTypedArray) {\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      this.needsGetU32 = true;\n      sb.push(`  function __liftTypedArray(constructor, pointer) {\n    if (!pointer) return null;\n    return new constructor(\n      memory.buffer,\n      __getU32(pointer + ${dataStartOffset}),\n      __dataview.getUint32(pointer + ${byteLengthOffset}, true) / constructor.BYTES_PER_ELEMENT\n    ).slice();\n  }\n`);\n    }\n    if (this.needsLowerTypedArray) {\n      let arrayBufferId = program.arrayBufferInstance.id;\n      let arrayBufferViewInstance = program.arrayBufferViewInstance;\n      let size = arrayBufferViewInstance.nextMemoryOffset;\n      let bufferOffset = arrayBufferViewInstance.offsetof(\"buffer\");\n      let dataStartOffset = arrayBufferViewInstance.offsetof(\"dataStart\");\n      let byteLengthOffset = arrayBufferViewInstance.offsetof(\"byteLength\");\n      this.needsSetU32 = true;\n      sb.push(`  function __lowerTypedArray(constructor, id, align, values) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, ${arrayBufferId})) >>> 0,\n      header = exports.__new(${size}, id) >>> 0;\n    __setU32(header + ${bufferOffset}, buffer);\n    __dataview.setUint32(header + ${dataStartOffset}, buffer, true);\n    __dataview.setUint32(header + ${byteLengthOffset}, length << align, true);\n    new constructor(memory.buffer, buffer, length).set(values);\n    exports.__unpin(buffer);\n    return header;\n  }\n`);\n    }\n    if (this.needsLiftStaticArray) {\n      let objectInstance = program.OBJECTInstance;\n      let rtSizeOffset = objectInstance.offsetof(\"rtSize\") - objectInstance.nextMemoryOffset;\n      this.needsGetU32 = true;\n      sb.push(`  function __liftStaticArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      length = __getU32(pointer - ${-rtSizeOffset}) >>> align,\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(pointer + (i << align >>> 0));\n    return values;\n  }\n`);\n    }\n    if (this.needsLowerStaticArray) {\n      sb.push(`  function __lowerStaticArray(lowerElement, id, align, values, typedConstructor) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, id)) >>> 0;\n    if (typedConstructor) {\n      new typedConstructor(memory.buffer, buffer, length).set(values);\n    } else {\n      for (let i = 0; i < length; i++) lowerElement(buffer + (i << align >>> 0), values[i]);\n    }\n    exports.__unpin(buffer);\n    return buffer;\n  }\n`);\n    }\n    if (this.needsLiftInternref || this.needsLowerInternref) {\n      sb.push(\"  class Internref extends Number {}\\n\");\n    }\n    if (this.needsLiftInternref) {\n      this.needsRetain = true;\n      this.needsRelease = true;\n      sb.push(`  const registry = new FinalizationRegistry(__release);\n  function __liftInternref(pointer) {\n    if (!pointer) return null;\n    const sentinel = new Internref(__retain(pointer));\n    registry.register(sentinel, pointer);\n    return sentinel;\n  }\n`);\n    }\n    if (this.needsLowerInternref) {\n      sb.push(`  function __lowerInternref(value) {\n    if (value == null) return 0;\n    if (value instanceof Internref) return value.valueOf();\n    throw TypeError(\"internref expected\");\n  }\n`);\n    }\n    if (this.needsRetain || this.needsRelease) {\n      sb.push(`  const refcounts = new Map();\n`);\n    }\n    if (this.needsRetain) {\n      sb.push(`  function __retain(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount) refcounts.set(pointer, refcount + 1);\n      else refcounts.set(exports.__pin(pointer), 1);\n    }\n    return pointer;\n  }\n`);\n    }\n    if (this.needsRelease) {\n      sb.push(`  function __release(pointer) {\n    if (pointer) {\n      const refcount = refcounts.get(pointer);\n      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);\n      else if (refcount) refcounts.set(pointer, refcount - 1);\n      else throw Error(\\`invalid refcount '\\${refcount}' for reference '\\${pointer}'\\`);\n    }\n  }\n`);\n    }\n    if (this.needsNotNull) {\n      sb.push(`  function __notnull() {\n    throw TypeError(\"value must not be null\");\n  }\n`);\n    }\n    if (\n      this.needsSetU8 ||\n      this.needsSetU16 ||\n      this.needsSetU32 ||\n      this.needsSetU64 ||\n      this.needsSetF32 ||\n      this.needsSetF64 ||\n      this.needsGetI8 ||\n      this.needsGetU8 ||\n      this.needsGetI16 ||\n      this.needsGetU16 ||\n      this.needsGetI32 ||\n      this.needsGetU32 ||\n      this.needsGetI64 ||\n      this.needsGetU64 ||\n      this.needsGetF32 ||\n      this.needsGetF64\n    ) {\n      sb.push(\"  let __dataview = new DataView(memory.buffer);\\n\");\n    }\n    if (this.needsSetU8) sb.push(makeCheckedSetter(\"U8\", \"setUint8\"));\n    if (this.needsSetU16) sb.push(makeCheckedSetter(\"U16\", \"setUint16\"));\n    if (this.needsSetU32) sb.push(makeCheckedSetter(\"U32\", \"setUint32\"));\n    if (this.needsSetU64) sb.push(makeCheckedSetter(\"U64\", \"setBigUint64\"));\n    if (this.needsSetF32) sb.push(makeCheckedSetter(\"F32\", \"setFloat32\"));\n    if (this.needsSetF64) sb.push(makeCheckedSetter(\"F64\", \"setFloat64\"));\n    if (this.needsGetI8) sb.push(makeCheckedGetter(\"I8\", \"getInt8\"));\n    if (this.needsGetU8) sb.push(makeCheckedGetter(\"U8\", \"getUint8\"));\n    if (this.needsGetI16) sb.push(makeCheckedGetter(\"I16\", \"getInt16\"));\n    if (this.needsGetU16) sb.push(makeCheckedGetter(\"U16\", \"getUint16\"));\n    if (this.needsGetI32) sb.push(makeCheckedGetter(\"I32\", \"getInt32\"));\n    if (this.needsGetU32) sb.push(makeCheckedGetter(\"U32\", \"getUint32\"));\n    if (this.needsGetI64) sb.push(makeCheckedGetter(\"I64\", \"getBigInt64\"));\n    if (this.needsGetU64) sb.push(makeCheckedGetter(\"U64\", \"getBigUint64\"));\n    if (this.needsGetF32) sb.push(makeCheckedGetter(\"F32\", \"getFloat32\"));\n    if (this.needsGetF64) sb.push(makeCheckedGetter(\"F64\", \"getFloat64\"));\n\n    let exportStart = options.exportStart;\n    if (exportStart) {\n      sb.push(`  exports.${exportStart}();\\n`);\n    }\n\n    if (hasAdaptedExports) {\n      sb.push(\"  return adaptedExports;\\n}\\n\");\n    } else {\n      sb.push(\"  return exports;\\n}\\n\");\n    }\n    --this.indentLevel;\n    assert(this.indentLevel == 0);\n\n    if (this.esm) {\n      sb.push(\"export const {\\n  \");\n      if (this.program.options.exportMemory) {\n        sb.push(\"memory,\\n  \");\n      }\n      if (this.program.options.exportTable) {\n        sb.push(\"table,\\n  \");\n      }\n      for (let i = 0, k = exports.length; i < k; ++i) {\n        if (i > 0) sb.push(\",\\n  \");\n        sb.push(exports[i]);\n      }\n      sb.push(`\n} = await (async url => instantiate(\n  await (async () => {\n    try { return await globalThis.WebAssembly.compileStreaming(globalThis.fetch(url)); }\n    catch { return globalThis.WebAssembly.compile(await (await import(\"node:fs/promises\")).readFile(url)); }\n  })(), {\n`);\n      let needsMaybeDefault = false;\n      let importExpr = new Array<string>();\n      for (let _keys = Map_keys(mappings), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        if (moduleName == \"env\") {\n          indent(sb, 2);\n          sb.push(\"env: globalThis,\\n\");\n        } else {\n          let moduleId = this.ensureModuleId(moduleName);\n          indent(sb, 2);\n          if (isIdentifier(moduleName)) {\n            sb.push(moduleName);\n          } else {\n            sb.push(\"\\\"\");\n            sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n            sb.push(\"\\\"\");\n          }\n          sb.push(\": __maybeDefault(__import\");\n          sb.push(moduleId.toString());\n          sb.push(\"),\\n\");\n          importExpr.push(\"import * as __import\");\n          importExpr.push(moduleId.toString());\n          importExpr.push(\" from \\\"\");\n          importExpr.push(escapeString(importToModule(moduleName), CharCode.DoubleQuote));\n          importExpr.push(\"\\\";\\n\");\n          needsMaybeDefault = true;\n        }\n      }\n      sb[0] = importExpr.join(\"\");\n      sb.push(`  }\n))(new URL(\"${escapeString(options.basenameHint, CharCode.DoubleQuote)}.wasm\", import.meta.url));\n`);\n      if (needsMaybeDefault) {\n        sb.push(`function __maybeDefault(module) {\n  return typeof module.default === \"object\" && Object.keys(module).length == 1\n    ? module.default\n    : module;\n}\n`);\n      }\n    }\n    return sb.join(\"\");\n  }\n\n  ensureModuleId(moduleName: string): i32 {\n    if (moduleName == \"env\") return -1;\n    let importMap = this.importMappings;\n    let moduleId = importMap.has(moduleName)\n      ? i32(importMap.get(moduleName))\n      : importMap.size;\n    importMap.set(moduleName, moduleId);\n    return moduleId;\n  }\n\n  /** Lifts a WebAssembly value to a JavaScript value, as an expression. */\n  makeLiftFromValue(valueExpr: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lift reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__liftBuffer(\");\n        this.needsLiftBuffer = true;\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"__liftString(\");\n        this.needsLiftString = true;\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftArray(\");\n        this.makeLiftFromMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftArray = true;\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__liftStaticArray(\");\n        this.makeLiftFromMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLiftStaticArray = true;\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        sb.push(\"__liftTypedArray(\");\n        if (clazz.name == \"Uint64Array\") {\n          sb.push(\"BigUint64Array\");\n        } else if (clazz.name == \"Int64Array\") {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        this.needsLiftTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__liftRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLifts.has(clazz)) {\n          this.deferredLifts.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLiftRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__liftInternref(\");\n        this.needsLiftInternref = true;\n      }\n      sb.push(valueExpr);\n      if (!valueExpr.startsWith(\"__get\")) {\n        // no need to coerce when lifting with indirection\n        sb.push(\" >>> 0\");\n      }\n      sb.push(\")\");\n    } else {\n      // Lift and coerce basic values (from a Wasm export)\n      if (type == Type.bool) { // i32 to boolean\n        sb.push(`${valueExpr} != 0`);\n      } else if (type.isUnsignedIntegerValue && type.size >= 32) {\n        if (type.size == 64) { // i64 to unsigned bigint\n          sb.push(`BigInt.asUintN(64, ${valueExpr})`);\n        } else { // i32 to unsigned\n          sb.push(`${valueExpr} >>> 0`);\n        }\n      } else {\n        sb.push(valueExpr);\n      }\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly value, as an expression. */\n  makeLowerToValue(valueExpr: string, type: Type, sb: string[] = this.sb): void {\n    if (type.isInternalReference) {\n      // Lower reference types\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"__lowerBuffer(\");\n        this.needsLowerBuffer = true;\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"__lowerString(\");\n        this.needsLowerString = true;\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerArray(\");\n        this.makeLowerToMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerArray = true;\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerStaticArray(\");\n        this.makeLowerToMemoryFunc(valueType, sb);\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(valueType.alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerStaticArray = true;\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        let valueType = clazz.getArrayValueType();\n        sb.push(\"__lowerTypedArray(\");\n        if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else {\n          sb.push(clazz.name); // TODO: what if extended?\n        }\n        sb.push(\", \");\n        sb.push(clazz.id.toString());\n        sb.push(\", \");\n        sb.push(clazz.getArrayValueType().alignLog2.toString());\n        sb.push(\", \");\n        this.needsLowerTypedArray = true;\n      } else if (isPlainObject(clazz)) {\n        sb.push(\"__lowerRecord\");\n        sb.push(clazz.id.toString());\n        sb.push(\"(\");\n        if (!this.deferredLowers.has(clazz)) {\n          this.deferredLowers.add(clazz);\n          let prevIndentLevel = this.indentLevel;\n          this.indentLevel = 1;\n          this.deferredCode.push(this.makeLowerRecord(clazz));\n          this.indentLevel = prevIndentLevel;\n        }\n      } else {\n        sb.push(\"__lowerInternref(\");\n        this.needsLowerInternref = true;\n      }\n      sb.push(valueExpr);\n      if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        // optional last argument for __lowerStaticArray\n        let valueType = clazz.getArrayValueType();\n        if (valueType.isNumericValue) {\n          sb.push(\", \");\n          if (valueType == Type.u8 || valueType == Type.bool) {\n            sb.push(\"Uint8Array\");\n          } else if (valueType == Type.i8) {\n            sb.push(\"Int8Array\");\n          } else if (valueType == Type.u16) {\n            sb.push(\"Uint16Array\");\n          } else if (valueType == Type.i16) {\n            sb.push(\"Int16Array\");\n          } else if (valueType == Type.u32 || valueType == Type.usize32) {\n            sb.push(\"Uint32Array\");\n          } else if (valueType == Type.i32 || valueType == Type.isize32) {\n            sb.push(\"Int32Array\");\n          } else if (valueType == Type.u64 || valueType == Type.usize64) {\n            sb.push(\"BigUint64Array\");\n          } else if (valueType == Type.i64 || valueType == Type.isize64) {\n            sb.push(\"BigInt64Array\");\n          } else if (valueType == Type.f32) {\n            sb.push(\"Float32Array\");\n          } else if (valueType == Type.f64) {\n            sb.push(\"Float64Array\");\n          } else {\n            // unreachable\n            assert(false);\n          }\n        }\n      }\n      sb.push(\")\");\n      if (!type.is(TypeFlags.Nullable)) {\n        this.needsNotNull = true;\n        sb.push(\" || __notnull()\");\n      }\n    } else {\n      // Lower basic types\n      sb.push(valueExpr); // basic value\n      if (type.isIntegerValue && type.size == 64) {\n        sb.push(\" || 0n\");\n      } else if (type == Type.bool) {\n        // may be stored to an Uint8Array, make sure to store 1/0\n        sb.push(\" ? 1 : 0\");\n      }\n    }\n  }\n\n  ensureLiftFromMemoryFn(valueType: Type): string {\n    if (valueType.isInternalReference) {\n      if (this.program.options.isWasm64) {\n        this.needsGetU64 = true;\n        return \"__getU64\";\n      } else {\n        this.needsGetU32 = true;\n        return \"__getU32\";\n      }\n    }\n    if (valueType == Type.i8) {\n      this.needsGetI8 = true;\n      return \"__getI8\";\n    }\n    if (valueType == Type.u8 || valueType == Type.bool) {\n      this.needsGetU8 = true;\n      return \"__getU8\";\n    }\n    if (valueType == Type.i16) {\n      this.needsGetI16 = true;\n      return \"__getI16\";\n    }\n    if (valueType == Type.u16) {\n      this.needsGetU16 = true;\n      return \"__getU16\";\n    }\n    if (valueType == Type.i32 || valueType == Type.isize32) {\n      this.needsGetI32 = true;\n      return \"__getI32\";\n    }\n    if (valueType == Type.u32 || valueType == Type.usize32) {\n      this.needsGetU32 = true;\n      return \"__getU32\";\n    }\n    if (valueType == Type.i64 || valueType == Type.isize64) {\n      this.needsGetI64 = true;\n      return \"__getI64\";\n    }\n    if (valueType == Type.u64 || valueType == Type.usize64) {\n      this.needsGetU64 = true;\n      return \"__getU64\";\n    }\n    if (valueType == Type.f32) {\n      this.needsGetF32 = true;\n      return \"__getF32\";\n    }\n    if (valueType == Type.f64) {\n      this.needsGetF64 = true;\n      return \"__getF64\";\n    }\n    return \"(() => { throw Error(\\\"unsupported type\\\"); })\";\n  }\n\n  /** Lifts a WebAssembly memory address to a JavaScript value, as a function. */\n  makeLiftFromMemoryFunc(valueType: Type, sb: string[] = this.sb): void {\n    let fn = this.ensureLiftFromMemoryFn(valueType);\n    if (\n      // Compound or with coercion, see makeLiftFromValue\n      valueType.isInternalReference ||\n      valueType == Type.bool ||\n      (valueType.isUnsignedIntegerValue && valueType.size >= 32)\n    ) {\n      sb.push(\"pointer => \");\n      this.makeLiftFromValue(`${fn}(pointer)`, valueType, sb);\n    } else {\n      sb.push(fn);\n    }\n  }\n\n  /** Lifts a WebAssembly memory address to a JavaScript value, as a call. */\n  makeLiftFromMemoryCall(valueType: Type, sb: string[] = this.sb, pointerExpr: string = \"pointer\"): void {\n    let fn = this.ensureLiftFromMemoryFn(valueType);\n    if (valueType.isInternalReference) {\n      this.makeLiftFromValue(`${fn}(${pointerExpr})`, valueType, sb);\n    } else {\n      sb.push(fn);\n      sb.push(\"(\");\n      sb.push(pointerExpr);\n      sb.push(\")\");\n      if (valueType == Type.bool) {\n        sb.push(\" != 0\");\n      }\n      // Other integers are known to be coerced here by loading from a view\n    }\n  }\n\n  ensureLowerToMemoryFn(valueType: Type): string {\n    if (valueType.isInternalReference) {\n      if (this.program.options.isWasm64) {\n        this.needsSetU64 = true;\n        return \"__setU64\";\n      } else {\n        this.needsSetU32 = true;\n        return \"__setU32\";\n      }\n    }\n    if (valueType == Type.i8 || valueType == Type.u8 || valueType == Type.bool) {\n      this.needsSetU8 = true;\n      return \"__setU8\";\n    }\n    if (valueType == Type.i16 || valueType == Type.u16) {\n      this.needsSetU16 = true;\n      return \"__setU16\";\n    }\n    if (valueType == Type.i32 || valueType == Type.u32 || valueType == Type.isize32 || valueType == Type.usize32) {\n      this.needsSetU32 = true;\n      return \"__setU32\";\n    }\n    if (valueType == Type.i64 || valueType == Type.u64 || valueType == Type.isize64 || valueType == Type.usize64) {\n      this.needsSetU64 = true;\n      return \"__setU64\";\n    }\n    if (valueType == Type.f32) {\n      this.needsSetF32 = true;\n      return \"__setF32\";\n    }\n    if (valueType == Type.f64) {\n      this.needsSetF64 = true;\n      return \"__setF64\";\n    }\n    return \"(() => { throw Error(\\\"unsupported type\\\") })\";\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly memory address, as a function. */\n  makeLowerToMemoryFunc(valueType: Type, sb: string[] = this.sb): void {\n    let fn = this.ensureLowerToMemoryFn(valueType);\n    if (valueType.isInternalReference) {\n      sb.push(\"(pointer, value) => { \");\n      sb.push(fn);\n      sb.push(\"(pointer, \");\n      this.makeLowerToValue(\"value\", valueType, sb);\n      sb.push(\"); }\");\n    } else {\n      sb.push(fn);\n    }\n  }\n\n  /** Lowers a JavaScript value to a WebAssembly memory address, as a call. */\n  makeLowerToMemoryCall(valueType: Type, sb: string[] = this.sb, pointerExpr: string = \"pointer\", valueExpr: string = \"value\"): void {\n    let fn = this.ensureLowerToMemoryFn(valueType);\n    sb.push(fn);\n    sb.push(\"(\");\n    sb.push(pointerExpr);\n    sb.push(\", \");\n    this.makeLowerToValue(valueExpr, valueType, sb);\n    sb.push(\")\");\n  }\n\n  makeLiftRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __liftRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(pointer) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lifting as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (!pointer) return null;\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"return {\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        assert(property.memoryOffset >= 0);\n        indent(sb, this.indentLevel);\n        sb.push(property.name);\n        sb.push(\": \");\n        this.makeLiftFromMemoryCall(property.type, sb, `pointer + ${property.memoryOffset}`);\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  makeLowerRecord(clazz: Class): string {\n    assert(isPlainObject(clazz));\n    let sb = new Array<string>();\n    indent(sb, this.indentLevel);\n    sb.push(\"function __lowerRecord\");\n    sb.push(clazz.id.toString());\n    sb.push(\"(value) {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"// \");\n    sb.push(clazz.type.toString());\n    sb.push(\"\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"// Hint: Opt-out from lowering as a record by providing an empty constructor\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"if (value == null) return 0;\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"const pointer = exports.__pin(exports.__new(\");\n    sb.push(clazz.nextMemoryOffset.toString());\n    sb.push(\", \");\n    sb.push(clazz.id.toString());\n    sb.push(\"));\\n\");\n    let members = clazz.members;\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        assert(property.memoryOffset >= 0);\n        indent(sb, this.indentLevel);\n        this.makeLowerToMemoryCall(property.type, sb, `pointer + ${property.memoryOffset}`, `value.${memberName}`);\n        sb.push(\";\\n\");\n      }\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\"exports.__unpin(pointer);\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"return pointer;\\n\");\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  Import,\n  Export\n}\n\nfunction isPlainValue(type: Type, kind: Mode): bool {\n  if (kind == Mode.Import) {\n    // may be stored to an Uint8Array, make sure to store 1/0\n    if (type == Type.bool) return false;\n    // requires coercion of undefined to 0n\n    if (type.isIntegerValue && type.size == 64) return false;\n  } else {\n    // requires coercion from 1/0 to true/false\n    if (type == Type.bool) return false;\n    // requires coercion from signed to unsigned for u32 and u64.\n    // Note, u8 and u16 doesn't overflow in native type so mark as plain\n    if (type.isUnsignedIntegerValue && type.size >= 32) return false;\n  }\n  return !type.isInternalReference;\n}\n\nfunction isPlainFunction(signature: Signature, mode: Mode): bool {\n  let parameterTypes = signature.parameterTypes;\n  let inverseMode = mode == Mode.Import ? Mode.Export : Mode.Import;\n  if (!isPlainValue(signature.returnType, mode)) return false;\n  for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n    if (!isPlainValue(parameterTypes[i], inverseMode)) return false;\n  }\n  return true;\n}\n\nfunction isPlainObject(clazz: Class): bool {\n  // A plain object does not inherit and does not have a constructor or private properties\n  if (clazz.base && !clazz.prototype.implicitlyExtendsObject) return false;\n  let members = clazz.members;\n  if (members) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = _values[i];\n      if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n      if (member.is(CommonFlags.Constructor)) {\n        // a generated constructor is ok\n        if (member.declaration.range != Source.native.range) return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction indentText(text: string, indentLevel: i32, sb: string[], butFirst: bool = false): void {\n  let lineStart = 0;\n  let length = text.length;\n  let pos = 0;\n  while (pos < length) {\n    if (text.charCodeAt(pos) == CharCode.LineFeed) {\n      if (butFirst) butFirst = false;\n      else indent(sb, indentLevel);\n      sb.push(text.substring(lineStart, lineStart = pos + 1));\n    }\n    ++pos;\n  }\n  if (lineStart < length) {\n    if (!butFirst) indent(sb, indentLevel);\n    sb.push(text.substring(lineStart));\n  }\n}\n\nexport function liftRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // functions lift as internref using __pin\n    assert(type.signatureReference);\n    return true;\n  }\n  let program = clazz.program;\n  // flat collections lift via memory copy\n  if (\n    clazz.extendsPrototype(program.arrayBufferInstance.prototype) ||\n    clazz.extendsPrototype(program.stringInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayBufferViewInstance.prototype)\n  ) {\n    return false;\n  }\n  // nested collections lift depending on element type\n  if (\n    clazz.extendsPrototype(program.arrayPrototype) ||\n    clazz.extendsPrototype(program.staticArrayPrototype)\n  ) {\n    return liftRequiresExportRuntime(clazz.getArrayValueType());\n  }\n  // complex objects lift as internref using __pin. plain objects may or may not\n  // involve the runtime: assume that they do to avoid potentially costly checks\n  return true;\n}\n\nexport function lowerRequiresExportRuntime(type: Type): bool {\n  // TODO: enable v128 in signatures in future\n  // if (type.isVectorValue) return true;\n  if (!type.isInternalReference) return false;\n  let clazz = type.classReference;\n  if (!clazz) {\n    // lowers by reference\n    assert(type.signatureReference);\n    return false;\n  }\n  // lowers using __new\n  let program = clazz.program;\n  if (\n    clazz.extendsPrototype(program.arrayBufferInstance.prototype) ||\n    clazz.extendsPrototype(program.stringInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayBufferViewInstance.prototype) ||\n    clazz.extendsPrototype(program.arrayPrototype) ||\n    clazz.extendsPrototype(program.staticArrayPrototype)\n  ) {\n    return true;\n  }\n  // complex objects lower via internref by reference,\n  // while plain objects lower using __new\n  return isPlainObject(clazz);\n}\n\n/** Makes a checked setter function to memory for the given basic type. */\nfunction makeCheckedSetter(type: string, fn: string): string {\n  return `  function __set${type}(pointer, value) {\n    try {\n      __dataview.${fn}(pointer, value, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      __dataview.${fn}(pointer, value, true);\n    }\n  }\n`;\n}\n\n/** Makes a checked getter function from memory for the given basic type. */\nfunction makeCheckedGetter(type: string, fn: string): string {\n  return `  function __get${type}(pointer) {\n    try {\n      return __dataview.${fn}(pointer, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      return __dataview.${fn}(pointer, true);\n    }\n  }\n`;\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport {\n  Target,\n  Runtime,\n  Feature\n} from \"./common\";\n\nimport {\n  Compiler,\n  Options,\n  UncheckedBehavior\n} from \"./compiler\";\n\nimport {\n  TSDBuilder,\n  JSBuilder\n} from \"./bindings\";\n\nimport {\n  Range,\n  DiagnosticMessage,\n  DiagnosticCategory,\n  formatDiagnosticMessage\n} from \"./diagnostics\";\n\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\nimport { Source } from \"./ast\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\nexport function setRuntime(options: Options, runtime: Runtime): void {\n  options.runtime = runtime;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `uncheckedBehavior` option. */\nexport function setUncheckedBehavior(options: Options, uncheckedBehavior: UncheckedBehavior): void {\n  options.uncheckedBehavior = uncheckedBehavior;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Adds a 'globalAliases' value. */\nexport function addGlobalAlias(options: Options, alias: string, name: string): void {\n  let globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Removes a 'globalAliases' value. */\nexport function removeGlobalAlias(options: Options, alias: string): void {\n  let globalAliases = options.globalAliases;\n  if (globalAliases) globalAliases.delete(alias);\n}\n\n/** Sets the `exportStart` option. */\nexport function setExportStart(options: Options, exportStart: string | null): void {\n  options.exportStart = exportStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sets the `exportRuntime` option. */\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\n  options.exportRuntime = exportRuntime;\n}\n\n/** Default stack size. */\nexport const DEFAULT_STACK_SIZE = 32768;\n\n/** Sets the `stackSize` option. */\nexport function setStackSize(options: Options, stackSize: i32): void {\n  options.stackSize = stackSize;\n}\n\n/** Sets the bundle semantic version. */\nexport function setBundleVersion(\n  options: Options,\n  bundleMajorVersion: i32,\n  bundleMinorVersion: i32,\n  bundlePatchVersion: i32,\n): void {\n  options.bundleMajorVersion = bundleMajorVersion;\n  options.bundleMinorVersion = bundleMinorVersion;\n  options.bundlePatchVersion = bundlePatchVersion;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SignExtension;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MutableGlobals;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NontrappingF2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BulkMemory;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.Simd;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.Threads;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.ExceptionHandling;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TailCalls;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.ReferenceTypes;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MultiValue;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.Memory64;\n/** Relaxed SIMD. */\nexport const FEATURE_RELAXED_SIMD = Feature.RelaxedSimd;\n/** Extended const expressions. */\nexport const FEATURE_EXTENDED_CONST = Feature.ExtendedConst;\n/** String references. */\nexport const FEATURE_STRINGREF = Feature.Stringref;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Gives the compiler a hint of the emitted module's basename. */\nexport function setBasenameHint(options: Options, basename: string): void {\n  options.basenameHint = basename;\n}\n\n/** Gives the compiler a hint that bindings will be generated. */\nexport function setBindingsHint(options: Options, bindings: bool): void {\n  options.bindingsHint = bindings;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\nexport function setDebugInfo(options: Options, debug: bool): void {\n  options.debugInfo = debug;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Gets the code of a diagnostic message. */\nexport function getDiagnosticCode(diagnostic: DiagnosticMessage): i32 {\n  return diagnostic.code;\n}\n\n/** Gets the category of a diagnostic message. */\nexport function getDiagnosticCategory(diagnostic: DiagnosticMessage): DiagnosticCategory {\n  return diagnostic.category;\n}\n\n/** Gets the textual message of a diagnostic message. */\nexport function getDiagnosticMessage(diagnostic: DiagnosticMessage): string {\n  return diagnostic.message;\n}\n\n/** Gets the primary range, if any, of a diagnostic message. */\nexport function getDiagnosticRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.range;\n}\n\n/** Gets the related range, if any, of a diagnostic message. */\nexport function getDiagnosticRelatedRange(diagnostic: DiagnosticMessage): Range | null {\n  return diagnostic.relatedRange;\n}\n\n/** Gets a range's start offset. */\nexport function getRangeStart(range: Range): i32 {\n  return range.start;\n}\n\n/** Gets a range's end offsset. */\nexport function getRangeEnd(range: Range): i32 {\n  return range.end;\n}\n\n/** Gets a range's relevant source. */\nexport function getRangeSource(range: Range): Source {\n  return range.source;\n}\n\n/** Gets a source's normalized path. */\nexport function getSourceNormalizedPath(source: Source): string {\n  return source.normalizedPath;\n}\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Info;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Warning;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.Error;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program, esm: bool): string {\n  return TSDBuilder.build(program, esm);\n}\n\n/** Builds JavaScript glue code for the specified program. */\nexport function buildJS(program: Program, esm: bool): string {\n  return JSBuilder.build(program, esm);\n}\n\n/** Gets the Binaryen module reference of a module. */\nexport function getBinaryenModuleRef(module: Module): usize {\n  return module.ref;\n}\n\n/** Validates a module. */\nexport function validate(module: Module): bool {\n  return module.validate();\n}\n\n/** Optimizes a module. */\nexport function optimize(\n  module: Module,\n  optimizeLevel: i32,\n  shrinkLevel: i32,\n  debugInfo: bool = false,\n  zeroFilledMemory: bool = false\n): void {\n  module.optimize(optimizeLevel, shrinkLevel, debugInfo, zeroFilledMemory);\n}\n","/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  Range,\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  CharCode,\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n  ModuleDeclaration,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n  /** Current overridden module name. */\n  currentModuleName: string | null = null;\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] = []\n  ) {\n    super(diagnostics);\n    this.sources = sources;\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    let normalizedPath = normalizePath(path);\n    let internalPath = mangleInternalPath(normalizedPath);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text == null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    let source = new Source(\n      isEntry\n        ? SourceKind.UserEntry\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LibraryEntry\n            : SourceKind.Library\n          : SourceKind.User,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n    this.currentModuleName = null;\n\n    // tokenize and parse\n    let tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    let statements = source.statements;\n    while (!tn.skip(Token.EndOfFile)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    let flags = namespace ? namespace.flags & CommonFlags.Ambient : CommonFlags.None;\n    let startPos = -1;\n\n    // check decorators\n    let decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.At)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    let exportStart = 0;\n    let exportEnd = 0;\n    let defaultStart = 0;\n    let defaultEnd = 0;\n    if (tn.skip(Token.Export)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.Export;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.Default)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = namespace != null && namespace.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.Declare | CommonFlags.Ambient;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    // parse the statement\n    let statement: Statement | null = null;\n\n    // handle declarations\n    let first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.Const: {\n        tn.next();\n        flags |= CommonFlags.Const;\n        if (tn.skip(Token.Enum)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.Let: flags |= CommonFlags.Let;\n      case Token.Var: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Enum: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Function: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Abstract: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        if (tn.peekOnNewLine()) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        let next = tn.peek();\n        if (next != Token.Class) {\n          if (next == Token.Interface) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.Abstract;\n        // fall through\n      }\n      case Token.Class:\n      case Token.Interface: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.Namespace: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Import: {\n        tn.next();\n        flags |= CommonFlags.Import;\n        if (flags & CommonFlags.Export) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.Type: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.Module: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() == Token.StringLiteral && !tn.peekOnNewLine()) {\n          tn.discard(state);\n          statement = this.parseModuleDeclaration(tn, flags);\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.Export) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.Prefer)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.Declare) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement != null) {\n      switch (statement.kind) {\n        case NodeKind.EnumDeclaration:\n        case NodeKind.FunctionDeclaration:\n        case NodeKind.ClassDeclaration:\n        case NodeKind.InterfaceDeclaration:\n        case NodeKind.NamespaceDeclaration: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    let backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    let dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    let first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    let current = first;\n    while (tn.skip(Token.Dot)) {\n      if (tn.skip(Token.Identifier)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    let token = tn.next();\n    let startPos = tn.tokenPos;\n\n    let type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OpenParen) {\n\n      // '(' FunctionSignature ')'\n      let isInnerParenthesized = tn.skip(Token.OpenParen);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isInnerParenthesized) {\n          if (!tn.skip(Token.CloseParen)) {\n            if (!suppressErrors) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n            }\n            return null;\n          }\n        }\n        type = signature;\n      } else if (isInnerParenthesized || this.tryParseSignatureIsSignature) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode.Unexpected_token,\n            tn.range()\n          );\n        }\n        return null;\n      // Type (',' Type)* ')'\n      } else if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode.Unexpected_token,\n            tn.range()\n          );\n        }\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.Void) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.This) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.True || token == Token.False) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.Null) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.StringLiteral) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.Identifier) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LessThan)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.Comma));\n        if (!tn.skip(Token.GreaterThan)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | type\n    while (tn.skip(Token.Bar)) {\n      let nextType = this.parseType(tn, false, true);\n      if (!nextType) return null;\n      let typeIsNull = type.kind == NodeKind.NamedType && (<NamedTypeNode>type).isNull;\n      let nextTypeIsNull = nextType.kind == NodeKind.NamedType && (<NamedTypeNode>nextType).isNull;\n      if (!typeIsNull && !nextTypeIsNull) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode.Not_implemented_0, nextType.range, \"union types\"\n          );\n        }\n        return null;\n      } else if (nextTypeIsNull) {\n        type.isNullable = true;\n        type.range.end = nextType.range.end;\n      } else if (typeIsNull) {\n        nextType.range.start = type.range.start;\n        nextType.isNullable = true;\n        type = nextType;\n      } else {\n        // `null | null` still `null`\n        type.range.end = nextType.range.end;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OpenBracket)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CloseBracket)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.Bar)) {\n        if (tn.skip(Token.Null)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode.Not_implemented_0,\n              tn.range(), \"union types\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    let state = tn.mark();\n    let startPos = tn.tokenPos;\n    let parameters: ParameterNode[] | null = null;\n    let thisType: NamedTypeNode | null = null;\n    let isSignature: bool = false;\n    let firstParamNameNoType: IdentifierExpression | null = null;\n    let firstParamKind: ParameterKind = ParameterKind.Default;\n\n    if (tn.skip(Token.CloseParen)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.Default;\n        if (tn.skip(Token.Dot_Dot_Dot)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.Rest;\n        }\n        if (tn.skip(Token.This)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NamedType) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.Question)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.Rest) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.Optional;\n            }\n          }\n          if (tn.skip(Token.Colon)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.Comma) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            if (tn.peek() == Token.CloseParen) break; // allow trailing comma\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.Comma));\n      if (!tn.skip(Token.CloseParen)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    let returnType: TypeNode | null;\n    if (tn.skip(Token.Equals_GreaterThan)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n\n    if (!parameters) parameters = [];\n\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    let startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.Dot)) {\n        if (tn.skipIdentifier(IdentifierHandling.Prefer)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OpenParen)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    let declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declaration.overriddenModuleName = this.currentModuleName;\n      declarations.push(declaration);\n    } while (tn.skip(Token.Comma));\n\n    let ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    if (!tn.skip(Token.Semicolon) && !isFor) this.checkASI(tn);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    let flags = parentFlags;\n    if (tn.skip(Token.Exclamation)) {\n      flags |= CommonFlags.DefinitelyAssigned;\n    }\n\n    let type: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      type = this.parseType(tn, true);\n    }\n\n    let initializer: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!initializer) return null;\n      if (flags & CommonFlags.DefinitelyAssigned) {\n        this.error(\n          DiagnosticCode.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions,\n          initializer.range\n        );\n      }\n    } else if (!isFor) {\n      if (flags & CommonFlags.Const) {\n        if (!(flags & CommonFlags.Ambient)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    let range = Range.join(identifier.range, tn.range());\n    if ((flags & CommonFlags.DefinitelyAssigned) != 0 && (flags & CommonFlags.Ambient) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.Identifier) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OpenBrace) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    let members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let member = this.parseEnumValue(tn, CommonFlags.None);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseBrace)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    let ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let value: Expression | null = null;\n    if (tn.skip(Token.Equals)) {\n      value = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    let startPos = tn.tokenPos;\n    let expr: Expression | null = null;\n    let nextToken = tn.peek();\n    if (\n      nextToken != Token.Semicolon &&\n      nextToken != Token.CloseBrace &&\n      !tn.peekOnNewLine()\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    let ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    if (!tn.skip(Token.Semicolon)) this.checkASI(tn);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    let typeParameters = new Array<TypeParameterNode>();\n    let seenOptional = false;\n    let start = tn.tokenPos;\n    while (!tn.skip(Token.GreaterThan)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.GreaterThan)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.Identifier) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Extends)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.Equals)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    let parameters = new Array<ParameterNode>();\n    let seenRest: ParameterNode | null = null;\n    let seenOptional = false;\n    let reportedRest = false;\n    let thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.This)) {\n      if (tn.skip(Token.Colon)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NamedType) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CloseParen)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.Optional: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.Rest: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    let isRest = false;\n    let isOptional = false;\n    let startRange: Range | null = null;\n    let accessFlags: CommonFlags = CommonFlags.None;\n    if (isConstructor) {\n      if (tn.skip(Token.Public)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Public;\n      } else if (tn.skip(Token.Protected)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Protected;\n      } else if (tn.skip(Token.Private)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.Private;\n      }\n      if (tn.peek() == Token.Readonly) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.Colon) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.Readonly;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.Dot_Dot_Dot)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.Question)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.Comma + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.Rest\n          : isOptional\n            ? ParameterKind.Optional\n            : ParameterKind.Default,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    let signatureStart = -1;\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    if (!tn.skip(Token.OpenParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    let thisType = this.parseParametersThis;\n\n    let isSetter = (flags & CommonFlags.Set) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.Get) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    let returnType: TypeNode | null = null;\n    if (tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (tn.skip(Token.OpenBrace)) {\n      if (flags & CommonFlags.Ambient) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.Ambient)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    let ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.None,\n      tn.range(startPos, tn.pos)\n    );\n    ret.overriddenModuleName = this.currentModuleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n    let arrowKind = ArrowKind.None;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.Function) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OpenParen)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.Parenthesized;\n      assert(tn.token == Token.OpenParen);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    let signatureStart = tn.pos;\n    let parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    let returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.Single && tn.skip(Token.Colon)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.Equals_GreaterThan)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    let signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    let body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OpenBrace)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.Comma + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OpenBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    let declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    let isInterface = tn.token == Token.Interface;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    let identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.Generic;\n    }\n\n    let extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.Extends)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NamedType) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    let implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.Implements)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NamedType) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.Comma));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    declaration.overriddenModuleName = this.currentModuleName;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    let startPos = tn.tokenPos;\n    let name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OpenBrace)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    let members = new Array<DeclarationStatement>();\n    let declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.None,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CloseBrace)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.IndexSignature) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.EndOfFile)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CloseBrace));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   'declare'?\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'override'?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    let isInterface = parent.kind == NodeKind.InterfaceDeclaration;\n    let startPos = 0;\n    let decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.At)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.At));\n      if (isInterface && decorators) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    let flags = parent.flags & CommonFlags.Ambient;\n\n    // interface methods are always overridden if used\n    if (isInterface) flags |= CommonFlags.Overridden;\n\n    let declareStart = 0;\n    let declareEnd = 0;\n    let contextIsAmbient = parent.is(CommonFlags.Ambient);\n    if (tn.skip(Token.Declare)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"declare\"\n        );\n      } else {\n        if (contextIsAmbient) {\n          this.error(\n            DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n            tn.range()\n          ); // recoverable\n        } else {\n          flags |= CommonFlags.Declare | CommonFlags.Ambient;\n          declareStart = tn.tokenPos;\n          declareEnd = tn.pos;\n        }\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.Ambient;\n    }\n\n    let accessStart = 0;\n    let accessEnd = 0;\n    if (tn.skip(Token.Public)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.Public;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Private)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.Private;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.Protected)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.Protected;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let staticStart = 0;\n    let staticEnd = 0;\n    let abstractStart = 0;\n    let abstractEnd = 0;\n    if (tn.skip(Token.Static)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.Static;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.Instance;\n      if (tn.skip(Token.Abstract)) {\n        if (isInterface || !parent.is(CommonFlags.Abstract)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.Abstract;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.Generic) flags |= CommonFlags.GenericContext;\n    }\n\n    let overrideStart = 0;\n    let overrideEnd = 0;\n    if (tn.skip(Token.Override)) {\n      if (isInterface || parent.extendsType == null) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"override\"\n        );\n      } else {\n        flags |= CommonFlags.Override;\n        overrideStart = tn.tokenPos;\n        overrideEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    let readonlyStart = 0;\n    let readonlyEnd = 0;\n    if (tn.peek() == Token.Readonly) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.Colon) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.Readonly;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    let state = tn.mark();\n    let isConstructor = false;\n    let isGetter = false;\n    let getStart = 0;\n    let getEnd = 0;\n    let isSetter = false;\n    let setStart = 0;\n    let setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.Get)) {\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier && !tn.peekOnNewLine()) {\n          flags |= CommonFlags.Get;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Set)) {\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier && !tn.peekOnNewLine()) {\n          flags |= CommonFlags.Set;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.Constructor)) {\n        flags |= CommonFlags.Constructor;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Readonly) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    let isGetterOrSetter = isGetter || isSetter;\n    let name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OpenBracket)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.Public) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Protected) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.Private) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"private\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Static) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.Override) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(overrideStart, overrideEnd), \"override\"\n          );\n        }\n        if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.Readonly) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.Semicolon);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.Always)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LessThan)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.Generic;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OpenParen)) {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_appear_on_class_elements_of_this_kind,\n          tn.range(declareStart, declareEnd), \"declare\"\n        ); // recoverable\n      }\n\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.Public |\n            CommonFlags.Protected |\n            CommonFlags.Private |\n            CommonFlags.Readonly\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.Instance,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.Colon)) {\n        if (name.kind == NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.Constructor);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.Constructor) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OpenBrace)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.Abstract) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.Ambient | CommonFlags.Abstract))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.Declare) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(declareStart, declareEnd), \"Ambient fields\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Abstract) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Get) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.Set) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.Question)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.Exclamation)) {\n        flags |= CommonFlags.DefinitelyAssigned;\n      }\n      if (tn.skip(Token.Colon)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.Equals)) {\n        if (flags & CommonFlags.Ambient) {\n          this.error(\n            DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        }\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n        if (flags & CommonFlags.DefinitelyAssigned) {\n          this.error(\n            DiagnosticCode.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions,\n            name.range\n          );\n        }\n      }\n      let range = tn.range(startPos, tn.pos);\n      if ((flags & CommonFlags.DefinitelyAssigned) != 0 && (isInterface || (flags & CommonFlags.Ambient) != 0)) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.Comma))) {\n        tn.skip(Token.Semicolon);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    let start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.Colon)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NamedType) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CloseBracket)) {\n            if (tn.skip(Token.Colon)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NamedType) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OpenBrace)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CloseBrace)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) {\n            if (member.kind == NodeKind.Export) {\n              this.error(\n                DiagnosticCode.A_default_export_can_only_be_used_in_a_module,\n                member.range,\n              );\n              return null;\n            }\n            members.push(member);\n          } else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.EndOfFile)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        declaration.overriddenModuleName = this.currentModuleName;\n        tn.skip(Token.Semicolon);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    let path: StringLiteralExpression | null = null;\n    let currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OpenBrace)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else if (tn.skip(Token.Asterisk)) {\n      if (tn.skip(Token.From)) {\n        if (tn.skip(Token.StringLiteral)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier(IdentifierHandling.Always)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    let name = tn.readIdentifier();\n    let range = tn.range();\n    let ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    let members: ImportDeclaration[] | null = null;\n    let namespaceName: IdentifierExpression | null = null;\n    let skipFrom = false;\n    if (tn.skip(Token.OpenBrace)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CloseBrace)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.Comma)) {\n          if (tn.skip(Token.CloseBrace)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.Asterisk)) { // import * from \"file\"\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.Identifier, IdentifierHandling.Prefer)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.Comma)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.From)) {\n      if (tn.skip(Token.StringLiteral)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.Always)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.As)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.Equals)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    let state = tn.mark();\n    let token = tn.next();\n    let statement: Statement | null = null;\n    switch (token) {\n      case Token.Break: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.Const: {\n        statement = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos);\n        break;\n      }\n      case Token.Continue: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.Do: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.For: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.If: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.Let: {\n        statement = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos);\n        break;\n      }\n      case Token.Var: {\n        statement = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos);\n        break;\n      }\n      case Token.OpenBrace: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.Return: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.Semicolon: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.Switch: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.Throw: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.Try: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.Void: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.While: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.Type: { // also identifier\n        if (tn.peek(IdentifierHandling.Prefer) == Token.Identifier) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.None, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    let statements = new Array<Statement>();\n    while (!tn.skip(Token.CloseBrace)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.EndOfFile) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    let ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    if (topLevel) tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek() == Token.Identifier && !tn.peekOnNewLine()) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    let identifier: IdentifierExpression | null = null;\n    if (tn.peek() == Token.Identifier && !tn.peekOnNewLine()) {\n      tn.next(IdentifierHandling.Prefer);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    let ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    let startPos = tn.tokenPos;\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.While)) {\n\n      if (tn.skip(Token.OpenParen)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CloseParen)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    let expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    let ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    let startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OpenParen)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.Const)) {\n        initializer = this.parseVariable(tn, CommonFlags.Const, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Let)) {\n        initializer = this.parseVariable(tn, CommonFlags.Let, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.Var)) {\n        initializer = this.parseVariable(tn, CommonFlags.None, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.Semicolon)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.Of)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.Expression) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.Identifier) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.Variable) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.Variable) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.Const) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.Semicolon) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.Semicolon)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.Semicolon) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CloseParen)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CloseParen)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    let iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CloseParen)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    let statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.Else)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CloseParen)) {\n        if (tn.skip(Token.OpenBrace)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CloseBrace)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.Semicolon);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    let startPos = tn.tokenPos;\n    let statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.Case)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.Default)) {\n      if (tn.skip(Token.Colon)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.Case &&\n          tn.nextToken != Token.Default &&\n          tn.nextToken != Token.CloseBrace\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn);\n    if (!expression) return null;\n    let ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    if (!tn.skip(Token.Semicolon)) this.checkASI(tn);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    let startPos = tn.tokenPos;\n    let stmt: Statement | null;\n    if (tn.skip(Token.OpenBrace)) {\n      let bodyStatements = new Array<Statement>();\n      while (!tn.skip(Token.CloseBrace)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        bodyStatements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.Catch)) {\n        if (!tn.skip(Token.OpenParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.Finally)) {\n        if (!tn.skip(Token.OpenBrace)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CloseBrace)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        bodyStatements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.Semicolon);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' '|'? Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LessThan)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.Generic;\n      }\n      if (tn.skip(Token.Equals)) {\n        tn.skip(Token.Bar);\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (isCircularTypeAlias(name.text, type)) {\n          this.error(\n            DiagnosticCode.Type_alias_0_circularly_references_itself,\n            name.range, name.text\n          );\n          return null;\n        }\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.Semicolon);\n        ret.overriddenModuleName = this.currentModuleName;\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseModuleDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags\n  ): ModuleDeclaration | null {\n\n    // at 'module': StringLiteral ';'?\n\n    let startPos = tn.tokenPos;\n    assert(tn.next() == Token.StringLiteral); // checked earlier\n    let moduleName = tn.readString();\n    let ret = Node.createModuleDeclaration(moduleName, flags, tn.range(startPos, tn.pos));\n    this.currentModuleName = moduleName;\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    let startPos = tn.tokenPos;\n    let expression = this.parseExpression(tn, Precedence.Grouping);\n    if (!expression) return null;\n    let ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.Semicolon);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    let startPos = tn.tokenPos;\n    if (tn.skip(Token.OpenParen)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CloseParen)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.Semicolon);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    let token = tn.next(IdentifierHandling.Prefer);\n    let startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.Dot_Dot_Dot:\n      case Token.Yield: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.Exclamation:\n      case Token.Tilde:\n      case Token.Plus:\n      case Token.Minus:\n      case Token.TypeOf:\n      case Token.Void:\n      case Token.Delete: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.Plus_Plus:\n      case Token.Minus_Minus: {\n        let operand = this.parseExpression(tn, Precedence.UnaryPrefix);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.Identifier:\n          case NodeKind.ElementAccess:\n          case NodeKind.PropertyAccess: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.New: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OpenParen) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.Null: return Node.createNullExpression(tn.range());\n      case Token.True: return Node.createTrueExpression(tn.range());\n      case Token.False: return Node.createFalseExpression(tn.range());\n      case Token.This: return Node.createThisExpression(tn.range());\n      case Token.Constructor: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OpenParen: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CloseParen)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.Parenthesized\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.Prefer)) {\n\n            // function expression\n            case Token.Dot_Dot_Dot: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.Identifier: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CloseParen: {\n                  // `Identifier):Type =>` is function expression\n                  if (tn.skip(Token.Colon)) {\n                    let type = this.parseType(tn, true, true);\n                    if (type == null) {\n                      again = false;\n                      break;\n                    }\n                  }\n                  if (!tn.skip(Token.Equals_GreaterThan)) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.Colon: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.Question: {\n                  if (\n                    tn.skip(Token.Colon) ||   // optional parameter with type\n                    tn.skip(Token.Comma) ||   // optional parameter without type\n                    tn.skip(Token.CloseParen) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.Comma: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CloseParen)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OpenBracket: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CloseBracket)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.Comma) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBracket)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OpenBrace: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CloseBrace)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.StringLiteral)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.Colon)) {\n            let value = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.Comma)) {\n            if (tn.skip(Token.CloseBrace)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LessThan: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GreaterThan)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.Call);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.Prefix,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Identifier: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.skip(Token.TemplateLiteral)) {\n          return this.parseTemplateLiteral(tn, identifier);\n        }\n        if (tn.peek() == Token.Equals_GreaterThan && !tn.peekOnNewLine()) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.Default,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.Single,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.Super: {\n        if (tn.peek() != Token.Dot && tn.nextToken != Token.OpenParen) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.StringLiteral: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.TemplateLiteral: {\n        return this.parseTemplateLiteral(tn);\n      }\n      case Token.IntegerLiteral: {\n        let value = tn.readInteger();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      case Token.FloatLiteral: {\n        let value = tn.readFloat();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.Slash: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.Slash)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.Function: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.Class: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.EndOfFile) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    let state = tn.mark();\n    if (!tn.skip(Token.LessThan)) return null;\n    let start = tn.tokenPos;\n    let typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() == Token.GreaterThan) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.Comma));\n    if (tn.skip(Token.GreaterThan)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OpenParen)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    let args = new Array<Expression>();\n    while (!tn.skip(Token.CloseParen)) {\n      let expr = this.parseExpression(tn, Precedence.Comma + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.Comma)) {\n        if (tn.skip(Token.CloseParen)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.Comma\n  ): Expression | null {\n    assert(precedence != Precedence.None);\n    let expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    let startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    let nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.As: {\n          if (tn.skip(Token.Const)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.Const,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.As,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.Exclamation: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NonNull,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.InstanceOf: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OpenBracket: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CloseBracket)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.Plus_Plus:\n        case Token.Minus_Minus: {\n          if (\n            expr.kind != NodeKind.Identifier &&\n            expr.kind != NodeKind.ElementAccess &&\n            expr.kind != NodeKind.PropertyAccess\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.Question: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.Colon)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.Comma\n            ? Precedence.Comma + 1\n            : Precedence.Comma\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.Comma: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.Comma + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.Comma));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.Dot: {\n          if (tn.skipIdentifier(IdentifierHandling.Always)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.Call) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          if (tn.skip(Token.TemplateLiteral)) {\n            expr = this.parseTemplateLiteral(tn, expr);\n            if (!expr) return null;\n          } else {\n            expr = this.maybeParseCallExpression(tn, expr, true);\n          }\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.Equals:\n        case Token.Plus_Equals:\n        case Token.Minus_Equals:\n        case Token.Asterisk_Asterisk_Equals:\n        case Token.Asterisk_Equals:\n        case Token.Slash_Equals:\n        case Token.Percent_Equals:\n        case Token.LessThan_LessThan_Equals:\n        case Token.GreaterThan_GreaterThan_Equals:\n        case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n        case Token.Ampersand_Equals:\n        case Token.Caret_Equals:\n        case Token.Bar_Equals:\n        case Token.Asterisk_Asterisk: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LessThan:\n        case Token.GreaterThan:\n        case Token.LessThan_Equals:\n        case Token.GreaterThan_Equals:\n        case Token.Equals_Equals:\n        case Token.Equals_Equals_Equals:\n        case Token.Exclamation_Equals_Equals:\n        case Token.Exclamation_Equals:\n        case Token.Plus:\n        case Token.Minus:\n        case Token.Asterisk:\n        case Token.Slash:\n        case Token.Percent:\n        case Token.LessThan_LessThan:\n        case Token.GreaterThan_GreaterThan:\n        case Token.GreaterThan_GreaterThan_GreaterThan:\n        case Token.Ampersand:\n        case Token.Bar:\n        case Token.Caret:\n        case Token.Ampersand_Ampersand:\n        case Token.Bar_Bar:\n        case Token.In: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\n    // at '`': ... '`'\n    let startPos = tag ? tag.range.start : tn.tokenPos;\n    let parts = new Array<string>();\n    let rawParts = new Array<string>();\n    let exprs = new Array<Expression>();\n    parts.push(tn.readString(0, tag != null));\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    while (tn.readingTemplateString) {\n      let expr = this.parseExpression(tn);\n      if (!expr) return null;\n      exprs.push(expr);\n      if (!tn.skip(Token.CloseBrace)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"}\"\n        );\n        return null;\n      }\n      parts.push(tn.readString(CharCode.Backtick, tag != null));\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    }\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    let callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.Identifier: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.Call: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    let typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OpenParen) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn))\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  private checkASI(\n    tn: Tokenizer\n  ): void {\n    // see: https://tc39.es/ecma262/#sec-automatic-semicolon-insertion\n    let nextToken = tn.peek();\n    if (nextToken == Token.EndOfFile || nextToken == Token.CloseBrace || tn.peekOnNewLine()) return;\n    this.error(\n      DiagnosticCode.Unexpected_token,\n      tn.range(tn.nextTokenPos)\n    );\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    if (tn.peekOnNewLine()) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek();\n      if (\n        nextToken == Token.EndOfFile ||   // next step should handle this\n        nextToken == Token.Semicolon      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.peekOnNewLine()) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:\n        case Token.TemplateLiteral: {\n          tn.readString();\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.OpenBrace: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n    tn.readingTemplateString = false;\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    let depth = 1;\n    let again = true;\n    do {\n      switch (tn.next()) {\n        case Token.EndOfFile: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OpenBrace: {\n          ++depth;\n          break;\n        }\n        case Token.CloseBrace: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.Identifier: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.StringLiteral:{\n          tn.readString();\n          break;\n        }\n        case Token.TemplateLiteral: {\n          tn.readString();\n          while(tn.readingTemplateString){\n            this.skipBlock(tn);\n            tn.readString(CharCode.Backtick);\n          }\n          break;\n        }\n        case Token.IntegerLiteral: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FloatLiteral: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  None,\n  Comma,\n  Spread,\n  Yield,\n  Assignment,\n  Conditional,\n  LogicalOr,\n  LogicalAnd,\n  BitwiseOr,\n  BitwiseXor,\n  BitwiseAnd,\n  Equality,\n  Relational,\n  Shift,\n  Additive,\n  Multiplicative,\n  Exponentiated,\n  UnaryPrefix,\n  UnaryPostfix,\n  Call,\n  MemberAccess,\n  Grouping\n}\n\n/** Determines the precedence of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.Comma: return Precedence.Comma;\n    case Token.Equals:\n    case Token.Plus_Equals:\n    case Token.Minus_Equals:\n    case Token.Asterisk_Asterisk_Equals:\n    case Token.Asterisk_Equals:\n    case Token.Slash_Equals:\n    case Token.Percent_Equals:\n    case Token.LessThan_LessThan_Equals:\n    case Token.GreaterThan_GreaterThan_Equals:\n    case Token.GreaterThan_GreaterThan_GreaterThan_Equals:\n    case Token.Ampersand_Equals:\n    case Token.Caret_Equals:\n    case Token.Bar_Equals: return Precedence.Assignment;\n    case Token.Question: return Precedence.Conditional;\n    case Token.Bar_Bar: return Precedence.LogicalOr;\n    case Token.Ampersand_Ampersand: return Precedence.LogicalAnd;\n    case Token.Bar: return Precedence.BitwiseOr;\n    case Token.Caret: return Precedence.BitwiseXor;\n    case Token.Ampersand: return Precedence.BitwiseAnd;\n    case Token.Equals_Equals:\n    case Token.Exclamation_Equals:\n    case Token.Equals_Equals_Equals:\n    case Token.Exclamation_Equals_Equals: return Precedence.Equality;\n    case Token.As:\n    case Token.In:\n    case Token.InstanceOf:\n    case Token.LessThan:\n    case Token.GreaterThan:\n    case Token.LessThan_Equals:\n    case Token.GreaterThan_Equals: return Precedence.Relational;\n    case Token.LessThan_LessThan:\n    case Token.GreaterThan_GreaterThan:\n    case Token.GreaterThan_GreaterThan_GreaterThan: return Precedence.Shift;\n    case Token.Plus:\n    case Token.Minus: return Precedence.Additive;\n    case Token.Asterisk:\n    case Token.Slash:\n    case Token.Percent: return Precedence.Multiplicative;\n    case Token.Asterisk_Asterisk: return Precedence.Exponentiated;\n    case Token.Plus_Plus:\n    case Token.Minus_Minus: return Precedence.UnaryPostfix;\n    case Token.Dot:\n    case Token.OpenBracket:\n    case Token.Exclamation: return Precedence.MemberAccess;\n  }\n  return Precedence.None;\n}\n\n/** Checks if the type alias of the given name and type is circular. */\nfunction isCircularTypeAlias(name: string, type: TypeNode): bool {\n  switch (type.kind) {\n    case NodeKind.NamedType: {\n      if ((<NamedTypeNode>type).name.identifier.text == name) {\n        return true;\n      }\n      let typeArguments = (<NamedTypeNode>type).typeArguments;\n      if (typeArguments) {\n        for (let i = 0, k = typeArguments.length; i < k; i++) {\n          if (isCircularTypeAlias(name, typeArguments[i])) return true;\n        }\n      }\n      break;\n    }\n    case NodeKind.FunctionType: {\n      let functionType = <FunctionTypeNode>type;\n      if (isCircularTypeAlias(name, functionType.returnType)) return true;\n      let parameters = functionType.parameters;\n      for (let i = 0, k = parameters.length; i < k; i++) {\n        if (isCircularTypeAlias(name, parameters[i].type)) return true;\n      }\n      break;\n    }\n    default: assert(false);\n  }\n  return false;\n}\n","/**\n * @fileoverview Infrastructure for custom Binaryen passes.\n * @license Apache-2.0\n */\n\nimport {\n  Module,\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  GlobalRef,\n  Index,\n  StringRef\n} from \"../module\";\n\nimport {\n  _BinaryenExpressionGetId,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenIfGetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenLoopGetBody,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n  _BinaryenFunctionGetBody,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenLocalSetGetValue,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalGetInitExpr,\n  _BinaryenLoadGetPtr,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenUnaryGetValue,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenDropGetValue,\n  _BinaryenBlockSetChildAt,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenReturnGetValue,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenRefIsNullGetValue,\n  _BinaryenRefAsGetValue,\n  _BinaryenTryGetBody,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenIfSetCondition,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfSetIfFalse,\n  _BinaryenLoopSetBody,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakSetValue,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchSetValue,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenLocalSetSetValue,\n  _BinaryenGlobalSetSetValue,\n  _BinaryenLoadSetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreSetValue,\n  _BinaryenUnarySetValue,\n  _BinaryenExpressionFinalize,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinarySetRight,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectSetCondition,\n  _BinaryenDropSetValue,\n  _BinaryenReturnSetValue,\n  _BinaryenMemoryGrowSetDelta,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWSetValue,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgSetReplacement,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceSetValue,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernarySetC,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftSetShift,\n  _BinaryenSIMDLoadSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitSetSize,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopySetSize,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillSetSize,\n  _BinaryenRefIsNullSetValue,\n  _BinaryenTrySetBody,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenBlockGetName,\n  _BinaryenLoopGetName,\n  _BinaryenBreakGetName,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenCallGetTarget,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalSetGetName,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenThrowGetTag,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqSetRight,\n  _BinaryenFunctionSetBody,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31NewSetValue,\n  _BinaryenI31GetSetI31,\n  _BinaryenCallRefGetNumOperands,\n  _BinaryenCallRefGetOperandAt,\n  _BinaryenCallRefGetTarget,\n  _BinaryenRefTestGetRef,\n  _BinaryenRefCastGetRef,\n  _BinaryenBrOnGetName,\n  _BinaryenBrOnGetRef,\n  _BinaryenStructNewGetNumOperands,\n  _BinaryenStructNewGetOperandAt,\n  _BinaryenStructGetGetRef,\n  _BinaryenStructSetGetRef,\n  _BinaryenStructSetGetValue,\n  _BinaryenStructSetGetIndex,\n  _BinaryenStructGetGetIndex,\n  _BinaryenArrayNewGetSize,\n  _BinaryenArrayNewGetInit,\n  _BinaryenArrayInitGetNumValues,\n  _BinaryenArrayInitGetValueAt,\n  _BinaryenArrayGetGetRef,\n  _BinaryenArrayGetGetIndex,\n  _BinaryenArraySetGetRef,\n  _BinaryenArraySetGetIndex,\n  _BinaryenArraySetGetValue,\n  _BinaryenArrayLenGetRef,\n  _BinaryenArrayCopyGetDestRef,\n  _BinaryenArrayCopyGetDestIndex,\n  _BinaryenArrayCopyGetSrcRef,\n  _BinaryenArrayCopyGetSrcIndex,\n  _BinaryenArrayCopyGetLength,\n  _BinaryenStringNewGetPtr,\n  _BinaryenStringNewGetLength,\n  _BinaryenStringNewGetStart,\n  _BinaryenStringNewGetEnd,\n  _BinaryenStringMeasureGetRef,\n  _BinaryenStringEncodeGetPtr,\n  _BinaryenStringEncodeGetRef,\n  _BinaryenStringEncodeGetStart,\n  _BinaryenStringConcatGetLeft,\n  _BinaryenStringConcatGetRight,\n  _BinaryenStringEqGetLeft,\n  _BinaryenStringEqGetRight,\n  _BinaryenStringAsGetRef,\n  _BinaryenStringWTF8AdvanceGetRef,\n  _BinaryenStringWTF8AdvanceGetPos,\n  _BinaryenStringWTF8AdvanceGetBytes,\n  _BinaryenStringWTF16GetGetRef,\n  _BinaryenStringWTF16GetGetPos,\n  _BinaryenStringIterNextGetRef,\n  _BinaryenStringIterMoveGetRef,\n  _BinaryenStringIterMoveGetNum,\n  _BinaryenStringSliceWTFGetRef,\n  _BinaryenStringSliceWTFGetStart,\n  _BinaryenStringSliceWTFGetEnd,\n  _BinaryenStringSliceIterGetRef,\n  _BinaryenStringSliceIterGetNum,\n  _BinaryenCallRefSetOperandAt,\n  _BinaryenCallRefSetTarget,\n  _BinaryenRefTestSetRef,\n  _BinaryenRefCastSetRef,\n  _BinaryenBrOnSetRef,\n  _BinaryenStructNewSetOperandAt,\n  _BinaryenStructGetSetRef,\n  _BinaryenStructSetSetRef,\n  _BinaryenStructSetSetValue,\n  _BinaryenArrayNewSetSize,\n  _BinaryenArrayNewSetInit,\n  _BinaryenArrayGetSetRef,\n  _BinaryenArrayGetSetIndex,\n  _BinaryenArraySetSetRef,\n  _BinaryenArraySetSetIndex,\n  _BinaryenArraySetSetValue,\n  _BinaryenArrayLenSetRef,\n  _BinaryenArrayCopySetDestRef,\n  _BinaryenArrayCopySetDestIndex,\n  _BinaryenArrayCopySetSrcRef,\n  _BinaryenArrayCopySetSrcIndex,\n  _BinaryenArrayCopySetLength,\n  _BinaryenRefAsSetValue,\n  _BinaryenStringNewSetPtr,\n  _BinaryenStringNewSetLength,\n  _BinaryenStringNewSetStart,\n  _BinaryenStringNewSetEnd,\n  _BinaryenStringMeasureSetRef,\n  _BinaryenStringEncodeSetRef,\n  _BinaryenStringEncodeSetPtr,\n  _BinaryenStringEncodeSetStart,\n  _BinaryenStringConcatSetLeft,\n  _BinaryenStringConcatSetRight,\n  _BinaryenStringEqSetLeft,\n  _BinaryenStringEqSetRight,\n  _BinaryenStringAsSetRef,\n  _BinaryenStringWTF8AdvanceSetRef,\n  _BinaryenStringWTF8AdvanceSetPos,\n  _BinaryenStringWTF8AdvanceSetBytes,\n  _BinaryenStringWTF16GetSetRef,\n  _BinaryenStringWTF16GetSetPos,\n  _BinaryenStringIterNextSetRef,\n  _BinaryenStringIterMoveSetRef,\n  _BinaryenStringIterMoveSetNum,\n  _BinaryenStringSliceWTFSetRef,\n  _BinaryenStringSliceWTFSetStart,\n  _BinaryenStringSliceWTFSetEnd,\n  _BinaryenStringSliceIterSetRef,\n  _BinaryenStringSliceIterSetNum,\n  _BinaryenArrayInitSetValueAt\n} from \"../glue/binaryen\";\n\n/** Base class of custom Binaryen visitors. */\nexport abstract class Visitor {\n  /** Expression stack. */\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\n\n  /** Gets the current expression being walked. */\n  get currentExpression(): ExpressionRef {\n    let currentExpression = this._currentExpression;\n    if (!currentExpression) throw new Error(\"not walking expressions\");\n    return currentExpression;\n  }\n  _currentExpression: ExpressionRef = 0;\n\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\n  get parentExpressionOrNull(): ExpressionRef {\n    let stack = this.stack;\n    let length = stack.length;\n    return length ? stack[length - 1] : 0;\n  }\n\n  // Expressions\n\n  visitBlock(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitIf(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBreak(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSwitch(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCall(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirectPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStore(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBinary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSelect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitReturn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemorySize(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryGrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitNop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnreachable(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicRMW(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicWait(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicNotify(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicFence(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDReplace(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShuffle(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDTernary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShift(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDataDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryFill(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitPop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefIsNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefFunc(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTry(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitThrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRethrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleMake(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31New(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallRef(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefTest(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefCast(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBrOn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArraySet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayLen(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringMeasure(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEncode(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringConcat(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF8Advance(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringWTF16Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterNext(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringIterMove(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceWTF(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStringSliceIter(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  // Immediates\n\n  visitName(name: StringRef): void {\n    // unimp\n  }\n\n  visitLabel(name: StringRef): void {\n    // unimp\n  }\n\n  visitIndex(index: Index): void {\n    // unimp\n  }\n\n  visitTag(name: StringRef): void {\n    // unimp\n  }\n\n  // Delegate\n\n  /** Visits any expression, delegating to the respective visitor methods. */\n  visit(expr: ExpressionRef): void {\n    let previousExpression = this._currentExpression;\n    this._currentExpression = assert(expr);\n    switch (_BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Block: {\n        this.stack.push(expr);\n        let name = _BinaryenBlockGetName(expr);\n        if (name) this.visitLabel(name);\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitBlock(expr);\n        break;\n      }\n      case ExpressionId.If: {\n        this.stack.push(expr);\n        this.visit(_BinaryenIfGetCondition(expr));\n        this.visit(_BinaryenIfGetIfTrue(expr));\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\n        if (ifFalse) this.visit(ifFalse);\n        assert(this.stack.pop() == expr);\n        this.visitIf(expr);\n        break;\n      }\n      case ExpressionId.Loop: {\n        this.stack.push(expr);\n        let name = _BinaryenLoopGetName(expr);\n        if (name) this.visitLabel(name);\n        this.visit(_BinaryenLoopGetBody(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoop(expr);\n        break;\n      }\n      case ExpressionId.Break: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBreakGetName(expr));\n        let condition = _BinaryenBreakGetCondition(expr);\n        if (condition) this.visit(condition);\n        let value = _BinaryenBreakGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitBreak(expr);\n        break;\n      }\n      case ExpressionId.Switch: {\n        this.stack.push(expr);\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\n        if (defaultName) this.visitLabel(defaultName);\n        let numNames = _BinaryenSwitchGetNumNames(expr);\n        for (let i: Index = 0; i < numNames; ++i) {\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\n        }\n        this.visit(_BinaryenSwitchGetCondition(expr));\n        let value = _BinaryenSwitchGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitSwitch(expr);\n        break;\n      }\n      case ExpressionId.Call: {\n        this.visitCallPre(expr);\n        this.stack.push(expr);\n        this.visitName(_BinaryenCallGetTarget(expr));\n        let numOperands = _BinaryenCallGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCall(expr);\n        break;\n      }\n      case ExpressionId.CallIndirect: {\n        this.visitCallIndirectPre(expr);\n        this.stack.push(expr);\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCallIndirect(expr);\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalGet(expr);\n        break;\n      }\n      case ExpressionId.LocalSet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\n        this.visit(_BinaryenLocalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalSet(expr);\n        break;\n      }\n      case ExpressionId.GlobalGet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalGetGetName(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalGet(expr);\n        break;\n      }\n      case ExpressionId.GlobalSet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalSetGetName(expr));\n        this.visit(_BinaryenGlobalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalSet(expr);\n        break;\n      }\n      case ExpressionId.Load: {\n        this.stack.push(expr);\n        this.visit(_BinaryenLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoad(expr);\n        break;\n      }\n      case ExpressionId.Store: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStoreGetPtr(expr));\n        this.visit(_BinaryenStoreGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStore(expr);\n        break;\n      }\n      case ExpressionId.Const: {\n        this.visitConst(expr);\n        break;\n      }\n      case ExpressionId.Unary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenUnaryGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitUnary(expr);\n        break;\n      }\n      case ExpressionId.Binary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenBinaryGetLeft(expr));\n        this.visit(_BinaryenBinaryGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBinary(expr);\n        break;\n      }\n      case ExpressionId.Select: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSelectGetIfTrue(expr));\n        this.visit(_BinaryenSelectGetIfFalse(expr));\n        this.visit(_BinaryenSelectGetCondition(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSelect(expr);\n        break;\n      }\n      case ExpressionId.Drop: {\n        this.stack.push(expr);\n        this.visit(_BinaryenDropGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitDrop(expr);\n        break;\n      }\n      case ExpressionId.Return: {\n        let value = _BinaryenReturnGetValue(expr);\n        if (value) {\n          this.stack.push(expr);\n          this.visit(value);\n          assert(this.stack.pop() == expr);\n        }\n        this.visitReturn(expr);\n        break;\n      }\n      case ExpressionId.MemorySize: {\n        this.visitMemorySize(expr);\n        break;\n      }\n      case ExpressionId.MemoryGrow: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryGrow(expr);\n        break;\n      }\n      case ExpressionId.Nop: {\n        this.visitNop(expr);\n        break;\n      }\n      case ExpressionId.Unreachable: {\n        this.visitUnreachable(expr);\n        break;\n      }\n      case ExpressionId.AtomicRMW: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicRMW(expr);\n        break;\n      }\n      case ExpressionId.AtomicCmpxchg: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicCmpxchg(expr);\n        break;\n      }\n      case ExpressionId.AtomicWait: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicWait(expr);\n        break;\n      }\n      case ExpressionId.AtomicNotify: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicNotify(expr);\n        break;\n      }\n      case ExpressionId.AtomicFence: {\n        this.visitAtomicFence(expr);\n        break;\n      }\n      case ExpressionId.SIMDExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDExtract(expr);\n        break;\n      }\n      case ExpressionId.SIMDReplace: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDReplace(expr);\n        break;\n      }\n      case ExpressionId.SIMDShuffle: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShuffle(expr);\n        break;\n      }\n      case ExpressionId.SIMDTernary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDTernary(expr);\n        break;\n      }\n      case ExpressionId.SIMDShift: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShift(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoad: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoad(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoadStoreLane: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoadStoreLane(expr);\n        break;\n      }\n      case ExpressionId.MemoryInit: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryInitGetDest(expr));\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\n        this.visit(_BinaryenMemoryInitGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryInit(expr);\n        break;\n      }\n      case ExpressionId.DataDrop: {\n        this.visitDataDrop(expr);\n        break;\n      }\n      case ExpressionId.MemoryCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryCopy(expr);\n        break;\n      }\n      case ExpressionId.MemoryFill: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryFillGetDest(expr));\n        this.visit(_BinaryenMemoryFillGetValue(expr));\n        this.visit(_BinaryenMemoryFillGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryFill(expr);\n        break;\n      }\n      case ExpressionId.Pop: {\n        this.visitPop(expr);\n        break;\n      }\n      case ExpressionId.RefNull: {\n        this.visitRefNull(expr);\n        break;\n      }\n      case ExpressionId.RefIsNull: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefIsNullGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefIsNull(expr);\n        break;\n      }\n      case ExpressionId.RefFunc: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefFunc(expr);\n        break;\n      }\n      case ExpressionId.RefEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefEqGetLeft(expr));\n        this.visit(_BinaryenRefEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefEq(expr);\n        break;\n      }\n      case ExpressionId.Try: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTryGetBody(expr));\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitTry(expr);\n        break;\n      }\n      case ExpressionId.Throw: {\n        this.stack.push(expr);\n        this.visitTag(_BinaryenThrowGetTag(expr));\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitThrow(expr);\n        break;\n      }\n      case ExpressionId.Rethrow: {\n        this.visitRethrow(expr);\n        break;\n      }\n      case ExpressionId.TupleMake: {\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitTupleMake(expr);\n        break;\n      }\n      case ExpressionId.TupleExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\n        assert(this.stack.pop() == expr);\n        this.visitTupleExtract(expr);\n        break;\n      }\n      case ExpressionId.I31New: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31NewGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31New(expr);\n        break;\n      }\n      case ExpressionId.I31Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31GetGetI31(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31Get(expr);\n        break;\n      }\n      case ExpressionId.CallRef: {\n        this.stack.push(expr);\n        let numOperands = _BinaryenCallRefGetNumOperands(expr);\n        if (numOperands) {\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenCallRefGetOperandAt(expr, i));\n          }\n        }\n        this.visit(_BinaryenCallRefGetTarget(expr));\n        assert(this.stack.pop() == expr);\n        this.visitCallRef(expr);\n        break;\n      }\n      case ExpressionId.RefTest: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefTestGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefTest(expr);\n        break;\n      }\n      case ExpressionId.RefCast: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefCastGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefCast(expr);\n        break;\n      }\n      case ExpressionId.BrOn: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBrOnGetName(expr));\n        this.visit(_BinaryenBrOnGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBrOn(expr);\n        break;\n      }\n      case ExpressionId.StructNew: {\n        let numOperands = _BinaryenStructNewGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenStructNewGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitStructNew(expr);\n        break;\n      }\n      case ExpressionId.StructGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructGetGetRef(expr));\n        this.visitIndex(_BinaryenStructGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructGet(expr);\n        break;\n      }\n      case ExpressionId.StructSet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStructSetGetRef(expr));\n        this.visitIndex(_BinaryenStructSetGetIndex(expr));\n        this.visit(_BinaryenStructSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStructSet(expr);\n        break;\n      }\n      case ExpressionId.ArrayNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayNewGetSize(expr));\n        let init = _BinaryenArrayNewGetInit(expr);\n        if (init) this.visit(init);\n        assert(this.stack.pop() == expr);\n        this.visitArrayNew(expr);\n        break;\n      }\n      case ExpressionId.ArrayInit: {\n        let numValues = _BinaryenArrayInitGetNumValues(expr);\n        if (numValues) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numValues; ++i) {\n            this.visit(_BinaryenArrayInitGetValueAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitArrayInit(expr);\n        break;\n      }\n      case ExpressionId.ArrayGet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayGetGetRef(expr));\n        this.visit(_BinaryenArrayGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayGet(expr);\n        break;\n      }\n      case ExpressionId.ArraySet: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArraySetGetRef(expr));\n        this.visit(_BinaryenArraySetGetIndex(expr));\n        this.visit(_BinaryenArraySetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArraySet(expr);\n        break;\n      }\n      case ExpressionId.ArrayLen: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayLenGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayLen(expr);\n        break;\n      }\n      case ExpressionId.ArrayCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenArrayCopyGetDestRef(expr));\n        this.visit(_BinaryenArrayCopyGetDestIndex(expr));\n        this.visit(_BinaryenArrayCopyGetSrcRef(expr));\n        this.visit(_BinaryenArrayCopyGetSrcIndex(expr));\n        this.visit(_BinaryenArrayCopyGetLength(expr));\n        assert(this.stack.pop() == expr);\n        this.visitArrayCopy(expr);\n        break;\n      }\n      case ExpressionId.RefAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefAsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefAs(expr);\n        break;\n      }\n      case ExpressionId.StringNew: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringNewGetPtr(expr));\n        let length = _BinaryenStringNewGetLength(expr); // LM only\n        if (length) this.visit(length);\n        let start = _BinaryenStringNewGetStart(expr); // GC only\n        if (start) this.visit(start);\n        let end = _BinaryenStringNewGetEnd(expr); // GC only\n        if (end) this.visit(end);\n        assert(this.stack.pop() == expr);\n        this.visitStringNew(expr);\n        break;\n      }\n      case ExpressionId.StringConst: {\n        this.stack.push(expr);\n        assert(this.stack.pop() == expr);\n        this.visitStringConst(expr);\n        break;\n      }\n      case ExpressionId.StringMeasure: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringMeasureGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringMeasure(expr);\n        break;\n      }\n      case ExpressionId.StringEncode: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEncodeGetRef(expr));\n        this.visit(_BinaryenStringEncodeGetPtr(expr));\n        let start = _BinaryenStringEncodeGetStart(expr); // GC only\n        if (start) this.visit(start);\n        assert(this.stack.pop() == expr);\n        this.visitStringEncode(expr);\n        break;\n      }\n      case ExpressionId.StringConcat: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringConcatGetLeft(expr));\n        this.visit(_BinaryenStringConcatGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringConcat(expr);\n        break;\n      }\n      case ExpressionId.StringEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringEqGetLeft(expr));\n        this.visit(_BinaryenStringEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringEq(expr);\n        break;\n      }\n      case ExpressionId.StringAs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringAsGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringAs(expr);\n        break;\n      }\n      case ExpressionId.StringWTF8Advance: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF8AdvanceGetRef(expr));\n        this.visit(_BinaryenStringWTF8AdvanceGetPos(expr));\n        this.visit(_BinaryenStringWTF8AdvanceGetBytes(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF8Advance(expr);\n        break;\n      }\n      case ExpressionId.StringWTF16Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringWTF16GetGetRef(expr));\n        this.visit(_BinaryenStringWTF16GetGetPos(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringWTF16Get(expr);\n        break;\n      }\n      case ExpressionId.StringIterNext: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringIterNextGetRef(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringIterNext(expr);\n        break;\n      }\n      case ExpressionId.StringIterMove: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringIterMoveGetRef(expr));\n        this.visit(_BinaryenStringIterMoveGetNum(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringIterMove(expr);\n        break;\n      }\n      case ExpressionId.StringSliceWTF: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceWTFGetRef(expr));\n        this.visit(_BinaryenStringSliceWTFGetStart(expr));\n        this.visit(_BinaryenStringSliceWTFGetEnd(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceWTF(expr);\n        break;\n      }\n      case ExpressionId.StringSliceIter: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStringSliceIterGetRef(expr));\n        this.visit(_BinaryenStringSliceIterGetNum(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStringSliceIter(expr);\n        break;\n      }\n      default: throw new Error(\"unexpected expression kind\");\n    }\n    this._currentExpression = previousExpression;\n  }\n}\n\n/** Base class of custom Binaryen passes. */\nexport abstract class Pass extends Visitor {\n\n  /** Gets the current function being walked. */\n  get currentFunction(): FunctionRef {\n    let currentFunction = this._currentFunction;\n    if (!currentFunction) throw new Error(\"not walking a function\");\n    return currentFunction;\n  }\n  private _currentFunction: FunctionRef = 0;\n\n  /** Gets the current global being walked. */\n  get currentGlobal(): GlobalRef {\n    let currentGlobal = this._currentGlobal;\n    if (!currentGlobal) throw new Error(\"not walking a global\");\n    return currentGlobal;\n  }\n  private _currentGlobal: GlobalRef = 0;\n\n  /** Constructs a new Binaryen pass. */\n  constructor(readonly module: Module) {\n    super();\n  }\n\n  // Walking\n\n  /** Walks the entire module. */\n  walkModule(): void {\n    this.walkFunctions();\n    this.walkGlobals();\n  }\n\n  /** Walks all functions. */\n  walkFunctions(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific function. */\n  walkFunction(func: FunctionRef): void {\n    let body = _BinaryenFunctionGetBody(func);\n    if (body) {\n      this._currentFunction = func;\n      this.visit(body);\n      this._currentFunction = 0;\n    }\n  }\n\n  /** Walks all global variables. */\n  walkGlobals(): void {\n    let moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific global variable. */\n  walkGlobal(global: GlobalRef): void {\n    this._currentGlobal = global;\n    let init = _BinaryenGlobalGetInitExpr(global);\n    if (init) this.visit(init);\n    this._currentGlobal = 0;\n  }\n\n  // Utility\n\n  /** Replaces the current expression with the specified replacement. */\n  replaceCurrent(replacement: ExpressionRef): void {\n    let search = this.currentExpression;\n    let func = this.currentFunction;\n    let body = _BinaryenFunctionGetBody(func);\n    if (body == search) {\n      _BinaryenFunctionSetBody(func, replacement);\n    } else {\n      let parent = assert(this.parentExpressionOrNull);\n      let replaced = replaceChild(parent, search, replacement);\n      if (!replaced) throw Error(\"failed to replace expression\");\n      _BinaryenExpressionFinalize(parent);\n    }\n  }\n}\n\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\nexport function replaceChild(\n  /** Parent expression containing `search`. */\n  parent: ExpressionRef,\n  /** Expression to replace. */\n  search: ExpressionRef,\n  /** Expression to replace `search` with. */\n  replacement: ExpressionRef\n): ExpressionRef {\n  switch (_BinaryenExpressionGetId(parent)) {\n    case ExpressionId.Block: {\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\n      for (let i: Index = 0; i < numChildren; ++i) {\n        let child = _BinaryenBlockGetChildAt(parent, i);\n        if (child == search) {\n          _BinaryenBlockSetChildAt(parent, i, replacement);\n          return child;\n        }\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      let condition = _BinaryenIfGetCondition(parent);\n      if (condition == search) {\n        _BinaryenIfSetCondition(parent, replacement);\n        return condition;\n      }\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenIfSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenIfSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      break;\n    }\n    case ExpressionId.Loop: {\n      let body = _BinaryenLoopGetBody(parent);\n      if (body == search) {\n        _BinaryenLoopSetBody(parent, replacement);\n        return body;\n      }\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = _BinaryenBreakGetCondition(parent);\n      if (condition == search) {\n        _BinaryenBreakSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenBreakGetValue(parent);\n      if (value == search) {\n        _BinaryenBreakSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Switch: {\n      let condition = _BinaryenSwitchGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSwitchSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenSwitchGetValue(parent);\n      if (value == search) {\n        _BinaryenSwitchSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Call: {\n      let numOperands = _BinaryenCallGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      let target = _BinaryenCallIndirectGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallIndirectSetTarget(parent, replacement);\n        return target;\n      }\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      let value = _BinaryenLocalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenLocalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      let value = _BinaryenGlobalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenGlobalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Load: {\n      let ptr = _BinaryenLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.Store: {\n      let ptr = _BinaryenStoreGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStoreSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenStoreGetValue(parent);\n      if (value == search) {\n        _BinaryenStoreSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      let value = _BinaryenUnaryGetValue(parent);\n      if (value == search) {\n        _BinaryenUnarySetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Binary: {\n      let left = _BinaryenBinaryGetLeft(parent);\n      if (left == search) {\n        _BinaryenBinarySetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenBinaryGetRight(parent);\n      if (right == search) {\n        _BinaryenBinarySetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Select: {\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenSelectSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenSelectSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      let condition = _BinaryenSelectGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSelectSetCondition(parent, replacement);\n        return condition;\n      }\n      break;\n    }\n    case ExpressionId.Drop: {\n      let value = _BinaryenDropGetValue(parent);\n      if (value == search) {\n        _BinaryenDropSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Return: {\n      let value = _BinaryenReturnGetValue(parent);\n      if (value == search) {\n        _BinaryenReturnSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.MemorySize: {\n      break;\n    }\n    case ExpressionId.MemoryGrow: {\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\n      if (delta == search) {\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\n        return delta;\n      }\n      break;\n    }\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenAtomicRMWGetValue(parent);\n      if (value == search) {\n        _BinaryenAtomicRMWSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\n        return expected;\n      }\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\n      if (repl == search) {\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\n        return repl;\n      }\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\n        return expected;\n      }\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\n      if (timeout == search) {\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\n        return timeout;\n      }\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\n        return ptr;\n      }\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\n      if (notifyCount == search) {\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\n        return notifyCount;\n      }\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      let vec = _BinaryenSIMDExtractGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDExtractSetVec(parent, replacement);\n        return vec;\n      }\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\n        return vec;\n      }\n      let value = _BinaryenSIMDReplaceGetValue(parent);\n      if (value == search) {\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\n      if (left == search) {\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenSIMDShuffleGetRight(parent);\n      if (right == search) {\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      let a = _BinaryenSIMDTernaryGetA(parent);\n      if (a == search) {\n        _BinaryenSIMDTernarySetA(parent, replacement);\n        return a;\n      }\n      let b = _BinaryenSIMDTernaryGetB(parent);\n      if (b == search) {\n        _BinaryenSIMDTernarySetB(parent, replacement);\n        return b;\n      }\n      let c = _BinaryenSIMDTernaryGetC(parent);\n      if (c == search) {\n        _BinaryenSIMDTernarySetC(parent, replacement);\n        return c;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      let vec = _BinaryenSIMDShiftGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDShiftSetVec(parent, replacement);\n        return vec;\n      }\n      let shift = _BinaryenSIMDShiftGetShift(parent);\n      if (shift == search) {\n        _BinaryenSIMDShiftSetShift(parent, replacement);\n        return shift;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoadStoreLane: {\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\n        return ptr;\n      }\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      let dest = _BinaryenMemoryInitGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryInitSetDest(parent, replacement);\n        return dest;\n      }\n      let offset = _BinaryenMemoryInitGetOffset(parent);\n      if (offset == search) {\n        _BinaryenMemoryInitSetOffset(parent, replacement);\n        return offset;\n      }\n      let size = _BinaryenMemoryInitGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryInitSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      let dest = _BinaryenMemoryCopyGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryCopySetDest(parent, replacement);\n        return dest;\n      }\n      let source = _BinaryenMemoryCopyGetSource(parent);\n      if (source == search) {\n        _BinaryenMemoryCopySetSource(parent, replacement);\n        return source;\n      }\n      let size = _BinaryenMemoryCopyGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryCopySetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      let dest = _BinaryenMemoryFillGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryFillSetDest(parent, replacement);\n        return dest;\n      }\n      let value = _BinaryenMemoryFillGetValue(parent);\n      if (value == search) {\n        _BinaryenMemoryFillSetValue(parent, replacement);\n        return value;\n      }\n      let size = _BinaryenMemoryFillGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryFillSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIsNull: {\n      let value = _BinaryenRefIsNullGetValue(parent);\n      if (value == search) {\n        _BinaryenRefIsNullSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.RefEq: {\n      let left = _BinaryenRefEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenRefEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenRefEqGetRight(parent);\n      if (right == search) {\n        _BinaryenRefEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Try: {\n      let body = _BinaryenTryGetBody(parent);\n      if (body == search) {\n        _BinaryenTrySetBody(parent, replacement);\n        return body;\n      }\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\n        if (catchBody == search) {\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\n          return catchBody;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Throw: {\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\n      if (tuple == search) {\n        _BinaryenTupleExtractSetTuple(parent, replacement);\n        return tuple;\n      }\n      break;\n    }\n    case ExpressionId.I31New: {\n      let value = _BinaryenI31NewGetValue(parent);\n      if (value == search) {\n        _BinaryenI31NewSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.I31Get: {\n      let i31Expr = _BinaryenI31GetGetI31(parent);\n      if (i31Expr == search) {\n        _BinaryenI31GetSetI31(parent, replacement);\n        return i31Expr;\n      }\n      break;\n    }\n    case ExpressionId.CallRef: {\n      let numOperands = _BinaryenCallRefGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallRefGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallRefSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      let target = _BinaryenCallRefGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallRefSetTarget(parent, replacement);\n        return target;\n      }\n      break;\n    }\n    case ExpressionId.RefTest: {\n      let ref = _BinaryenRefTestGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefTestSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.RefCast: {\n      let ref = _BinaryenRefCastGetRef(parent);\n      if (ref == search) {\n        _BinaryenRefCastSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.BrOn: {\n      let ref = _BinaryenBrOnGetRef(parent);\n      if (ref == search) {\n        _BinaryenBrOnSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructNew: {\n      let numOperands = _BinaryenStructNewGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenStructNewGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenStructNewSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.StructGet: {\n      let ref = _BinaryenStructGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructGetSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StructSet: {\n      let ref = _BinaryenStructSetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStructSetSetRef(parent, replacement);\n        return ref;\n      }\n      let value = _BinaryenStructSetGetValue(parent);\n      if (value == search) {\n        _BinaryenStructSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayNew: {\n      let size = _BinaryenArrayNewGetSize(parent);\n      if (size == search) {\n        _BinaryenArrayNewSetSize(parent, replacement);\n        return size;\n      }\n      let init = _BinaryenArrayNewGetInit(parent);\n      if (init == search) {\n        _BinaryenArrayNewSetInit(parent, replacement);\n        return init;\n      }\n      break;\n    }\n    case ExpressionId.ArrayInit: {\n      let numValues = _BinaryenArrayInitGetNumValues(parent);\n      for (let i: Index = 0; i < numValues; ++i) {\n        let value = _BinaryenArrayInitGetValueAt(parent, i);\n        if (value == search) {\n          _BinaryenArrayInitSetValueAt(parent, i, replacement);\n          return value;\n        }\n      }\n      break;\n    }\n    case ExpressionId.ArrayGet: {\n      let ref = _BinaryenArrayGetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayGetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArrayGetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArrayGetSetIndex(parent, replacement);\n        return index;\n      }\n      break;\n    }\n    case ExpressionId.ArraySet: {\n      let ref = _BinaryenArraySetGetRef(parent);\n      if (ref == search) {\n        _BinaryenArraySetSetRef(parent, replacement);\n        return ref;\n      }\n      let index = _BinaryenArraySetGetIndex(parent);\n      if (index == search) {\n        _BinaryenArraySetSetIndex(parent, replacement);\n        return index;\n      }\n      let value = _BinaryenArraySetGetValue(parent);\n      if (value == search) {\n        _BinaryenArraySetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.ArrayLen: {\n      let ref = _BinaryenArrayLenGetRef(parent);\n      if (ref == search) {\n        _BinaryenArrayLenSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.ArrayCopy: {\n      let destRef = _BinaryenArrayCopyGetDestRef(parent);\n      if (destRef == search) {\n        _BinaryenArrayCopySetDestRef(parent, replacement);\n        return destRef;\n      }\n      let destIndex = _BinaryenArrayCopyGetDestIndex(parent);\n      if (destIndex == search) {\n        _BinaryenArrayCopySetDestIndex(parent, replacement);\n        return destIndex;\n      }\n      let srcRef = _BinaryenArrayCopyGetSrcRef(parent);\n      if (srcRef == search) {\n        _BinaryenArrayCopySetSrcRef(parent, replacement);\n        return srcRef;\n      }\n      let srcIndex = _BinaryenArrayCopyGetSrcIndex(parent);\n      if (srcIndex == search) {\n        _BinaryenArrayCopySetSrcIndex(parent, replacement);\n        return srcIndex;\n      }\n      let length = _BinaryenArrayCopyGetLength(parent);\n      if (length == search) {\n        _BinaryenArrayCopySetLength(parent, replacement);\n        return length;\n      }\n      break;\n    }\n    case ExpressionId.RefAs: {\n      let value = _BinaryenRefAsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefAsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.StringNew: {\n      let ptr = _BinaryenStringNewGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStringNewSetPtr(parent, replacement);\n        return ptr;\n      }\n      let length = _BinaryenStringNewGetLength(parent);\n      if (length == search) {\n        _BinaryenStringNewSetLength(parent, replacement);\n        return length;\n      }\n      let start = _BinaryenStringNewGetStart(parent);\n      if (start == search) {\n        _BinaryenStringNewSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringNewGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringNewSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringConst: {\n      break;\n    }\n    case ExpressionId.StringMeasure: {\n      let ref = _BinaryenStringMeasureGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringMeasureSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringEncode: {\n      let ref = _BinaryenStringEncodeGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringEncodeSetRef(parent, replacement);\n        return ref;\n      }\n      let ptr = _BinaryenStringEncodeGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStringEncodeSetPtr(parent, replacement);\n        return ptr;\n      }\n      let start = _BinaryenStringEncodeGetStart(parent);\n      if (start == search) {\n        _BinaryenStringEncodeSetStart(parent, replacement);\n        return start;\n      }\n      break;\n    }\n    case ExpressionId.StringConcat: {\n      let left = _BinaryenStringConcatGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringConcatSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringConcatGetRight(parent);\n      if (right == search) {\n        _BinaryenStringConcatSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringEq: {\n      let left = _BinaryenStringEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenStringEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenStringEqGetRight(parent);\n      if (right == search) {\n        _BinaryenStringEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.StringAs: {\n      let ref = _BinaryenStringAsGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringAsSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF8Advance: {\n      let ref = _BinaryenStringWTF8AdvanceGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF8AdvanceSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF8AdvanceGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF8AdvanceSetPos(parent, replacement);\n        return pos;\n      }\n      let bytes = _BinaryenStringWTF8AdvanceGetBytes(parent);\n      if (bytes == search) {\n        _BinaryenStringWTF8AdvanceSetBytes(parent, replacement);\n        return bytes;\n      }\n      break;\n    }\n    case ExpressionId.StringWTF16Get: {\n      let ref = _BinaryenStringWTF16GetGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringWTF16GetSetRef(parent, replacement);\n        return ref;\n      }\n      let pos = _BinaryenStringWTF16GetGetPos(parent);\n      if (pos == search) {\n        _BinaryenStringWTF16GetSetPos(parent, replacement);\n        return pos;\n      }\n      break;\n    }\n    case ExpressionId.StringIterNext: {\n      let ref = _BinaryenStringIterNextGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringIterNextSetRef(parent, replacement);\n        return ref;\n      }\n      break;\n    }\n    case ExpressionId.StringIterMove: {\n      let ref = _BinaryenStringIterMoveGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringIterMoveSetRef(parent, replacement);\n        return ref;\n      }\n      let num = _BinaryenStringIterMoveGetNum(parent);\n      if (num == search) {\n        _BinaryenStringIterMoveSetNum(parent, replacement);\n        return num;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceWTF: {\n      let ref = _BinaryenStringSliceWTFGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceWTFSetRef(parent, replacement);\n        return ref;\n      }\n      let start = _BinaryenStringSliceWTFGetStart(parent);\n      if (start == search) {\n        _BinaryenStringSliceWTFSetStart(parent, replacement);\n        return start;\n      }\n      let end = _BinaryenStringSliceWTFGetEnd(parent);\n      if (end == search) {\n        _BinaryenStringSliceWTFSetEnd(parent, replacement);\n        return end;\n      }\n      break;\n    }\n    case ExpressionId.StringSliceIter: {\n      let ref = _BinaryenStringSliceIterGetRef(parent);\n      if (ref == search) {\n        _BinaryenStringSliceIterSetRef(parent, replacement);\n        return ref;\n      }\n      let num = _BinaryenStringSliceIterGetNum(parent);\n      if (num == search) {\n        _BinaryenStringSliceIterSetNum(parent, replacement);\n        return num;\n      }\n      break;\n    }\n    default: throw new Error(\"unexpected expression id\");\n  }\n  return 0;\n}\n","/**\n * @fileoverview Shadow stack instrumentation for a precise GC.\n *\n * Instruments function arguments and local assignments marked with a 'tostack'\n * call to also do stores to a shadow stack of managed values only.\n *\n * Consider a simple call to a function looking like the following, taking\n * managed arguments, plus assigning managed values to locals:\n *\n *   function foo(a: Obj, b: Obj): Obj {\n *     let c = __tostack(a) // slot 2\n *     __collect()\n *     return b\n *   }\n *\n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\n *\n * At the call to `__collect()` the 32-bit stack frame of the function is:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed argument 'a'\n *      4   | Second managed argument 'b'\n *   -------|----------------------------\n *      8   | First managed local 'c'\n *\n * We are splitting the frame in two halves as annotated since both halves are\n * only known separately for indirect calls, with the first half becoming an\n * extension of the calling function's stack frame by means of treating the\n * arguments as if these were locals beyond the caller's `numLocals`. Function\n * arguments stay a bit longer on the stack than usually, but we also don't have\n * to modify the stack pointer pre-call at all this way. The caller's amended\n * stack frame when assuming one managed local may look like this:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local '?'\n *      4   | Extended with first managed argument 'a'\n *      8   | Extended with second managed argument 'b'\n *\n * with the callee's stack frame becoming just:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local 'c'\n *\n * Instrumentation added below looks about like the following, with the stack\n * growing downwards and 't' and 'r' being new temporary locals:\n *\n *   // callee frameSize = 1 * sizeof<usize>()\n *   function foo(a: usize, b: usize): usize {\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\n *     __collect()\n *     let r = b\n *     __stack_pointer += frameSize\n *     return r\n *   }\n *\n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\n *   (\n *     r = foo(\n *       ( t = a,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\n *         t ),\n *       ( t = b,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\n *         t )\n *     ),\n *     r\n *   )\n *\n * Also note that we have to `memory.fill` the second half because the first\n * assignment to a local may happen at a later point within the function. The\n * invariant we need to maintain for a precise GC is that it only sees zeroes\n * or valid pointers, but never an invalid pointer left on the stack earlier.\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\n * size of 16 bytes, and `memory.fill`, if available, beyond.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  _BinaryenAddFunction,\n  _BinaryenAddFunctionExport,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallGetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionSetBody,\n  _BinaryenGetExport,\n  _BinaryenGetFunction,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetSetValue,\n  _BinaryenRemoveExport,\n  _BinaryenRemoveFunction,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n  _free\n} from \"../glue/binaryen\";\n\nimport {\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  Index,\n  BinaryOp,\n  TypeRef,\n  allocPtrArray,\n  Module,\n  ExternalKind,\n  ExportRef,\n  expandType,\n  isConstZero,\n} from \"../module\";\n\nimport {\n  Compiler,\n  Options\n} from \"../compiler\";\n\nimport {\n  Feature\n} from \"../common\";\n\nimport {\n  BuiltinNames\n} from \"../builtins\";\n\nimport {\n  Source\n} from \"../ast\";\n\ntype LocalIndex = Index;\ntype SlotIndex = Index;\ntype SlotMap = Map<LocalIndex,SlotIndex>;\ntype TempMap = Map<TypeRef,LocalIndex>;\n\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\n  if (\n    _BinaryenExpressionGetId(expr) == ExpressionId.Call &&\n    module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack\n  ) {\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\n    return _BinaryenCallGetOperandAt(expr, 0);\n  }\n  return 0;\n}\n\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\nfunction needsSlot(module: Module, value: ExpressionRef): bool {\n  switch (_BinaryenExpressionGetId(value)) {\n    // no need to stack null pointers\n    case ExpressionId.Const: return !isConstZero(value);\n    // note: can't omit a slot when assigning from another local since the other\n    // local might have shorter lifetime and become reassigned, say in a loop,\n    // then no longer holding on to the previous value in its stack slot.\n  }\n  return true;\n}\n\n/** Instruments a module with a shadow stack for precise GC. */\nexport class ShadowStackPass extends Pass {\n  /** Stack frame slots, per function. */\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\n  /** Temporary locals, per function. */\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\n  /** Exports (with managed operands) map. */\n  exportMap: Map<string,i32[]> = new Map();\n  /** Compiler reference. */\n  compiler: Compiler;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.compiler = compiler;\n  }\n\n  /** Compiler options. */\n  get options(): Options { return this.compiler.options; }\n  /** Target pointer type. */\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\n  /** Target pointer size. */\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\n  /** Target pointer addition operation. */\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\n  /** Target pointer subtraction operation. */\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\n\n  /** Gets a constant with the specified value of the target pointer type. */\n  ptrConst(value: i32): ExpressionRef {\n    return this.ptrType == TypeRef.I64\n      ? this.module.i64(value)\n      : this.module.i32(value);\n  }\n\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\n    let slotMap: SlotMap;\n    if (this.slotMaps.has(func)) {\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      if (slotMap.has(localIndex)) {\n        return changetype<i32>(slotMap.get(localIndex));\n      }\n    } else {\n      slotMap = new Map();\n      this.slotMaps.set(func, slotMap);\n    }\n    let slotIndex = slotMap.size;\n    slotMap.set(localIndex, slotIndex);\n    return slotIndex;\n  }\n\n  /** Notes the presence of an exported function taking managed operands. */\n  noteExport(name: string, managedOperandIndices: i32[]): void {\n    if (!managedOperandIndices.length) return;\n    this.exportMap.set(name, managedOperandIndices);\n  }\n\n  /** Gets a shared temporary local of the given type in the specified functions. */\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\n    let tempMap: TempMap;\n    if (this.tempMaps.has(func)) {\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\n      if (tempMap.has(type)) {\n        return changetype<Index>(tempMap.get(type));\n      }\n    } else {\n      tempMap = new Map();\n      this.tempMaps.set(func, tempMap);\n    }\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\n    let localIndex = numLocals + tempMap.size;\n    tempMap.set(type, localIndex);\n    return localIndex;\n  }\n\n  /** Makes an expression modifying the stack pointer by the given offset. */\n  makeStackOffset(offset: i32): ExpressionRef {\n    assert(offset != 0);\n    let module = this.module;\n    let expr = module.global_set(BuiltinNames.stack_pointer,\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        this.ptrConst(abs(offset))\n      )\n    );\n    if (offset > 0) return expr;\n    return module.block(null, [\n      expr,\n      this.makeStackCheck()\n    ], TypeRef.None);\n  }\n\n  /** Makes a sequence of expressions zeroing the stack frame. */\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\n    assert(frameSize > 0);\n    let module = this.module;\n    if (this.options.hasFeature(Feature.BulkMemory) && frameSize > 16) {\n      stmts.push(\n        module.memory_fill(\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.i32(0), // TODO: Wasm64 also i32?\n          this.ptrConst(frameSize)\n        )\n      );\n    } else {\n      let remain = frameSize;\n      while (remain >= 8) {\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(8,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i64(0),\n            TypeRef.I64,\n            frameSize - remain\n          )\n        );\n        remain -= 8;\n      }\n      if (remain) {\n        assert(remain == 4);\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(4,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i32(0),\n            TypeRef.I32,\n            frameSize - remain\n          )\n        );\n      }\n    }\n  }\n\n  private hasStackCheckFunction: bool = false;\n\n  /** Makes a check that the current stack pointer is valid. */\n  makeStackCheck(): ExpressionRef {\n    let module = this.module;\n    if (!this.hasStackCheckFunction) {\n      this.hasStackCheckFunction = true;\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\n        module.if(\n          module.binary(BinaryOp.LtI32,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.global_get(BuiltinNames.data_end, this.ptrType)\n          ),\n          this.compiler.makeStaticAbort(\n            this.compiler.ensureStaticString(\"stack overflow\"),\n            Source.native\n          )\n        )\n      );\n    }\n    return module.call(\"~stack_check\", null, TypeRef.None);\n  }\n\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\n    let module = this.module;\n    let numSlots = 0;\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      let operand = operands[i];\n      let match = matchPattern(module, operand);\n      if (!match) continue;\n      if (!needsSlot(module, match)) {\n        operands[i] = match;\n        continue;\n      }\n      let currentFunction = this.currentFunction;\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\n      let stmts = new Array<ExpressionRef>();\n      // t = value\n      stmts.push(\n        module.local_set(temp, match, false)\n      );\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\n      stmts.push(\n        module.store(this.ptrSize,\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.local_get(temp, this.ptrType),\n          this.ptrType, slotIndex * this.ptrSize\n        )\n      );\n      // -> t\n      stmts.push(\n        module.local_get(temp, this.ptrType)\n      );\n      operands[i] = module.block(null, stmts, this.ptrType);\n      ++numSlots;\n    }\n    return numSlots;\n  }\n\n  /** Slot offset accounting for nested calls. */\n  private callSlotOffset: i32 = 0;\n  /** Slot offset stack in nested calls. */\n  private callSlotStack: i32[] = new Array();\n\n  /** @override */\n  visitCallPre(call: ExpressionRef): void {\n    let numOperands = _BinaryenCallGetNumOperands(call);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCall(call: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCallIndirect(callIndirect: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    let module = this.module;\n    let value = _BinaryenLocalSetGetValue(localSet);\n    let match = matchPattern(module, value);\n    if (!match) return;\n    if (!needsSlot(module, match)) {\n      _BinaryenLocalSetSetValue(localSet, match);\n      return;\n    }\n    let index = _BinaryenLocalSetGetIndex(localSet);\n    let slotIndex = this.noteSlot(this.currentFunction, index);\n    let stmts = new Array<ExpressionRef>();\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\n    stmts.push(\n      module.store(this.ptrSize,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        module.local_tee(index, match, false),\n        this.ptrType, slotIndex * this.ptrSize\n      )\n    );\n    if (_BinaryenLocalSetIsTee(localSet)) {\n      // -> local\n      stmts.push(\n        module.local_get(index, this.ptrType)\n      );\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\n    } else {\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\n    }\n  }\n\n  /** Updates a function with additional locals etc. */\n  updateFunction(funcRef: FunctionRef): void {\n    let name = _BinaryenFunctionGetName(funcRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\n    let vars = new Array<TypeRef>();\n    for (let i: Index = 0; i < numVars; ++i) {\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\n    }\n    let tempMaps = this.tempMaps;\n    if (tempMaps.has(funcRef)) {\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\n        vars.push(_keys[i]);\n      }\n    }\n    let moduleRef = this.module.ref;\n    _BinaryenRemoveFunction(moduleRef, name);\n    let cArr = allocPtrArray(vars);\n    let newFuncRef = _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\n    if (this.options.sourceMap || this.options.debugInfo) {\n      let func = this.compiler.program.searchFunctionByRef(newFuncRef);\n      if (func) func.addDebugInfo(this.module, newFuncRef);\n    }\n    _free(cArr);\n  }\n\n  /** Updates a function export taking managed arguments. */\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\n    let module = this.module;\n    let moduleRef = module.ref;\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\n\n    let internalNameRef = _BinaryenExportGetValue(exportRef);\n    let internalName = module.readStringCached(internalNameRef)!;\n    let externalNameRef = _BinaryenExportGetName(exportRef);\n    let funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let paramTypes = expandType(params);\n    let numParams = paramTypes.length;\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let numLocals = numParams;\n    let vars = new Array<TypeRef>();\n    let numSlots = assert(managedOperandIndices.length);\n    let frameSize = numSlots * this.ptrSize;\n    let wrapperName = \"export:\" + internalName;\n    let wrapperNameRef = module.allocStringCached(wrapperName);\n\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\n        stmts.push(\n          module.store(this.ptrSize,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\n            this.ptrType, slotIndex * this.ptrSize\n          )\n        );\n      }\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\n      for (let i = 0; i < numParams; ++i) {\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\n      }\n      if (results != TypeRef.None) {\n        let tempIndex = numLocals++;\n        vars.push(results);\n        // t = original(...)\n        stmts.push(\n          module.local_set(tempIndex,\n            module.call(internalName, forwardedOperands, results),\n            false // internal\n          )\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(tempIndex, results)\n        );\n      } else {\n        // original(...)\n        stmts.push(\n          module.call(internalName, forwardedOperands, results)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      }\n      let cArr = allocPtrArray(vars);\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\n        module.block(null, stmts, results)\n      );\n      _free(cArr);\n    }\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\n  }\n\n  /** @override */\n  walkModule(): void {\n    // Run the pass normally\n    super.walkModule();\n\n    // Instrument returns in functions utilizing stack slots\n    let module = this.module;\n    let instrumentReturns = new InstrumentReturns(this);\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\n      let func = _keys[i];\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      let frameSize = slotMap.size * this.ptrSize;\n\n      // Instrument function returns\n      instrumentReturns.frameSize = frameSize;\n      instrumentReturns.walkFunction(func);\n\n      // Instrument function entry\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      // memory.fill(__stack_pointer, 0, frameSize)\n      this.makeStackFill(frameSize, stmts);\n\n      // Handle implicit return\n      let body = _BinaryenFunctionGetBody(func);\n      let bodyType = _BinaryenExpressionGetType(body);\n      if (bodyType == TypeRef.Unreachable) {\n        // body\n        stmts.push(\n          body\n        );\n      } else if (bodyType == TypeRef.None) {\n        // body\n        stmts.push(\n          body\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      } else {\n        let temp = this.getSharedTemp(func, bodyType);\n        // t = body\n        stmts.push(\n          module.local_set(temp, body, false)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(temp, bodyType)\n        );\n      }\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\n    }\n\n    // Update functions we added more locals to\n    // TODO: _BinaryenFunctionAddVar ?\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\n      this.updateFunction(_keys[i]);\n    }\n\n    // Update exports taking managed arguments\n    let exportMap = this.exportMap;\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\n      let exportName = _keys[i];\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\n      this.updateExport(exportRef, managedOperandIndices);\n    }\n  }\n}\n\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\nclass InstrumentReturns extends Pass {\n  /** Parent pass. */\n  parentPass: ShadowStackPass;\n  /** Frame size of the current function being processed. */\n  frameSize: i32 = 0;\n\n  constructor(shadowStack: ShadowStackPass) {\n    super(shadowStack.module);\n    this.parentPass = shadowStack;\n  }\n\n  /** @override */\n  visitReturn(ret: ExpressionRef): void {\n    assert(this.frameSize);\n    let module = this.module;\n    let value = _BinaryenReturnGetValue(ret);\n    let stmts = new Array<ExpressionRef>();\n    if (value) {\n      let returnType = _BinaryenExpressionGetType(value);\n      if (returnType == TypeRef.Unreachable) return;\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\n      // t = value\n      stmts.push(\n        module.local_set(temp, value, false)\n      );\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return t\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\n    } else {\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return\n    }\n    stmts.push(\n      ret\n    );\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\n  }\n}\n","/**\n * @fileoverview A lightweight store instrumentation pass.\n * \n * Can be used to find rogue stores to protected memory addresses like object\n * headers or similar, without going overboard with instrumentation. Also\n * passes a flag whether a store originates within the runtime or other code.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  Compiler\n} from \"../compiler\";\n\nimport {\n  createType,\n  ExpressionRef,\n  TypeRef\n} from \"../module\";\n\nimport {\n  _BinaryenFunctionGetName,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr\n} from \"../glue/binaryen\";\n\n/** Instruments stores to also call an import. */\nexport class RtraceMemory extends Pass {\n  /** Whether we've seen any stores. */\n  seenStores: bool = false;\n  /** Target pointer type. */\n  ptrType: TypeRef;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.ptrType = compiler.options.sizeTypeRef;\n  }\n\n  checkRT(): bool {\n    let functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\n    return functionName.startsWith(\"~lib/rt/\");\n  }\n\n  /** @override */\n  visitStore(store: ExpressionRef): void {\n    let module = this.module;\n    let ptr = _BinaryenStoreGetPtr(store);\n    let offset = _BinaryenStoreGetOffset(store);\n    let bytes = _BinaryenStoreGetBytes(store);\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\n    _BinaryenStoreSetPtr(store,\n      module.call(\"~onstore\", [\n        ptr,\n        module.i32(offset),\n        module.i32(bytes),\n        module.i32(i32(this.checkRT()))\n      ], this.ptrType)\n    );\n    this.seenStores = true;\n  }\n\n  // TODO: MemoryFill, Atomics\n\n  /** @override */\n  walkModule(): void {\n    super.walkModule();\n    if (this.seenStores) {\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\n        this.ptrType\n      );\n    }\n  }\n}\n","import {\n  SourceKind\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  ClassPrototype,\n  Element,\n  ElementKind,\n  Function,\n  Enum,\n  Class,\n  Interface,\n  File,\n  FunctionPrototype,\n  Global,\n  Program,\n  Property,\n  PropertyPrototype,\n  InterfacePrototype\n} from \"../program\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.UserEntry) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    let exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    let exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.Private) && !this.includePrivate) return;\n    let seen = this.seen;\n    if (!element.is(CommonFlags.Instance) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.Global: {\n        if (element.is(CommonFlags.Compiled)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.Enum: {\n        if (element.is(CommonFlags.Compiled)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.EnumValue: break; // handled by visitEnum\n      case ElementKind.FunctionPrototype: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.ClassPrototype: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.InterfacePrototype: {\n        this.visitInterfaceInstances(name, <InterfacePrototype>element);\n        break;\n      }\n      case ElementKind.PropertyPrototype: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.Property: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.Namespace: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TypeDefinition:\n      case ElementKind.IndexSignature: break;\n      default: {\n        // Not (directly) reachable exports:\n        // File, Local, Function, Class, Interface\n        assert(false);\n      }\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.Compiled)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        assert(instance.kind == ElementKind.Class);\n        if (instance.is(CommonFlags.Compiled)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  private visitInterfaceInstances(name: string, element: InterfacePrototype): void {\n    let instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = <Interface>unchecked(_values[i]);\n        assert(instance.kind == ElementKind.Interface);\n        if (instance.is(CommonFlags.Compiled)) this.visitInterface(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n// Helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nexport function hasCompiledMember(element: Element): bool {\n  let members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FunctionPrototype: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.ClassPrototype: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.Compiled)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.Compiled) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n","import {\n  Source\n} from \"../ast\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\nimport {\n  Global,\n  Program,\n  Function,\n  Class,\n  Interface,\n  Enum,\n  ElementKind,\n  Element,\n  PropertyPrototype\n} from \"../program\";\n\nimport {\n  Type,\n  TypeFlags\n} from \"../types\";\n\nimport {\n  CharCode,\n  escapeString,\n  indent, isIdentifier\n} from \"../util\";\n\nimport {\n  ExportsWalker\n} from \"./util\";\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program, esm: bool = true): string {\n    return new TSDBuilder(program, esm).build();\n  }\n\n  private esm: bool;\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n  private seenObjectTypes: Map<Class,string> = new Map();\n  private deferredTypings: string[] = new Array();\n\n  /** Constructs a new TypeScript definitions builder. */\n  constructor(program: Program, esm: bool, includePrivate: bool = false) {\n    super(program, includePrivate);\n    this.esm = esm;\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    let sb = this.sb;\n    let type = element.type;\n    let tsType = this.toTypeScriptType(type, Mode.EXPORT);\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"const \");\n    sb.push(name);\n    sb.push(\": {\\n\");\n    indent(sb, ++this.indentLevel);\n    sb.push(\"/** @type `\");\n    sb.push(type.toString());\n    sb.push(\"` */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"get value(): \");\n    sb.push(tsType);\n    if (!element.is(CommonFlags.Const)) {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"set value(value: \");\n      sb.push(tsType);\n      sb.push(\");\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"};\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    let sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"/** \");\n    sb.push(element.internalName);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    let members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.EnumValue) continue;\n        indent(sb, this.indentLevel);\n        sb.push(\"/** @type `i32` */\\n\");\n        indent(sb, this.indentLevel);\n        sb.push(memberName);\n        sb.push(\",\\n\");\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    let sb = this.sb;\n    let signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(\"/**\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\" * \");\n    sb.push(element.internalName);\n    sb.push(\"\\n\");\n    let parameterTypes = signature.parameterTypes;\n    let numParameters = parameterTypes.length;\n    for (let i = 0; i < numParameters; ++i) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @param \");\n      sb.push(element.getParameterName(i));\n      sb.push(\" `\");\n      sb.push(parameterTypes[i].toString());\n      sb.push(\"`\\n\");\n    }\n    let returnType = signature.returnType;\n    if (returnType != Type.void) {\n      indent(sb, this.indentLevel);\n      sb.push(\" * @returns `\");\n      sb.push(returnType.toString());\n      sb.push(\"`\\n\");\n    }\n    indent(sb, this.indentLevel);\n    sb.push(\" */\\n\");\n    indent(sb, this.indentLevel);\n    sb.push(\"export \");\n    if (this.esm) sb.push(\"declare \");\n    sb.push(\"function \");\n    sb.push(name);\n    sb.push(\"(\");\n    let requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      sb.push(element.getParameterName(i));\n      if (i >= requiredParameters) sb.push(\"?\");\n      sb.push(\": \");\n      sb.push(this.toTypeScriptType(parameterTypes[i], Mode.IMPORT));\n    }\n    sb.push(\"): \");\n    sb.push(this.toTypeScriptType(returnType, Mode.EXPORT));\n    sb.push(\";\\n\");\n  }\n\n  visitClass(name: string, element: Class): void {\n    // not implemented\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    // not implemented\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    // not implemented\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // not implemented\n  }\n\n  build(): string {\n    let sb = this.sb;\n    if (!this.esm) {\n      sb.push(\"declare namespace __AdaptedExports {\\n\");\n      ++this.indentLevel;\n    }\n    if (this.program.options.exportMemory) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported memory */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const memory: WebAssembly.Memory;\\n`);\n    }\n    if (this.program.options.exportTable) {\n      indent(sb, this.indentLevel);\n      sb.push(\"/** Exported table */\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(`export ${this.esm ? \"declare \" : \"\"}const table: WebAssembly.Table;\\n`);\n    }\n    this.walk();\n    if (!this.esm) {\n      --this.indentLevel;\n      sb.push(\"}\\n\");\n    }\n    let deferredTypes = this.deferredTypings;\n    for (let i = 0, k = deferredTypes.length; i < k; ++i) {\n      sb.push(deferredTypes[i]);\n    }\n    if (!this.esm) {\n      sb.push(\"/** Instantiates the compiled WebAssembly module with the given imports. */\\n\");\n      sb.push(\"export declare function instantiate(module: WebAssembly.Module, imports: {\\n\");\n      let moduleImports = this.program.moduleImports;\n      for (let _keys = Map_keys(moduleImports), i = 0, k = _keys.length; i < k; ++i) {\n        let moduleName = _keys[i];\n        sb.push(\"  \");\n        if (isIdentifier(moduleName)) {\n          sb.push(moduleName);\n        } else {\n          sb.push(\"\\\"\");\n          sb.push(escapeString(moduleName, CharCode.DoubleQuote));\n          sb.push(\"\\\"\");\n        }\n        sb.push(\": unknown,\\n\");\n      }\n      sb.push(\"}): Promise<typeof __AdaptedExports>;\\n\");\n    }\n    return sb.join(\"\");\n  }\n\n  isPlainObject(clazz: Class): bool {\n    // A plain object does not inherit and does not have a constructor or private properties\n    if (clazz.base && !clazz.prototype.implicitlyExtendsObject) return false;\n    let members = clazz.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.isAny(CommonFlags.Private | CommonFlags.Protected)) return false;\n        if (member.is(CommonFlags.Constructor)) {\n          // a generated constructor is ok\n          if (member.declaration.range != Source.native.range) return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  toTypeScriptType(type: Type, mode: Mode): string {\n    if (type.isInternalReference) {\n      const sb = new Array<string>();\n      const clazz = assert(type.getClassOrWrapper(this.program));\n      if (clazz.extendsPrototype(this.program.arrayBufferInstance.prototype)) {\n        sb.push(\"ArrayBuffer\");\n      } else if (clazz.extendsPrototype(this.program.stringInstance.prototype)) {\n        sb.push(\"string\");\n      } else if (clazz.extendsPrototype(this.program.arrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"Array<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extendsPrototype(this.program.staticArrayPrototype)) {\n        const valueType = clazz.getArrayValueType();\n        sb.push(\"ArrayLike<\");\n        sb.push(this.toTypeScriptType(valueType, mode));\n        sb.push(\">\");\n      } else if (clazz.extendsPrototype(this.program.arrayBufferViewInstance.prototype)) {\n        const valueType = clazz.getArrayValueType();\n        if (valueType == Type.i8) {\n          sb.push(\"Int8Array\");\n        } else if (valueType == Type.u8) {\n          if (clazz.extendsPrototype(this.program.uint8ClampedArrayPrototype)) {\n            sb.push(\"Uint8ClampedArray\");\n          } else {\n            sb.push(\"Uint8Array\");\n          }\n        } else if (valueType == Type.i16) {\n          sb.push(\"Int16Array\");\n        } else if (valueType == Type.u16) {\n          sb.push(\"Uint16Array\");\n        } else if (valueType == Type.i32) {\n          sb.push(\"Int32Array\");\n        } else if (valueType == Type.u32) {\n          sb.push(\"Uint32Array\");\n        } else if (valueType == Type.i64) {\n          sb.push(\"BigInt64Array\");\n        } else if (valueType == Type.u64) {\n          sb.push(\"BigUint64Array\");\n        } else if (valueType == Type.f32) {\n          sb.push(\"Float32Array\");\n        } else if (valueType == Type.f64) {\n          sb.push(\"Float64Array\");\n        } else {\n          sb.push(\"unknown\");\n        }\n      } else {\n        let seenObjectTypes = this.seenObjectTypes;\n        let typeName: string;\n        if (seenObjectTypes.has(clazz)) {\n          typeName = assert(seenObjectTypes.get(clazz));\n          sb.push(typeName);\n          if (this.isPlainObject(clazz)) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n          }\n        } else {\n          let isPlain = this.isPlainObject(clazz);\n          typeName = `${isPlain ? \"__Record\" : \"__Internref\"}${clazz.id}`;\n          sb.push(typeName);\n          seenObjectTypes.set(clazz, typeName);\n          if (isPlain) {\n            sb.push(mode == Mode.EXPORT ? \"<never>\" : \"<undefined>\");\n            this.deferredTypings.push(this.makeRecordType(clazz, mode));\n          } else {\n            this.deferredTypings.push(this.makeInternrefType(clazz));\n          }\n        }\n      }\n      if (type.is(TypeFlags.Nullable)) {\n        sb.push(\" | null\");\n      }\n      return sb.join(\"\");\n    } else {\n      if (type == Type.bool) {\n        return \"boolean\";\n      }\n      if (type == Type.void) {\n        return \"void\";\n      }\n      if (type.isNumericValue) {\n        if (type.isLongIntegerValue) {\n          return \"bigint\";\n        }\n        return \"number\";\n      }\n    }\n    return \"unknown\";\n  }\n\n  makeRecordType(clazz: Class, mode: Mode): string {\n    let sb = new Array<string>();\n    let members = clazz.members;\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\ndeclare interface __Record\");\n    sb.push(clazz.id.toString());\n    sb.push(\"<TOmittable> {\\n\");\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = _keys[i];\n        let member = assert(members.get(memberName));\n        if (member.kind != ElementKind.PropertyPrototype) continue;\n        let property = (<PropertyPrototype>member).instance; // resolved during class finalization\n        if (!property || !property.isField) continue;\n        sb.push(\"  /** @type `\");\n        sb.push(property.type.toString());\n        sb.push(\"` */\\n  \");\n        sb.push(property.name);\n        sb.push(\": \");\n        sb.push(this.toTypeScriptType(property.type, mode));\n        if (this.fieldAcceptsUndefined(property.type)) {\n          sb.push(\" | TOmittable\");\n        }\n        sb.push(\";\\n\");\n      }\n    }\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n\n  fieldAcceptsUndefined(type: Type): bool {\n    if (type.isInternalReference) {\n      return type.is(TypeFlags.Nullable);\n    }\n    return true;\n  }\n\n  makeInternrefType(clazz: Class): string {\n    let sb = new Array<string>();\n    sb.push(\"/** \");\n    sb.push(clazz.internalName);\n    sb.push(\" */\\n\");\n    sb.push(\"declare class __Internref\");\n    sb.push(clazz.id.toString());\n    sb.push(\" extends Number {\\n\");\n    let base: Class | null = clazz;\n    do {\n      sb.push(\"  private __nominal\");\n      sb.push(base.id.toString());\n      sb.push(\": symbol;\\n\");\n      base = base.base;\n    } while (base);\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n// Helpers\n\nenum Mode {\n  IMPORT,\n  EXPORT\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}